<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Node.js简单实现后端服务器</title>
    <url>/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>这个示例中，没有用到MySQl数据库，只是简单的创建POST表单路由进行处理数据，以及表单数据的校验<br>用到的npm包&#x2F;第三方模块：<br>Express：<code>npm i express@4.17.1</code> – Web 开发框架，快速创建 Web 服务器<br>Joi：<code>npm install joi --save</code> – hapijs 自带的数据校验模块<br>@escook&#x2F;express-joi中间件: <code>npm i @escook/express-joi</code> – 实现自动对表单数据进行验证的功能</p>
</blockquote>
<blockquote>
<p>全局安装了nodemon工具，可以监听文件的更改，自动重新执行</p>
</blockquote>
<blockquote>
<p>该示例没有在路由之前配置cors中间件，从而解决接口跨域的问题<br>这个是航空文化馆项目的后端，还没写完<br>没有用到mysql模块：<code>npm i mysql</code><br>也没有用到express-session中间件：<code>npm i express-session</code>（这个干吗用的？）</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0">
<li>如果是拿被别人写好的项目，第一步是导入这个项目所用的包，<code>npm i</code>命令</li>
<li>创建后端项目文件夹如serve</li>
<li>初始化文件夹<code>npm init -y</code><br> 在空项目的根目录中初始化一个package.json的包管理配置文件</li>
<li>安装必要的包&#x2F;依赖<br> 安装Express —— <code>npm i express@4.17.1</code></li>
<li>创建服务器文件，命名如app.js</li>
</ol>
<h2 id="创建简单的web服务器-及其-模块化"><a href="#创建简单的web服务器-及其-模块化" class="headerlink" title="创建简单的web服务器 及其 模块化"></a>创建简单的web服务器 及其 模块化</h2><ol>
<li><p>创建基本的express框架 – eser(vscode快捷生成代码&#x2F;&#x2F;自己配置 – 文件–首选项–配置用户代码片段)</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//导入express模块</span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">//创建express服务器实例</span><br><span class="line">const app = express()</span><br><span class="line">const port = 8080;</span><br><span class="line"></span><br><span class="line">//调用app.listen方法，指定端口号并启动web服务器</span><br><span class="line">app.listen(port,()=&gt;&#123;</span><br><span class="line">    console.log(`Express server running at http://127.0.0.1:$&#123;port&#125;`)</span><br><span class="line">&#125;)      </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由<br> 可以先在当前文件尝试是否成功，之后再分离到对应模块</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建express路由实例</span><br><span class="line">const router = express.Router()</span><br><span class="line">// 配置路由</span><br><span class="line">app.use(router)</span><br><span class="line">// 提交预约表单</span><br><span class="line">router.post(&#x27;/form&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.body);</span><br><span class="line">    res.send(&#x27;发送表单数据成功&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用postman测试请求是否成功<br> 向 <a href="http://127.0.0.1:8080/form">http://127.0.0.1:8080/form</a> 发送post请求<br> 响应函数中打印出来的req.body结果是undefined，这是因为我们没有配置解析表单的中间件</p>
</li>
<li><p>配置解析表单的中间件<br> &#x2F;&#x2F; 配置解析表单数据的中间件,注意：这个中间件，只能解析applicaton&#x2F;x-www-form-urlencoded格式的表单数据<br> <code>app.use(express.urlencoded(&#123;extended:false&#125;))</code><br> 再次发送请求，我们就得到了表单提交的数据</p>
</li>
<li><p>分离到路由模块<br> 创建router文件夹，创建如user.js文件&#x2F;&#x2F;处理用户路由<br> 将路由部分写到这个地方，然后把router暴露出去<br> <code>module.exports = router</code><br> 然后在app.js中导入并使用路由模块</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入并使用用户路由模块</span><br><span class="line">const userRouter = require(&#x27;./router/user&#x27;)</span><br><span class="line">// 配置路由</span><br><span class="line">app.use(userRouter)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
<li><p>分离处理函数到路由处理模块，同5操作<br> 创建router_handler文件夹，在该目录下创建对应的用户路由处理文件user.js<br> 把处理函数暴露出去</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exports.formSubmit = (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.body);</span><br><span class="line">    res.send(&#x27;发送表单数据成功&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在路由模块导入导入用户路由处理函数对应的模块<br> <code>const user_handler = require(&#39;../router_handler/user&#39;)</code><br> 路由的响应函数换成对应的user_handler.formSubmit</p>
</li>
</ol>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>这里使用joi模块来进行数据验证<br>Joi 是 hapijs 自带的数据校验模块，他已经高度封装常用的校验功能。</p>
<ol>
<li><p>安装joi包，为表单中携带的每个数据项，定义验证规则</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install joi --save</span><br><span class="line">// ES6写法 import Joi from &#x27;joi&#x27;</span><br><span class="line">const joi = require(&#x27;joi&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>安装 @escook&#x2F;express-joi 中间件，来实现自动对表单数据进行验证的功能：<br> <code>npm i @escook/express-joi</code></p>
</li>
<li><p>joi验证规则</p>
<ul>
<li>string() 值必须是字符串</li>
<li>number() 值必须是数字</li>
<li>alphanum() 值只能是包含 a-zA-Z0-9 的字符串</li>
<li>min(length) 最小长度</li>
<li>max(length) 最大长度</li>
<li>required() 值是必填项，不能为 undefined</li>
<li>pattern(正则表达式) 值必须符合正则表达式的规则</li>
<li>any() 任意</li>
<li>date() 日期</li>
<li>time() 时间</li>
<li>iso() 要求字符串值采用有效的 ISO 8601 日期格式。</li>
</ul>
</li>
<li><p>新建 &#x2F;schema&#x2F;user.js 用户信息验证规则模块，并初始化代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入joi模块</span><br><span class="line">const joi = require(&#x27;joi&#x27;)</span><br><span class="line"></span><br><span class="line">// 表单校验规则</span><br><span class="line">const unit = joi.string().required()</span><br><span class="line">const contact = joi.string().required()</span><br><span class="line">const phone = joi.string().pattern(/^[1][\d]&#123;10&#125;$/).required()</span><br><span class="line">const numVisitors = joi.number().min(16).required()</span><br><span class="line">const guide = joi.string().pattern(/yes|no|是|否/).required()</span><br><span class="line">const date = joi.date().min(&#x27;now&#x27;).iso().required()</span><br><span class="line">const time = joi.string().pattern(/^[\d]&#123;2&#125;[\s]*:[\s]*[\d]&#123;2&#125;$/).required()</span><br><span class="line"></span><br><span class="line">// 表单的验证规则对象</span><br><span class="line">exports.form_schema =&#123;</span><br><span class="line">    body:&#123;</span><br><span class="line">        unit,</span><br><span class="line">        contact,</span><br><span class="line">        phone,</span><br><span class="line">        numVisitors,</span><br><span class="line">        guide,</span><br><span class="line">        date,</span><br><span class="line">        time,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由模块添加数据校验</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入验证表单数据的中间件</span><br><span class="line">const expressJoi = require(&#x27;@escook/express-joi&#x27;)</span><br><span class="line">// 导入需要验证的规则</span><br><span class="line">const &#123;form_schema&#125; = require(&#x27;../schema/user&#x27;)</span><br></pre></td></tr></table></figure>
<p> 在表单提交的路由中，声明局部中间件，对当前请求中携带的数据进行验证<br> 数据验证通过后，会把这次请求流转给后面的路由处理函数<br> 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理<br> <code>router.post(&#39;/form&#39;,expressJoi(form_schema), user_handler.formSubmit)</code></p>
</li>
<li><p>在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端<br> 在路由注册之后声明错误级别中间件，注意这里需要在app.js导入joi</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const joi = require(&#x27;joi&#x27;)</span><br><span class="line">// 错误中间件</span><br><span class="line">app.use(function(err,req,res,next)&#123;</span><br><span class="line">    //数据验证失败</span><br><span class="line">    if(err instanceof joi.ValidationError) return res.send(err.message)</span><br><span class="line">    // 未知错误</span><br><span class="line">    res.send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化与Webpack</title>
    <url>/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>了解工程化的前端开发方式<br>知道Webpack在实际开发中所起到的作用</p>
<blockquote>
<p>我们只需要了解webpack的工作原理，并不要求我们掌握如何配置，因为工作中我们会使用一些工具如Vue-CLI脚手架，它们已经帮我们配置好了</p>
</blockquote>
</blockquote>
<p>[toc]</p>
<h2 id="前端工程化相关概念"><a href="#前端工程化相关概念" class="headerlink" title="前端工程化相关概念"></a>前端工程化相关概念</h2><p>前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。<br>好处:前端开发自成体系，有一套标准的开发方案和流程。</p>
<p>实际的前端开发，是四个现代化：</p>
<ul>
<li><strong>模块化</strong> (js的模块化、css的模块化、资源的模块化) ———— js的复用</li>
<li><strong>组件化</strong> (复用现有的UI结构、样式、行为) ———— UI结构的复用</li>
<li><strong>规范化</strong> (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</li>
<li><strong>自动化</strong> (自动化构建、自动部署、自动化测试)</li>
</ul>
<h3 id="前端工程化解决方案"><a href="#前端工程化解决方案" class="headerlink" title="前端工程化解决方案"></a>前端工程化解决方案</h3><ul>
<li>早期的前端工程化解决方案:<ul>
<li>grunt (<a href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</li>
<li>gulp (<a href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</li>
</ul>
</li>
<li>目前主流的前端工程化解决方案:<ul>
<li>webpack (<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</li>
<li>parcel (<a href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>) ———— 开发第三方包会用到</li>
</ul>
</li>
</ul>
<h2 id="webpack-常见用法"><a href="#webpack-常见用法" class="headerlink" title="webpack 常见用法"></a>webpack 常见用法</h2><ol>
<li><p>什么是webpack？<br> 概念：webPack是<strong>前端项目工程化的具体解决方案</strong>。<br> 主要功能: 它提供了友好的<strong>前端模块化开发支持</strong>，以及<strong>代码压缩混淆</strong>(干掉注释和空格)、<strong>处理浏览器端JavaScript的兼容性</strong>、<strong>性能优化</strong>等强大的功能。<br> 好处:让程序员把<strong>工作的重心</strong>放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意:目前Vue，React等前端项目，基本上都是基于webpack进行工程化开发的。</p>
</li>
<li><p>创建列表隔行变色项目</p>
<ol>
<li>新建项目空白目录，并运行npm init -y命令，初始化包管理配置文件 package.json</li>
<li>新建src源代码目录</li>
<li>新建src -&gt; index.html首页和src -&gt; index.js 脚本文件</li>
<li>初始化首页基本的结构</li>
<li>运行npm install jquery -S命令，安装jQuery(-S明确告诉npm，包要记录到dependencies下，开发上线都会用到)</li>
<li>通过ES6模块化的方式导入jQuery，实现列表隔行变色效果</li>
</ol>
</li>
<li><p>在项目中安装webpack<br> 运行如下命令，安装webpack相关的两个包（-D告诉npm记录到devDependencies下，只在开发阶段会用到）<br> <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code></p>
</li>
<li><p>在项目中配置webpack</p>
<ol>
<li><p>在项目根目录中，创建名为<strong>webpack.config.js</strong>的webpack配置文件，并初始化如下的基本配置:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    // mode 用来指定构建模式。可选值有 development和 production</span><br><span class="line">    // 开发阶段选develement，上线改成production</span><br><span class="line">    mode: &#x27;development&#x27; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在package.json的 scripts节点下，新增<strong>dev脚本</strong>如下:<br> 这个dev是可以随意命名的，后面的webpack是必须写webpack<br> scripts节点下有个默认的test脚本，删掉就行</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    // script 节点下的脚本，可以通过 npm run 执行。例如 npm run dev</span><br><span class="line">    &quot;dev&quot;: &quot;webpack&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中运行npm run dev命令，启动 webpack进行项目的打包构建<br> 运行成功后，项目会多一个dist文件夹，里面的main.js就是webpack根据index.js帮我们自动生成的，做一下兼容性处理<br> 处理完以后，index.js还有兼容性问题，而main.js没有兼容性问题<br> 所以网页应该引入的是main.js文件<br> .<br> 由nodejs升级引起的构建错误：0308010C:digital envelope routines::unsupported<br> <a href="https://juejin.cn/post/7202639428132044858">https://juejin.cn/post/7202639428132044858</a><br> 报错原因可以看这篇文章<br> 解决设置（似乎还没有一个100%完全的解决方法，都会存在一些问题）:<br> <code>&quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack&quot;</code><br> .<br> 这个main.js是webpack帮我们把jquery.js和index.js文件进行了合并，但是并没有压缩，main.js中还有注释和代码缩进，如果要压缩，需要把webpack.config.js的mode设置为production，然后重新运行，整个文件的体积就被压缩的更小了，但是打包的时间更长了<br> .<br> 所以开发的时候，mode都设置成develement，只有上线的时候才会设置为production</p>
</li>
<li><p>webpack的默认约定 ———— 如何打包<br> 在webpack 4.x和5.的版本中，有如下的默认约定:</p>
<ol>
<li>默认的打包入口文件为src -&gt; index.js</li>
<li>默认的输出文件路径为dist -&gt; main.js</li>
</ol>
<p> 注意:可以在webpack.config.js中修改打包的默认约定<br> 如果找不到要处理的文件，就会报错</p>
</li>
<li><p>自定义打包的入口和出口<br> 在webpack.config.js 配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require( &#x27;path&#x27;) //导入 node.js中专门操作路径的模块</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //打包入口文件的路径</span><br><span class="line">    entry: path.join(__dirname,&#x27;./src/index.js&#x27;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        //输出文件的存放路径 </span><br><span class="line">        path: path.join(__dirname,&#x27;./dist&#x27;),</span><br><span class="line">        //输出文件的名称</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>这个时候，我们会发现，每次我们更改index.js的代码之后，都需要再次执行npm run dev更新生成的文件才行，这样非常麻烦，所以我们需要用到webpack的插件</p>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><p>最常用的webpack插件有两个：</p>
<ol>
<li>webpack-dev-server<ul>
<li>类似于node.js的nodemon工具</li>
<li>每当修改了源代码，webpack都会自动进行项目的打包和构建</li>
</ul>
</li>
<li>html-webpack-plugin<ul>
<li>webpack 中的HTML插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定制index.html页面的内容<hr></li>
</ul>
</li>
</ol>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol>
<li><p>安装webpack-dev-server<br> <code>npm i webpack-dev-server@3.11.2 -D</code><br> .<br> 在配置好之后，npm run dev 运行报错<br> Unable to load ‘@webpack-cli&#x2F;serve’ command<br> TypeError: options.forEach is not a function<br> .<br> 下载<code>npm install webpack@5.42.1 webpack-cli@4.10.0 -D</code></p>
</li>
<li><p>配置webpack-dev-server</p>
<ol>
<li>修改package.json -&gt; scripts中的dev命令如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    // script节点下的脚本，可以通过npm run 执行</span><br><span class="line">    &quot;dev&quot; : &quot;webpack serve&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>再次运行npm run dev命令，重新进行项目的打包<br> 在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</li>
</ol>
<p> 注意:webpack-dev-server 会启动一个实时打包的http服务器</p>
</li>
</ol>
<p>注意，webpack-dev-server启动后，构建后的文件是在内存中的，不会实际生成具体的文件，所以我们打开的页面效果不会发生变化</p>
<p>我们执行npm run dev 命令，它执行的其实是webpack serve命令<br>这个命令执行成功后，第一行返回的是，<br><code>i ｢wds｣: Project is running at http://localhost:8080/</code><br>是整个项目运行在8080端口<br>所以，要看更新后的效果，要打开这个网址来查看，不能和以前一样的方法查看，因为之前查看的是file协议，不是当前的http协议</p>
<p>我们打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 网址，进入src，浏览器就会自动打开这个目录下的index文件，但是还是页面没有更改，我们再看第二行<br><code>i ｢wds｣: webpack output is served from /</code><br>告诉我们，输出在根目录，但是根目录并看不到bundle.js，但是其实它是有的，我们打开<a href="http://localhost:8080/bundle.js">http://localhost:8080/bundle.js</a> 可以访问到该文件</p>
<p><strong>webpack-dev-server这个插件，它把生成的bundle没有放到实际的物理磁盘上，而是放到了内存里面</strong><br>这是因为，如果频繁的修改文件，ctrl s，如果是把文件放到物理磁盘上，就会频繁的读写磁盘，对磁盘寿命性能都会有很大影响，所以要访问最新的bundle要访问内存里的bundle，所以应该<strong>在页面加载和引用内存里的bundle.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://localhost:8080/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">也可以直接这样引用，看不见，但是可以引用的</span><br><span class="line">&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但是由于我的vscode默认的使用5500端口，所以第二种引用会引用到5500端口，但是5500端口并不存在bundle.js，所以会报错,只能使用第一种引用</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>有一点不方便的是，打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 之后，我们还要点击一次src进入目录中，才能打开首页<br>我们希望一进入8080就能看到首页<br>html-webpack-plugin，这个插件可以把src里面的首页复制一份，放到根目录中<br>安装插件：<code>npm i html-webpack-plugin@5.3.2 -D</code></p>
<ul>
<li><p>配置<br>  把new出来的插件htmlPlugin 挂载&#x2F;添加到plugins插件的数组里面，这样webpack在运行的时候就会调用这个插件的实例，把src(template)里的页面复制一份放到根目录(filename)中<br>  不过也是复制出来的一个内存里的页面</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 导入HTML插件，得到一个构造函数</span><br><span class="line">const HtmlPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">// 2．创建HTML插件的实例对象</span><br><span class="line">const htmlPlugin = new HtmlPlugin(&#123;</span><br><span class="line">    template: &#x27;./src/index.html&#x27;,//指定原文件的存放路径</span><br><span class="line">    filename: &#x27;./index.html&#x27;,//指定生成的文件的存放路径</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;development&#x27; ,</span><br><span class="line">    // 3．通过 plugins节点，使 htmlPlugin插件生效</span><br><span class="line">    plugins: [htmlPlugin], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个作用<br>  html-webpack-plugin插件除了帮我们复制页面，还会在复制出来的页面，自动注入一个脚本(js引用)，去引用内存里的bundle.js<br>  .<br>  我们npm run dev运行之后，如果把html页面的js引入注释掉，内存中页面样式是还在的，并没有消失。<br>  我们查看源码，可以发现它是有js引用的，而且是没有加.&#x2F;的同级目录引用，因为内存中的html和hundle.js在同一级目录</p>
</li>
</ul>
<p>配置完webpack之后，我们的开发体验会变的很好，但是配置过程又非常繁琐。<br>我不想自己配置，又想体验配置后的好处 ———— Vue-cli<br>这个工具已经帮我们配置好了webpack</p>
<h2 id="devServer-节点"><a href="#devServer-节点" class="headerlink" title="devServer 节点"></a>devServer 节点</h2><p>还有一个不爽的点(程序员的很多不爽XDD)，每次重新运行项目，都要手动打开8080页面，我们懒就要懒到底<br><strong>在npm run dev运行成功之后，自动打开浏览器展示网页</strong></p>
<ul>
<li>配置<br>  在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    // 初次打包完成后，自动打开浏览器</span><br><span class="line">    open: true,</span><br><span class="line">    // 实时打包所使用的主机地址</span><br><span class="line">    host: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    //实时打包所使用的端口号</span><br><span class="line">    port: 80, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="webpack中的loader（加载器）"><a href="#webpack中的loader（加载器）" class="headerlink" title="webpack中的loader（加载器）"></a>webpack中的loader（加载器）</h2><ol>
<li><p>loader概述<br> 在实际开发过程中，webpack默认只能打包处理以.js 后缀名结尾的模块。其他<strong>非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包</strong>，否则会报错!</p>
<p> loader加载器的作用:<strong>协助webpack打包处理特定的文件模块</strong>。比如:</p>
<ul>
<li>css-loader可以打包处理.css相关的文件</li>
<li>less-loader可以打包处理.less相关的文件</li>
<li>babel-loader可以打包处理webpack无法处理的高级JS语法</li>
</ul>
<p> 在webpack里面，一切都可以进行导入，一切皆模块，不建议程序员手动去引入样式和脚本(link，script)</p>
<p> 在js中也可以导入样式(ES6语法)<code>import &#39;./css/index.css&#39;</code></p>
</li>
<li><p>打包处理 css 文件</p>
<ol>
<li>运行<code>npm i style-loader@3.0.0 css-loader@5.2.6 -D</code>命令，安装处理css文件的loader</li>
<li>在webpack.config.js 的 module -&gt; rules 数组中，添加loader规则如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123; </span><br><span class="line">    //所有第三方文件模块的匹配规则</span><br><span class="line">    rules: [ //文件后缀名的匹配规则</span><br><span class="line">        &#123; test: /\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
 其中，<strong>test</strong>表示匹配的<strong>文件类型</strong>, <strong>use</strong>表示对应<strong>要调用的loader</strong><br> 注意:</li>
</ol>
<ul>
<li>use数组中指定的loader <strong>顺序是固定的</strong></li>
<li>多个loader的调用顺序是: <strong>从后往前调用</strong><br>  loader在调用的时候，是从后往前调的 <a href='#loader-调用过程'>loader调用过程</a></li>
</ul>
</li>
<li><p>打包处理 less文件</p>
<ol>
<li>运行<code>npm i less-loader@10.0.1 less@4.1.1 -D</code>命令</li>
<li>在webpack.config.js 的module -&gt; rules数组中，添加loader规则如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123; //所有第三方文件模块的匹配规则</span><br><span class="line">    rules: [ //文件后缀名的匹配规则</span><br><span class="line">        &#123; test: /\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;]&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个less是内部依赖项，就是less-loader内部依赖于less，但是不需要手动的去声明less</li>
</ol>
</li>
<li><p>打包处理样式表中与url路径相关的文件</p>
<ol>
<li>运行<code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code>命令</li>
<li>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123; //所有第三方文件模块的匹配规则</span><br><span class="line">    rules:[//文件后缀名的匹配规则</span><br><span class="line">        //如果需要调用的loader只有一个(use)，则只传递一个字符串也行，如果有多个loader，则必须指定数组</span><br><span class="line">        &#123; test: /\.jpg|png|gif$/,use: &#x27;url-loader?limit=22229&#x27;&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中?之后的是 loader的参数项:</li>
</ol>
<ul>
<li>limit用来指定图片的大小，单位是字节(byte)</li>
<li>只有≤limit 大小的图片，才会被转为base64格式的图片</li>
</ul>
</li>
<li><p>打包处理js文件中的高级语法<br> webpack只能打包处理一部分高级的JavaScript语法。对于那些webpack无法处理的高级js语法，需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1．定义了名为info的装饰器</span><br><span class="line">function info(target) &#123;</span><br><span class="line">    //2．为目标添加静态属性info</span><br><span class="line">    target.info = &#x27;Person info&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 3．为Person类应用info装饰器</span><br><span class="line">@info</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 4．打印 Person 的静态属性info</span><br><span class="line">console.log(Person.info)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.1 运行如下的命令安装对应的依赖包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js的 module -&gt; rules数组中，添加loader规则如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包</span><br><span class="line">&#123; test: /\.js$/, use: &#x27;babel-loader&#x27; , exclude: /node_modules/ &#125;</span><br></pre></td></tr></table></figure>
<p>exclude排除了node_modules文件夹，因为只需要处理我们自己写的代码就可以了，第三方的包没有兼容性问题，本身已经解决了，不需要处理(如果不排除也会对其进行处理影响性能)</p>
<p>5.2 配置babel-loader<br>打包处理js文件中的高级语法，比处理其他文件要多这么一步<br>在项目根目录下，创建名为 babel.config.js 的配置文件，定义Babel的配置项如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这些配置从官方文档找到对应项直接粘过来就行了</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //声明babel 可用的插件</span><br><span class="line">    plugins: [[&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; legacy: true &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考Babel的官网<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></p>
<h3 id="loader-调用过程"><a href="#loader-调用过程" class="headerlink" title="loader 调用过程"></a>loader 调用过程</h3><ol>
<li>webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</li>
<li>由于代码中包含了 index.css 这个文件，因此 webpack默认处理不了</li>
<li><strong>当webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器。</strong></li>
<li>webpack 把 index.css 这个文件，先转交给最后一个 loader 进行处理(先转交给css-loader) .</li>
<li>当 css-loader 处理完毕之后，会把处理的结果，转交给下一个 loader (转交给style-loader)</li>
<li>当 style-loader 处理完毕之后，发现没有下一个 loader 了，于是就把处理的结果，转交给了 webpack</li>
<li>webpack 把 style-loader 处理的结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。</li>
</ol>
<h3 id="base64图片的优缺点"><a href="#base64图片的优缺点" class="headerlink" title="base64图片的优缺点"></a>base64图片的优缺点</h3><p>浏览器在拿到HTMl标签以后，需要再发送请求，拿到图片以后才能把图片渲染出来</p>
<p>但是使用用base64图片，在拿到img标签以后，就顺手的把图片对应的字符串也给请求下来了，可以防止发起一些不必要的网络请求</p>
<p>如果页面有许多小图标，就要发送很多次请求，对性能来讲非常不好，就可以把图片都转成base64格式的字符串</p>
<p>缺点：<br>图片转成base64，体积会增大一点点，所以大图片就不适合</p>
<p><strong>ES6 import导入图片得到的是一个base64字符串</strong>(可以打印看一下)<br>如 <code>import logo from &#39;./images/logo.png&#39;</code></p>
<h3 id="webpack处理样式的过程"><a href="#webpack处理样式的过程" class="headerlink" title="webpack处理样式的过程"></a>webpack处理样式的过程</h3><p>ES6在js文件导入样式<code>import &#39;./css/index.css&#39;</code><br>这种语法代表，只需要加载这个文件，把css样式给加载过来，不需要接收(接收的话，打印出来是undefined)</p>
<p>webpack加载和处理js文件，处理的结果会生成一个新的js文件(如bundle.js)，而且会在页面引用过去，在这个bundle.js里面，会包含我们import引入的样式，在这个bundle.js里面，css样式会被转成js的方式去运行</p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>我们如果要上线，应该拿到这些文件发给后端，让后端去部署上线<br>发布上线就是：<br>前端把项目生成一份最终的结果，有页面，配套的css js 图片等等<br>所有资源都在生成的文件夹里面，把所有内容打包发给后端<br>后端拿到结果去部署上线</p>
<p>现在我们要解决的问题是：页面和bundle.js放到内存里面了，需要把它生成到实际的物理磁盘上。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>在package.json文件的scripts节点下，新增build命令如下:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    “dev&quot; : &quot;webpack serve&quot;，//开发环境中，运行dev命令</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时，运行 build命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <code>--mode</code>是一个参数项，用来指定webpack的<strong>运行模式</strong>。production 代表生产环境，会对打包生成的文件进行<strong>代码压缩</strong>和<strong>性能优化</strong>。<br>    注意:通过<code>--mode</code>指定的参数项，会<strong>覆盖</strong>webpack.config.js 中的<code>--mode</code>选项。</p>
<p>这里的dev命令是webpack serve，就是我们装的插件，是把文件生成到内存中，可以监听文件的更改自动执行npm run dev<br>而这里build就是要执行webpack命令把文件生成到磁盘上，这里注意要改成<br>    <code>set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack --mode production</code></p>
<h3 id="优化图片和js文件存放路径"><a href="#优化图片和js文件存放路径" class="headerlink" title="优化图片和js文件存放路径"></a>优化图片和js文件存放路径</h3><ol>
<li>js文件<br>在webpack.js的output对象属性中，把filename前面加上个文件夹<br> <code>filename:&#39;js/bundle.js&#39;</code></li>
<li>图片<br>修改webpack.config.js 中的url-loader配置项，新增outputPath选项即可指定图片文件的输出路径: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /.jpg|png|gif$/ ,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &#x27;url-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: 22228,</span><br><span class="line">            //明确指定把打包生成的图片文件，存储到dist目录下的 image 文件夹中</span><br><span class="line">            outputPath: &#x27;image&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者直接用?xx&#x3D;xx&amp;xx&#x3D;xx的方式在loader后面携带参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; test: /\.jpg|png|gif$/, use: &#x27;url-loader?limit=22229&amp;outputPath=images&#x27; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置和使用clean-webpack-plugin插件自动删除dist目录"><a href="#配置和使用clean-webpack-plugin插件自动删除dist目录" class="headerlink" title="配置和使用clean-webpack-plugin插件自动删除dist目录"></a>配置和使用clean-webpack-plugin插件自动删除dist目录</h3><p><strong>webpack5已经默认封装(内置)了该插件，直接在配置文件里output设置属性clean:true即可</strong></p>
<hr>
<p>为了防止旧文件干扰我们的事件，在每次重新发布的时候会把生成的打包好的dist文件夹删掉。<br>为了在每次打包发布时自动清理掉dist目录中的旧文件，可以安装并配置dlean-webpack-plugin插件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1．安装清理dist目录的 webpack 插件</span><br><span class="line">npm install clean-webpack-plugin@3.0.0 -D</span><br><span class="line">// 2．按需导入插件、得到插件的构造函数之后，创建插件的实例对象</span><br><span class="line">const &#123; CleanwebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)</span><br><span class="line">const cleanPlugin = new CleanwebpackPlugin()</span><br><span class="line">// 3．把创建的 cleanPlugin 插件实例对象，挂载到plugins节点中</span><br><span class="line">plugins: [htmlPlugin,cleanPlugin],//挂载插件 </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检验是否是删除之后重新生产的方法</strong>：<br>可以在dist文件夹下新建如1.txt文件，重新打包，如果文件还在，说明是没有删除直接打包的，如果不再了，那就是删除之后重新打包。</li>
</ul>
<h2 id="source-Map-–-开发阶段检错"><a href="#source-Map-–-开发阶段检错" class="headerlink" title="source Map – 开发阶段检错"></a>source Map – 开发阶段检错</h2><p>告诉你文件的报错位置，用于调试bug<br>开发阶段 npm run dev 检错的<br><strong>在发布项目的时候，处于安全性考虑，建议关闭SourceMap</strong>。防止一些人通过报错位置来拿到我们的源代码(通过修改页面代码来主动让页面某功能报错来拿到该功能位置的源码这样吗？)<br>新版本开发环境建议使用cheap-module-source-map？</p>
<ol>
<li>什么是 source Map<br> <strong>Source Map就是一个信息文件，里面储存着位置信息</strong>。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的<strong>转换前的位置</strong>。<br> 有了它，出错的时候，<strong>除错工具将直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</li>
</ol>
<p>即是：页面报错，控制台会显示错误以及错误文件及其报错位置，如果没有配置这个，它显示的就是打包压缩后的代码的位置</p>
<ol start="2">
<li><p>webpack <strong>开发环境下的</strong> Source Map<br> <strong>在开发环境下</strong>，webpack<strong>默认启用了</strong>Source Map功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。<br> 但是，开发环境下默认生成的Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</p>
</li>
<li><p>解决默认的Source Map的问题<br> 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;development&#x27;,</span><br><span class="line">    // eval-source-map 仅限在&quot;开发模式&quot;下使用，不建议在&quot;生产模式&quot;下使用。</span><br><span class="line">    //此选项生成的 Source Map 能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span><br><span class="line">    // 在开发调试阶段，建议大家都把devtool的值设置为eval-source-map</span><br><span class="line">    devtool: &#x27;eval-source-map&#x27;,</span><br><span class="line">    //省略其它配置项...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack <strong>生产环境下的</strong> Source Map<br>在生产环境下，如果省略了devtool选项，则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人</p>
</li>
<li><p><strong>只定位行数不暴露源码</strong> – 对调试和安全都比较友好<br>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以<strong>将devtool的值设置为nosources-source-map</strong>。<br>知道了行号，我们就可以定位到源码的行位置来解决bug</p>
</li>
<li><p>定位行数且暴露源码<br>在生产环境下，如果<strong>想在定位报错行数的同时，展示具体报错的源码</strong>。此时可以将devtool的值设置为source-map。<br>坚决不推荐。(但是这不是和eval-source-map一样吗？？)<br>这种方式会生成一个SourceMap(但是nosources-source-map也有，eval-soure-map应该也有吧)<br>可以看到在dist的js目录下，除了有bundle.js还有个bundle.js.map，这就是我们的SourceMap</p>
</li>
</ol>
<h3 id="Source-Map的最佳实践"><a href="#Source-Map的最佳实践" class="headerlink" title="Source Map的最佳实践"></a>Source Map的最佳实践</h3><ol>
<li>开发环境下:<ul>
<li>建议把devtool的值设置为<strong>eval-source-map</strong></li>
<li>好处: 可以精准定位到具体的错误行</li>
</ul>
</li>
<li>生产环境下:<ul>
<li>建议<strong>关闭Source Map</strong> 或 将devtool的值设置为<strong>nosources-source-map</strong></li>
<li>好处: 防止源码泄露，提高网站的安全性</li>
</ul>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul>
<li>两次 ctrl + c 可以直接结束 webpack serve？<br>原本需要一次ctrl + c 然后按Y + enter结束</li>
</ul>
<h3 id="webpack中-的原理和好处"><a href="#webpack中-的原理和好处" class="headerlink" title="webpack中 @ 的原理和好处"></a>webpack中 @ 的原理和好处</h3><p>这样一个场景：<br>src目录下 有一个info文件 js&#x2F;text&#x2F;info<br>而这个info文件要导入src目录下的msg.js文件<br>就需要这样导入: import msg from ‘..&#x2F;..&#x2F;msg’<br>如果info的文件层级再深一点，这个..&#x2F;会让人不知道翻了几层<br>所以<br><strong>建议大家都使用 @ 符号表示src源代码目录，从外往里查找，不要使用..&#x2F;从里往外查找</strong><br>import msg from ‘@&#x2F;msg.js’</p>
<p>在webpack里面，@不能直接用，需要先配置一下<br>在webpack.config.js中，module.exports中增加一个resolve属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            // 告诉webpack，程序员写的代码中，@符号表示src这一层目录</span><br><span class="line">            &#x27;@&#x27;: path.join(__dirname,&#x27;./src/&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在浏览器安装vue-devtools调试工具"><a href="#在浏览器安装vue-devtools调试工具" class="headerlink" title="在浏览器安装vue-devtools调试工具"></a>在浏览器安装vue-devtools调试工具</h3><p>edge扩展中直接搜，有一个vue.js-devtools<br><strong>在详情设置中，有个允许访问文件URL(文件网址)的设置，默认是关闭的状态，需要我们手动打开</strong></p>
<h2 id="实际开发中不需要自己配置webpack"><a href="#实际开发中不需要自己配置webpack" class="headerlink" title="实际开发中不需要自己配置webpack"></a><strong>实际开发中不需要自己配置webpack</strong></h2><ul>
<li>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</li>
<li>开箱即用，所有webpack配置项都是现成的!</li>
<li>我们只需要知道webpack 中的基本概念即可!</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Webpack</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 基本使用 &amp; 常用指令</title>
    <url>/tsukimiya.github.io/2024/04/20/Vue/2.vue%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&amp;%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>使用Vue指令完成页面结构的渲染<br>使用Vue调试工具辅助Vue的开发</p>
</blockquote>
<blockquote>
<p><strong>掌握Vue的两个特性：数据驱动视图、双向数据绑定<br>    掌握Vue的底层原理 MVVM – model数据源、view视图&#x2F;页面结构、viewmodel vue实例<br>    掌握Vue六大类指令的使用</strong><br>    新学到的东西 – 事件绑定指令中的：<a href="#param">参数问题</a>、<a href="#event">$event</a>、<a href="#modifier">事件修饰符</a>、<a href="#key">按键修饰符</a></p>
</blockquote>
<p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://cn.vuejs.org/guide/introduction.html">官方文档</a><br>Vue是一套<strong>用于构建用户界面的前端框架</strong><br>构建用户界面：用vue往html页面填充数据<br>框架：一套现成的解决方案，程序员只能遵守框架的规范去编写业务功能</p>
<p>学习vue就是学习vue框架中规定的用法<br><strong>vue的指令、组件(是对UI结构的复用)、路由、Vuex、vue组件库</strong></p>
<h3 id="vue的两个特性："><a href="#vue的两个特性：" class="headerlink" title="vue的两个特性："></a>vue的两个特性：</h3><ol>
<li><strong>数据驱动视图</strong><br> vue会监听数据的变化，自动重新渲染页面的结构<br> 注意：<span style="color:red;" >数据驱动视图是单向的数据绑定<span></li>
<li><strong>双向数据绑定</strong><br> 填写表单时，自动把内容同步到数据源中<blockquote>
<p>在网页中，form表单负责<font color='green'>采集数据</font>，Ajax负责<font color='green'>提交数据</font></p>
</blockquote>
</li>
</ol>
<h3 id="MVVM-–-vue的底层原理"><a href="#MVVM-–-vue的底层原理" class="headerlink" title="MVVM – vue的底层原理"></a>MVVM – vue的底层原理</h3><p><font color='red'>MVVM是 vue 实现数据驱动视图和双向数据绑定的核心原理。</font><br>MVVM 指的是 <strong>M</strong>odel(数据源)、<strong>V</strong>iew(视图) 和 <strong>V</strong>iew<strong>M</strong>odel(vue实例)，它把每个 HTML 页面都拆分成了这三个部分。</p>
<p>在MVVM概念中:<br><strong>Model</strong> 表示当前页面渲染时所依赖的<strong>数据源</strong>。<br><strong>View</strong> 表示当前页面所渲染的 DOM 结构。(<strong>页面结构，也即是视图</strong>)<br><strong>ViewModel</strong> 表示 <strong>vue 的实例</strong>，它是<strong>MVVM的核心</strong>。(就是vue)<br><img src="/tsukimiya.github.io/images/vue/MVVM%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p>
<ul>
<li>MVVM的工作原理：<br>  ViewModel作为MVVM的核心，是它把当前页面的<font color="green">数据源</font>(Model)和<font color="green">页面的结构</font>(View)连接在了一起。<br>  <img src="/tsukimiya.github.io/images/vue/MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="img"><br>  <strong>当数据源发生变化时</strong>，会被ViewModel监听到，VM会根据最新的数据源<strong>自动更新</strong>页面的结构<br>  <strong>当表单元素的值发生变化时</strong>，也会被VM监听到，VM会把变化过后最新的值<strong>自动同步</strong>到Model数据源中</li>
</ul>
<h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><p>当前，vue共有3个大版本，其中:<br>3.x版本的vue 于2020-09-19发布<br>2.x版本的vue 已于 2023 年 12 月 31 日停止维护<br>1.x版本的vue几乎被淘汰，不再建议学习与使用</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p>基本使用步骤</p>
<ol>
<li>导入VUE.js脚本文件<br> 可以借助 script 标签直接通过 CDN(提供 npm 包服务) 来使用 Vue：<br> <code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在页面声明一个将要被vue所控制的区域</li>
<li>创建vm实例对象(vue实例对象)</li>
</ol>
</li>
<li><p>基本代码与MVVM的对应关系<br> model：data指向的对象<br> view：el指向的选择器<br> ViewModel：new Vue()构造函数得到的实例对象</p>
</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。<br>指令是vue开发中最基础、最常用、最简单的知识点</p>
<p>vue的指令 <strong>按照不同用途</strong> 可以分为如下6大类：</p>
<ol>
<li><p>内容渲染指令：<code>v-text</code> 、<code>&#123;&#123;&#125;&#125;</code>  、 <code>v-html</code></p>
<blockquote>
<p>v-test 会覆盖默认文本内容，一般使用<code>&#123;&#123;&#125;&#125;</code>插值表达式<br> v-text和差值表达式只能渲染纯文本内容<br> v-html可以把带标签的字符串渲染成HTML内容</p>
</blockquote>
</li>
<li><p>属性绑定指令: <code>v-bind</code> &#x2F; <code>:xxx=</code> </p>
<blockquote>
<p>差值表达式只能用在元素的内容节点中，不能用在属性节点中<br> v-bind用法：<code>&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;</code><br> <strong>vue规定 <code>v-bind:</code> 指令可以简写为<code>:</code></strong></p>
</blockquote>
<blockquote>
<p>在vue提供的模版渲染语法中，除了支持<strong>绑定简单的数据值之外，还支持JS表达式的运算</strong>如：<br> <code>&#123;&#123;number + 1&#125;&#125;</code>、<code>&#123;&#123;ok?'YES':'NO'&#125;&#125;</code>、<code>&#123;&#123;msg.split('').reserve().join('')&#125;&#125;</code>(反转字符串)、<code>字符串拼接</code> 等等</p>
</blockquote>
</li>
<li><p>事件绑定指令：<code>v-on</code> &#x2F; <code>@</code></p>
<blockquote>
<p>语法如 <code>v-on:clock=&quot;add&quot;</code> 简写<code>@click=&quot;add&quot;</code><br> methods下的函数变量也支持简写：<code>add:function()&#123;&#125; --&gt; add()&#123;&#125;</code><br> 在处理函数中<strong>修改数据的值</strong>可以通过vm(接受vue实例的变量名)来修改：vm.count,但是不推荐，<strong>推荐用this</strong></p>
</blockquote>
<ul>
<li><p>绑定事件并传参</p>
<blockquote>
<p>在调用的地方传参 <code>@click=&quot;add(1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="param" color="red">参数问题</font></p>
<blockquote>
<p>如果定义的函数变量是有参数的</p>
</blockquote>
<ol>
<li><code>add(n)&#123;&#125; -- @click=&quot;add(1)&quot;</code> 正常传参 n&#x2F;&#x2F;1</li>
<li><code>add(n)&#123;&#125; -- @click=&quot;add()&quot;</code> n&#x2F;&#x2F;undefined</li>
<li><code>add(n)&#123;&#125; -- @click=&quot;add&quot;</code> n被认定为事件对象PointerEvent，通常我们会定义为e&#x2F;event<br> 如果是多个参数，如</li>
<li><code>add(a,b)&#123;&#125; -- @click=&quot;add(1,2)&quot;</code> 正常传参 a&#x2F;&#x2F;1 b&#x2F;&#x2F;2</li>
<li><code>add(a,b)&#123;&#125; -- @click=&quot;add(1)&quot;</code> a&#x2F;&#x2F;1 b&#x2F;&#x2F;undefined</li>
<li><code>add(a,b)&#123;&#125; -- @click=&quot;add()&quot;</code> a&#x2F;un b&#x2F;&#x2F;un</li>
<li><code>add(a,b)&#123;&#125; -- @click=&quot;add&quot;</code> a&#x2F;&#x2F;事件对象PointerEvent ，b&#x2F;&#x2F;undefined</li>
</ol>
</li>
<li><p><font id="event" color="red">事件对象$event</font>(不常用)</p>
<blockquote>
<p>vue提供了内置变量<code>$event</code>,它就是原生DOM的事件对象e<br>  在绑定事件的时候，如果不传参 <code>add(e)&#123;&#125; -- @click=&quot;add&quot;</code> , 我们会接受到一个事件对象e<br>  如果传参，<code>@click=&quot;add(1)&quot;</code>,我们就接收不到这个事件对象了<br>  <strong>我们既要传参，又要用到事件对象e</strong>，如想要从事件对象上拿到e.target(触发事件的事件源) ，这个时候就可以用<code>$event</code><br>  <strong><code>$event</code>使用：传<code>$event</code>作参数进去，拿形参接收</strong><br>  <code>add(n,e)&#123;&#125; --  @click=&quot;add(1,$event)&quot;</code><br>  或<code>add(e,n)&#123;&#125; --  @click=&quot;add($event,1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="modifier" color="red">事件修饰符</font></p>
<blockquote>
<p>在事件处理函数中，调用<code>event.preventDefault()</code>(阻止默认行为)或<code>event.stopPropagation()</code>(阻止冒泡)是非常常见的需求。<br>  因此，vue提供了<strong>事件修饰符</strong>的概念，辅助程序员更方便的<strong>对事件的触发进行控制</strong>。<br>  如 <code>@click.prevent=&quot;show&quot;</code>绑定了show事件，同时阻止了默认行为<br>  常见的5个事件修饰符如下：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>.prevent</strong></td>
<td><strong>阻止默认行为</strong>(例如：阻止a链接的跳转、表单的提交等)</td>
</tr>
<tr>
<td align="center"><strong>.stop</strong></td>
<td><strong>阻止事件冒泡</strong></td>
</tr>
<tr>
<td align="center">.capture</td>
<td>以 捕获模式 触发当前的 事件处理函数</td>
</tr>
<tr>
<td align="center">.once</td>
<td>绑定的事件只触发1次</td>
</tr>
<tr>
<td align="center">.self</td>
<td>只有在 event.target 是当前元素自身时 触发事件处理函数</td>
</tr>
</tbody></table>
<ul>
<li><font id="key" color="red">按键修饰符</font><blockquote>
<p>在<strong>监听键盘事件</strong>时，经常需要<strong>判断详细的按键</strong>。<br>  此时，可以为键盘的相关事件添加<strong>按键修饰符</strong>，如：<br>  <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> – 只有在<code>key</code>是<code>Enter</code>时，调用<code>vm.submit()</code><br>  <code>&lt;input @keyup.esc=&quot;clearInput&quot;&gt;</code> – 只有在<code>key</code>是<code>Esc</code>时，调用<code>vm.clearInput()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>双向绑定指令 </p>
</li>
<li><p>条件渲染指令</p>
</li>
<li><p>列表渲染指令</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/tsukimiya.github.io/hello%20world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello Front-end</title>
    <url>/tsukimiya.github.io/index.html</url>
    <content><![CDATA[<p>Welcome to my study blog! This is my continuously make up a main post. If you get any problems when using my blog, you can send the email to <a href="mailto:&#x68;&#x61;&#x72;&#x69;&#x69;&#106;&#x69;&#99;&#111;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#99;&#x6f;&#109;">&#x68;&#x61;&#x72;&#x69;&#x69;&#106;&#x69;&#99;&#111;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#99;&#x6f;&#109;</a></p>
<h2 id="Study-Guide"><a href="#Study-Guide" class="headerlink" title="Study Guide"></a>Study Guide</h2><center>Here provide you some study sources and study route.</center>
<!-- This is [main tech](#Main-Line) -->
<center>This is <a href='#Main-Line'>main tech</a></center>

<h3 id="Nice-Tools"><a href="#Nice-Tools" class="headerlink" title="Nice Tools"></a>Nice Tools</h3><ul>
<li><p><a href="https://cn.vuejs.org/api/">Vue.js API官方文档</a> <font color='red'> 推荐 </font></p>
</li>
<li><p><a href="https://jquery.cuishifeng.cn/">JQuery API 中文在线文档</a>(<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a>)</p>
<blockquote>
<p>不过很多API的解释和案例都有点解释不清。。</p>
</blockquote>
</li>
<li><p><a href="https://regexr-cn.com/">正则表达式测试工具</a>(<a href="https://regexr-cn.com/">https://regexr-cn.com/</a>)</p>
</li>
<li><p><a href="https://base64.us/">Base64 在线编码解码</a>(<a href="https://base64.us/">https://base64.us/</a>)</p>
<blockquote>
<p>也可以选择图片文件来获取它的 Base64 编码的 DataURI 形式</p>
</blockquote>
</li>
<li><p><a href="https://www.iconfont.cn/">阿里巴巴矢量他图标库</a>(<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a>) <font color='red'> 推荐 </font></p>
</li>
<li><p><a href="https://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a>(<a href="https://www.xuanfengge.com/funny/html5/element/">https://www.xuanfengge.com/funny/html5/element/</a>)</p>
</li>
</ul>
<h3 id="Guide-Book"><a href="#Guide-Book" class="headerlink" title="Guide Book"></a>Guide Book</h3><ul>
<li><p>ES6</p>
<ul>
<li>《ECMAScript 6 教程》– 阮一峰 <a href="https://es6.ruanyifeng.com/">官方</a> <a href="https://wangdoc.com/es6/">网道镜像</a> <blockquote>
<p>网道(<a href="https://wangdoc.com/">https://wangdoc.com/</a>) 是一个文档网站，提供互联网开发文档。PC显示更佳。<br>  阮一峰博客的移动端显示更佳 <font color='red'> 推荐 </font></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a> <font color='red'> 推荐 </font><blockquote>
<p>写的很细，无论是基础还是进阶都可以看</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><ol>
<li><p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">鱼皮前端学习路线</a></p>
<blockquote>
<p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">https://www.codefather.cn/前端学习路线-by-程序员鱼皮/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习路线</a></p>
<blockquote>
<p><a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
</ol>
<h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ol>
<li><p><a href="https://www.freecodecamp.org/chinese/learn">freecodecamp编程免费教学慈善组织</a></p>
<blockquote>
<p>编程学习课程(可以获得认证，有官方中文) <a href="https://www.freecodecamp.org/chinese/learn">https://www.freecodecamp.org/chinese/learn</a></p>
</blockquote>
<blockquote>
<p>也有程序员英文学习课程——<a href="https://www.freecodecamp.org/chinese/learn/a2-english-for-developers/">学习面向开发者的英语课程</a></p>
</blockquote>
<blockquote>
<p>对应的<a href="https://www.freecodecamp.org/chinese/news/">专栏</a> 可以阅读学习一些技术文章</p>
</blockquote>
<blockquote>
<p>对应的<a href="https://forum.freecodecamp.org/c/chinese/533">学习论坛</a> 也是支持中文的</p>
</blockquote>
</li>
<li><p><a href="https://www.w3cschool.cn/codecamp/">w3c编程入门实战训练</a></p>
<blockquote>
<p><a href="https://www.w3cschool.cn/codecamp/">https://www.w3cschool.cn/codecamp/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习</a></p>
<blockquote>
<p>同样是阿里云学习路线的网页，两者都在一个界面<br> <a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
<li><p><a href="https://time.geekbang.org/column/intro/154">极客时间前端基础 ￥59</a></p>
<blockquote>
<p>主讲人 程劭非（winter）  前手机淘宝前端负责人<br> 讲解JS、HTML、CSS、浏览器<br> <a href="https://time.geekbang.org/column/intro/154">https://time.geekbang.org/column/intro/154</a></p>
</blockquote>
</li>
</ol>
<h3 id="Necessary-Tech"><a href="#Necessary-Tech" class="headerlink" title="Necessary Tech"></a>Necessary Tech</h3><p><a href="https://www.bilibili.com/video/BV1eC411p73m/">前端技术的十八年风雨(2006-2024)-bilibili</a></p>
<h4 id="Main-Line"><a href="#Main-Line" class="headerlink" title="Main Line"></a><font id='Main-Line' color='red'>Main Line</font></h4><ol>
<li><p>前端三剑客基础 HTML5 – CSS3 – JS5&#x2F;ES5</p>
<blockquote>
<p>H5引入了许多新特性和API，如语义化元素、表单控件、图形和多媒体元素，以及各种Web API等等<br>CSS3的新特性：如圆角(border-radius)、阴影(box-shadow、text-shadow)、渐变(gradient)、动画(animation)、过渡(transition)、弹性布局(flex)等</p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马JS最新教程</a> (2023.1.31 | 60:10:24)<br> Pink老师最新版JS课程，主要讲解JS核心知识，包含最新ES6语法、API、js高级等<br> <a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">https://www.bilibili.com/video/BV1Y84y1L7Nn</a></p>
</blockquote>
</li>
<li><p>三剑客进阶 移动Web&#x2F;<font color='red'>web API</font> – Less – Sass? – Scss? – <font color='red'>ES6</font></p>
<blockquote>
<p>移动web要学习一些web API、布局来更好的适配页面，如Flex 或是em vw vh等</p>
</blockquote>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br> Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
<blockquote>
<p>ES6对JS进行了语法改进，还增加了<strong>类和继承、Promise等特性</strong>，最重要的是<strong>制定了模块化标准</strong>，为开发者提供了更好的开发工具和语言特性，使得JS变的更加现代化、强大灵活<br> <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">黑马ES6教程</a> (19.7.31 | 91-122p)<br> 阮一峰es6教程 – <a href="https://es6.ruanyifeng.com/">官方</a> | <a href="https://wangdoc.com/es6/intro">网道镜像</a> <font color="red">推荐</font></p>
</blockquote>
</li>
<li><p>前端库&#x2F;工具 jQuery – bootStrap – ajax</p>
<blockquote>
<p>bootStrap是使用jQuery库来实现的？</p>
</blockquote>
</li>
<li><p>版本管理工具 git</p>
<blockquote>
<p>不过一开始应该不会用到，可以在学过node之后再学更好些</p>
</blockquote>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">黑马Git教程</a>(17.1.16 | 75-101p | 4h5min)</p>
<blockquote>
<p>很细，可以结合下面的文章补充<br>  建议先看廖雪峰的教程到git安装的地方，再开始学这个，然后廖雪峰教程跟进<br>  <a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">https://www.bilibili.com/video/BV1zs411h74a?t=8.1&amp;p=75</a></p>
</blockquote>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a> – 廖雪峰 </p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a><br>  因为是文章，所以会有地方不如视频直观明了，也有一些没说到的地方，但是也有很多视频中没有的东西</p>
</blockquote>
</li>
</ul>
</li>
<li><p>JS运行环境 ———— <font color='red'>Node.js</font></p>
<blockquote>
<p>Node.js是一个基于Chrome V8引擎的JS运行时环境，用于构建快速、可扩展的网络应用程序。之后，开发者就可以用JS来写服务端程序。</p>
<blockquote>
<p>node主要学习npm包管理器及各种包(工具)的使用<br> 学习node之后会让你更顺利的学习各种框架以及git<br> 学习node也会加深你对前后端交互以及后端的理解<br>Node.js采用非阻塞I&#x2F;O模型，能够高效处理大量并发请求，从响应效率上比同时代PHP更有优势</p>
</blockquote>
</blockquote>
<ul>
<li><strong>KoaJS</strong>(2013)<blockquote>
<p>Koa是Express的下一代框架，旨在解决Express中一些设计上的限制和缺陷，使得异步编程更加优雅、代码更加清晰、应用更急啊灵活</p>
</blockquote>
</li>
</ul>
</li>
<li><p>目前主流框架 <font color='red'>Vue(2014 尤雨溪) &#x2F; React(2013 Facebook)</font> &#x2F; <font color='#555'>Angular(2009 Google)</font></p>
<blockquote>
<ol>
<li><strong>Angular</strong>（不必要学，很多银行国企在用）(2009)<br>  2009年 由Google发布，引入了许多新概念，如双向数据绑定、依赖注入和模板化，为Web开发带来了革命性的变化，也为后续的SPA框架(单页面应用程序)发展奠定了基础。<br>  然而AngularJS是典型的“精英”框架，用后端思维设计的前端框架，直接沿用了MVC思想，加上很多首创的概念，比较晦涩难懂，因此不怎么流行<br>  angularjs和.net在国内同等命运，先进但无人问津，招人困难所以转vue+java</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>Vue</strong>(2014)<br>  Vue结合了Angular和React的优点，同时提供了更简洁的API和更灵活的设计，Vue的开发方式更像之前的套模版，使得开发者无缝过度，深受喜爱。<br>  Vue极为接地气，组件了活跃的社区，由社区编写了各语种的开发文档，每项说明都配上实例，还提供了各种应用场景的代码 DEMO<blockquote>
<p>Vue支持Webpack构建工具的使用<br>  原生Vue组件在js文件中的使用、Vue Cli脚手架、Element UI<br>  vue的核心原理（MVVM）、了解vue生命周期、组件传值、路由、vuex</p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>2.1 <strong>Nuxt.js</strong>(2016)<br>     在Next.js的启发下，Vue阵营出现了Nuxt，功能和Next几乎一模一样，给Vue提供了开箱即用的丰富功能和工具，使得Vue开发应用更加高效便捷<br>2.2 <strong>Uni-App</strong>(2018)（uni,unique,是统一的意思）<br>     是一款 使用Vue.js开发所有前端应用的 跨平台应用开发框架，开发者编写一套代码 基于Vue开发应用，可发布到iOS、Android、Web（响应式）&#x2F;H5、以及各种小程序、快应用等多个平台。<br>2.3 <strong>Vue3</strong>(2020)<br>     Vue3增加了组合式开发模式、增加了TS支持、引入了全新的Composition API，更加适应现代化前端的开发模式。同时，尤雨溪还推出了现代化前端构建工具Vite。<br>2.4 <strong>Vite</strong>(2020)<br>     Vite利用模块 热更新、按需编译等特性，为开发者提供了一种快速、轻量级、现代化的前端构建工具，填补了Webpack的性能瓶颈。</p>
</blockquote>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>React</strong>(2013)<br>  React引入了虚拟DOM的概念、组件化开发、单向数据流、使用JSX语法等等，极大的改变了前端的开发方式，推动了前端开发向组件化、高性能、高效率的方向发展。</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>3.1 <strong>React Native</strong>(2015)<br>     基于React开发的框架，使用JS和React的语法来构建原生移动应用。通过它，开发者可以使用相同的代码库构建同时运行在ios和Android平台上的原生应用。<br>3.2 <strong>Next.JS</strong>(2016)<br>     Next.JS是一个基于React的轻量级框架，提供了服务器端渲染、静态导出等功能，简化了React应用的开发和部署，使得React应用更易于优化和扩展，同时提供了更好的性能和SEO支持，成为构建现代Web应用的流行选择。 </p>
<blockquote>
<p>3.2.1 <strong>Server Actions</strong>(2023)<br>     2023年，Next.js14版本推出Server Actions，允许开发者直接在组件编写服务端代码,这张图被称作“科技圈最讨厌图片”，不少开发者困惑，这不就是PHP吗，因此Next.js也被戏称为Next.php<br>     <img width='300px' src='./images/Server%20Actions.png' /></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.3 <strong>Taro</strong>（2018）<br>     Taro除了是基于react之外，其他的功能与UniApp一模一样<br>     <code>2019年疫情爆发，人员统计、表单收集、健康码等等都是临时性、紧迫性的业务需求，没有现成的产品使用，过去呢种动辄上月甚至数年的开发周期显然不能满足，此时小程序承载了这一巨任，经常会有数天开发周期的小程序出现供防疫工作使用。在这里头UniApp和Taro充分发挥了它们的作用，尽管小程序是畸形发展的产物、UniApp和Taro开发会出现数不尽的兼容问题，但不可否认，这三年，它们对防疫工作的贡献是巨大的。</code></p>
</blockquote>
</blockquote>
<blockquote>
<ol start="4">
<li>React与Vue的对比<ol>
<li>国内比较推崇vue，而国外则比较偏爱React。目前国内中小公司仍以vue为主，不过部分也开始转向React，大公司则比较倾向React。</li>
<li>Vue使用模版语法，对元素实行绑定，是传统的HTML、CSS、JS分离式编程</li>
<li>React将用户界面抽象为组件的集合，强调组件之间的高度重用性，采用了反直觉的将HTML、CSS、JS封装在一起</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="PC-or-408-or-ELSE"><a href="#PC-or-408-or-ELSE" class="headerlink" title="PC or 408 or ELSE"></a>PC or 408 or ELSE</h4><ul>
<li><p>理解 OSI 模型和 TCP&#x2F;IP 协议族</p>
</li>
<li><p>学习 SSL&#x2F;TLS 协议和加密通信技术，保障网络通信的安全性。</p>
</li>
<li><p>掌握常见的安全协议如 HTTPS、SSH 等的原理和使用方法。</p>
</li>
<li><p><font color='red'>XXS 跨站脚本</font></p>
<blockquote>
<p>学习 XSS 攻击的基本原理，包括攻击者向网站注入恶意脚本代码，以及受害者浏览网站时执行恶意脚本的过程。</p>
</blockquote>
<blockquote>
<p>学习如何发现网站中的 XSS 漏洞，包括手动审查源代码、使用自动化工具进行漏洞扫描等方法。</p>
</blockquote>
<blockquote>
<p>学习反射型 XSS、存储型 XSS 和 DOM 型 XSS 等不同类型的 XSS 攻击，了解它们的区别和特点。</p>
</blockquote>
<blockquote>
<p>了解攻击者利用 XSS 漏洞进行的一些常见攻击，如窃取用户信息、会话劫持、网站篡改等。</p>
</blockquote>
</li>
<li><p>DDOS 分布式拒绝服务攻击</p>
<blockquote>
<p>网络攻击，旨在使目标系统或网络资源不可用，通常是通过使目标系统或网络过载或崩溃来实现的。攻击者利用大量的合法或非法的网络流量向目标系统发送请求，导致目标系统无法处理正常的用户请求，从而使其服务不可用。</p>
</blockquote>
</li>
</ul>
<h4 id="Else-Tech"><a href="#Else-Tech" class="headerlink" title="Else Tech"></a>Else Tech</h4><p>一些分支以及完全不是前端的技术</p>
<ul>
<li><p>构建工具 <strong>Webpack</strong>(2012)、Parcel</p>
<blockquote>
<p>在2016年，在ES6&#x2F;ES 2015的一剂强心丸的影响下，Webpack支持ES Module，Webpack开始在前端社区迅速流行。特别是在React和Vue等流行框架的支持下，Webpack的使用逐渐成为前端开发的标配</p>
</blockquote>
</li>
<li><p>包管理器<strong>npm</strong>、Yarn</p>
</li>
<li><p><strong>TypeScript</strong>（TS）(2012)</p>
<blockquote>
<p>2012年问世，由于JS是动态语言，意味着JS基本与大型项目无缘，或者需要承担巨大的维护代价，而TS的出现，使得JS可以像静态语言一样开发项目，赋予JS无限的可能。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV14Z4y1u7pi?t=27.0">黑马TS教程</a>(2020年 时长11:46:00)</li>
<li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TS入门教程</a> – 个人博客所作(作者xcatliu) <font color='red'>推荐</font><blockquote>
<p><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">https://ts.xcatliu.com/introduction/what-is-typescript.html</a><br>  是部署在GitHub Pages上的，很好的教程！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Electron(2013 GitHub)</p>
<blockquote>
<p>基于Chromium和Node.js的跨平台桌面应用程序开发框架，允许开发者使用Web技术来构建原生桌面应用</p>
</blockquote>
</li>
<li><p>Svelte(2016)</p>
<blockquote>
<p>Svelte 和 Vue、React一样都是现代化前端框架。<br>      不同的是，Svelte没有采用虚拟DOM技术，使得其更加轻巧。近年来，随着开发者对其性能优势和开发体验的认可，Svelte逐渐成为前端开发中备受推崇的框架之一。</p>
</blockquote>
<p>  SvelteKit(2021 Svelte官方)</p>
<blockquote>
<p>和Next、Nuxt相同功能的框架，极大丰富了Svelte生态系统</p>
</blockquote>
</li>
<li><p><strong>Tailwind CSS</strong>(2017)</p>
<blockquote>
<p>在React和Vue等组件化开发框架的发展下，DOM的不用不再是难题，在大型项目下，CSS的复用已经名存实亡，于是Tailwind CSS出现了。<br>  Tailwind CSS的设计理念是提供一组原子类，以快速构建样式，而不需要编写自定义的CSS，这一开发方式深受开发者喜爱，并成为Next框架的默认组件。至此，Sass、Less完成了它们的历史使命。</p>
</blockquote>
</li>
<li><p>Flutter(2017 Google)</p>
<blockquote>
<p>Flutter是一种用于构建跨平台移动应用的框架。可以同时在IOS、Android、Web和桌面平台运行。</p>
</blockquote>
</li>
<li><p>NestJS(2017)</p>
<blockquote>
<p>NestJS设计灵感来源于 Angular 框架，借鉴了其模块化、依赖注入和装饰器等概念，用于构建高效且可扩展的服务端应用程序，弥补了Node生态中的一些框架空白，加上对TS的支持，为JS开发大型后端应用打下基础</p>
</blockquote>
</li>
<li><p>ArkTS语言(2022 华为)</p>
<blockquote>
<p>华为确定改语言用于鸿蒙APP开发。是基于TS扩展的语言，意味着如果会Web前端，也就会鸿蒙应用开发。<br>  华为使用ArkTS语言，意味着瞬间拥有了大量的开发者基础，同时很可能促进所有的终端开发都采用JS，而那时前端技术将迎来大一统</p>
</blockquote>
</li>
<li><p>PHP(后端服务器)</p>
<blockquote>
<p>PHP是世界上最好的语言。</p>
</blockquote>
</li>
<li><p>Python(爬虫、脚本、大数据分析)</p>
</li>
<li><p>Java – Java框架 –Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud&#x2F;&#x2F;Sprint家族</p>
</li>
</ul>
<h2 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h2><ol>
<li><a href="https://www.xuanfengge.com/it-job-seekers-resume-how-to-write.html">IT求职者的简历该如何编写</a>(轩枫阁)<blockquote>
<p>2014&#x2F;10&#x2F;14的帖子，不过还是有很多值得学习的地方</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Pulled Post</title>
    <url>/tsukimiya.github.io/PulledPost/index.html</url>
    <content><![CDATA[<blockquote>
<p><code>Here are many posts pulling for you, hope you&#39;ll gain something</code></p>
</blockquote>
<h2 id="Pulled-Bloger-or-Community"><a href="#Pulled-Bloger-or-Community" class="headerlink" title="Pulled Bloger or Community"></a>Pulled Bloger or Community</h2><ol>
<li><p>沧沧凉凉 – <a href="https://juejin.cn/user/1380642337065421/posts">掘金</a> | <a href="https://www.zhihu.com/people/hatsune-87/posts">知乎</a></p>
</li>
<li><p>freecodecamp编程免费教学慈善组织 – <a href="https://www.freecodecamp.org/chinese/learn">官网</a> | <a href="https://www.freecodecamp.org/chinese/news/">专栏</a> | <a href="https://forum.freecodecamp.org/c/chinese/533">论坛</a></p>
<blockquote>
<p>官方支持中文，专栏和论坛有很多优质文章</p>
</blockquote>
</li>
<li><p><a href="https://www.xuanfengge.com/">轩枫阁</a> <font color="red">墙裂Pull!!</font></p>
<blockquote>
<p>前端大神的个人博客！腾讯微信前端工程师！ orz_<br> <a href="https://www.xuanfengge.com/funny/">SOME NB H5&amp;C3&amp;Animation orz_</a>(H5元素周期表就出自这里)<br> look older，but niubility build from 2013</p>
</blockquote>
</li>
</ol>
<h2 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h2><ol>
<li><a href="https://www.xuanfengge.com/fe-books.html">Web前端开发推荐阅读书籍、学习课程下载</a> <font color="green">推荐书籍可参考!!</font>(轩枫阁)<blockquote>
<p>可惜太老了，15年的推荐，可以参考一下一些推荐的书籍</p>
</blockquote>
</li>
</ol>
<h3 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h3><ol>
<li><a href="https://www.xuanfengge.com/funny/html5/spider/">逼真的蜘蛛</a>(轩枫阁)<blockquote>
<p>有时间仿一下，感觉和之前见到的一个博客磁吸线条成网的背景原理相似</p>
</blockquote>
</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h4><ol>
<li><a href="https://juejin.cn/post/7075162881498562590">Varlet，被尤雨溪推荐，这款开箱即用的Vue3组件库做对了什么</a>(掘金22&#x2F;3&#x2F;15)<blockquote>
<p>Varlet：一个基于 Vue3 开发的 Material 风格移动端组件库</p>
</blockquote>
</li>
</ol>
<h2 id="MD"><a href="#MD" class="headerlink" title="MD"></a>MD</h2><ul>
<li><a href="https://www.runoob.com/markdown/md-table.html">markdown表格语法</a>(菜鸟教程)</li>
</ul>
<h2 id="Blog-Build"><a href="#Blog-Build" class="headerlink" title="Blog Build"></a>Blog Build</h2><ul>
<li><a href="https://iknowwang.com/">如何架設網站：一個完全免費的教學（Blog推薦 + 網頁製作軟體 ）</a>(Wordpress)<blockquote>
<p>讲到了很多建设网站的东西</p>
</blockquote>
</li>
</ul>
<h3 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/37896471">WordPress搭建教程：手把手教你搭建WordPress博客</a>(知乎)<blockquote>
<p>域名推荐在 <a href="https://www.namesilo.com/?rid=d27fa32do">Namesilo</a> 购买，价格便宜，赠送永久免费的隐私保护。(0.99$&#x2F;第一年)<br>注册账户。注册信息建议如实填写，并勾选“Keep my information private”默认使用隐私保护。<br> 设置域名续费规则、注册时长等。在“Have a Coupon……”处输入优惠码 okoff 或者 go2think，点击“Submit”应用，优惠一美元。<br> 完成后点击“CONTINUE”付款，支持支付宝和 Paypal 等。</p>
</blockquote>
</li>
</ol>
<h3 id="Hexo-Next"><a href="#Hexo-Next" class="headerlink" title="Hexo + Next"></a>Hexo + Next</h3><ol>
<li><p><a href="https://cloud.tencent.com/developer/article/2065803">Hexo图标样式参考</a>(腾讯云)</p>
<blockquote>
<p>Hexo 支持FontAwesome图标，就是在代码中出现名字以fa fa开头的类名，本文介绍具具体图标来源和使用方法。</p>
</blockquote>
</li>
<li><p>post页面图片引用(self) </p>
<blockquote>
<p>hexo + next 似乎并不支持@作为索引根目录或source目录，至少试了不起作用<br> 可以将图片放到source的images文件下，然后用markdown引用<br> <code>![img](/images/xxx.png)</code><br> 在images前面有一个&#x2F;,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,如果想要更改可以修改_config.yml下的source_dir参数</p>
</blockquote>
<ul>
<li>参考文章 – <a href="https://blog.csdn.net/Miracle_ps/article/details/114791335">Hexo 添加图片</a>(CSDN)</li>
</ul>
</li>
</ol>
<h2 id="408"><a href="#408" class="headerlink" title="408"></a>408</h2><h3 id="计算机网络原理"><a href="#计算机网络原理" class="headerlink" title="计算机网络原理"></a>计算机网络原理</h3><ul>
<li>计算机网络原理 谢希仁（第8版）课后习题答案<ul>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126150861">第一章–分组交换 &#x2F; 时延 &#x2F; 性能指标 &#x2F; OSI七层模型和TCP&#x2F;IP五层模型–网络体系结构</a>(CSDN&#x2F;答案不全)<br>  不全的部分参考这个 <a href="https://cloud.tencent.com/developer/article/2055618">Post</a> (腾讯云&#x2F;Q10开始排版不好)</li>
<li><a href="https://blog.csdn.net/weixin_62985813/article/details/134105653">第二章–物理层</a>(CSDN)</li>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126276788">第三章–数据链路层</a>(CSDN)</li>
</ul>
</li>
</ul>
<h2 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h2><ol>
<li><a href="https://www.xuanfengge.com/it-job-seekers-resume-how-to-write.html">IT求职者的简历该如何编写</a>(轩枫阁)<blockquote>
<p>2014&#x2F;10&#x2F;14的帖子，不过还是有很多值得学习的地方</p>
</blockquote>
</li>
</ol>
<h2 id="ELSE"><a href="#ELSE" class="headerlink" title="ELSE"></a>ELSE</h2>]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/tsukimiya.github.io/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/tsukimiya.github.io/guestbook/index.html</url>
    <content><![CDATA[<h1 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的博客！</h1><blockquote>
<p>欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的。目前留言板块尚未配置完全，暂时无法使用，如有问题请邮箱：<br><a href="mailto:&#104;&#97;&#x72;&#105;&#105;&#106;&#x69;&#99;&#x6f;&#64;&#x6f;&#x75;&#x74;&#108;&#111;&#111;&#107;&#46;&#99;&#x6f;&#x6d;">&#104;&#97;&#x72;&#105;&#105;&#106;&#x69;&#99;&#x6f;&#64;&#x6f;&#x75;&#x74;&#108;&#111;&#111;&#107;&#46;&#99;&#x6f;&#x6d;</a><br><a href="mailto:&#49;&#x38;&#x33;&#50;&#55;&#49;&#53;&#56;&#x33;&#x38;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#49;&#x38;&#x33;&#50;&#55;&#49;&#53;&#56;&#x33;&#x38;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;</a><br>欢迎给我发送邮件</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>日程表</title>
    <url>/tsukimiya.github.io/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Task</title>
    <url>/tsukimiya.github.io/schedule/task.html</url>
    <content><![CDATA[<blockquote>
<p>快给我滚去学习！给你一拳</p>
</blockquote>
<h2 id="Study-Tech"><a href="#Study-Tech" class="headerlink" title="Study Tech"></a>Study Tech</h2><h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h3><ol>
<li>vue框架<ul>
<li><p>黑马vue课程（21.8 | vue2 - 12h）<br>  <a href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&p=32">https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&amp;p=32</a></p>
</li>
<li><p>邓瑞编程 3小时学会Vue3 (24.1.23 | 2h16min)</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1nV411Q7RX">https://www.bilibili.com/video/BV1nV411Q7RX</a><br> 有个人博客教程<a href="https://www.dengruicode.com/">https://www.dengruicode.com/</a><br> 可以看看这个，反正很短</p>
</blockquote>
</li>
<li><p>尚硅谷 禹神 Vue3+TS（23.12.19 | 14h）</p>
<blockquote>
<p>基于Vue3的setup语法糖讲解，全程采用TypeScript+组合式API编码，贴心准备TypeScript快速上手笔记！带你快速上手纯血版Vue3！<br>  <a href="https://www.bilibili.com/video/BV1Za4y1r7KE">https://www.bilibili.com/video/BV1Za4y1r7KE</a></p>
</blockquote>
</li>
<li><p><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a> <font color='red'> 推荐 </font><br>  &gt; 写的很细，无论是基础还是进阶都可以看</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>如何记录网站每天的访问量及访问IP？</p>
</li>
<li><p>在首页和标签页添加 字数统计+阅读时长 以及 打赏 &#x2F;&#x2F; 应该要修改源模版文件代码</p>
<blockquote>
<p>要将字数统计和阅读时长设置添加到首页和标签页，你需要在网站的主题或模板文件中进行修改。具体来说，你需要找到首页和标签页的模板文件，并在其中添加相应的代码以显示字数统计和阅读时长。<br>  通常，这些模板文件可以在你的网站主题文件夹中找到。你可以查看主题的文档或者在主题文件夹中搜索包含首页和标签页内容的模板文件。<br>  一旦找到了这些模板文件，你可以根据需要修改它们，添加类似以下的代码来显示字数统计和阅读时长：<br>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.symbols %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>字数统计: &#123;&#123; page.symbols &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if page.time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阅读时长: &#123;&#123; page.time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><br>请注意，具体的代码可能会因为你使用的网站平台或主题而有所不同。最好查阅你使用的平台或主题的文档，以确保正确添加字数统计和阅读时长功能。</p>
</blockquote>
</li>
<li><p>markdown解析a标签或<code>[]()</code>的地址链接会把参数去掉，所以如果是带参数的连接会失效，最好标注一下连接地址，在浏览器点击未被解析的链接地址(解决一下这个问题，然后写一篇post)</p>
<blockquote>
<p>但是hexo解析之后生成的HTML页面上点击是没有问题的，把参数带上了<br>  hexo生成的HTML页面很多样式也和MD显示有区别，应该是内部处理了？</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>pink html + css + 移动端后面这部分看一下</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV14J4114768/?p=389">https://www.bilibili.com/video/BV14J4114768/?p=389</a><br> p357-388为 CSS2D、3D(这里有空也看一下吧，正好做一下笔记)<br> 后面<br> p389-p502大致都是移动端，包括流式布局，Less，响应式相关<br> p503-513为bootStrap<br> bootStrap BS 以 Less (Sass), OOCSS 与 SMACSS 为基础<br> 最后是项目</p>
</blockquote>
</li>
<li><p>es6</p>
<ul>
<li>黑马视频<br> <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&amp;p=91</a></li>
<li>阮一峰es6书(手机进行中)<br> <a href="https://wangdoc.com/es6/intro">https://wangdoc.com/es6/intro</a></li>
</ul>
</li>
<li><p>ajax + git</p>
</li>
</ol>
<h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><ul>
<li><p>微信小程序 + uni-app<br><a href="https://www.bilibili.com/video/BV1834y1676P?t=75.0">https://www.bilibili.com/video/BV1834y1676P?t=75.0</a></p>
</li>
<li><p>react<br><a href="https://www.bilibili.com/video/BV1gh411U7JD?t=50.3">https://www.bilibili.com/video/BV1gh411U7JD?t=50.3</a></p>
</li>
<li><p>js面试<br><a href="https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1">https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1</a></p>
</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><p>CSS 布局经典问题大全<br><a href="https://www.html-js.com/article/5889">https://www.html-js.com/article/5889</a></p>
</li>
<li><p>网站会DDOS攻击会有哪些反应，如何应对此现象？<br><a href="https://www.html-js.com/article/6657">https://www.html-js.com/article/6657</a></p>
</li>
<li><p>响应式网页设计——怎样让一个网站在手机、平板上好看<br><a href="https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/">https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/</a></p>
</li>
<li><p>什么是 XSS？如何保护网站免受 DOM 跨站脚本攻击<br><a href="https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/">https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/</a></p>
</li>
<li><p>SEO优化？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=4.5&p=311">https://www.bilibili.com/video/BV14J4114768?t=4.5&amp;p=311</a></p>
</li>
<li><p>上传服务器？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=2.5&p=355">https://www.bilibili.com/video/BV14J4114768?t=2.5&amp;p=355</a></p>
</li>
<li><p>多栏布局<br>多栏布局是最常见的css布局之一，实现的方式不下10种，它们分别应对各种各样的业务场景，而bs的流式布局堪称撑起一片天，它的响应式看似独霸天下能满足80%的要求，但开发者们仍会保留20%用于追逐更高效的技巧，而且随着前端的发展，原生bs流式布局已然有更优的实现方式了。</p>
</li>
<li><p>Layui – 快速实现页面布局效果，</p>
</li>
<li><p>防抖 节流<br><a href="https://www.bilibili.com/video/BV1zs411h74a?t=5.0&p=66">https://www.bilibili.com/video/BV1zs411h74a?t=5.0&amp;p=66</a></p>
</li>
<li><p>web APIs(页面适配，less，Sass等一些)</p>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br>  Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
</li>
<li><p>es6，模块化，组件化，css3，less，scss</p>
</li>
<li><p>QQ的卡片是怎么写的？随机给一张图片的那种卡片</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tsukimiya.github.io/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
