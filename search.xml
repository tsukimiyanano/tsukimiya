<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用emoji表情</title>
    <url>/tsukimiya.github.io/2024/05/07/Hexo/hexo%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<blockquote>
<p>本文章不对emoji的使用做太深入的研究，因为在写文章上是一个不太必要的需求，也是一个鲜少使用的东西，总之能用就行。</p>
</blockquote>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>直接给出结论：</p>
<ol>
<li><strong>将表情符号复制并粘贴到Markdown格式的文本中</strong> <font color="red">推荐</font></li>
<li>直接使用表情符号的Unicode编码，格式：<code>&amp;#x[Unicode编码];</code><br>例如，😊的 Unicode 编码是 U+1F60A —— 对应的 HTML 实体编码是 <code>&amp;#x1F60A;</code><br>直接在md文件的文本内容里面输入HTML实体编码即可<code>&amp;#x1F60A;</code>&#x1F60A;</li>
</ol>
<p>Tip1: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。<br>Tip2: 千万不要去折腾什么插件了！不需要插件！没错，就是我折腾了好久卸载了</p>
<ul>
<li><p>附上可供使用的工具：<br>Windows 10周年更新内置的 <strong>Emoji键盘</strong> <code>win + .</code>快捷键唤出 <font color="red">推荐👍</font></p>
<p>在线工具-Emoji表情符号(可搜索)：<a href="https://www.toolhelper.cn/Encoding/Emoji">https://www.toolhelper.cn/Encoding/Emoji</a> <font color="red">推荐</font></p>
<blockquote>
<p>最推荐，附有表情说明，及其Unicode编码</p>
</blockquote>
<p>Emoji大全(可搜索)：<a href="https://emoji6.com/emojiall/">https://emoji6.com/emojiall/</a> <font color="green">推荐</font></p>
<blockquote>
<p>可备用</p>
</blockquote>
<p>EMOJI中文网(可搜索)：<a href="https://www.emojiall.com/zh-hans">https://www.emojiall.com/zh-hans</a></p>
<blockquote>
<p>速度有点慢，东西也太多了，不太好用</p>
</blockquote>
</li>
<li><p><a href="https://markdown.com.cn/extended-syntax/emoji.html">Markdown 官方教程 - Markdown 使用 Emoji 表情</a></p>
<blockquote>
<p>发现MD还有官网，官方教程中有提到复制粘贴的方法</p>
</blockquote>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因为<strong>emoji表情符号也是Unicode字符的一种</strong>。</p>
<ol>
<li><p><strong>Markdown文件显示的原理</strong><br>像 VSCode 中通过插件预览 Markdown 文件的功能，以及其他类似的 Markdown 预览功能，通常也是<strong>通过 Markdown 渲染引擎生成的 HTML 页面</strong>来实现的。</p>
</li>
<li><p>emoji正常显示的原理<br>Markdown本身对于文本中的普通Unicode字符都有很好的支持，包括表情符号。<br>所以在Markdown文本中，你可以直接使用表情符号的Unicode编码，或者直接复制粘贴表情符号，当 Markdown 文件被渲染时，渲染引擎会将表情符号正确地转换为对应的图像，并在最终生成的 HTML 页面中显示出来。<br>通常情况下，Markdown 渲染引擎会将表情符号识别为 Unicode 字符，就像对待普通的文本文字一样，并不会对其做什么处理。<strong>这和直接在 HTML 页面中使用表情符号是一样的效果。</strong></p>
</li>
<li><p>Hexo渲染的HTML页面显示emoji<br>Hexo依赖于 hexo-renderer-marked 渲染引擎来解析 Markdown 文本，和vscode中预览是一样的原理，只是使用的渲染器不同而已</p>
</li>
</ol>
<h2 id="hexo中使用emoji的问题"><a href="#hexo中使用emoji的问题" class="headerlink" title="hexo中使用emoji的问题"></a>hexo中使用emoji的问题</h2><p>因为之前从未在md使用过emoji，突然有想要使用的念头，于是在不太了解的情况下试图找到方法。于是导致产生了一系列的问题。</p>
<ol>
<li><p><strong>误解</strong><br>由于一些误解性的信息导向，以至于我一度以为Hexo不支持使用emoji</p>
<ul>
<li><p>vscode的Markdown Preview Enhanced插件是支持emoji的</p>
</li>
<li><p>在搜索引擎搜索，hexo中使用emoji表情，很多都是这样说：</p>
<ul>
<li>Hexo 默认的 Markdown 渲染器是 hexo-renderer-marked，这个渲染器不支持 emoji 表情。</li>
<li>Hexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中</li>
</ul>
<p>然后教你安装 hexo-filter-github-emojis 插件，并启用配置</p>
</li>
</ul>
<p> 但是，他们几乎都是在说 使用 <a href="https://markdown.com.cn/extended-syntax/emoji.html"><strong>表情符号简码</strong></a> 的方式来 在Hexo中使用Emoji</p>
<blockquote>
<p>表情符号简码，通过键入表情符号短代码来插入表情符号，如：<code>:smile:</code>、<code>:punch:</code></p>
</blockquote>
</li>
<li><p>配置并使用 <code>hexo-filter-github-emojis</code> 插件<br> 在参考了这三篇文章之后，卸载了原渲染器插件，安装了<code>hexo-renderer-markdown-it</code>并添加了如下配置：</p>
<blockquote>
<p>参考文章 <a href="https://cloud.tencent.com/developer/article/2065824">文章1 - 22.8</a>、<a href="https://luckysusu.top/post/hexo_emoji.html">文章2 - 23.10</a>、<a href="https://blog.xaoxu.cn/archives/hexo-use-emoji">文章3 - 21.8</a><br> 文章2的苏苏的小屋博客做的不错，不过有点花过头了XD</p>
</blockquote>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## markdown 渲染引擎配置，默认是hexo-renderer-marked，这个插件渲染速度更快，且有新特性</span></span><br><span class="line"><span class="comment">## 因为不能支持原来的全局资源文件夹，引用图片，没找到解决的方法，故不使用，还是原配好啊</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span>  <span class="comment"># add emoji</span></span><br></pre></td></tr></table></figure>
<p> 然后发现，博客上发布的文章基本没有什么变化，样式上渲染的算是接受度很好，我一度想着会不会样式会变的太大，还得花事件去修整，这里算是放了大心。<br> 再然后，我发现页面上的图片引用都失效了！！！</p>
</li>
<li><p>图片引用的问题<br> 似乎是更换的插件不支持<strong>全局资源文件夹引用</strong>，但是又因为文章的链接索引有日期在，想要通过相对路径引用到就需要好多..&#x2F;，如果每次都要这么干绝对受不了，且一定会有更好的办法<br> 然后各种搜索，各种尝试，下载了好几个插件，设置什么的，但是都没有解决这个问题。<br> 折腾许久未果，果断卸载了<code>hexo-filter-github-emojis</code> 插件，重装回原来的<code>hexo-renderer-marked</code>插件<br> 于是，问题又变回了：如何使用emoji的问题</p>
<p> 期间想到了也许可以通过使用base64来解决这个问题，因为图片是可以转成base64格式的字符串的，那么emoji应该也可以，那么有没有一些在线，将emoji及其base64格式的字符整理的网页呢？</p>
<p> 但是搜索并没有找到什么现有可用的一些这样的东西，甚至找不到相关的文章</p>
<blockquote>
<p>github还真有这样一个项目！<a href="https://github.com/watson/base64-emoji">base64-emoji</a></p>
</blockquote>
<p> 不过后来知道了，才知道，emoji本身其实是一种unicode字符，并不是图片，所以并不应该转换成base64，而是可以直接使用的，也许因此才没有相关文章。</p>
<blockquote>
<p>不过一些表情包，emoji就是图片，也是因此才会更加误以为emoji其实也是一些小图片吧(如搜狗输入法上自带的，有的还是存在C盘哪里的？忘记了。才发现搜狗如果输入一些关键字，就会出现对应的emoji，选择它会把图片放到md的同目录下，并添加到md上)</p>
</blockquote>
<p> 最后，在各种尝试下，终于得出了使用emoji的方法，也即是文章开头的方法</p>
</li>
</ol>
<ul>
<li>那么问题来了，在html页面如何使用emoji表情？js如何使用emoji？ <a href="https://zhuanlan.zhihu.com/p/328516890">参考一篇文章</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="hexo全局资源文件夹引用"><a href="#hexo全局资源文件夹引用" class="headerlink" title="hexo全局资源文件夹引用"></a>hexo全局资源文件夹引用</h3><p><code>![img](/images/vue/组件生命周期.png)</code><br>该格式会被渲染器解析为img元素渲染到页面上<br>[]里的值会被解析为img元素的alt属性，即如果找不到图片会显示为img这个字符串<br>()里的则会解析为img元素的src属性</p>
<h3 id="表情符号简码"><a href="#表情符号简码" class="headerlink" title="表情符号简码"></a>表情符号简码</h3><p>对于表情符号，GitHub Markdown支持使用特定的简码来直接显示表情。当你在Markdown文本中使用表情符号的简码时，GitHub会自动将其解析并替换为对应的表情符号图像，从而在文档中显示出来。</p>
<p>这种自动替换是GitHub的一个特性，使得Markdown文本中的表情符号可以直观地显示出来，增强了文档的可读性和趣味性。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>emoji</tag>
        <tag>markdown渲染器</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的API接口案例</title>
    <url>/tsukimiya.github.io/2024/05/08/Node/API%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="API接口案例"><a href="#API接口案例" class="headerlink" title="API接口案例"></a>API接口案例</h2><p>基于<strong>MySQL数据库 + Express</strong>对外提供<strong>用户列表</strong>的API接口服务</p>
<ol>
<li>技术栈：<ul>
<li>第三方包express、mysql2</li>
<li>ES6模块化</li>
<li>Promise</li>
<li>async&#x2F;await</li>
</ul>
</li>
<li>主要实现步骤<ol>
<li>搭建项目的基本结构</li>
<li>创建基本的服务器</li>
<li>创建db数据库操作模块</li>
<li>创建user_ctrl 业务模块</li>
<li>创建user_router路由模块</li>
</ol>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li><p>初始化包管理配置文件package.json —— <code>npm init -y</code></p>
</li>
<li><p>启用ES6模块化支持</p>
<ul>
<li>在package.json中声明<code>&quot;type&quot;: &quot;module&quot;</code></li>
</ul>
</li>
<li><p>安装第三方依赖包</p>
<ul>
<li>运行<code>npm install express@4.17.1 mysql2@2.2.5</code></li>
</ul>
</li>
<li><p>创建最基本的web服务器</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Express server running at http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>创建db数据库操作模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db/index.js</span></span><br><span class="line"><span class="keyword">import</span> mysql <span class="keyword">from</span> <span class="string">&#x27;mysql2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// 指定操作哪台电脑</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>, <span class="comment">// 指定端口号，一般mysql数据库的端口号都是3306</span></span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;my_db_01&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;ayu123+&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果导出pool，它不支持以promise API的形式来操作数据库</span></span><br><span class="line"><span class="comment">// 此时我们需要调用pool提供的.promise()，把返回值导出出去</span></span><br><span class="line"><span class="comment">// 外界拿到数据库的连接对象之后，就可以以Promise的方式来操作数据库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pool.<span class="title function_">promise</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>创建user_ctrl 业务模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller/user_ctrl.js</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&#x27;../db/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的按需导出语法，将getALLUser语法导出出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllUser</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">  <span class="comment">// 数组中，索引为0的那一项，是最终需要的数据，所以解构赋值出一个rows</span></span><br><span class="line">  <span class="keyword">const</span> [rows] = <span class="keyword">await</span> db.<span class="title function_">query</span>(<span class="string">&#x27;select id,username,nickname from users&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">messages</span>: <span class="string">&#x27;获取用户列表数据成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: rows,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建user_router路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user_router.js</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getAllUser &#125; <span class="keyword">from</span> <span class="string">&#x27;../controller/user_ctrl.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, getAllUser)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在app.js注册路由</span></span><br><span class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">&#x27;./router/user_router.js&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure></li>
<li><p>使用try…catch捕获异常<br>当报错之后，使用catch进行处理，程序不会发生崩溃</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller/user_ctrl.js</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&#x27;../db/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的按需导出语法，将getALLUser语法导出出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllUser</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">  <span class="comment">// 数组中，索引为0的那一项，是最终需要的数据，所以解构赋值出一个rows</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [rows] = <span class="keyword">await</span> db.<span class="title function_">query</span>(<span class="string">&#x27;select id,username,nickname,xxx from users&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">messages</span>: <span class="string">&#x27;获取用户列表数据成功！&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: rows,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">messages</span>: <span class="string">&#x27;获取用户数据失败！&#x27;</span>,</span><br><span class="line">      <span class="attr">desc</span>: err.<span class="property">messages</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode开发uniapp小程序，text、view标签报红错误提示</title>
    <url>/tsukimiya.github.io/2024/05/18/uni-app/view%E6%A0%87%E7%AD%BE%E6%8A%A5%E7%BA%A2%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p><img src="/tsukimiya.github.io/images/uniapp/%E6%A0%87%E7%AD%BE%E6%8A%A5%E7%BA%A2.png" alt="标签报红"></p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a><font color="violet">2.解决方案</font></h2><p>添加 @uni-helper&#x2F;uni-app-types 的类型依赖，然后在 tsconfig 里配置一下。</p>
<blockquote>
<p>亲测有效</p>
</blockquote>
<p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @uni-helper/uni-app-types</span><br></pre></td></tr></table></figure>

<p>在 tsconfig.json 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vueCompilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@uni-helper/uni-app-types/volar-plugin&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="3-另外一种解决方案"><a href="#3-另外一种解决方案" class="headerlink" title="3.另外一种解决方案"></a>3.另外一种解决方案</h2><p>直接使用div标签替换view标签，span标签替换text标签。这样就不会报错了。<br>uniapp会帮我们把div和span转换成view和text。</p>
<blockquote>
<p>uni-app官方文档中明确说明：</p>
<ul>
<li>小程序平台如果使用 <code>&lt;div&gt;</code> ，编译时会被转换为 <code>&lt;view&gt;</code>。</li>
<li>App平台 Vue2 项目在节点非常多时可以尝试使用 <code>&lt;div&gt;</code> 替换 <code>&lt;view&gt;</code> 以提升渲染性能。</li>
</ul>
<p>地址：<a href="https://uniapp.dcloud.io/component/view?id=view">https://uniapp.dcloud.io/component/view?id=view</a></p>
</blockquote>
<p>不过，还是推荐使用<code>&lt;view&gt;</code>和<code>&lt;text&gt;</code>，因为它们是平台原生支持的，符合小程序的开发规范。具有较高可读性，也更能保证多端兼容。</p>
<blockquote>
<p>view和text是uni-app为了保持多端一致性而提供的原生组件，它们分别对应于微信小程序、H5以及其他小程序平台的原生视图容器和文本显示元素。使用它们可以确保你的应用在不同平台（如微信小程序、H5、App等）有一致的表现和性能。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/q/1010000044860981?utm_source=sf-similar-question">https://segmentfault.com/q/1010000044860981?utm_source=sf-similar-question</a></p>
<p><a href="https://segmentfault.com/q/1010000044527776?utm_source=sf-similar-question">https://segmentfault.com/q/1010000044527776?utm_source=sf-similar-question</a></p>
]]></content>
      <categories>
        <category>uni-app</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>vscode</tag>
        <tag>vue3</tag>
        <tag>ts</tag>
        <tag>标签报红</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3内容介绍</title>
    <url>/tsukimiya.github.io/2024/05/08/vue3/1.vue3%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>Vue3内容：<br>    1. <font color="red"><strong>核心</strong></font>：<font color="red">ref、reactive、computed、watch、生命周期……</font><br>    2. <font color="green"><strong>常用</strong></font>：<font color="green">hooks、自定义ref、路由、pinia、mitt……</font><br>    3. <strong>面试</strong>：<strong>组件通信、响应式相关API……</strong></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue是一套<strong>用于构建用户界面的前端框架</strong>。它为构建用户界面提供了一整套的解决方案(俗称Vue全家桶)：</p>
<ul>
<li>vue (核心库)</li>
<li>vue-router (路由方案)</li>
<li>vuex (状态管理方案)</li>
<li>vue 组件库 (快速搭建页面U效果的方案)</li>
</ul>
<p>以及<strong>辅助vue项目开发</strong>的一系列工具:</p>
<ul>
<li>vue-cli (npm 全局包: 一键生成工程化的vue 项目 - 基于webpack、大而全)</li>
<li>vite (npm 全局包: 一键生成工程化的vue项目 – 小而巧)</li>
<li>vue-devtools (浏览器插件: 辅助调试的工具)</li>
<li>vetur (vscode插件: 提供语法高亮和智能提示)</li>
</ul>
<p><img src="/tsukimiya.github.io/images/vue/vue3.png" alt="vue3"></p>
<h2 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h2><blockquote>
<p>2020.9.18，Vue.js发布 3.0版本，代号：One Piece(海贼王)（尤雨溪老二次元了XD）<br>官方发布地址：Release v3.0.0 One Piece·vuejs&#x2F;core</p>
</blockquote>
<p>vue3.x中<strong>兼容vue2.x中绝大多数的API与特性</strong>，同时，<strong>新增了3.x所特有的功能</strong>、并<strong>废弃了某些2.x中的旧功能</strong>:</p>
<ul>
<li><p>新增的功能例如:<br><strong>组合式API</strong>、多根节点组件、更好的TypeScript支持等</p>
</li>
<li><p>废弃的旧功能如下︰<br><strong>过滤器</strong>、不再支持$on，$off和$once实例方法等</p>
</li>
</ul>
<p>详细的变更信息，请参考官方文档给出的<strong>迁移指南</strong>: <a href="https://v3-migration.vuejs.org/zh/">https://v3-migration.vuejs.org/zh/</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>编码语言：JS、<strong>TS</strong><blockquote>
<p>实际工作中，Vue3往往搭配着TS一起使用</p>
</blockquote>
</li>
<li>代码风格：<strong>组合式API</strong>(最新的)、选项式API(传统的)<blockquote>
<p>官方明确表示，推荐使用组合式API</p>
</blockquote>
</li>
<li>简写形式：<strong>setup语法糖</strong></li>
</ol>
<ul>
<li><font color="red"><strong>核心</strong></font>：<br><font color="red">ref、reactive、computed、watch、生命周期……</font></li>
<li><font color="green"><strong>常用</strong></font>：<br><font color="green">hooks、自定义ref、路由、pinia、mitt……</font></li>
<li><strong>面试</strong>：<br><strong>组件通信、响应式相关API……</strong></li>
</ul>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><ul>
<li><p>组合式API —— setup语法糖 —— <strong>弱化this</strong></p>
<blockquote>
<p>因为vue3里面，在setup语法糖中几乎不去碰this，所以完全可以写<strong>箭头函数</strong>(箭头函数的this指向定义箭头函数时所在上下文的this，而普通函数this指向取决于函数的调用上下文)</p>
</blockquote>
</li>
<li><p>子组件的标签</p>
<ol>
<li><strong>可以写多个</strong>(vue2只能写一个)</li>
<li>写法：<code>&lt;Person/&gt;</code>，<strong>支持自闭合标签的写法</strong>，也支持双标签写法<blockquote>
<p>vue2是双标签写法<code>&lt;Person&gt;&lt;/Person&gt;</code></p>
</blockquote>
</li>
</ol>
</li>
<li><p>根标签<br>vue3里面，<strong>根标签不是必须的</strong>，在template标签里可以有多个子级标签</p>
</li>
<li><p>setup语法糖底层弄了async<br>可以直接在<code>&lt;scrpit setup&gt;&lt;/scrpit&gt;</code>中写await：<code>let xxx = await axios.get(&#39;xxxx&#39;)</code></p>
<blockquote>
<p>但是在组件中使用了异步任务，组件内容就无法正常显示了，必须在父组件中，包裹一个<a href="/tsukimiya.github.io/2024/05/18/vue3/8.vue3%E6%96%B0%E7%BB%84%E4%BB%B6/#Suspense">Suspense元素</a></p>
</blockquote>
</li>
</ul>
<h2 id="vue-devtools调试工具"><a href="#vue-devtools调试工具" class="headerlink" title="vue-devtools调试工具"></a><strong>vue-devtools调试工具</strong></h2><p>vue-devtools有 vue2.x 和 vue3.x(带Beta标记的版本) 两个版本，<strong>不能交叉使用</strong>!<br>如何安装：<a href="https://juejin.cn/post/7125983116396593165">掘金</a>、<a href="https://blog.csdn.net/ashin8032/article/details/122600345">CSDN</a></p>
<p>但是，<strong>vite</strong>似乎<strong>集成了vue-devtools</strong>，不需要在浏览器安装插件，在创建项目的时候配置上 该调试工具即可使用。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js简单实现后端服务器</title>
    <url>/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>该示例没有用到数据库，是通过创建POST表单路由进行处理数据，将数据保存到文件中，以及数据校验<br>用到的npm包&#x2F;第三方模块：<br>Express：<code>npm i express@4.17.1</code> – Web 开发框架，快速创建 Web 服务器<br>Joi：<code>npm install joi --save</code> – hapijs 自带的数据校验模块<br>@escook&#x2F;express-joi中间件: <code>npm i @escook/express-joi</code> – 实现自动对表单数据进行验证的功能<br>cors： <code>npm i cors</code> – 配置cors跨域<br>dayjs： <code>npm install dayjs --save</code> – 格式化时间</p>
</blockquote>
<blockquote>
<p>全局安装了nodemon工具，可以监听文件的更改，自动重新执行</p>
</blockquote>
<blockquote>
<p>这个是航空文化馆项目的后端，还没写完<br>没有用到mysql模块：<code>npm i mysql</code><br>也没有用到express-session中间件：<code>npm i express-session</code>（这个干吗用的？）</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0">
<li>如果是拿被别人写好的项目，第一步是导入这个项目所用的包，<code>npm i</code>命令</li>
<li>创建后端项目文件夹如serve</li>
<li>初始化文件夹<code>npm init -y</code><br> 在空项目的根目录中初始化一个package.json的包管理配置文件</li>
<li>安装必要的包&#x2F;依赖<br> 安装Express —— <code>npm i express@4.17.1</code></li>
<li>创建服务器文件，命名如app.js</li>
</ol>
<h2 id="创建简单的web服务器-及其-模块化"><a href="#创建简单的web服务器-及其-模块化" class="headerlink" title="创建简单的web服务器 及其 模块化"></a>创建简单的web服务器 及其 模块化</h2><ol>
<li><p>创建基本的express框架 – eser(vscode快捷生成代码&#x2F;&#x2F;自己配置 – 文件–首选项–配置用户代码片段)</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Express server running at http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)      </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由<br> 可以先在当前文件尝试是否成功，之后再分离到对应模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建express路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// 提交预约表单</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/form&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用postman测试请求是否成功<br> 向 <a href="http://127.0.0.1:8080/form">http://127.0.0.1:8080/form</a> 发送post请求<br> 响应函数中打印出来的req.body结果是undefined，这是因为我们没有配置解析表单的中间件</p>
</li>
<li><p>配置解析表单的中间件<br> &#x2F;&#x2F; 配置解析表单数据的中间件,注意：这个中间件，只能解析applicaton&#x2F;x-www-form-urlencoded格式的表单数据<br> <code>app.use(express.urlencoded(&#123;extended:false&#125;))</code><br> 再次发送请求，我们就得到了表单提交的数据</p>
</li>
<li><p>分离到路由模块<br> 创建router文件夹，创建如user.js文件&#x2F;&#x2F;处理用户路由<br> 将路由部分写到这个地方，然后把router暴露出去<br> <code>module.exports = router</code><br> 然后在app.js中导入并使用路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
<li><p>分离处理函数到路由处理模块，同5操作<br> 创建router_handler文件夹，在该目录下创建对应的用户路由处理文件user.js<br> 把处理函数暴露出去</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">formSubmit</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在路由模块导入导入用户路由处理函数对应的模块<br> <code>const user_handler = require(&#39;../router_handler/user&#39;)</code><br> 路由的响应函数换成对应的user_handler.formSubmit</p>
</li>
</ol>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>这里使用joi模块来进行数据验证<br>Joi 是 hapijs 自带的数据校验模块，他已经高度封装常用的校验功能。</p>
<ol>
<li><p>安装joi包，为表单中携带的每个数据项，定义验证规则</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install joi --save</span><br><span class="line"><span class="comment">// ES6写法 import Joi from &#x27;joi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>安装 @escook&#x2F;express-joi 中间件，来实现自动对表单数据进行验证的功能：<br> <code>npm i @escook/express-joi</code></p>
</li>
<li><p>joi验证规则</p>
<ul>
<li>string() 值必须是字符串</li>
<li>number() 值必须是数字</li>
<li>alphanum() 值只能是包含 a-zA-Z0-9 的字符串</li>
<li>min(length) 最小长度</li>
<li>max(length) 最大长度</li>
<li>required() 值是必填项，不能为 undefined</li>
<li>pattern(正则表达式) 值必须符合正则表达式的规则</li>
<li>any() 任意</li>
<li>date() 日期</li>
<li>time() 时间</li>
<li>iso() 要求字符串值采用有效的 ISO 8601 日期格式。</li>
</ul>
</li>
<li><p>新建 &#x2F;schema&#x2F;user.js 用户信息验证规则模块，并初始化代码如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单校验规则</span></span><br><span class="line"><span class="keyword">const</span> unit = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> contact = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> phone = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[1][\d]&#123;10&#125;$/</span>).required()</span><br><span class="line"><span class="keyword">const</span> numVisitors = joi.<span class="title function_">number</span>().<span class="title function_">min</span>(<span class="number">16</span>).required()</span><br><span class="line"><span class="keyword">const</span> guide = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/yes|no|是|否/</span>).required()</span><br><span class="line"><span class="keyword">const</span> date = joi.<span class="title function_">date</span>().<span class="title function_">min</span>(<span class="string">&#x27;now&#x27;</span>).<span class="title function_">iso</span>().required()</span><br><span class="line"><span class="keyword">const</span> time = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[\d]&#123;2&#125;[\s]*:[\s]*[\d]&#123;2&#125;$/</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单的验证规则对象</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">form_schema</span> =&#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        unit,</span><br><span class="line">        contact,</span><br><span class="line">        phone,</span><br><span class="line">        numVisitors,</span><br><span class="line">        guide,</span><br><span class="line">        date,</span><br><span class="line">        time,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由模块添加数据校验</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入需要验证的规则</span></span><br><span class="line"><span class="keyword">const</span> &#123;form_schema&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 在表单提交的路由中，声明局部中间件，对当前请求中携带的数据进行验证<br> 数据验证通过后，会把这次请求流转给后面的路由处理函数<br> 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理<br> <code>router.post(&#39;/form&#39;,expressJoi(form_schema), user_handler.formSubmit)</code></p>
</li>
<li><p>在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端<br> 在路由注册之后声明错误级别中间件，注意这里需要在app.js导入joi</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    <span class="comment">//数据验证失败</span></span><br><span class="line">    <span class="keyword">if</span>(err <span class="keyword">instanceof</span> joi.<span class="property">ValidationError</span>) <span class="keyword">return</span> res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 未知错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> postman测试成功</p>
</li>
</ol>
<h2 id="配置cors-跨域"><a href="#配置cors-跨域" class="headerlink" title="配置cors 跨域"></a>配置cors 跨域</h2><p>之前我们都是在postman发送请求测试，如果我们在自己写的页面发送请求会发现报错<br>这是因为我们的页面打开的是file协议，而服务器则是http协议，</p>
<p>使用<strong>cors中间件</strong>解决跨域问题<br>cors 是Express的一个第三方中间件。通过安装和配置cors 中间件，可以很方便地解决跨域问题。<br>使用步骤分为如下3步:<br>    1. 运行<code>npm install cors</code>安装中间件<br>    2. 使用<code>const cors = require(&#39;cors&#39;)</code>导入中间件<br>    3. 在路由之前调用<code>app.use(cors())</code>配置中间件</p>
<p>注意：<strong>一定要在路由之前配置cors中间件，从而解决接口跨域的问题</strong></p>
<ul>
<li>前端发送axios请求：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        unit : <span class="string">&quot;00&quot;</span>,</span><br><span class="line">        contact : <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">        <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">        <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">        <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
注意：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的，然而我们没有配置解析JSON表单数据的中间件，所以后端能够接收到请求，但是拿不到参数</li>
</ul>
<p>配置解析JSON格式表单数据的中间件：<code>app.use(express.json())</code><br>再次在页面发送axois请求，测试成功</p>
<h2 id="处理数据-–-date时间格式化"><a href="#处理数据-–-date时间格式化" class="headerlink" title="处理数据 – date时间格式化"></a>处理数据 – date时间格式化</h2><blockquote>
<p>在路由处理模块，我们通过<code>const userInfo = req.body</code>接收了获取的数据<br>    但是打印userInfo出来发现，<code>date: 2025-05-15T00:00:00.000Z,</code>，和我们传入的<code>2025-05-15</code>并不一致<br>    遍历对象打印date又变成了：<code>date: Thu May 15 2025 08:00:00 GMT+0800 (中国标准时间)</code><br>    这也许是因为数据校验调用了date()导致<code>const date = joi.date().min(&#39;now&#39;).iso().required()</code><br>    所以我们需要手动处理一下接收到的date的格式</p>
</blockquote>
<ol>
<li><p>下载dayjs组件库，并引入到路由处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载 dayjs 组件库</span></span><br><span class="line">npm install dayjs --save</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进行引用</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&#x27;dayjs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理data<br>我们可以通过forEach遍历，并打印出每一项的数据（需要把对象的键值对包装成数组）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()方法 把对象中的 每个键值对 包装成一对数组 最后返回一个数组</span></span><br><span class="line"><span class="comment">// 返回如[ [key1,value,],[key2,value2] ,.. ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(userInfo).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] == <span class="string">&#x27;date&#x27;</span>)&#123;</span><br><span class="line">        item[<span class="number">1</span>] = <span class="title function_">dayjs</span>(item[<span class="number">1</span>]).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>date数据处理完毕</p>
</li>
</ol>
<h2 id="将数据保存到文件中"><a href="#将数据保存到文件中" class="headerlink" title="将数据保存到文件中"></a>将数据保存到文件中</h2><ol>
<li><p>导入fs文件处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>向form.txt文件中追加每一项数据,不需要我们手动去创建txt文件，如果没有会自动创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的路径，是以执行的文件为基准的,这里是暴露出去的函数，是在路由里面执行的</span></span><br><span class="line"><span class="comment">// 而路由是注册在app.js文件的，所以以app.js为基准</span></span><br><span class="line"><span class="comment">//这里是追加内容的函数，和写入函数writeFile使用一样，如果该文件不存在则会创建该文件</span></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./form.txt&#x27;</span>,data, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就成功向form.txt文件写入数据了，但是数据是没有换行的</p>
</li>
<li><p>写入数据换行 – 换行符常量 <code>os.EOL</code><br>先引入os模块：<code>const os = require(&#39;os&#39;)</code><br>然后修改追加的data数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里插入数据依旧插入的英文名称，没有进行更改对应中文处理</span></span><br><span class="line"><span class="keyword">let</span> data = item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>] + os.<span class="property">EOL</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;<span class="comment">// 每一次插入前，都多空上一行 和加上一行分隔符</span></span><br><span class="line">    data = os.<span class="property">EOL</span> + <span class="string">&quot;####预约申请表####&quot;</span> + os.<span class="property">EOL</span> + data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="增加msg路由模块"><a href="#增加msg路由模块" class="headerlink" title="增加msg路由模块"></a>增加msg路由模块</h2><blockquote>
<p>比form路由简单些，不需要进行太多数据验证，只需要保证数据不为空就行</p>
</blockquote>
<p>这里直接贴出代码</p>
<ul>
<li><p>路由模块 msg.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入express模块，并创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> msgRouter = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由处理模块</span></span><br><span class="line"><span class="keyword">const</span> msg_hander = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入数据校验模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; msg_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msgRouter.<span class="title function_">post</span>(<span class="string">&#x27;/msg&#x27;</span>,<span class="title function_">expressJoi</span>(msg_schema),msg_hander.<span class="property">msgSubmit</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = msgRouter</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msgSubmit</span> = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = req.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">&#x27;####留言####&#x27;</span> + os.<span class="property">EOL</span> + msg.<span class="property">msg</span> + os.<span class="property">EOL</span> + os.<span class="property">EOL</span>;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./msg.txt&#x27;</span>,data,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送留言数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据校验模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>);</span><br><span class="line"><span class="comment">// 校验规则 msg不少于10个字符，且是必填项</span></span><br><span class="line"><span class="keyword">const</span> msg = joi.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">10</span>).required();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msg_schema</span> = &#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        msg,<span class="comment">//注意必须写在body属性中，因为数据在req.body中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：记得要在app.js主程序页面配置路由<code>app.use(msgRouter)</code></strong></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3介绍&amp;Vite创建工程</title>
    <url>/tsukimiya.github.io/2024/05/10/vue3/2.vue3%E4%BB%8B%E7%BB%8D&amp;Vite%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Vue3简介"><a href="#Vue3简介" class="headerlink" title="Vue3简介"></a>Vue3简介</h1><ul>
<li>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code></li>
<li>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></li>
<li>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core</a></li>
<li>截止2023年10月，最新的公开版本为：<code>3.3.4</code>  <img width="50%" style="margin-left:0;" src="/tsukimiya.github.io/images/vue3/版本.png" alt="版本"></li>
</ul>
<h2 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h2><ul>
<li><p>打包大小减少<code>41%</code>。</p>
</li>
<li><p>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</p>
</li>
<li><p>内存减少<code>54%</code>。</p>
</li>
</ul>
<h2 id="源码的升级"><a href="#源码的升级" class="headerlink" title="源码的升级"></a>源码的升级</h2><ul>
<li><p>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</p>
</li>
<li><p>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</p>
</li>
</ul>
<h2 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h2><ul>
<li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li>
</ul>
<h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><ol>
<li><p><code>Composition API</code>（组合<code>API</code>）：</p>
<ul>
<li><p><code>setup</code></p>
</li>
<li><p><code>ref</code>与<code>reactive</code></p>
</li>
<li><p><code>computed</code>与<code>watch</code></p>
<p>……</p>
</li>
</ul>
</li>
<li><p>新的内置组件：</p>
<ul>
<li><p><code>Fragment</code></p>
</li>
<li><p><code>Teleport</code></p>
</li>
<li><p><code>Suspense</code></p>
<p>……</p>
</li>
</ul>
</li>
<li><p>其他改变：</p>
<ul>
<li><p>新的生命周期钩子</p>
</li>
<li><p><code>data</code> 选项应始终被声明为一个函数</p>
</li>
<li><p>移除<code>keyCode</code>支持作为<code> v-on</code> 的修饰符</p>
<p>……</p>
</li>
</ul>
</li>
</ol>
<h1 id="创建Vue3工程"><a href="#创建Vue3工程" class="headerlink" title="创建Vue3工程"></a>创建Vue3工程</h1><h2 id="基于-vue-cli-创建"><a href="#基于-vue-cli-创建" class="headerlink" title="基于 vue-cli 创建"></a>基于 vue-cli 创建</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p>
<blockquote>
<p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue <span class="literal">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli </span></span><br><span class="line">npm install <span class="literal">-g</span> @vue/<span class="built_in">cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行创建命令</span></span><br><span class="line">vue create vue_test</span><br><span class="line"></span><br><span class="line"><span class="comment">##  随后选择3.x</span></span><br><span class="line"><span class="comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span></span><br><span class="line"><span class="comment">##  &gt; 3.x</span></span><br><span class="line"><span class="comment">##    2.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于-vite-创建-推荐"><a href="#基于-vite-创建-推荐" class="headerlink" title="基于 vite 创建 (推荐)"></a>基于 vite 创建 (推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p>
<ul>
<li>轻量快速的热重载（<code>HMR</code>），能实现<strong>极速的服务启动</strong>。</li>
<li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li>
<li>真正的<strong>按需编译</strong>，不再等待整个应用编译完成。</li>
<li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：<br>webpack是处理完所有模块才启动工程，而vite是直接启动，后续按需加载(比较像懒加载)</li>
</ul>
<p><img src="/tsukimiya.github.io/images/vue3/webpack构建.png" alt="webpack构建" title="webpack构建" style="display:inline;width:49.8%;margin:0;box-shadow:0 0 10px black" />	<img src="/tsukimiya.github.io/images/vue3/vite构建.png" alt="vite构建" title="vite构建" style="display:inline;width:49.3%;margin:0;box-shadow:0 0 10px black" /></p>
<ul>
<li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.创建命令</span></span><br><span class="line">npm create vue@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.具体配置</span></span><br><span class="line"><span class="comment">## 配置项目名称 // 不能出现中文和特殊字符，最好用 纯小写字母+数字+下划线</span></span><br><span class="line">√ Project name: vue3_test</span><br><span class="line"><span class="comment">## 是否添加TypeScript支持</span></span><br><span class="line">√ Add TypeScript?  Yes</span><br><span class="line"><span class="comment">## 是否添加JSX支持</span></span><br><span class="line">√ Add JSX Support?  No</span><br><span class="line"><span class="comment">## 是否添加路由环境</span></span><br><span class="line">√ Add Vue Router <span class="keyword">for</span> Single Page Application development?  No</span><br><span class="line"><span class="comment">## 是否添加pinia环境</span></span><br><span class="line">√ Add Pinia <span class="keyword">for</span> state management?  No</span><br><span class="line"><span class="comment">## 是否添加单元测试</span></span><br><span class="line">√ Add Vitest <span class="keyword">for</span> Unit Testing?  No</span><br><span class="line"><span class="comment">## 是否添加端到端测试方案</span></span><br><span class="line">√ Add an <span class="keyword">End</span><span class="literal">-to-End</span> Testing Solution? » No</span><br><span class="line"><span class="comment">## 是否添加ESLint语法检查</span></span><br><span class="line">√ Add ESLint <span class="keyword">for</span> code quality?  Yes</span><br><span class="line"><span class="comment">## 是否添加Prettiert代码格式化</span></span><br><span class="line">√ Add Prettier <span class="keyword">for</span> code formatting?  No</span><br></pre></td></tr></table></figure>
<ul>
<li>项目文件<br>  一开始打开项目文件，会有很多文件报红，这是因为项目文件找不到依赖，可以发现我们没有<code>node_modules</code>文件夹，我们需要<code>npm i</code>安装所有的依赖，再重新打开项目文件，就好了<ul>
<li><p><code>.vscode/extensions.json</code>：配置了插件，如果vscode一个插件都没安装，会给你一个提示</p>
</li>
<li><p><code>public</code>：脚手架的根目录，只放了一个页签图标<code>favicon.ico</code>，就是网页标签的图标</p>
</li>
<li><p><code>env.d.ts</code>: <code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code><br>  ts不认识.jpg、.txt等文件，这个文件的作用就是让ts去认识这些文件</p>
<blockquote>
<p>比如，如果删掉这行代码，在a.ts文件中引入一个txt：<code>import b from &#39;./b.txt&#39;</code>，会发现ts不认识<br>  ctrl点进这个<code>vite/client</code>，这个文件中，常用的文件都配在这里了，包括各种图片视频图标等等</p>
</blockquote>
</li>
<li><p><code>index.html</code>：入口文件<br>  它引入了<code>src/main.ts</code>，它支撑着整个应用跑起来</p>
<blockquote>
<p>这点vite和webpack就有区别了，入口文件不是main.js，也不是mian.ts</p>
</blockquote>
</li>
<li><p>运行；<code>npm run dev</code></p>
</li>
</ul>
</li>
</ul>
<p>自己动手编写一个App组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好啊！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span> <span class="comment">//组件名</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.app</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>安装官方推荐的<code>vscode</code>插件：</p>
<img src="/tsukimiya.github.io/images/vue3/volar.png" alt="volar" style="width:30%;margin:0;display:inline" /> 

<img src="/tsukimiya.github.io/images/vue3/ts-volar.png" alt="ts-volar" style="width:30%;margin:0;display:inline" /> 

<blockquote>
<p>TS版本的volar现在已经启用，而是新的vue-offical将volar 和 TS volar两个插件的功能集合到了一起，但是好像目前很垃圾，评价很差</p>
</blockquote>
<p>总结：</p>
<ul>
<li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li>
<li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li>
<li><code>Vue3</code>中是通过<code>createApp</code> 函数创建一个应用实例。</li>
</ul>
<h2 id="一个简单的效果"><a href="#一个简单的效果" class="headerlink" title="一个简单的效果"></a>一个简单的效果</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">tel</span>:<span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zhang-san&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">tel</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这种写法就是<strong>vue2的选项式API</strong>(也叫<strong>配置式</strong>)，name、data、methods就是一个<strong>选项</strong>，或者说一个<strong>配置项</strong>。<br>这些东西写多了，就<strong>会出现一些问题</strong>，<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#why-composition-api">官网有明确的说明</a>，这里在下一篇文章通过动态图作说明→</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>Vite</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3路由</title>
    <url>/tsukimiya.github.io/2024/05/13/vue3/4.vue3%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<center style="margin:-30px 0 -60px;transform:translateY(-30px)">
<a href="https://router.vuejs.org/zh/introduction.html">Vue Router官方文档</a>
</center>

<h1 id="对路由的理解"><a href="#对路由的理解" class="headerlink" title="对路由的理解"></a>对路由的理解</h1><img src="/tsukimiya.github.io/images/vue3/路由的理解.png" alt="路由的理解" style="zoom:20%;border-radius:40px" /> 

<h1 id="基本切换效果"><a href="#基本切换效果" class="headerlink" title="基本切换效果"></a>基本切换效果</h1><ul>
<li><p><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</p>
</li>
<li><p>路由配置文件代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/News.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/About.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由器</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">	<span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),<span class="comment">// 路由器工作模式：hash模式/history模式</span></span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>main.ts</code>代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入路由器</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>) <span class="comment">// 创建一个应用</span></span><br><span class="line">app.<span class="title function_">use</span>(router) <span class="comment">// 使用路由器 </span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 挂载整个应用到app容器中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><code>App.vue</code>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Vue路由测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 展示区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;<span class="title class_">RouterLink</span>,<span class="title class_">RouterView</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="两个注意点"><a href="#两个注意点" class="headerlink" title="两个注意点"></a>两个注意点</h1><blockquote>
<ol>
<li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p>
</li>
<li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p>
</li>
</ol>
</blockquote>
<h1 id="路由器工作模式"><a href="#路由器工作模式" class="headerlink" title="路由器工作模式"></a>路由器工作模式</h1><blockquote>
<p>一般，后台管理项目，不需要考虑seo，直接用hash模式<br>前台项目，to C的，直接给客户用的，用history模式</p>
</blockquote>
<ol>
<li><code>history</code>模式</li>
</ol>
<blockquote>
<p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p>
<p>缺点：后期<strong>项目上线</strong>，<strong>需要服务端配合处理路径问题</strong>，否则刷新会有<code>404</code>错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  	<span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">//history模式</span></span><br><span class="line">  	<span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li><code>hash</code>模式</li>
</ol>
<blockquote>
<p>优点：兼容性更好，因为不需要服务器端处理路径。</p>
<p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code><strong>优化方面相对较差</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  	<span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(), <span class="comment">//hash模式</span></span><br><span class="line">  	<span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="to的两种写法"><a href="#to的两种写法" class="headerlink" title="to的两种写法"></a>to的两种写法</h1><p>字符串形式 和 <strong>对象形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种：to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种：to的对象写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>大部分项目，不是这么写路由的，而是直接 <strong>遍历的动态路由</strong>，<strong>这个时候对象尤其重要的</strong></p>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>作用：可以简化路由跳转及传参（后面就讲）。</p>
<p>给路由规则命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>跳转路由：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><ol>
<li><p>编写<code>News</code>的子路由：<code>Detail.vue</code></p>
</li>
<li><p>配置路由规则，使用<code>children</code>配置项：</p>
 <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转路由（记得要加完整路径）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail&quot;</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;news-list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">v-for</span>=<span class="string">&quot;news in newsList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;news.id&quot;</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;news.name&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-detail&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterView</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="路由传参-动态路由"><a href="#路由传参-动态路由" class="headerlink" title="路由传参 &#x2F; 动态路由"></a>路由传参 &#x2F; 动态路由</h1><h2 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h2><ol>
<li><p>传递参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;</span>&gt;</span></span><br><span class="line">	跳转</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span></span></span><br><span class="line"><span class="string"><span class="tag">    path:&#x27;/news/detail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id:news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title:news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content:news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印query参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h2><blockquote>
<p>用这种方式传参会被同事骂？因为它的字符串写法可读性很差？XDD<br>不过对象写法和query参数也没大差吧？而且开启路由传参也比较方便，为什么呢？<br>不过需要占位，这里也比query要麻烦，而且如果是可以不传的参数还要加？号</p>
</blockquote>
<ol>
<li><p>传递参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;`/news/detail/001/新闻001/内容001`&quot;</span>&gt;</span>&#123;&#123;news.title&#125;&#125;<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name:&#x27;xiang&#x27;, //用name跳转,不能用path，会报错</span></span></span><br><span class="line"><span class="string"><span class="tag">    params:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id:news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title:news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content:news.title</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印params参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>需要提前在路由规则占位 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是可传可不传的参数，需要在规则中加？，否则会报错 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content 可不传</span></span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content?&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p>
<p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p>
</blockquote>
<h1 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h1><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）<br>写法：params参数用 布尔值写法； query参数用 函数写法</p>
<blockquote>
<p>一般组件是直接写标签的，可以直接传递props<br>  路由组件(这里是Detail)都没有机会写标签，所以通过这种方式来传props</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>, <span class="comment">// params参数的占位规则写法</span></span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">Detail</span>, <span class="comment">// 这里就相当于 底层写了一个 &lt;Detail/&gt;</span></span><br><span class="line">  <span class="comment">// 下面的prop配置就相当于 &lt;Detail :id=?? :title=?? :content=?? /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一种写法：</span></span><br><span class="line">  <span class="comment">// props的布尔值写法，作用：把收到了每一组 params参数 ，作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// 只能处理params参数，也推荐params时候使用这种方式</span></span><br><span class="line">  <span class="comment">// props:true </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二种写法：</span></span><br><span class="line">  <span class="comment">// props的函数写法，返回一个对象</span></span><br><span class="line">  <span class="comment">// 作用：把 返回的对象中 每一组key-value 作为 props 传给Detail组件</span></span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>)&#123; <span class="comment">// 可以随意命名，但都是route对象</span></span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span> <span class="comment">// 或params</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三种写法： （极少用）</span></span><br><span class="line">  <span class="comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:&#123;a:1,b:2,c:3&#125;,  // 把参数写死了，没有意义，所以写的非常少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h1><ol>
<li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p>
</li>
<li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p>
<ul>
<li><code>push</code>是追加历史记录（默认值）。</li>
<li><code>replace</code>是替换当前记录。（登陆页面应该会用这个）</li>
</ul>
</li>
<li><p>开启<code>replace</code>模式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">replace</span>&gt;</span>News<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="声明式导航-编程式导航"><a href="#声明式导航-编程式导航" class="headerlink" title="声明式导航&amp;编程式导航"></a>声明式导航&amp;编程式导航</h1><p>编程式路由导航：脱离<code>&lt;RouterLink&gt;</code>实现路由跳转 （<strong>开发常用</strong>）<br>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">声明式</th>
<th align="center">编程式</th>
</tr>
</thead>
<tbody><tr>
<td>导航到不同的位置</td>
<td align="center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td align="center"><code>router.push(...)</code></td>
</tr>
<tr>
<td>替换当前位置</td>
<td align="center"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td align="center"><code>router.replace(...)</code></td>
</tr>
<tr>
<td>横跨历史</td>
<td align="center"><center>\</center></td>
<td align="center"><code>router.go(n)</code></td>
</tr>
</tbody></table>
<ul>
<li><code>router.go(n)</code>：横跨历史。采用一个整数作为参数，表示在历史堆栈中<strong>前进或后退多少步</strong>，类似于 <code>window.history.go(n)</code>。</li>
<li><code>n = 1</code>时，等同于：<code>router.forward()</code></li>
<li><code>n = -1</code>时，等同于：<code>router.back()</code></li>
</ul>
<blockquote>
<p><code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code> 的翻版，它们确实模仿了 <code>window.history</code> 的 API。<br>值得一提的是，无论在创建路由器实例时传递什么 history 配置(history模式，和hash模式 的路由器工作模式)，Vue Router 的导航方法 (push、replace、go) 都能始终正常工作。</p>
</blockquote>
<p>应用场景：</p>
<ol>
<li>符合某些条件才跳转，不是说一点就跳转<blockquote>
<p>到了10点整，自动跳到秒杀路由；只有登陆成功，自动跳转到个人中心</p>
</blockquote>
</li>
<li>鼠标滑过一个东西跳转(不点)</li>
<li>还有手机摇一摇跳转</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">parmas</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">push</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">replace</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/news&#x27;</span>) <span class="comment">// to能咋写，push就能咋写 // 1. 字符串写法 2. 对象写法</span></span><br></pre></td></tr></table></figure>

<p>点击button按钮进行路由跳转：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 导航区 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;news in newsList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;news.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showNewsDetail(news)&quot;</span>&gt;</span>查看新闻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;...&#125;&quot;</span>&gt;</span>&#123;&#123;news.title&#125;&#125;<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 展示区 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;News&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;<span class="title class_">RouterView</span>,<span class="title class_">RouterLink</span>,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> newsList = <span class="title function_">reactive</span>([...])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 定义一个接口</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  interface <span class="title class_">NewsInter</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">id</span>:string,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">title</span>:string,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">content</span>:string</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 直接写news会报错：参数news隐式具有any类型(就是不知道news是什么)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果想图方便简单，可以直接：news:any</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">showNewsDetail</span>(<span class="params">news:NewsInter</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    router.<span class="title function_">replace</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">query</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>:news.<span class="property">id</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">title</span>:news.<span class="property">title</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">content</span>:news.<span class="property">content</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在vue2中，编程式路由导航，如果重复跳转是报错的，但是vue3里面不会报错</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>作用：将特定的路径，重新定向到已有路由。</p>
<ul>
<li>具体编码：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">  <span class="attr">redirect</span>:<span class="string">&#x27;/news/detail&#x27;</span>, <span class="comment">// 嵌套子路由重定向</span></span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id?/:title?/:content?&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>,</span><br><span class="line">      <span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> route.<span class="property">params</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由进阶"><a href="#路由进阶" class="headerlink" title="路由进阶"></a>路由进阶</h1><p>导航守卫、路由元信息、路由懒加载、路由故障等等<br>参考<a href="https://router.vuejs.org/zh/introduction.html">官方文档</a></p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>
<ol>
<li>全局前置守卫<br>  当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时<strong>导航在所有守卫 resolve(解析) 完之前一直处于等待中</strong>。<ul>
<li>参数：<ul>
<li>to: 即将要进入的目标</li>
<li>from: 当前导航正要离开的路由<blockquote>
<p>新版Vue Router移除了next参数，但仍支持使用，因为其是常见的错误来源<br>  确保 next 在任何给定的导航守卫中都被严格调用一次，否则钩子永远都不会被解析或报错。</p>
</blockquote>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>false：取消导航，如果浏览器的 URL 改变了，URL 地址会重置到 from 路由对应的地址。</li>
<li>一个路由地址：如同调用 router.push()，且可以传入诸如 replace: true 或 name: ‘home’ 之类的选项。<br>它会中断当前的导航，同时用相同的 from 创建一个新导航。</li>
<li>如果什么都没有，undefined 或返回 true，则导航是有效的，并调用下一个导航守卫<blockquote>
<p>即：<br>return  true 或 undefined(没有返回值默认 为un) ，正常跳转<br>return false，阻止跳转<br>return 字符串 或 对象 （就和router.push()传参一样，也即使和to传参一样）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;路由前置守卫&quot;</span>,to,<span class="keyword">from</span>);</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&#x27;/about&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;路由前置守卫触发，从about跳转到news/detail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/news/detail&#x27;</span> <span class="comment">// 字符串形式，值是path地址，将用户重定向到新闻</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;news/detail&#x27;</span> &#125; <span class="comment">// 将用户重定向到新闻页面，对象形式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由前置守卫触发，false取消当前的导航，不跳转&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由前置守卫触发，return 对象形式 并传参&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">      <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;路由前置守卫跳转&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>:<span class="string">&#x27;跳转成功&#x27;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>全局前置守卫</strong>是<strong>最常用</strong>的导航守卫，其余还有：全局解析守卫、全局后置钩子、路由独享的守卫、组件内的守卫等，具体使用查看<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">官方文档 - 导航守卫</a></p>
</blockquote>
<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">完整的导航解析流程</a></h2><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>路由</tag>
        <tag>命名路由</tag>
        <tag>嵌套路由</tag>
        <tag>动态路由</tag>
        <tag>路由的props配置</tag>
        <tag>路由重定向</tag>
        <tag>编程式导航</tag>
        <tag>路由器工作模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinia - 符合直觉的Vue.js状态管理库</title>
    <url>/tsukimiya.github.io/2024/05/14/vue3/5.Pinia/</url>
    <content><![CDATA[<p>集中式状态(数据)管理，把需要共享的数据交给pinia管理</p>
<h1 id="准备一个效果"><a href="#准备一个效果" class="headerlink" title="准备一个效果"></a>准备一个效果</h1><img src="/tsukimiya.github.io/images/vue3/pinia_example.gif" alt="pinia_example" style="zoom:30%;border:3px solid" /> 

<h1 id="搭建-pinia-环境"><a href="#搭建-pinia-环境" class="headerlink" title="搭建 pinia 环境"></a>搭建 pinia 环境</h1><p>第一步：<code>npm install pinia</code></p>
<p>第二步：操作<code>src/main.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引入createPinia，用于创建pinia */</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建pinia */</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用插件 / 安装pinia */</span> </span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此时开发者工具中已经有了<code>pinia</code>选项</p>
<img src="/tsukimiya.github.io/images/vue3/pinia.png" style="zoom:80%;border:1px solid black;border-radius:10px" />

<h1 id="存储-读取数据"><a href="#存储-读取数据" class="headerlink" title="存储+读取数据"></a>存储+读取数据</h1><ol>
<li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p>
</li>
<li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p>
</li>
<li><p>具体编码：<code>src/store/count.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="comment">// 推荐和定义hooks一样用use命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体编码：<code>src/store/talk.ts</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">talkList</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada01&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,</span><br><span class="line">     		&#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada02&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada03&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中使用<code>state</code>中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123; sumStore.sum &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 引入对应的useXxxxxStore	</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;useSumStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/sum&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 调用useXxxxxStore得到对应的store</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> sumStore = <span class="title function_">useSumStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 虽然sumStore里面的sum是个ObjectRefImpl对象，但是这里，不能.value，会报错</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如let obj = reactive(&#123;a:1,b:1,c:ref(9)&#125;)，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这里的c就应该直接obj.c，而不能加.value，因为外面已经帮我们处理好了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumStore.<span class="property">sum</span>) <span class="comment">// 直接拿</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumStore.<span class="property">$state</span>.<span class="property">sum</span>) <span class="comment">// 也可以这样，但是没必要</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;talk in talkStore.talkList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;talk.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; talk.content &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;useTalkStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/talk&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> talkStore = <span class="title function_">useTalkStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="修改数据-三种方式"><a href="#修改数据-三种方式" class="headerlink" title="修改数据(三种方式)"></a>修改数据(三种方式)</h1><ol>
<li><p>第一种修改方式，<strong>直接修改</strong>(vuex中不允许直接修改，要借助mutation)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">666</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种修改方式：<strong>批量修改</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">  <span class="attr">sum</span>:<span class="number">999</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">value:number</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sum</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//操作countStore中的sum</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">value:number</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sum</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> -= value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中调用<code>action</code>即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用countStore</span></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应action</span></span><br><span class="line">countStore.<span class="title function_">incrementOdd</span>(n.<span class="property">value</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h1><blockquote>
<p>在组件中，我们每次使用store里的值，都需要在模版中如<code>&#123;&#123;countStore.sum&#125;&#125;</code>,每次使用都需要前面这一大长串。于是我们可以想到解构赋值:<br><code>const &#123; sum, school &#125; = countStore</code> ，但是这样数据就失去了响应式！<br>虽然可以借助<code>toRefs：const &#123; sum, school &#125; = Refs(countStore)</code><br>但是我们打印一下这个<code>Refs(countStore)</code>，可以发现它把整个store里面所有的属性(数据和方法)都打成了<strong>ref</strong>，虽然实现了，但是<strong>代价有点大</strong><br>所以，我们可以使用 —— <code>storeToRefs</code></p>
</blockquote>
<ul>
<li><p>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</p>
</li>
<li><p>注意：<code>pinia</code>提供的<code>storeToRefs</code><strong>只会将数据做转换</strong>，不会对方法进行ref包裹；而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中所有数据。</p>
</li>
<li><p>所取属性的数据类型：</p>
<ul>
<li>基本类型需要包裹，脚本文件中.value使用</li>
<li><strong>对象类型</strong>可以直接解构出来(还是响应式的)，也可以包裹(脚本文件中.value使用)<br>直接解构：<code>const &#123; talkList &#125; = talkStore</code>，然后直接talkList使用<br>包裹解构：<code>const &#123; talkList &#125; = storeToRefs(talkStore)</code>，在脚本文件中需要<code>talkList.value</code>使用</li>
</ul>
<blockquote>
<p>和toRefs基本一致？</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; useCountStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* 引入storeToRefs */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="comment">/* 得到countStore */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* 使用storeToRefs转换countStore，随后解构 */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> &#123;sum&#125; = <span class="title function_">storeToRefs</span>(countStore)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h1><ol>
<li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p>
</li>
<li><p>追加<code>getters</code>配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">/************/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">   <span class="comment">// 如果不用this，这里就可以写成 箭头函数</span></span><br><span class="line">    <span class="attr">bigSum</span>:(state):<span class="function"><span class="params">number</span> =&gt;</span> state.<span class="property">sum</span> *<span class="number">10</span>,</span><br><span class="line">    <span class="title function_">upperSchool</span>():string&#123;</span><br><span class="line">     <span class="comment">// this就是store</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">school</span>.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">printThis</span>:<span class="function">()=&gt;</span><span class="variable language_">this</span>, <span class="comment">// 得到的是undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;increment,decrement&#125; = countStore</span><br><span class="line"><span class="keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="title function_">storeToRefs</span>(countStore)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="subscribe"><a href="#subscribe" class="headerlink" title="$subscribe"></a>$subscribe</h1><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p>
<ul>
<li>mutate：本次修改的信息</li>
<li>state：真正的数据</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line">talkStore.$subscribe(<span class="function">(<span class="params">mutate,state</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LoveTalk&#x27;</span>,mutate,state)</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(talkList.<span class="property">value</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// as 是断言，能取出来的字符串</span></span><br><span class="line">    <span class="comment">// 第一次是null，应该给个空数组默认值</span></span><br><span class="line">    <span class="attr">talkList</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> string) || []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h1><blockquote>
<p>就和setup语法糖很像</p>
</blockquote>
<ul>
<li><p>数据直接用ref、reactive去定义</p>
</li>
<li><p>直接写函数，就是actions函数</p>
</li>
<li><p>getters直接写computed</p>
</li>
<li><p><strong>必须return出去</strong></p>
</li>
<li><p><strong>缺点</strong>：页面数据多的时候，一堆return</p>
</li>
<li><p><strong>优点</strong>：不用写那么多层次和结构，清晰一点，易于维护</p>
<blockquote>
<p>选项式优点：易于理解和迁移，与传统的Vuex风格相似<br>缺点：代码量增加，不够简洁，尤其是在大型项目中</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// talkList就是state</span></span><br><span class="line">  <span class="keyword">const</span> talkList = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> <span class="built_in">string</span>) || []</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getATalk函数相当于action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getATalk</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:&#123;<span class="attr">content</span>:title&#125;&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 把请求回来的字符串，包装成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(),title&#125;</span><br><span class="line">    <span class="comment">// 放到数组中</span></span><br><span class="line">    talkList.<span class="title function_">unshift</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;talkList,getATalk&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>Pinia</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块化</title>
    <url>/tsukimiya.github.io/2024/05/05/ES6/1.ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>ES6模块化 与 异步编程高级用法：<br>  E6的模块化语法<br>  使用Promise解决回调地狱的问题<br>  使用 async&#x2F;await 简化 Promise 的调用<br>  什么是 EventLoop<br>  宏任务 和 微任务 的执行顺序</p>
</blockquote>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol>
<li><p>node.js中如何实现模块化<br>node.js遵循了<strong>CommonJS</strong>的模块化规范。其中:</p>
<ul>
<li>导入其它模块使用<code>require()</code>方法</li>
<li>模块对外共享成员使用<code>module.exports</code>对象</li>
</ul>
</li>
<li><p><strong>模块化的好处</strong>：<br>大家都遵守同样的模块化规范写代码，<strong>降低了沟通的成本，极大方便了各个模块之间的相互调用</strong>，利人利己。</p>
</li>
</ol>
<h3 id="前端模块化规范的分类"><a href="#前端模块化规范的分类" class="headerlink" title="前端模块化规范的分类"></a>前端模块化规范的分类</h3><p>在<strong>ES6模块化规范诞生之前</strong>，JavaScript 社区已经尝试并提出了<strong>AMD、CMD、CommonJS</strong>等模块化规范。</p>
<blockquote>
<p>这几个规范不是官方的模块化标准，而是社区的开发者经过反复的实践与尝试，提出来的规范</p>
</blockquote>
<p>但是，这些由社区提出的模块化标准，还是存在一定的<strong>差异性与局限性</strong>、<strong>并不是</strong>浏览器与服务器<strong>通用的模块化标准</strong>，例如:</p>
<ul>
<li>AMD和CMD适用于<strong>浏览器端</strong>的Javascript模块化</li>
<li>CommonJS适用于<strong>服务器端</strong>的Javascript模块化</li>
</ul>
<p>太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，<strong>大一统的ES6模块化规范诞生了</strong>!</p>
<h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>ES6模块化规范是浏览器端与服务器端通用的模块化开发规范。</p>
<p>ES6模块化规范中定义:</p>
<ul>
<li>每个js文件都是一个独立的模块</li>
<li>导入其它模块成员使用<strong>import</strong>关键字</li>
<li>向外共享模块成员使用<strong>export</strong>关键字</li>
</ul>
<h3 id="在node-js中使用ES6模块化"><a href="#在node-js中使用ES6模块化" class="headerlink" title="在node.js中使用ES6模块化"></a>在node.js中使用ES6模块化</h3><p>node.js默认支持CommonJS模块化规范，如果要使用ES6模块化语法，需要配置：</p>
<ol>
<li>确保安装了v14.15.1或更高版本的node.js</li>
<li>在package.json的根节点中添加<code>&quot;type&quot;:&quot;module&quot;</code>节点</li>
</ol>
<h2 id="ES6模块化的基本语法"><a href="#ES6模块化的基本语法" class="headerlink" title="ES6模块化的基本语法"></a>ES6模块化的基本语法</h2><p>ES6的模块化主要包含如下3种用法:<br>    1. 默认导出与默认导入<br>    2. 按需导出与按需导入<br>    3. 直接导入并执行模块中的代码</p>
<ol>
<li><p>默认导出<br><code>export dufault 默认导出的成员</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  n1,</span><br><span class="line">  show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>只允许默认导出一次</strong>(使用唯一的一次export default)</p>
</li>
<li><p>默认导入<br><code>import 接收名称 from &#39;模块标识符&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./1.默认导出.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1); <span class="comment">//&#123; n1: 10, show: [Function: show] &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>接收名称</strong>可以是任意名称，只要是<strong>合法的成员名称即可</strong>(只能以字符_$开头，不能以数字)</p>
</li>
<li><p>按需导出<br><code>export 按需导出的成员</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s1 = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s2 = <span class="string">&#x27;ccc&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>可以使用多次</strong>，可以和默认导出一起使用。</p>
</li>
<li><p>按需导入<br><code>import &#123;s1&#125; from &#39;模块标识符&#39;</code><br>导入多个模块成员<br><code>import &#123;s1,s2,s3&#125; from &#39;模块标识符&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> info, &#123;s1, s2 <span class="keyword">as</span> str2, say&#125; <span class="keyword">from</span> <span class="string">&#x27;./3.按需导出.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1); <span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// console.log(s2); // 报错，未定义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2); <span class="comment">// ccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(say);<span class="comment">// [Function: say]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// info 接收的默认导出的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// &#123; a:20 &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>按需导入的成员<strong>名称必须</strong>和按需导出的名称<strong>保持一致</strong></li>
<li>按需导入时，可以使用 <strong>as关键字</strong> 进行<strong>重命名</strong></li>
<li>按需导入可以和默认导入一起使用</li>
</ol>
</li>
<li><p><strong>直接导入并执行模块中的代码</strong><br>如果<strong>只想单纯地执行某个模块中的代码</strong>，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码，示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./5.直接运行模块中的代码.js&#x27;</span></span><br><span class="line"><span class="comment">// node testjs 结果 --  0 1 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>ES6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3组件通信&amp;插槽</title>
    <url>/tsukimiya.github.io/2024/05/15/vue3/6.vue3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1&amp;%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p>
<ul>
<li>移出事件总线，使用<code>mitt</code>代替。</li>
</ul>
<ul>
<li><code>vuex</code>换成了<code>pinia</code>。</li>
<li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li>
<li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li>
<li><code>$children</code>被砍掉了。</li>
</ul>
<p><font color="red"><strong>9个组件通信方式用处 及 选择:</strong></font></p>
<table>
<thead>
<tr>
<th></th>
<th>通信方式</th>
<th>通信类型、关系</th>
<th>特点</th>
<th>使用建议</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><font color="red">props</font></td>
<td>简单父&lt;&#x3D;&gt;子通信</td>
<td>传递数据或事件简单直接</td>
<td>更为直观和易于理解。<font color="red">推荐</font></td>
</tr>
<tr>
<td>2</td>
<td><font color="red">自定义事件</font></td>
<td>子-&gt;父</td>
<td>事件对象$event: 是调用emit时所提供的数据，可以是任意类型！使用v-on监听自定义事件</td>
<td>事件名推荐使用肉串命名(kebab-case形式)。<font color="red">推荐</font></td>
</tr>
<tr>
<td>3</td>
<td>mitt</td>
<td>任意组件通信</td>
<td>接收数据的组件提前绑好事件，提供数据的组件在合适的时候触发事件</td>
<td>和Event Bus相似，事件管理分散，难以跟踪事件流，<strong>难以维护</strong></td>
</tr>
<tr>
<td>4</td>
<td>v-model</td>
<td>父&lt;&#x3D;&gt;子通信</td>
<td><strong>本质：props传参+自定义事件</strong>，<strong>简化双向数据同步</strong></td>
<td>UI组件库底层使用</td>
</tr>
<tr>
<td>5</td>
<td>$attrs</td>
<td>祖&lt;&#x3D;&gt;孙(子为中介)</td>
<td>需要子组件作为中介，会自动排除子组件props中声明过的属性</td>
<td>影响组件封装性、属性重复定义以及影响渲染性能等。谨慎使用，不推荐</td>
</tr>
<tr>
<td>6</td>
<td>$refs、$parent</td>
<td>$refs：父→子、、 $parent：子→父</td>
<td>获取组件实例，可以操作暴露出去的数据</td>
<td>尽量少用，破坏封装</td>
</tr>
<tr>
<td>7</td>
<td>provide、inject</td>
<td>祖&lt;&#x3D;&gt;孙直接通信</td>
<td>对子组件0打扰</td>
<td>适合祖先到后代的数据传递，但谨慎防过度使用，不便于维护</td>
</tr>
<tr>
<td>8</td>
<td><a href="/tsukimiya.github.io/2024/05/14/vue3/5.Pinia/"><font color="red">pinia</font></a></td>
<td>任意组件通信</td>
<td>集中式状态(数据)管理</td>
<td>比vuex更优化，特别适合复杂状态共享。<font color="red">推荐使用</font></td>
</tr>
<tr>
<td>9</td>
<td>插槽slot</td>
<td><strong>本质 父&lt;&#x3D;&gt;子通信</strong></td>
<td>对结构复用，支持自定义结构，提高组件的可重用性和灵活性</td>
<td>UI组件库作用域插槽用的非常多，<strong>适合 父 控制 子 部分布局或内容的场景</strong></td>
</tr>
</tbody></table>
<p><strong>常见搭配形式：</strong></p>
<img src="/tsukimiya.github.io/images/vue3/组件通信.png" alt="组件通信" style="zoom:60%;" /> 

<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><blockquote>
<p>props是单向数据流，从父组件传递给子组件，而不能从子组件传递给父组件。<br>vue3与vue2的props不同的点在于：<strong>vue3可以传函数</strong><br>所以，vue2中，自定义属性props只能父传子，而子传父就需要借助自定义函数<br>但是，<strong>vue3中，自定义事件props不仅能够父传子，还能够子传父</strong>（通过 调用父的函数传参 的形式）</p>
</blockquote>
<p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p>
<ul>
<li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。 ———— 父给子，<strong>直接传值</strong></li>
<li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。 ———— 子给父，<strong>传参形式调用父的函数</strong>(父要先给子传一个函数)</li>
</ul>
<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>儿子给的玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span> <span class="attr">:getToy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;奔驰&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> toy = <span class="title function_">ref</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">getToy</span>(<span class="params">value:string</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    toy.<span class="property">value</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>父给我的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getToy(toy)&quot;</span>&gt;</span>玩具给父亲<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Child&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;奥特曼&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;getToy&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ol>
<li>概述：自定义事件常用于：<strong>子 &#x3D;&gt; 父。</strong></li>
<li>注意区分好：原生事件、自定义事件。</li>
</ol>
<ul>
<li>原生事件：<ul>
<li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）	</li>
<li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li>
</ul>
</li>
<li>自定义事件：<ul>
<li>事件名是任意名称（<a href="https://cn.vuejs.org/guide/components/events.html#emitting-and-listening-to-events">官方<strong>推荐使用 kebab-case 形式</strong>(也叫<strong>肉串命名</strong>)来编写监听器&#x2F;自定义事件</a>）（<a href="https://v2.cn.vuejs.org/v2/guide/components-custom-events.html">vue2时候就已经有这个规矩了</a>）</li>
<li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！</strong ></li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;toy = $event&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件中，触发事件：</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;send-toy&#x27;</span>, 具体数据)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）、vue2的<code>$bus</code>功能类似，可以实现任意组件间通信。<br>mitt体积非常小，200byte，用不用项目体积几乎没有变化<br>因为vue3中没有全局事件总线，所以用这种插件替代</p>
<blockquote>
<p>他们都是一个套路：<br>接收数据的：提前绑好事件（提前订阅消息）<br>提供数据的：在合适的时候触发事件（发布消息）</p>
</blockquote>
<p>尽量不要使用全局事件总线vue2 - $bus，vue3 - mitt，会变得<strong>难以维护</strong>，provide&#x2F;inject也是一样尽量不要用</p>
<p><strong>语法</strong>：</p>
<ul>
<li>all：拿到所有绑定的事件<ul>
<li>clean：<code>emitter.all.clear()</code>，清空，清空所有绑定的事件</li>
</ul>
</li>
<li>emit：触发某一个事件</li>
<li>off：解绑某一个事件</li>
<li>on：绑定某一个事件</li>
</ul>
<p><strong>安装</strong><code>mitt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure>

<p>新建文件：<code>src\utils\emitter.ts</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter，emitter能绑定事件、触发事件</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure>
<p>在main.ts引入emitter<br>全局引入emitter？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/utils/emitter&#x27;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter，emitter能绑定事件、触发事件</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 绑定事件</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 触发事件</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;abc&#x27;,666)</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;xyz&#x27;,777)</span></span><br><span class="line"><span class="comment">  &#125;, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 清理事件</span></span><br><span class="line"><span class="comment">    emitter.all.clear()</span></span><br><span class="line"><span class="comment">  &#125;, 3000); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure>

<p><strong>接收数据的组件</strong>中：<strong>绑定事件</strong>、同时在<strong>销毁前解绑事件</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send-toy事件被触发&#x27;</span>,value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件卸载时，解绑事件，，如果不解绑，对内存不友好</span></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 解绑事件</span></span><br><span class="line">  emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>【第三步：<strong>提供数据的组件</strong>，在合适的时候<strong>触发事件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;emitter.emit(&#x27;send-toy&#x27;,toy)&quot;</span>&gt;给弟弟玩具&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>,toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote>
<p>和vue2相比有一些变化<br>UI组件库底层，大量使用v-model进行通信</p>
</blockquote>
<ol>
<li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p>
</li>
<li><p>前序知识 —— <code>v-model</code>的<strong>本质</strong>（v-model用在HTML标签上 – 表单元素上）<br> v-model的底层，是一个动态的value值，<code>:value</code>,配合上<code>input事件</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用v-model指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-model的本质是下面这行代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;userName&quot;</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ts会爆红，因为$event可能为null —— 通过js new Event()出来的</span></span><br><span class="line"><span class="comment">加上&lt;&gt;是断言，告诉它就是个HTML输入类型的元素 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组件标签上</strong>的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p>
<blockquote>
<p>也就是绑定了一个props传参 + 一个自定义事件(接收每次修改的值)</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件标签上使用v-model指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件标签上v-model的本质 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- vue2用的是:value、@input=&quot;&quot;，Vue3是:modelValue、@update:modelValue // 它就是一个自定义事件，只是它命名里面带了冒号: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">:modelValue</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">update:model-value</span>=<span class="string">&quot;userName = $event&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- userName = $event的作用，和(val)=&gt;username = val是一样的 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于原生事件，$event就是事件对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于自定义事件，$event接收的就是触发事件时，传递过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AtguiguInput</code>组件中：</p>
<blockquote>
<p>这些，就是UI组件库底层做的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;AtguiguInput&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 接收props</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 声明事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:model-value&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p>
<blockquote>
<p>如果直接写<code>v-model=&quot;xxx&quot;</code> , 底层默认就是<code>:modelValue</code> + <code>update:modelValue</code><br> 当然也可以改这个名字，比如改成abc，就需要我们这样写：<code>v-model:abc=&quot;xxx&quot;</code>，<br> 在底层，就变成了<code>:abc=&quot;xxx&quot;</code>、<code>@update:abc=&quot;xxx = $event&quot;</code><br> 在组件中，封装的就不再是拿modelValue接收，而是拿<code>abc</code> 和 <code>update:abc</code>：<br> <code>defineProps([&#39;abc&#39;])</code>、<code>const emit = defineEmits([&#39;update:abc&#39;])</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 也可以更换value，例如改成abc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:abc</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上面代码的本质如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">:abc</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">update:abc</span>=<span class="string">&quot;userName = $event&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AtguiguInput</code>组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">:value</span>=<span class="string">&quot;abc&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;AtguiguInput&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 接收props</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;abc&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 声明事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:abc&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>value</code>可以更换，那么就可以在组件标签上<strong>多次使用</strong><code>v-model</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:abc</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">v-model:xyz</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h2><ol>
<li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p>
</li>
<li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p>
<blockquote>
<p> 注意：<code>$attrs</code><strong>会自动排除</strong><code>props</code>中<strong>声明过的属性</strong>(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p>
</blockquote>
</li>
</ol>
<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:a</span>=<span class="string">&quot;a&quot;</span> <span class="attr">:b</span>=<span class="string">&quot;b&quot;</span> <span class="attr">:c</span>=<span class="string">&quot;c&quot;</span> <span class="attr">:d</span>=<span class="string">&quot;d&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123;x:100,y:200&#125;&quot;</span> <span class="attr">:updateA</span>=<span class="string">&quot;updateA&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> b = <span class="title function_">ref</span>(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> c = <span class="title function_">ref</span>(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> d = <span class="title function_">ref</span>(<span class="number">4</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">updateA</span>(<span class="params">value</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    a.<span class="property">value</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GrandChild</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Child&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">GrandChild</span> <span class="keyword">from</span> <span class="string">&#x27;./GrandChild.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>孙组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grand-child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>孙组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>a：&#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>b：&#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>c：&#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>d：&#123;&#123; d &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>x：&#123;&#123; x &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>y：&#123;&#123; y &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateA(666)&quot;</span>&gt;</span>点我更新A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;GrandChild&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">defineProps</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;updateA&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="refs、-parent"><a href="#refs、-parent" class="headerlink" title="$refs、$parent"></a><code>$refs</code>、<code>$parent</code></h2><ol>
<li><p>概述：</p>
<ul>
<li><code>$refs</code>用于 ：<strong>父→子。</strong></li>
<li><code>$parent</code>用于：<strong>子→父。</strong></li>
</ul>
</li>
<li><p>原理如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$refs</code></td>
<td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td>
</tr>
<tr>
<td><code>$parent</code></td>
<td>值为对象，当前组件的父组件实例对象。</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li><p><code>$refs</code>使用 – 父-&gt;子<br><code>$refs</code>本身就是一个响应式的对象，里面再去读取ref( 组件实例c1 c2(响应式对象)身上的响应式对象toy、computer )，就不需要<code>.value</code><br>响应式对象<code>$refs</code>，里面包含 每一个组件实例(也是响应式对象)，每一个组件实例身上包含 暴露给父组件的响应式对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child1</span> ref=<span class="string">&quot;c1&quot;</span>/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Child2</span> <span class="attr">ref</span>=<span class="string">&quot;c2&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeToy&quot;</span>&gt;</span>修改Child1的玩具<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeComputer&quot;</span>&gt;</span>修改Child2的电脑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getAllChild($refs)&quot;</span>&gt;</span>让所有孩子的书变多<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child1</span> <span class="keyword">from</span> <span class="string">&#x27;./Child1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child2</span> <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref,reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="title function_">ref</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  c1.<span class="property">value</span>.<span class="property">toy</span> = <span class="string">&#x27;小猪佩奇&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeComputer</span>(<span class="params"></span>)&#123;</span><br><span class="line">  c2.<span class="property">value</span>.<span class="property">computer</span> = <span class="string">&#x27;华为&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要告诉程序，ref是对象，对象又是字符串的键，值不知道是什么 -- 否则飘红(ts)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAllChild</span>(<span class="params">refs:&#123;[key:string]:any&#125;</span>)&#123; <span class="comment">// 这里也可以直接any</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(refs)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> refs)&#123;</span><br><span class="line">    refs[key].<span class="property">book</span> += <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 子组件需要把数据交给外部</span></span><br><span class="line"><span class="comment">// child1把数据交给外部</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;toy,book&#125;)</span><br><span class="line"><span class="comment">// child2把数据交给外部</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;computer,book&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$parent</code>使用 – 子-&gt;父<br><code>$parent</code>也是一个响应式的对象，里面再去读取ref也不需要<code>.value</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;minusHouse($parent)&quot;</span>&gt;干掉父亲的一套房产&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minusHouse</span>(<span class="params">parent:any</span>)&#123;</span><br><span class="line">  parent.<span class="property">house</span> -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件同样将数据需要暴露出去</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;house&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h2><ol>
<li><p>概述：实现<strong>祖孙组件</strong>直接通信</p>
</li>
<li><p>具体使用：</p>
<ul>
<li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li>
<li>在后代组件中通过<code>inject</code>配置来声明接收数据</li>
</ul>
</li>
<li><p>具体编码：</p>
<p>【第一步】父组件中，使用<code>provide</code>提供数据<br> 注意：不要去<code>.value</code>，因为你一旦<code>.value</code>，就是在取值了，这样就是把具体的值传进去，而不是传进去响应式的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>资产：&#123;&#123; money &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>汽车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;money += 1&quot;</span>&gt;</span>资产+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;car.price += 1&quot;</span>&gt;</span>汽车价格+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref,reactive,provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> money = <span class="title function_">ref</span>(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">price</span>:<span class="number">100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用于更新money的方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">updateMoney</span>(<span class="params">value:number</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    money.<span class="property">value</span> += value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 提供数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">provide</span>(<span class="string">&#x27;moneyContext&#x27;</span>,&#123;money,updateMoney&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p>
</blockquote>
<p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grand-child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是孙组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>资产：&#123;&#123; money &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>汽车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateMoney(6)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;GrandChild&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 注入数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> &#123;money,updateMoney&#125; = <span class="title function_">inject</span>(<span class="string">&#x27;moneyContext&#x27;</span>,&#123;<span class="attr">money</span>:<span class="number">0</span>,<span class="attr">updateMoney</span>:<span class="function">(<span class="params">x:number</span>)=&gt;</span>&#123;&#125;&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果模版中写的是 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &lt;h4&gt;汽车 品牌&#123;&#123; car.<span class="property">brand</span> &#125;&#125; 金额 &#123;&#123; car.<span class="property">price</span> &#125;&#125;&lt;/h4&gt;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这里的两个car.xxx就会飘红，但是不会报错，这里是因为它没有推断好</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果想要不爆红，可以通过默认值的形式，去帮助它推断：</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>,&#123;<span class="attr">brand</span>:<span class="string">&#x27;未知&#x27;</span>,<span class="attr">price</span>:<span class="number">0</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果没有传，那就是默认值，传了就不是 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h2><p>参考之前<code>pinia</code>部分的讲解</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p><img src="/tsukimiya.github.io/tsukimiya.github.io/images/vue3/default_slot.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">    &lt;<span class="title class_">Category</span> title=<span class="string">&quot;今日热门游戏&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Category</span>&gt;</span><br><span class="line">子组件中：</span><br><span class="line">    &lt;template&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 默认插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">    &lt;<span class="title class_">Category</span> title=<span class="string">&quot;今日热门游戏&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">s2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>更多<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Category</span>&gt;</span><br><span class="line">子组件中：</span><br><span class="line">    &lt;template&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>UI组件库用作用域插槽用的非常多，如：对话框、表格</p>
</blockquote>
<p>也就是，把数据传给组件的使用者。</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">   &lt;<span class="title class_">Game</span> v-slot=<span class="string">&quot;params&quot;</span>&gt;</span><br><span class="line">   &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">Game</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;params&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in params.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Game</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">子组件中：</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日游戏榜单<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span> <span class="attr">a</span>=<span class="string">&quot;哈哈&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Category&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;英雄联盟&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王者荣耀&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;红色警戒&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;斗罗大陆&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     ])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3核心语法</title>
    <url>/tsukimiya.github.io/2024/05/12/vue3/3.vue3%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>组合式API setup语法糖（name属性 – vite插件简化）</li>
<li>响应式数据的创建：ref、reactive</li>
<li>计算属性：computed（get、set）</li>
<li>监听器：watch (能够监听的4种数据、监听的 5种情况)</li>
<li>标签的ref属性</li>
<li>props（接收+限制类型+指定默认值+限制必要性）</li>
<li>vue生命周期（整体可分为四个阶段、八个钩子）<ul>
<li>vue解析流程、父子组件生命周期顺序</li>
</ul>
</li>
<li>hooks（封装）</li>
</ul>
</blockquote>
<h1 id="OptionsAPI-与-CompositionAPI"><a href="#OptionsAPI-与-CompositionAPI" class="headerlink" title="OptionsAPI 与 CompositionAPI"></a>OptionsAPI 与 CompositionAPI</h1><ul>
<li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li>
<li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li>
</ul>
<h2 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h2><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，<strong>不便于维护和复用</strong>。</p>
<img src="/tsukimiya.github.io/images/vue3/options劣势1.gif" alt="options劣势1.gif" style="display:inline;height:300px;margin:0;border-radius:20px" />
<img src="/tsukimiya.github.io/images/vue3/options劣势2.gif" alt="options劣势2.gif" style="display:inline;height:300px;margin:0;border-radius:20px" />

<h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p>
<img src="/tsukimiya.github.io/images/vue3/comp优势1.gif" alt="comp优势1.gif" style="display:inline;height:300px;border-radius:10px"  />
<img src="/tsukimiya.github.io/images/vue3/comp优势2.gif" alt="comp优势2.gif" style="display:inline;height:300px;border-radius:10px"  />

<blockquote>
<p>说明：以上四张动图原创作者：大帅老猿(掘金)</p>
</blockquote>
<h1 id="拉开序幕的-setup"><a href="#拉开序幕的-setup" class="headerlink" title="拉开序幕的 setup"></a>拉开序幕的 setup</h1><h2 id="setup-概述"><a href="#setup-概述" class="headerlink" title="setup 概述"></a>setup 概述</h2><p><strong>setup</strong>是<code>Vue3</code>中一个<strong>新的配置项，值是一个函数</strong>，它是 <code>Composition API</code> <strong>“表演的舞台”</strong>，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在<code>setup</code>中。</p>
<p>特点如下：</p>
<ul>
<li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li>
<li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li>
<li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，<strong>它是“领先”所有钩子执行的</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//setup中的this是undefined，vue3中已经弱化this了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> age = <span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> tel = <span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 方法，原来写在methods中</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        name = <span class="string">&#x27;zhang-san&#x27;</span> <span class="comment">//注意：此时这么修改name页面是不变化的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        age += <span class="number">1</span> <span class="comment">//注意：此时这么修改age页面是不变化的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(tel)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 返回一个对象，对象中的内容，模板中可以直接使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;name,age,tel,changeName,changeAge,showTel&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="setup-的返回值"><a href="#setup-的返回值" class="headerlink" title="setup 的返回值"></a>setup 的返回值</h2><ul>
<li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用（<strong>重点关注</strong>）。</li>
<li>若返回一个<strong>函数</strong>：则可以自定义渲染内容，代码如下：<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// setup的返回值也可以是一个渲染函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="string">&#x27;你好啊！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="setup-与-Options-API-的关系"><a href="#setup-与-Options-API-的关系" class="headerlink" title="setup 与 Options API 的关系"></a>setup 与 Options API 的关系</h2><ul>
<li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>……）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li>
<li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>……）。<blockquote>
<p>因为<code>setup</code>是最早的生命周期，所以setup可以被其他选项摸到，而它摸不到其他选项。</p>
</blockquote>
</li>
<li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。<blockquote>
<p>虽然他们可以共存，但是vue3不要写vue2的data、method，不到万不得已。</p>
</blockquote>
</li>
</ul>
<h2 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h2><blockquote>
<p>每次我们在setup中定义了数据，并使用，都需要把它return出去，这就很麻烦，大量的编写应用，就很容易忘记去return。所以有更简单的写法 —— <strong>setup语法糖</strong><br>多写一个script标签，写上setup属性<code>&lt;script setup&gt;&lt;/script&gt;</code><br>这样，这个里面的东西就相当于，写到setup(){}函数里面，而且它还会<strong>自动return</strong></p>
</blockquote>
<p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的写法是setup语法糖 --&gt;</span><br><span class="line">&lt;!--  &lt;script&gt; and &lt;script setup&gt; 必须是相同的语法类型，否则报错，这里都是ts类型 --&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  console.log(this) //undefined</span><br><span class="line">  </span><br><span class="line">  // 数据（注意：此时的name、age、tel都不是响应式数据）</span><br><span class="line">  let name = &#x27;张三&#x27;</span><br><span class="line">  let age = 18</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changName()&#123;</span><br><span class="line">    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function changAge()&#123;</span><br><span class="line">    console.log(age)</span><br><span class="line">    age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所以对于vue3的项目，有<strong>两个script标签</strong>，<strong>一个是专门配置组合式API的</strong>，<strong>一个是专门配置组件名字的</strong>。但是写两个难受了，还不能合到一块，我们可以借助插件完成↓</p>
<p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p>
<ol>
<li><p>第一步：<code>npm i vite-plugin-vue-setup-extend -D</code></p>
</li>
<li><p>第二步：<code>vite.config.ts</code></p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueSetupExtend</span> <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-vue-setup-extend&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="title class_">VueSetupExtend</span>() ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></p>
</li>
</ol>
<h1 id="ref-创建：基本类型的响应式数据"><a href="#ref-创建：基本类型的响应式数据" class="headerlink" title="ref 创建：基本类型的响应式数据"></a>ref 创建：基本类型的响应式数据</h1><blockquote>
<p>在<strong>vue2中</strong>，只要将<strong>数据</strong>定义到<strong>data节点</strong>里面，这个数据就<strong>自动是响应式</strong>的了，其他它在<strong>背后</strong>是做了<strong>数据代理和数据劫持</strong><br><strong>vue3</strong>有两个东西去<strong>定义响应式数据</strong>：<strong>ref、reactive</strong>(这个<code>ref</code>和vue2中的<code>$ref</code>不是一个东西)</p>
</blockquote>
<ul>
<li><strong>作用：</strong>定义响应式变量。</li>
<li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li>
<li><strong>返回值：</strong>一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li>
<li><strong>注意点：</strong><ul>
<li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li>
<li>对于<code>let name = ref(&#39;张三&#39;)</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// tel就是一个普通的字符串，不是响应式的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> tel = <span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// JS中操作ref对象时候需要.value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    name.<span class="property">value</span> = <span class="string">&#x27;李四&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// name = ref(&#x27;zhang-san&#x27;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// JS中操作ref对象时候需要.value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    age.<span class="property">value</span> += <span class="number">1</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(tel)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="reactive-创建：对象类型的响应式数据"><a href="#reactive-创建：对象类型的响应式数据" class="headerlink" title="reactive 创建：对象类型的响应式数据"></a>reactive 创建：对象类型的响应式数据</h1><ul>
<li><strong>作用：</strong>定义一个<strong>响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）<blockquote>
<p>reactive只能定义 对象类型的响应式数据</p>
</blockquote>
</li>
<li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li>
<li><strong>返回值：</strong> 一个<code>Proxy</code>的实例对象，简称：响应式对象。</li>
<li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。<ul>
<li>该对象的<strong>所有子属性</strong>（不论嵌套多深）都会被转换为<strong>响应式的</strong>。</li>
<li>即使是后来<strong>新增的属性</strong>，由于使用了Proxy代理，Vue也能确保这些新属性自动成为<strong>响应式的</strong></li>
<li>当<strong>删除一个属性</strong>时，Vue的响应式系统也能<strong>感知到</strong>这一变化，并<strong>相应地处理依赖更新</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>游戏列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCarPrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeFirstGame&quot;</span>&gt;</span>修改第一游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123; <span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;原神&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeCarPrice</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  car.<span class="property">price</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  games[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;流星蝴蝶剑&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="ref-创建：对象类型的响应式数据"><a href="#ref-创建：对象类型的响应式数据" class="headerlink" title="ref 创建：对象类型的响应式数据"></a>ref 创建：对象类型的响应式数据</h1><ul>
<li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li>
<li>若<code>ref</code>接收的是<strong>对象类型的时候</strong>，<strong>内部</strong>其实也是<strong>调用了</strong><code>reactive</code>函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>游戏列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCarPrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeFirstGame&quot;</span>&gt;</span>修改第一游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> car = <span class="title function_">ref</span>(&#123; <span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> games = <span class="title function_">ref</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;原神&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(car)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeCarPrice</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  car.<span class="property">value</span>.<span class="property">price</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  games.<span class="property">value</span>[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;流星蝴蝶剑&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="ref-对比-reactive"><a href="#ref-对比-reactive" class="headerlink" title="ref 对比 reactive"></a>ref 对比 reactive</h1><p>宏观角度看：</p>
<blockquote>
<ol>
<li><p><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</p>
</li>
<li><p><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</p>
</li>
</ol>
</blockquote>
<ul>
<li>区别：</li>
</ul>
<blockquote>
<ol>
<li><p><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。<br> 设置 – 扩展 – Volar(老版的TS volar插件)<br>   设置 – 扩展 – Vue(新版的vue-offical插件)</p>
<img src="/tsukimiya.github.io/images/vue3/自动补充value.png" alt="自动补充value" style="zoom:60%;border-radius:20px;margin:0;transform:translateY(-30px)" /> 
</li>
<li><p><code>reactive</code><strong>重新分配一个新对象</strong>，<strong>会失去响应式</strong>（可以使用<code>Object.assign</code>去整体替换）。（官方文档将其叫做：<strong>reactive的局限性</strong>）</p>
</li>
</ol>
</blockquote>
<ul>
<li><p><font color="red"><strong>一个注意点：.value的问题</strong></font><br><code>ref</code>创建的变量，必须使用<code>.value</code><br><code>reactive</code>创建的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>:<span class="title function_">ref</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> , obj.<span class="property">b</span> , obj.<span class="property">c</span>)</span><br></pre></td></tr></table></figure>
<p>虽然c是一个响应式的数据，数字3 ，， 但是不需要<code>.value</code>,如果<code>.value</code>得到的事undefined<br><code>c</code>是一个<strong>响应式的数据</strong>，但是它是<strong>放在一个响应式对象里面的</strong>，也就是说，当你去触碰<code>obj.c</code>的时候，它<strong>自动就解包</strong>了(自动已经开始读取value了)</p>
</li>
<li><p>重新分配一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;汽车信息：一辆&#123;&#123;car.<span class="property">brand</span>&#125;&#125;车，价值&#123;&#123;car.<span class="property">price</span>&#125;&#125;万&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>换一辆车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> <span class="comment">// 点击按钮不起作用 -- 失去响应式</span></span><br><span class="line"><span class="comment">// 重新分配一个对象</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changePrice</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car.<span class="property">price</span> += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发换车事件后，由于失去响应式，修改价格也不会再生效</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car = &#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;</span><br><span class="line">  car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;) <span class="comment">// 即便是用reactive包裹，依旧一样会失去响应式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以通过ES6的assign方法来修改，会将后面所有对象的属性加到car中，同名则覆盖</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(car,&#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="title function_">ref</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car.<span class="property">value</span> = &#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125; <span class="comment">// 如果是ref，就可以直接整体改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>这种写法经常是无法避免的，比如后端返回一个对象，有二十多个属性，我们是不可能一个一个修改属性值的，肯定是要重新分配一个对象</p>
</blockquote>
<ul>
<li><strong>使用原则</strong>：</li>
</ul>
<blockquote>
<ol>
<li>若需要一个<strong>基本类型</strong>的响应式数据，必须使用<code>ref</code>。</li>
<li>若需要一个<strong>响应式对象</strong>，<strong>层级不深</strong>，<code>ref</code>、<code>reactive</code>都可以。</li>
<li>若需要一个<strong>响应式对象</strong>，且<strong>层级较深</strong>，推荐使用<code>reactive</code>。<blockquote>
<p>做表单相关的，做收集数据、表单数据回显，推荐使用reactive<br>如果一个表单里面有非常多数据，大量的使用ref，最终的代码就会一堆.value，不是很合适<br>ref代理对象还是调的reactive,所以<strong>reactive代理对象性能更好</strong></p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="toRefs-与-toRef"><a href="#toRefs-与-toRef" class="headerlink" title="toRefs 与 toRef"></a>toRefs 与 toRef</h1><blockquote>
<p><strong>toRefs</strong>应该会更<strong>常用</strong>些，毕竟写法更简单，而且也可以获取单个属性</p>
</blockquote>
<ul>
<li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。<blockquote>
<p>如果嵌套的过多，每次都要去<code>.</code>很多东西，就很麻烦，直接取出来可以更方便</p>
</blockquote>
</li>
<li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li>
<li>语法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 模板中也可以直接写解构出来的响应式数据，如 &#123;&#123; name &#125;&#125;*/&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;person.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别：&#123;&#123;person.gender&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeGender&quot;</span>&gt;</span>修改性别<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,reactive,toRefs,toRef&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRef、toRefs得到的都是ObjectRefImpl对象，修改得到的响应式数据的值，对象中的属性值也同时被修改</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;name,gender&#125; = <span class="title function_">toRefs</span>(person)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRef将person对象中的age属性取出，且依然保持响应式的能力</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">toRef</span>(person,<span class="string">&#x27;age&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这样写是不一样的！！！得到的都是RefImpl对象，而不是ObjectRefImpl对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这两个写法都是把person的age这个基本数据的值取了出来，作为定义的响应式数据的初始值，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 不会影响到person.age</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">toRef</span>(person.<span class="property">age</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(person.<span class="property">age</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果是这种写法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 由于ref(person)得到的是一个RefImpl对象，想要解构出name、gender属性，必须.value才行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 最终取到的值，只是普通的基本类型数据，所以结构得到的name、gender是非响应式数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;name,gender&#125; = <span class="title function_">ref</span>(person).<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    name.<span class="property">value</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    age.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeGender</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    gender.<span class="property">value</span> = <span class="string">&#x27;女&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p>
<img src="/tsukimiya.github.io/images/vue3/computed.gif" style="zoom:20%; margin:0" />  

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;ref,computed&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let firstName = ref(&#x27;zhang&#x27;)</span><br><span class="line">  let lastName = ref(&#x27;san&#x27;)</span><br><span class="line"></span><br><span class="line">  // 计算属性——只读取，不修改</span><br><span class="line">  // 这么定义出来的fullname是个`ComputedRefImpl`对象</span><br><span class="line">  // 所以打印fullname的值应该.value，但是不能修改</span><br><span class="line">  /* let fullName = computed(()=&gt;&#123;</span><br><span class="line">    // 计算属性是有缓存的，方法是没有缓存的</span><br><span class="line">    // 它在第一次算完之后，再次使用的时候，数据没变，就直接拿上一次的计算结果来用</span><br><span class="line">    console.log(1) // 模版中使用多次计算属性，只会打印一个1</span><br><span class="line">    return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 计算属性——既读取又修改</span><br><span class="line">  let fullName = computed(&#123;</span><br><span class="line">    // 读取</span><br><span class="line">    get()&#123;</span><br><span class="line">      return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改</span><br><span class="line">    set(val)&#123; // 这里的val就是.value接收的值 -- li-si</span><br><span class="line">      console.log(&#x27;有人修改了fullName&#x27;,val)</span><br><span class="line">      firstName.value = val.split(&#x27;-&#x27;)[0]</span><br><span class="line">      lastName.value = val.split(&#x27;-&#x27;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function changeFullName()&#123;</span><br><span class="line">    // 这里没有修改任何东西，只是引起了fullname的set调用</span><br><span class="line">    fullName.value = &#x27;li-si&#x27;</span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><ul>
<li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li>
<li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：<blockquote>
<ol>
<li><code>ref</code>定义的数据。</li>
<li><code>reactive</code>定义的数据。</li>
<li>一个函数，返回一个值（相当于一个<code>getter</code>函数）。</li>
<li>一个包含上述内容的数组。</li>
</ol>
</blockquote>
</li>
</ul>
<p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p>
<h2 id="情况一-常用"><a href="#情况一-常用" class="headerlink" title="* 情况一(常用)"></a>* 情况一(常用)</h2><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况一：监视【ref】定义的【基本类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>点我sum+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    sum.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况一：监视【ref】定义的【基本类型】数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> stopWatch = <span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(newValue &gt;= <span class="number">10</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">stopWatch</span>() <span class="comment">// 解除监视 ，函数名就是定义的名称</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="* 情况二"></a>* 情况二</h2><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p>
<blockquote>
<p>注意：</p>
<ul>
<li><p>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</p>
</li>
<li><p>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了，去访问的时候都是已经改变过的值了。</p>
<blockquote>
<p>实际开发中，大多数情况下，我们是不管这个旧值的</p>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况二：监视【ref】定义的【对象类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson&quot;</span>&gt;</span>修改整个人<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">ref</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span>.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span>.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 通过字面量的形式，缔造一个全新的对象赋值给value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">90</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* </span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第一个参数是：被监视的数据</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第二个参数是：监视的回调</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第三个参数是：配置对象（deep、immediate等等.....） </span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">  */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>,<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// deep属性，开启深度监视，属性值改变也会触发</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// immediate属性，代表立即监视，一上来先执行一次，这个时候新的值是当前这个，旧的值是undefined</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况三"><a href="#情况三" class="headerlink" title="*  情况三"></a>*  情况三</h2><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况三：监视【reactive】定义的【对象类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson&quot;</span>&gt;</span>修改整个人<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试：&#123;&#123;obj.a.b.c&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>修改obj.a.b.c<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">b</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">c</span>:<span class="number">666</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 地址值根本没有发生变化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 只能说批量的去修改了里面的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(person,&#123;<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">80</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span> = <span class="number">888</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 并且这里的深度监视是不能关闭的，这叫隐式的创建了深层的监听</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(obj,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Obj变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况四-常用"><a href="#情况四-常用" class="headerlink" title="* 情况四(常用)"></a>* 情况四(常用)</h2><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p>
<ol>
<li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li>
<li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，<strong>建议写成函数</strong>。<blockquote>
<p>如果直接监听，只能监听到属性改变，但是整体改变后监听就失效了<br> 写成函数监听，就和ref的对象数据监听一样了</p>
</blockquote>
</li>
</ol>
<p>结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC1&quot;</span>&gt;</span>修改第一台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC2&quot;</span>&gt;</span>修改第二台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>修改整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">car</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c1</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c2</span>:<span class="string">&#x27;宝马&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC1</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c1</span> = <span class="string">&#x27;奥迪&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC2</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c2</span> = <span class="string">&#x27;大众&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span> = &#123;<span class="attr">c1</span>:<span class="string">&#x27;雅迪&#x27;</span>,<span class="attr">c2</span>:<span class="string">&#x27;爱玛&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">  &#125;) */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">car</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.car变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况五-有几率"><a href="#情况五-有几率" class="headerlink" title="* 情况五(有几率)"></a>* 情况五(有几率)</h2><p>监视上述的多个数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况五：监视上述的多个数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC1&quot;</span>&gt;</span>修改第一台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC2&quot;</span>&gt;</span>修改第二台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>修改整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">car</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c1</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c2</span>:<span class="string">&#x27;宝马&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC1</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c1</span> = <span class="string">&#x27;奥迪&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC2</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c2</span> = <span class="string">&#x27;大众&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span> = &#123;<span class="attr">c1</span>:<span class="string">&#x27;雅迪&#x27;</span>,<span class="attr">c2</span>:<span class="string">&#x27;爱玛&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况五：监视上述的多个数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">name</span>,person.<span class="property">car</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.car变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h1><ul>
<li><p>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p>
</li>
<li><p><code>watch</code>对比<code>watchEffect</code></p>
<blockquote>
<ol>
<li><p>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</p>
</li>
<li><p><code>watch</code>：要明确指出监视的数据</p>
</li>
<li><p><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</p>
<blockquote>
<p>全自动的监视</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>需求：水温达到50℃，或水位达到20cm，则联系服务器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>水温：&#123;&#123;temp&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>水位：&#123;&#123;height&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePrice&quot;</span>&gt;</span>水温+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>水位+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch,watchEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> temp = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> height = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePrice</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    temp.<span class="property">value</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    height.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用watch实现，需要明确的指出要监视：temp、height</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>([temp,height],<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 从value中获取最新的temp值、height值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> [newTemp,newHeight] = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 室温达到50℃，或水位达到20cm，立刻联系服务器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(newTemp &gt;= <span class="number">50</span> || newHeight &gt;= <span class="number">20</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用watchEffect实现，不用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> stopWtach = <span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 室温达到50℃，或水位达到20cm，立刻联系服务器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(temp.<span class="property">value</span> &gt;= <span class="number">50</span> || height.<span class="property">value</span> &gt;= <span class="number">20</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>)?.<span class="property">innerText</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 水温达到100，或水位达到50，取消监视</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(temp.<span class="property">value</span> === <span class="number">100</span> || height.<span class="property">value</span> === <span class="number">50</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理了&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">stopWtach</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="标签的-ref-属性"><a href="#标签的-ref-属性" class="headerlink" title="标签的 ref 属性"></a>标签的 ref 属性</h1><p>作用：用于注册模板引用。</p>
<blockquote>
<ul>
<li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p>
</li>
<li><p><strong>用在组件标签上</strong>，获取的是<strong>组件实例对象</strong>。</p>
</li>
</ul>
</blockquote>
<p>用在普通<code>DOM</code>标签上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;title1&quot;</span>&gt;</span>尚硅谷<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">ref</span>=<span class="string">&quot;title2&quot;</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">ref</span>=<span class="string">&quot;title3&quot;</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;inpt&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showLog&quot;</span>&gt;</span>点我打印内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 创建一个title1，用于存储ref标记的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 名称必须和标记的名称一致</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title1 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title2 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title3 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如果直接打印出来，由于setup执行是最早的，元素还没有渲染，所以是undefined</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title1.<span class="property">value</span>); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">showLog</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过id获取元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> t1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 打印内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>((t1 <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>((&lt;<span class="title class_">HTMLElement</span>&gt;t1).<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(t1?.<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过ref获取元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title1.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title2.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title3.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用在组件标签上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件<span class="title class_">App</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">ref</span>=<span class="string">&quot;ren&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Person.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> ren = <span class="title function_">ref</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ren.<span class="property">value</span>.<span class="property">name</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ren.<span class="property">value</span>.<span class="property">age</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>子组件<code>Person.vue</code>中要使用<code>defineExpose</code>宏命令<strong>暴露内容</strong><br>在app组件中直接打印出组件的实例对象，是看不到组件内的数据的，这是一种保护措施</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3最新版本已经内置了defineExpose,不需要引入了，是宏命令</span></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup name=<span class="string">&quot;Person&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;ref,defineExpose&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">	<span class="comment">// 数据</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line">  <span class="comment">/****************************/</span></span><br><span class="line">  <span class="comment">// 使用defineExpose将组件中的数据交给外部</span></span><br><span class="line">  <span class="title function_">defineExpose</span>(&#123;name,age&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TS接口</span></span><br><span class="line"><span class="comment">// 定义一个接口，限制每个Person对象的格式</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PersonInter</span> &#123;</span><br><span class="line"> <span class="attr">id</span>:string,</span><br><span class="line"> <span class="attr">name</span>:string,</span><br><span class="line"> <span class="attr">age</span>:number,</span><br><span class="line"> x?:number <span class="comment">// x是可有可无，有的话必须为number类型</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// TS 自定义类型 &amp; 泛型</span></span><br><span class="line"><span class="comment">// 定义一个自定义类型Persons</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Persons</span> = <span class="title class_">Array</span>&lt;<span class="title class_">PersonInter</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>中代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">:list</span>=<span class="string">&quot;persons&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Person.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 最新的规范，为了与值做区分，导入的类型要加type</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;type <span class="title class_">Persons</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 虽然let persons&lt;Persons&gt; = reactive([...])这样写没有报错，但是这种写法并没有使得规范生效</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// reactive对象，是支持泛型的</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> persons = reactive&lt;<span class="title class_">Persons</span>&gt;([</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e12&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e13&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e14&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王五&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">x</span>:<span class="number">9</span>&#125;</span></span><br><span class="line"><span class="language-javascript">  ])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Person.vue</code>中代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 新版vue3似乎也内置了defineProps和withDefaults,不需要引入</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//defineXXX，这种的一般都属于宏函数，在vue3里面不用引入</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;defineProps&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;type <span class="title class_">PersonInter</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;@/types&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第一种写法：仅接收</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// defineProps返回值是一个Proxy对象，包含所有你接收的东西</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// defineProps参数必须是字符串的数组，命名必须和传入的值保持一致(否则为undefined)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;list&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第二种写法：接收+限制类型（而且还是个必要传的值）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;<span class="attr">list</span>:<span class="title class_">Persons</span>&#125;&gt;()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第三种写法：接收+限制类型+指定默认值+限制必要性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;&#123;list?:<span class="title class_">Persons</span>&#125;&gt;(),&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">list</span>:<span class="function">()=&gt;</span>[&#123;<span class="attr">id</span>:<span class="string">&#x27;asdasg01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;小猪佩奇&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// vue2中直接把props属性定义为对象类型default:xxx，就很简单</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul>
<li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，<strong>这些特定的函数统称为</strong>：<strong>生命周期钩子</strong></p>
<blockquote>
<p>生命周期、生命周期函数、生命周期钩子，都是指的生命周期</p>
</blockquote>
</li>
<li><p>规律：</p>
<blockquote>
<p><strong>生命周期</strong>整体分为<strong>四个阶段</strong>，<strong>八个钩子</strong>：<font color="red"><strong>创建、挂载、更新、销毁</strong></font>，<font color="green">每个阶段都有两个钩子</font>，一前一后。</p>
</blockquote>
<blockquote>
<p>这些是vue最为常用、最为基本的生命周期。<br>虽然vue的钩子(生命周期)不止8个，像是nextTick，路由守卫，缓存路由组件的钩子，但是只要掌握基本的这8个，其他的都可以现用现查现写</p>
</blockquote>
</li>
<li><p><code>Vue2</code>的生命周期</p>
<blockquote>
<p>创建阶段：<code>beforeCreate</code>、<code>created</code></p>
<p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p>
<p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p>
<p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p>
</blockquote>
</li>
<li><p><code>Vue3</code>的生命周期</p>
<blockquote>
<p><strong>创建阶段</strong>：<code>setup</code></p>
<p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p>
<p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p>
<p><strong>卸载阶段</strong>：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p>
</blockquote>
</li>
<li><p><strong>常用的钩子</strong>：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123; sum &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>点我sum+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue3写法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    sum.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setup&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 生命周期钩子</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeMount</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;挂载之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;挂载完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeUpdate</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onUpdated</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeUnmount</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>vue解析流程</strong>：<br>任何一个组件都有生命周期，这就涉及到了父与子之间的生命周期顺序:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// App.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>父创建</code> – <code>父挂载前</code> – 子创建 – 子挂载前 – 子挂载完毕 – <code>父挂载完毕</code></p>
<blockquote>
<p>父 和 子 ， 子组件先挂载完<br>  解析流程：<br>  入口文件<code>index.html</code> 引入了<code>main.ts</code>，<code>main.ts</code>要把<code>App</code>挂到页面上，于是解析<code>App组件</code>。<br>  解析的时候发现<code>App组件</code>里面用到了<code>Person子组件</code>，它马上去忙<code>Person</code>，等把<code>Person</code>里面所有的东西都忙完了，然后就算<code>&lt;Person/&gt;</code>这一行解析完了(证明该调的钩子都调完了)<br>  <code>App</code>整个解析完了，就是<code>h1</code>这块解析完了</p>
</blockquote>
<p>  子是先执行的，父是最后的。所以<strong>App组件永远是最后挂载的</strong></p>
</li>
</ul>
<h1 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h1><ul>
<li><p>什么是<code>hook</code>？—— 把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</p>
<blockquote>
<p><strong>本质是一个函数</strong>，一个 .js&#x2F;.ts文件<br>  作用：<strong>封装</strong>，高内聚，低耦合。让一个功能的数据和方法贴在一起(不用hooks和vue2写法没太大区别)<br>正是有了hooks，组合式才发挥出来了威力！</p>
</blockquote>
</li>
<li><p>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</p>
</li>
<li><p>命名规范：useXXX</p>
</li>
<li><p>返回值: 返回值没有强制要求必须是对象，但是为了更好地组织和管理状态，以及提高代码的可读性，建议在组合函数中返回一个对象</p>
</li>
</ul>
<p>示例代码：</p>
<ul>
<li><p><code>useSum.ts</code>中内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出的必须是一个函数，并且没有名字！</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// hooks里面能写钩子！</span></span><br><span class="line">    <span class="title function_">increment</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据，写数组[]，甚至map容器都行，但是推荐写对象。</span></span><br><span class="line">  <span class="keyword">return</span> &#123;sum,increment,decrement&#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>useDog.ts</code>中内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios,&#123;<span class="title class_">AxiosError</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dogList = reactive&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDog</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发请求</span></span><br><span class="line">      <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)</span><br><span class="line">      <span class="comment">// 维护数据</span></span><br><span class="line">      dogList.<span class="title function_">push</span>(data.<span class="property">message</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      <span class="keyword">const</span> err = &lt;<span class="title class_">AxiosError</span>&gt;error</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载钩子</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">getDog</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;dogList,getDog&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中具体使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>点我-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-for</span>=<span class="string">&quot;(u,index) in dogList.urlList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;(u as string)&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;dogList.isLoading&quot;</span>&gt;</span>加载中......<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getDog&quot;</span>&gt;</span>再来一只狗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;defineComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> useSum <span class="keyword">from</span> <span class="string">&#x27;./hooks/useSum&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> useDog <span class="keyword">from</span> <span class="string">&#x27;./hooks/useDog&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;sum,increment,decrement&#125; = <span class="title function_">useSum</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;dogList,getDog&#125; = <span class="title function_">useDog</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="拓展-–-mixin"><a href="#拓展-–-mixin" class="headerlink" title="拓展 – mixin"></a>拓展 – mixin</h1><p>mixin是vue2的一种<strong>设计模式</strong>，用于<strong>实现组件间的代码复用</strong><br>通常会定义一组可复用的组件配置，如数据，计算属性，方法，生命周期钩子等，将其<strong>封装</strong>到一个如<code>myMixin.js</code>的文件中</p>
<p>工作原理：将 mixin 对象中的选项与组件自身的选项进行合并。如果 mixin 和组件中存在相同的选项，如 methods、data、computed 等，Vue 会按照一定的规则进行合并处理。例如：</p>
<ul>
<li>对于 data，mixin 中的数据会被合并到组件的数据对象中，如果有同名属性，则组件自身的 data 优先级更高，会覆盖 mixin 中的同名属性。</li>
<li>对于 methods、computed、watch 等，如果存在同名函数或属性，它们会被合并，不会覆盖，如果同名方法都存在，则两个方法都会执行（对于生命周期钩子，会将它们合并成数组，依次调用）。</li>
<li>对于生命周期钩子，如果 mixin 和组件都定义了同一个钩子函数，则这些函数会被合成一个数组，当生命周期事件触发时，这些函数会按照它们被发现的顺序依次调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 mixin</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello from mixin!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">showMsg</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在需要使用的vue组件中引入该文件：<code>import myMixin from &#39;./myMixin.js&#39;;</code><br>并挂载到mixin选项上：<code>mixins: [myMixin], // 引入mixin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单文件组件（.vue文件）中使用 mixin</span></span><br><span class="line"><span class="comment">// 或者是，在一个独立的JavaScript模块文件（如myComponent.js）中：</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> myMixin <span class="keyword">from</span> <span class="string">&#x27;./myMixin.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMsg</span>(); <span class="comment">// 使用来自mixin的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>组合式API</tag>
        <tag>setup语法糖</tag>
        <tag>ref</tag>
        <tag>reactive</tag>
        <tag>toRefs</tag>
        <tag>computed</tag>
        <tag>计算属性</tag>
        <tag>watch</tag>
        <tag>侦听器</tag>
        <tag>props</tag>
        <tag>生命周期</tag>
        <tag>hooks</tag>
        <tag>mixin设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3其它 API</title>
    <url>/tsukimiya.github.io/2024/05/18/vue3/7.vue3%E5%85%B6%E4%BB%96API/</url>
    <content><![CDATA[<blockquote>
<p>使用场景不是很多，了解一下常用的</p>
</blockquote>
<h1 id="shallowRef-与-shallowReactive"><a href="#shallowRef-与-shallowReactive" class="headerlink" title="shallowRef 与 shallowReactive"></a>shallowRef 与 shallowReactive</h1><p>作用：提升性能</p>
<h2 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h2><ol>
<li><p>作用：创建一个响应式数据，但<strong>只对顶层属性进行响应式处理</strong>。</p>
<blockquote>
<p>如果是对象类型的数据，不再关注对象内部的属性，只关注对象整体(地址值是否变化)</p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(initialValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p>
</li>
<li><p>应用场景：只关心对象是否被整体替换，如服务器承诺每次返回的都是一个新的对象。</p>
<blockquote>
<p><strong>这个时候</strong>用shallowRef<strong>效率更高</strong>一些</p>
</blockquote>
</li>
</ol>
<h2 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h2><ol>
<li><p>作用：创建一个<strong>浅层响应式</strong>对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p>
<blockquote>
<p>属性值为非对象的，保持响应式 </p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来<strong>绕开深度响应</strong>。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可<strong>提升性能</strong>。</p>
</blockquote>
<h1 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h1><p><strong>作用：保护数据</strong></p>
<blockquote>
<p>readonly用的更多一点</p>
</blockquote>
<h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h2><ol>
<li><p>作用：用于创建一个对象的<strong>深只读副本</strong>。 &#x2F;&#x2F; 维护住关联关系，会跟着源对象变化</p>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> readOnlyCopy = <span class="title function_">readonly</span>(original); <span class="comment">// 参数只接收一个响应式对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ul>
<li>对象的所有嵌套属性都将变为只读。<blockquote>
<p>不过修改源对象，生成的对象也会同步修改(但是不能直接修改生成的只读对象)</p>
</blockquote>
</li>
<li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li>创建不可变的状态快照。</li>
<li>保护全局状态或配置不被修改。</li>
</ul>
</li>
</ol>
<h2 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h2><ol>
<li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p>
<blockquote>
<p>只处理浅层次的只读</p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> shallowReadOnlyCopy = <span class="title function_">shallowReadonly</span>(original);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ul>
<li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p>
</li>
<li><p>适用于只需保护对象顶层属性的场景。</p>
</li>
</ul>
</li>
</ol>
<h1 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h1><h2 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h2><ol>
<li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。<br>对原始对象修改，toRaw的对象也会同步修改</p>
<blockquote>
<p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。<strong>不建议保存对原始对象的持久引用，请谨慎使用</strong>。</p>
</blockquote>
<blockquote>
<p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以<strong>确保它们收到的是普通对象</strong></p>
</blockquote>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* toRaw */</span></span><br><span class="line"><span class="comment">// 响应式对象</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">let</span> rawPerson = <span class="title function_">toRaw</span>(person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citysd = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(person))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(rawPerson))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys2))</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h2><ol>
<li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p>
<blockquote>
<p>例如使用<code>mockjs</code>等第三方库时，为了防止误把<code>第三方库</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code>&#x2F;<code>第三方库</code></p>
<blockquote>
<p>如果误把mockjs变成响应式对象，会导致对里面任何一个小属性的修改都会被vue发现，有一定效率上的问题<br>mockjs 后端的接口还没有出现的时候，我们可以借助mockjs库去模拟接口</p>
</blockquote>
</blockquote>
</li>
<li><p>编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citys = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="customRef-自定义Ref"><a href="#customRef-自定义Ref" class="headerlink" title="customRef&#x2F;自定义Ref"></a>customRef&#x2F;自定义Ref</h1><blockquote>
<p>公司一般会 <strong>把自定义Ref封装成一个hooks</strong></p>
</blockquote>
<p>作用：创建一个<strong>自定义的</strong><code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p>
<blockquote>
<p>其实就是在原生ref基础上，加上自己的一些逻辑(比如延迟1s再更新数据)</p>
</blockquote>
<p><strong>核心</strong>：如何理解<code>track()</code>和<code>trigger()</code></p>
<ul>
<li>track()：监视msg的更新，<strong>一旦变化就更新页面</strong><blockquote>
<p>页面模板中，是取的msg的值，触发的是get</p>
</blockquote>
</li>
<li>trigger(): 通知Vue数据msg变化了(于是就会更新页面)<blockquote>
<p>msg被修改，就会触发set的调用</p>
</blockquote>
</li>
</ul>
<p>实现防抖效果（<code>useSumRef.ts</code>）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新页面(监视msg的更新)</span></span><br><span class="line">        <span class="keyword">return</span> initValue</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          initValue = value</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">//通知Vue数据msg变化了</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useSumRef <span class="keyword">from</span> <span class="string">&quot;@/hooks/useSumRef&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;msg&#125; = <span class="title function_">useSumRef</span>(<span class="string">&#x27;123&#x27;</span>,<span class="number">500</span>) <span class="comment">// msg初始值为&#x27;123&#x27;, 500毫秒后才更新页面</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/tsukimiya.github.io/2024/05/06/ES6/2.Promise/</url>
    <content><![CDATA[<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><ol>
<li><p>回调地狱<br>多层回调函数的相互嵌套，就形成了回调地狱。示例代码如:</p>
<blockquote>
<p>回调地狱更多导致的问题还是：<strong>难以阅读和维护</strong>，通常出现在异步操作中<br>其和递归问题导致的栈溢出还是不同的，两者是不同的问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span>&#123; <span class="comment">//第1层回调函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;延时1秒后输出&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//第2层回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再延时2秒后输出&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//第3层回调函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再延时3秒后输出&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>回调地狱的缺点:<br>代码耦合性太强，牵一发而动全身，<strong>难以维护</strong><br>大量冗余的代码相互嵌套，代码的<strong>可读性变差</strong></p>
</li>
<li><p>如何解决<br>为了解决回调地狱的问题，ES6 (ECMAScript 2015)中新增了<strong>Promise</strong>的概念。</p>
<blockquote>
<p>解决回调地狱的方法包括使用 Promise、async&#x2F;await 等异步编程技术，以及使用函数式编程的方式来组织代码，使其更具可读性和可维护性。</p>
</blockquote>
</li>
</ol>
<h2 id="Promise基本概念"><a href="#Promise基本概念" class="headerlink" title="Promise基本概念"></a>Promise基本概念</h2><ol>
<li><p><strong>Promise是一个构造函数</strong></p>
<ul>
<li>我们可以创建Promise 的实例 <code>const p = newPromise()</code></li>
<li>new出来的Promise 实例对象，<strong>代表一个异步操作</strong></li>
</ul>
</li>
<li><p><strong>Promise.prototype 上包含一个.then()方法</strong></p>
<ul>
<li>每一次new Promise()构造函数得到的实例对象，</li>
<li>都可以<strong>通过原型链的方式</strong>访问到.then()方法，例如<code>p.then()</code></li>
</ul>
</li>
<li><p><strong>.then()方法用来预先指定成功和失败的回调函数</strong></p>
<ul>
<li>p.then(<strong>成功的回调函数</strong>，<strong>失败的回调函数</strong>)</li>
<li>p.then(result,&#x3D;&gt; {}, error &#x3D;&gt; {})</li>
<li>调用.then()方法时，<strong>成功的回调函数是必选的</strong>、失败的回调函数是可选的</li>
</ul>
</li>
</ol>
<h2 id="基于-then-fs-异步的读取文件内容"><a href="#基于-then-fs-异步的读取文件内容" class="headerlink" title="基于 then-fs 异步的读取文件内容"></a>基于 then-fs 异步的读取文件内容</h2><ol>
<li><p>基于回调函数按顺序读取文件内容<br>虽然可以保证文件的读取顺序，但是形成了一个回调地狱的问题<br><img src="/tsukimiya.github.io/images/ES6/%E5%9F%BA%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="img"></p>
</li>
<li><p>基于 then-fs 读取文件内容<br><strong>fs模块仅支持 以回调函数的方式 读取文件，不支持Promise的调用方式</strong>。因此，需要先安装 then-fs 第三方包，从而支持基于Promise的方式读取文件的内容： <code>npm install then-fs</code></p>
</li>
</ol>
<ul>
<li><strong>then-fs 的基本使用</strong><br>调用 then-fs 提供的<strong>readFile()<strong>方法，可以异步地读取文件的内容，</strong>它的返回值是 Promise 的实例对象</strong>。因此可以<strong>调用.then()方法</strong>为每个 Promise 异步操作指定<strong>成功</strong>和<strong>失败</strong>之后的回调函数。示例代码如下:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Promise的方式读取文件</span></span><br><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"><span class="comment">// .then()中的失败回调是可选的，这里省略了</span></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1);&#125;)</span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r2);&#125;)</span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r3);&#125;)</span><br></pre></td></tr></table></figure>
当前只是异步的去读文件，<strong>无法保证文件的读取顺序</strong>，多次执行读取顺序不一</li>
</ul>
<h2 id="基于Promise按顺序读取文件的内容"><a href="#基于Promise按顺序读取文件的内容" class="headerlink" title="基于Promise按顺序读取文件的内容"></a>基于Promise按顺序读取文件的内容</h2><ul>
<li><p><strong>.then方法的特性</strong><br>如果上一个.then()方法中<strong>返回了一个新的Promise实例对象</strong>，则可以通过下一个.then()继续进行处理。通过.then()方法的<strong>链式调用</strong>，就解决了回调地狱的问题。</p>
</li>
<li><p><strong>基于Promise</strong>按顺序读取文件的内容<br><strong>只要任何方法返回值是一个Promise实例对象，那就都可以继续调用.then()方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">// 返回值是Promise的实例对象</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123; <span class="comment">// 通过.then 为返回的promise实例指定成功之后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 .catch 捕获错误<br>在 Promise 的链式操作中如果发生了错误，可以使用Promise.prototype.catch方法进行捕获和处理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>) <span class="comment">// 文件不存在</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  &#125;) <span class="comment">// 只返回错误，没有读取的文件内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不希望前面的错误导致后续的.then无法正常执行，<strong>可以将.catch的调用提前</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;) <span class="comment">// 先打印错误，然后打印读取内容，r1为undefined，r2r3读取成功</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h2><p>Promise.all()方法会发起并行的Promise异步操作，等<strong>所有的异步操作全部结束后</strong>才会执行下一步的.then操作（等待机制）。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [</span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promiseArr).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [ &#x27;111&#x27;, &#x27;222&#x27;, &#x27;333&#x27; ]</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise示例的顺序，就是最终拿到的结果的顺序。如果有一个文件读取错误，所有数据都拿不到</p>
<h2 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a>Promise.race() 方法</h2><p>Promise.race()方法会发起并行的Promise异步操作，<strong>只要任何一个异步操作完成，就立即执行下一步的.then操作</strong>（赛跑机制）。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [</span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promiseArr).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只会拿到一个文件的读取结果，读取最快的那个，无法保证读取的文件是哪个</p>
<h2 id="基于Promise封装异步读文件的方法"><a href="#基于Promise封装异步读文件的方法" class="headerlink" title="基于Promise封装异步读文件的方法"></a>基于Promise封装异步读文件的方法</h2><ul>
<li><p>方法的封装要求:</p>
<ol>
<li>方法的名称要定义为getFile</li>
<li>方法接收一个形参fpath，表示要读取的文件的路径</li>
<li>方法的返回值为Promise 实例对象</li>
</ol>
</li>
<li><p>getFile方法的基本定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>new Promise()</strong> 只是创建了一个<strong>形式上的异步操作</strong></p>
</li>
<li><p><strong>创建具体的异步操作</strong><br>如果想要创建具体的异步操作，则需要在new Promise()构造函数期间，<strong>传递一个function函数，将具体的<br>异步操作定义到function函数内部</strong>。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fpath,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err,dataStr</span>)=&gt;</span>&#123; &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取.then的两个实参<br>通过.then()指定的成功和失败的回调函数，可以在 function的形参中 进行接收，示例代码如下:<br><img src="/tsukimiya.github.io/images/ES6/%E8%8E%B7%E5%8F%96.then%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%9E%E5%8F%82.png" alt="img"></p>
</li>
<li><p>调用 resolve 和 reject 回调函数<br>Promise<strong>异步操作的结果</strong>，可以调用 <strong>resolve</strong> 或 <strong>reject</strong> 回调函数进行处理。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fpath, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="title function_">reject</span>(err) <span class="comment">// 发生错误</span></span><br><span class="line">      <span class="title function_">resolve</span>(dataStr) <span class="comment">// 读取成功</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1)&#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);&#125;)</span><br><span class="line"><span class="comment">// 失败的回调函数可以省略不写，可以用catch进行捕获</span></span><br><span class="line"><span class="title function_">getFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1)&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>回调地狱</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3新组件</title>
    <url>/tsukimiya.github.io/2024/05/18/vue3/8.vue3%E6%96%B0%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><ul>
<li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li>
</ul>
<p>场景：<br>点击button按钮，会出现弹窗，我们想要弹窗fixed定位出现在视口中央位置<br>如果我们给父元素添加了一个filter滤镜样式，会发现定位失效了，它变成了相对父元素的定位，但是又不能删掉filter，这个时候，就可以用teleport</p>
<blockquote>
<p>当然，影响这个position: fixed的不仅仅有filter</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// to的意思是，modal弹出来的时候，塞到哪里去</span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&#x27;body&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是弹窗中的一些内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终，在页面呈现的时候，modal元素会从App里面出来，被放到主页面最下面，，而且它的逻辑不会拎出去</p>
<h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><ul>
<li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验 </li>
<li>使用步骤： <ul>
<li>异步引入组件</li>
<li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li>
</ul>
</li>
<li>使用场景：子组件在setup里面写了着异步任务，并且异步任务所提供的数据需要使用，想让它网速慢的时候也能呈现一些东西，就可以用Suspense</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span> // 底层是用插槽实现的</span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span> // 异步任务OK了才出现</span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span> // 异步任务没有做完的时候出现</span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.......<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>react路由懒加载时候 就是用suspense包裹 fallback定义loading</p>
</blockquote>
<h2 id="全局API转移到应用对象"><a href="#全局API转移到应用对象" class="headerlink" title="全局API转移到应用对象"></a>全局API转移到应用对象</h2><blockquote>
<p>这些都是vue2的一些全局API，vue3转移到了app实例对象身上（vue3里面是没有Vue构造函数的）<br>原来的<code>Vue.xxx</code>都变成了<code>app.xxx</code></p>
</blockquote>
<ul>
<li><code>app.component</code>：注册全局组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello</span> <span class="keyword">from</span> <span class="string">&#x27;./hello.vue&#x27;</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;Hello&#x27;</span>,<span class="title class_">Hello</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>app.config</code>：配置对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="comment">// 比如这个,x在任意组件都是可用的</span></span><br><span class="line"><span class="comment">// 不过不推荐使用这个globalProperties，污染全局</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">x</span> = <span class="number">99</span></span><br><span class="line"><span class="comment">// 不过在使用的时候会爆红，不过不会报错，因为组件文件里没有x</span></span><br><span class="line"><span class="comment">// 可以配置如下来解决： // vue文档有</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vue&#x27;</span> &#123;</span><br><span class="line">  interface <span class="title class_">ComponentCustomProperties</span>&#123;</span><br><span class="line">    <span class="attr">x</span>:number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>app.directive</code>：注册全局指令<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;beauty&#x27;</span>,<span class="function">(<span class="params">element,&#123;value&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  element.<span class="property">innerText</span> += value</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;h2 v-beauty=<span class="string">&quot;啊啊啊啊&quot;</span>&gt;好开心&lt;<span class="regexp">/h2&gt; /</span>/ 使用 --- 页面显示 黄色的 好开心啊啊啊啊</span><br></pre></td></tr></table></figure></li>
<li><code>app.mount</code>：挂载应用</li>
<li><code>app.unmount</code>：卸载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  app.<span class="title function_">unmount</span>() <span class="comment">// 2s后，页面没了</span></span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>app.use</code>：安装插件</li>
</ul>
<h2 id="其他-Vue3的非兼容性改变"><a href="#其他-Vue3的非兼容性改变" class="headerlink" title="其他 - Vue3的非兼容性改变"></a>其他 - <font color="red">Vue3的非兼容性改变</font></h2><blockquote>
<p>意思是：Vue3里面，做了哪些和Vue2里面不一样的 &#x2F;&#x2F; <a href="https://v3-migration.vuejs.org/zh/breaking-changes/">vue官方文档 - 从vue2迁移</a><br>也就是 ———— <strong>Vue2 和 Vue3的区别</strong>，所有人都得知道！</p>
</blockquote>
<ul>
<li><p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p>
</li>
<li><p><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</p>
<blockquote>
<p>vue2中可以@keyup.13，vue3中不允许了</p>
</blockquote>
</li>
<li><p><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></p>
<blockquote>
<p>vue2中可以 :a.sync&#x3D;’sum’，vue3中整合到v-model里了</p>
</blockquote>
</li>
<li><p><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</p>
<blockquote>
<p>vue2中，v-if和v-for不可以用在一个标签上，因为v-for优先级更高<br>  vue3中，可以在同一个元素使用，并且v-if的优先级提的更高了</p>
</blockquote>
</li>
<li><p>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</p>
</li>
<li><p>移除了过滤器 <code>filter</code>。</p>
</li>
<li><p>移除了<code>$children</code> 实例 <code>propert</code>。</p>
<p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>EventLoop</title>
    <url>/tsukimiya.github.io/2024/05/07/ES6/4.EventLoop/</url>
    <content><![CDATA[<h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>JS是一门<strong>单线程执行</strong>的编程语言。同一事件只能做一件事情。</p>
<p>JS的执行线程<br>↓<br>任务1 → 任务2 → 任务3 → 任务N（待执行的任务队列）</p>
<p>单线程执行队列的问题：<br>如果<strong>前一个任务非常耗时</strong>，则后续的任务就不得不一直等待，从而导致<strong>程序假死</strong>的问题。</p>
<h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><p>为了防止某个<strong>耗时任务</strong>导致<strong>程序假死</strong>的问题，JavaScript把待执行的任务分为了两类:</p>
<ol>
<li>同步任务 (synchronous)<ul>
<li>又叫做<strong>非耗时任务</strong>，指的是在主线程上排队执行的那些任务</li>
<li>只有前一个任务执行完毕，才能执行后一个任务</li>
</ul>
</li>
<li>异步任务 (asynchronous)<ul>
<li>又叫做<strong>耗时任务</strong>，异步任务由JavaScript<strong>委托给宿主环境</strong>进行执行</li>
<li>当异步任务执行完成后，会<strong>通知JavaScript主线程</strong>执行异步任务的<strong>回调函数</strong><blockquote>
<p>宿主环境就是JS的执行环境，在浏览器里面运行JS，浏览器就是JS的宿主环境，在Node.js…</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="同步任务和异步任务的执行过程"><a href="#同步任务和异步任务的执行过程" class="headerlink" title="同步任务和异步任务的执行过程"></a>同步任务和异步任务的执行过程</h2><p><img src="/tsukimiya.github.io/images/ES6/js%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="js执行过程"></p>
<h2 id="EventLoop的基本概念"><a href="#EventLoop的基本概念" class="headerlink" title="EventLoop的基本概念"></a>EventLoop的基本概念</h2><p><strong>JavaScript主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行</strong>。这个过程是循环不断的，所以整个的这种运行机<br>制又称为<strong>EventLoop</strong>(事件循环)。</p>
<ul>
<li><p>练习<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A0.png" alt="练习"></p>
</li>
<li><p>分享文章<br>面试必问之 JS 事件循环(Event Loop)，看这一篇足够(<a href="https://zhuanlan.zhihu.com/p/580956436">https://zhuanlan.zhihu.com/p/580956436</a>)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>宏任务和微任务</title>
    <url>/tsukimiya.github.io/2024/05/08/ES6/5.%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="什么是宏任务和微任务"><a href="#什么是宏任务和微任务" class="headerlink" title="什么是宏任务和微任务"></a>什么是宏任务和微任务</h2><p>JavaScript把异步任务又做了进一步的划分，异步任务又分为两类，分别是:</p>
<ol>
<li>宏任务( macrotask)<ul>
<li>异步Ajax请求、</li>
<li>setTimeout、setlnterval、</li>
<li>文件操作</li>
<li>其它宏任务</li>
</ul>
</li>
<li>微任务( microtask)<ul>
<li>Promise.then、.catch和.finally</li>
<li>process.nextTick</li>
<li>其它微任务</li>
</ul>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/ES6/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1.png" alt="宏任务和微任务"></p>
<h2 id="划分依据"><a href="#划分依据" class="headerlink" title="划分依据"></a>划分依据</h2><p>异步任务是根据<strong>任务的触发时机</strong>和<strong>任务队列的不同</strong>来分为宏任务和微任务的。下面是它们的依据：</p>
<ol>
<li><p><strong>触发时机</strong>：</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>：宏任务是由 JavaScript 引擎外部的任务触发的，比如 DOM 事件（如点击事件、鼠标移动事件）、<code>setTimeout</code>、<code>setInterval</code>、网络请求等。宏任务代表着一个独立的、顺序执行的任务单元，它们会被放入宏任务队列中等待执行。</li>
<li><strong>微任务（Micro Task）</strong>：微任务是在当前任务执行完成之后立即执行的任务，它们一般是由 JavaScript 引擎内部触发的，比如 Promise 的状态改变、<code>queueMicrotask</code> 函数等。微任务的执行时机是在当前宏任务执行结束、事件循环进入下一次循环之前。</li>
</ul>
</li>
<li><p><strong>任务队列</strong>：</p>
<ul>
<li><strong>宏任务队列</strong>：宏任务队列中存放着各种宏任务，包括了 DOM 事件、定时器、I&#x2F;O 操作等。在事件循环的每一轮中，只有一个宏任务会被执行。</li>
<li><strong>微任务队列</strong>：微任务队列中存放着微任务，它们的执行顺序是按照它们进入队列的顺序执行的。在每个宏任务执行结束后，会检查并执行所有的微任务，直到微任务队列为空。</li>
</ul>
</li>
</ol>
<p>因此，异步任务是根据触发时机和任务队列的不同而被分为宏任务和微任务的。这种分化使得 JavaScript 引擎能够灵活地处理异步任务，并根据执行上下文的情况来调度它们的执行顺序。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>宏任务和微任务是交替执行的。<br>在 JavaScript 中，<strong>执行完同步任务后</strong>，<strong>会先检查是否存在微任务</strong>，如果存在，则先执行微任务队列中的所有微任务。执行完所有微任务后，再去执行宏任务队列中的任务。<br><img src="/tsukimiya.github.io/images/ES6/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="宏任务微任务执行顺序"></p>
<ul>
<li><p>场景举例<br><img src="/tsukimiya.github.io/images/ES6/%E5%9C%BA%E6%99%AF.png" alt="场景"></p>
</li>
<li><p>练习<br>new Promise 是同步任务，其调用的.then是微任务<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A02.png" alt="练习2"></p>
</li>
<li><p>练习<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A03.png" alt="练习3"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>宏任务和微任务</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await</title>
    <url>/tsukimiya.github.io/2024/05/06/ES6/3.async-await/</url>
    <content><![CDATA[<h2 id="什么是-async-await"><a href="#什么是-async-await" class="headerlink" title="什么是 async &#x2F; await"></a>什么是 async &#x2F; await</h2><p><strong>async&#x2F;await</strong> 是 <strong>ES8</strong>(ECMAScript 2017)引入的新语法，用来<strong>简化Promise异步操作</strong>。在async&#x2F;await出现之前，开发者只能通过<strong>链式.then()的方式</strong>处理Promise异步操作。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">// 返回值是Promise的实例对象</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123; <span class="comment">// 通过.then 为返回的promise实例指定成功之后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>.then链式调用的<strong>优点</strong>：解决了回调地狱的问题<br>.then链式调用的<strong>缺点</strong>：代码冗余、阅读性差、不易理解</p>
<h2 id="async-await-的基本使用"><a href="#async-await-的基本使用" class="headerlink" title="async &#x2F; await 的基本使用"></a>async &#x2F; await 的基本使用</h2><p>使用async&#x2F; await简化 Promise异步操作的示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"><span class="comment">// 按顺序读取文件 1 2 3 的内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllFile</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 如果不加await，它的返回值就是Promise实例，加了await，返回值就是最终读取到的文件中的内容</span></span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1) <span class="comment">// 111</span></span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2) <span class="comment">// 222</span></span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3) <span class="comment">// 333</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getAllFile</span>()</span><br></pre></td></tr></table></figure>
<p>如果<strong>某个方法的返回值是个Promise实例对象</strong>，那么我们就可以在前面<strong>用await</strong>来进行<strong>修饰</strong>，修饰完毕之后，这个<strong>返回值就不再是Promise实例</strong>，而是<strong>变成一个真正的值</strong>。<br>而且需要注意：<font color='red'>如果这个方法内部用到了await，那么这个方法必须被async来修饰</font></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><font color='green'>如果在 function 中使用了 await ，则 function <strong>必须</strong>被 async 修饰</font></li>
<li><font color='green'>在 async 方法中，<strong>第一个 await 之前的代码会同步执行</strong>，await之后的代码会异步执行</font><br>最终输出的顺序：A、B、C、111 222 333、D<br>碰到第一个await，主线程就退出了方法执行，立马输出了C，当1 2 3异步读取完成之后就按顺序输出，最后异步的输出了D<br><img src="/tsukimiya.github.io/images/ES6/async%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="async/await方法执行顺序"></li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化与Webpack</title>
    <url>/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>了解工程化的前端开发方式<br>知道Webpack在实际开发中所起到的作用</p>
<blockquote>
<p>我们只需要了解webpack的工作原理，并不要求我们掌握如何配置，因为工作中我们会使用一些工具如Vue-CLI脚手架，它们已经帮我们配置好了</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>webpack 的基本使用</strong>：安装、webpack.config.js、修改打包入口<br><strong>webpack的两个插件</strong>(常用的plugin的基本使用)：<br>webpack-dev-server – (每次修改后自动进行项目的打包和构建)<br>html-webpack-plugin – (把src里面的首页在内存中复制一份，放到根目录中)<br><strong>常用的loader 的基本使用</strong>：协助webpack打包处理特定的文件模块。<br><strong>Source Map 的作用</strong>：精准定位到错误行并显示对应的源码，方便开发者调试源码中的错误</p>
</blockquote>
<h2 id="前端工程化相关概念"><a href="#前端工程化相关概念" class="headerlink" title="前端工程化相关概念"></a>前端工程化相关概念</h2><p>前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。<br>好处:前端开发自成体系，有一套标准的开发方案和流程。</p>
<p>实际的前端开发，是四个现代化：</p>
<ul>
<li><strong>模块化</strong> (js的模块化、css的模块化、资源的模块化) ———— js的复用</li>
<li><strong>组件化</strong> (复用现有的UI结构、样式、行为) ———— UI结构的复用</li>
<li><strong>规范化</strong> (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</li>
<li><strong>自动化</strong> (自动化构建、自动部署、自动化测试)</li>
</ul>
<h3 id="前端工程化解决方案"><a href="#前端工程化解决方案" class="headerlink" title="前端工程化解决方案"></a>前端工程化解决方案</h3><ul>
<li>早期的前端工程化解决方案:<ul>
<li>grunt (<a href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</li>
<li>gulp (<a href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</li>
</ul>
</li>
<li>目前主流的前端工程化解决方案:<ul>
<li>webpack (<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</li>
<li>parcel (<a href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>) ———— 开发第三方包会用到</li>
</ul>
</li>
</ul>
<h2 id="webpack-常见用法"><a href="#webpack-常见用法" class="headerlink" title="webpack 常见用法"></a>webpack 常见用法</h2><ol>
<li><p>什么是webpack？<br> 概念：webPack是<strong>前端项目工程化的具体解决方案</strong>。<br> 主要功能: 它提供了友好的<strong>前端模块化开发支持</strong>，以及<strong>代码压缩混淆</strong>(干掉注释和空格)、<strong>处理浏览器端JavaScript的兼容性</strong>、<strong>性能优化</strong>等强大的功能。<br> 好处:让程序员把<strong>工作的重心</strong>放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意:目前Vue，React等前端项目，基本上都是基于webpack进行工程化开发的。</p>
</li>
<li><p>创建列表隔行变色项目</p>
<ol>
<li>新建项目空白目录，并运行npm init -y命令，初始化包管理配置文件 package.json</li>
<li>新建src源代码目录</li>
<li>新建src -&gt; index.html首页和src -&gt; index.js 脚本文件</li>
<li>初始化首页基本的结构</li>
<li>运行npm install jquery -S命令，安装jQuery(-S明确告诉npm，包要记录到dependencies下，开发上线都会用到)</li>
<li>通过ES6模块化的方式导入jQuery，实现列表隔行变色效果</li>
</ol>
</li>
<li><p>在项目中安装webpack<br> 运行如下命令，安装webpack相关的两个包（-D告诉npm记录到devDependencies下，只在开发阶段会用到）<br> <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code></p>
</li>
<li><p>在项目中配置webpack</p>
<ol>
<li><p>在项目根目录中，创建名为<strong>webpack.config.js</strong>的webpack配置文件，并初始化如下的基本配置:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// mode 用来指定构建模式。可选值有 development和 production</span></span><br><span class="line">    <span class="comment">// 开发阶段选develement，上线改成production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在package.json的 scripts节点下，新增<strong>dev脚本</strong>如下:<br> 这个dev是可以随意命名的，后面的webpack是必须写webpack<br> scripts节点下有个默认的test脚本，删掉就行</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script 节点下的脚本，可以通过 npm run 执行。例如 npm run dev</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中运行npm run dev命令，启动 webpack进行项目的打包构建<br> 运行成功后，项目会多一个dist文件夹，里面的main.js就是webpack根据index.js帮我们自动生成的，做一下兼容性处理<br> 处理完以后，index.js还有兼容性问题，而main.js没有兼容性问题<br> 所以网页应该引入的是main.js文件<br> .<br> 由nodejs升级引起的构建错误：0308010C:digital envelope routines::unsupported<br> <a href="https://juejin.cn/post/7202639428132044858">https://juejin.cn/post/7202639428132044858</a><br> 报错原因可以看这篇文章<br> 解决设置（似乎还没有一个100%完全的解决方法，都会存在一些问题）:<br> <code>&quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack&quot;</code><br> .<br> 这个main.js是webpack帮我们把jquery.js和index.js文件进行了合并，但是并没有压缩，main.js中还有注释和代码缩进，如果要压缩，需要把webpack.config.js的mode设置为production，然后重新运行，整个文件的体积就被压缩的更小了，但是打包的时间更长了<br> .<br> 所以开发的时候，mode都设置成develement，只有上线的时候才会设置为production</p>
</li>
<li><p>webpack的默认约定 ———— 如何打包<br> 在webpack 4.x和5.的版本中，有如下的默认约定:</p>
<ol>
<li>默认的打包入口文件为src -&gt; index.js</li>
<li>默认的输出文件路径为dist -&gt; main.js</li>
</ol>
<p> 注意:可以在webpack.config.js中修改打包的默认约定<br> 如果找不到要处理的文件，就会报错</p>
</li>
<li><p>自定义打包的入口和出口<br> 在webpack.config.js 配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">&#x27;path&#x27;</span>) <span class="comment">//导入 node.js中专门操作路径的模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//打包入口文件的路径</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//输出文件的存放路径 </span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="comment">//输出文件的名称</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>这个时候，我们会发现，每次我们更改index.js的代码之后，都需要再次执行npm run dev更新生成的文件才行，这样非常麻烦，所以我们需要用到webpack的插件</p>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><p>最常用的webpack插件有两个：</p>
<ol>
<li>webpack-dev-server<ul>
<li>类似于node.js的nodemon工具</li>
<li>每当修改了源代码，webpack都会自动进行项目的打包和构建</li>
</ul>
</li>
<li>html-webpack-plugin<ul>
<li>webpack 中的HTML插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定制index.html页面的内容<hr></li>
</ul>
</li>
</ol>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol>
<li><p>安装webpack-dev-server<br> <code>npm i webpack-dev-server@3.11.2 -D</code><br> .<br> 在配置好之后，npm run dev 运行报错<br> Unable to load ‘@webpack-cli&#x2F;serve’ command<br> TypeError: options.forEach is not a function<br> .<br> 下载<code>npm install webpack@5.42.1 webpack-cli@4.10.0 -D</code></p>
</li>
<li><p>配置webpack-dev-server</p>
<ol>
<li>修改package.json -&gt; scripts中的dev命令如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script节点下的脚本，可以通过npm run 执行</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>再次运行npm run dev命令，重新进行项目的打包<br> 在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</li>
</ol>
<p> 注意:webpack-dev-server 会启动一个实时打包的http服务器</p>
</li>
</ol>
<p>注意，webpack-dev-server启动后，构建后的文件是在内存中的，不会实际生成具体的文件，所以我们打开的页面效果不会发生变化</p>
<p>我们执行npm run dev 命令，它执行的其实是webpack serve命令<br>这个命令执行成功后，第一行返回的是，<br><code>i ｢wds｣: Project is running at http://localhost:8080/</code><br>是整个项目运行在8080端口<br>所以，要看更新后的效果，要打开这个网址来查看，不能和以前一样的方法查看，因为之前查看的是file协议，不是当前的http协议</p>
<p>我们打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 网址，进入src，浏览器就会自动打开这个目录下的index文件，但是还是页面没有更改，我们再看第二行<br><code>i ｢wds｣: webpack output is served from /</code><br>告诉我们，输出在根目录，但是根目录并看不到bundle.js，但是其实它是有的，我们打开<a href="http://localhost:8080/bundle.js">http://localhost:8080/bundle.js</a> 可以访问到该文件</p>
<p><strong>webpack-dev-server这个插件，它把生成的bundle没有放到实际的物理磁盘上，而是放到了内存里面</strong><br>这是因为，如果频繁的修改文件，ctrl s，如果是把文件放到物理磁盘上，就会频繁的读写磁盘，对磁盘寿命性能都会有很大影响，所以要访问最新的bundle要访问内存里的bundle，所以应该<strong>在页面加载和引用内存里的bundle.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://localhost:8080/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// 也可以直接这样引用，看不见，但是可以引用的</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>但是由于我的vscode默认的使用5500端口，所以第二种引用会引用到5500端口，但是5500端口并不存在bundle.js，所以会报错,只能使用第一种引用</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>有一点不方便的是，打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 之后，我们还要点击一次src进入目录中，才能打开首页<br>我们希望一进入8080就能看到首页<br>html-webpack-plugin，这个插件可以把src里面的首页复制一份，放到根目录中<br>安装插件：<code>npm i html-webpack-plugin@5.3.2 -D</code></p>
<ul>
<li><p>配置 – 在webpack.config.js中配置<br>  把new出来的插件htmlPlugin 挂载&#x2F;添加到plugins插件的数组里面，这样webpack在运行的时候就会调用这个插件的实例，把src(template)里的页面复制一份放到根目录(filename)中<br>  不过也是复制出来的一个内存里的页面</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入HTML插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 2．创建HTML插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,<span class="comment">//指定原文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,<span class="comment">//指定生成的文件的存放路径</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> ,</span><br><span class="line">    <span class="comment">// 3．通过 plugins节点，使 htmlPlugin插件生效</span></span><br><span class="line">    <span class="attr">plugins</span>: [htmlPlugin], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个作用<br>  html-webpack-plugin插件除了帮我们复制页面，还会在复制出来的页面，自动注入一个脚本(js引用)，去引用内存里的bundle.js<br>  .<br>  我们npm run dev运行之后，如果把html页面的js引入注释掉，内存中页面样式是还在的，并没有消失。<br>  我们查看源码，可以发现它是有js引用的，而且是没有加.&#x2F;的同级目录引用，因为内存中的html和hundle.js在同一级目录</p>
</li>
</ul>
<p>配置完webpack之后，我们的开发体验会变的很好，但是配置过程又非常繁琐。<br>我不想自己配置，又想体验配置后的好处 ———— Vue-cli<br>这个工具已经帮我们配置好了webpack</p>
<h2 id="devServer-节点"><a href="#devServer-节点" class="headerlink" title="devServer 节点"></a>devServer 节点</h2><p>还有一个不爽的点(程序员的很多不爽XDD)，每次重新运行项目，都要手动打开8080页面，我们懒就要懒到底<br><strong>在npm run dev运行成功之后，自动打开浏览器展示网页</strong></p>
<ul>
<li>配置<br>  在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 初次打包完成后，自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 实时打包所使用的主机地址</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="comment">//实时打包所使用的端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="webpack中的loader（加载器）"><a href="#webpack中的loader（加载器）" class="headerlink" title="webpack中的loader（加载器）"></a>webpack中的loader（加载器）</h2><ol>
<li><p>loader概述<br> 在实际开发过程中，webpack默认只能打包处理以.js 后缀名结尾的模块。其他<strong>非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包</strong>，否则会报错!</p>
<p> loader加载器的作用:<strong>协助webpack打包处理特定的文件模块</strong>。比如:</p>
<ul>
<li>css-loader可以打包处理.css相关的文件</li>
<li>less-loader可以打包处理.less相关的文件</li>
<li>babel-loader可以打包处理webpack无法处理的高级JS语法</li>
</ul>
<p> 在webpack里面，一切都可以进行导入，一切皆模块，不建议程序员手动去引入样式和脚本(link，script)</p>
<p> 在js中也可以导入样式(ES6语法)<code>import &#39;./css/index.css&#39;</code></p>
</li>
<li><p>打包处理 css 文件</p>
<ol>
<li>运行<code>npm i style-loader@3.0.0 css-loader@5.2.6 -D</code>命令，安装处理css文件的loader</li>
<li>在webpack.config.js 的 module -&gt; rules 数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
 其中，<strong>test</strong>表示匹配的<strong>文件类型</strong>, <strong>use</strong>表示对应<strong>要调用的loader</strong><br> 注意:</li>
</ol>
<ul>
<li>use数组中指定的loader <strong>顺序是固定的</strong></li>
<li>多个loader的调用顺序是: <strong>从后往前调用</strong><br>  loader在调用的时候，是从后往前调的 <a href='#loader-调用过程'>loader调用过程</a></li>
</ul>
</li>
<li><p>打包处理 less文件</p>
<ol>
<li>运行<code>npm i less-loader@10.0.1 less@4.1.1 -D</code>命令</li>
<li>在webpack.config.js 的module -&gt; rules数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个less是内部依赖项，就是less-loader内部依赖于less，但是不需要手动的去声明less</li>
</ol>
</li>
<li><p>打包处理样式表中与url路径相关的文件</p>
<ol>
<li>运行<code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code>命令</li>
<li>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        <span class="comment">//如果需要调用的loader只有一个(use)，则只传递一个字符串也行，如果有多个loader，则必须指定数组</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,<span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&#x27;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中?之后的是 loader的参数项:</li>
</ol>
<ul>
<li>limit用来指定图片的大小，单位是字节(byte)</li>
<li>只有≤limit 大小的图片，才会被转为base64格式的图片</li>
</ul>
</li>
<li><p>打包处理js文件中的高级语法<br> webpack只能打包处理一部分高级的JavaScript语法。对于那些webpack无法处理的高级js语法，需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1．定义了名为info的装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">//2．为目标添加静态属性info</span></span><br><span class="line">    target.<span class="property">info</span> = <span class="string">&#x27;Person info&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3．为Person类应用info装饰器</span></span><br><span class="line">@info</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4．打印 Person 的静态属性info</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.1 运行如下的命令安装对应的依赖包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js的 module -&gt; rules数组中，添加loader规则如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span> , <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>exclude排除了node_modules文件夹，因为只需要处理我们自己写的代码就可以了，第三方的包没有兼容性问题，本身已经解决了，不需要处理(如果不排除也会对其进行处理影响性能)</p>
<p>5.2 配置babel-loader<br>打包处理js文件中的高级语法，比处理其他文件要多这么一步<br>在项目根目录下，创建名为 babel.config.js 的配置文件，定义Babel的配置项如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些配置从官方文档找到对应项直接粘过来就行了</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//声明babel 可用的插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考Babel的官网<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></p>
<h3 id="loader-调用过程"><a href="#loader-调用过程" class="headerlink" title="loader 调用过程"></a>loader 调用过程</h3><ol>
<li>webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</li>
<li>由于代码中包含了 index.css 这个文件，因此 webpack默认处理不了</li>
<li><strong>当webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器。</strong></li>
<li>webpack 把 index.css 这个文件，先转交给最后一个 loader 进行处理(先转交给css-loader) .</li>
<li>当 css-loader 处理完毕之后，会把处理的结果，转交给下一个 loader (转交给style-loader)</li>
<li>当 style-loader 处理完毕之后，发现没有下一个 loader 了，于是就把处理的结果，转交给了 webpack</li>
<li>webpack 把 style-loader 处理的结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。<br><img src="/tsukimiya.github.io/images/vue/loader%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="loader调用过程"></li>
</ol>
<h3 id="base64图片的优缺点"><a href="#base64图片的优缺点" class="headerlink" title="base64图片的优缺点"></a>base64图片的优缺点</h3><p>浏览器在拿到HTMl标签以后，需要再发送请求，拿到图片以后才能把图片渲染出来</p>
<p>但是使用用base64图片，在拿到img标签以后，就顺手的把图片对应的字符串也给请求下来了，可以防止发起一些不必要的网络请求</p>
<p>如果页面有许多小图标，就要发送很多次请求，对性能来讲非常不好，就可以把图片都转成base64格式的字符串</p>
<p>缺点：<br>图片转成base64，体积会增大一点点，所以大图片就不适合</p>
<p><strong>ES6 import导入图片得到的是一个base64字符串</strong>(可以打印看一下)<br>如 <code>import logo from &#39;./images/logo.png&#39;</code></p>
<h3 id="webpack处理样式的过程"><a href="#webpack处理样式的过程" class="headerlink" title="webpack处理样式的过程"></a>webpack处理样式的过程</h3><p>ES6在js文件导入样式<code>import &#39;./css/index.css&#39;</code><br>这种语法代表，只需要加载这个文件，把css样式给加载过来，不需要接收(接收的话，打印出来是undefined)</p>
<p>webpack加载和处理js文件，处理的结果会生成一个新的js文件(如bundle.js)，而且会在页面引用过去，在这个bundle.js里面，会包含我们import引入的样式，在这个bundle.js里面，css样式会被转成js的方式去运行</p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>我们如果要上线，应该拿到这些文件发给后端，让后端去部署上线<br>发布上线就是：<br>前端把项目生成一份最终的结果，有页面，配套的css js 图片等等<br>所有资源都在生成的文件夹里面，把所有内容打包发给后端<br>后端拿到结果去部署上线</p>
<p>现在我们要解决的问题是：页面和bundle.js放到内存里面了，需要把它生成到实际的物理磁盘上。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>在package.json文件的scripts节点下，新增build命令如下:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    “dev&quot; : &quot;webpack serve&quot;，//开发环境中，运行dev命令</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时，运行 build命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <code>--mode</code>是一个参数项，用来指定webpack的<strong>运行模式</strong>。production 代表生产环境，会对打包生成的文件进行<strong>代码压缩</strong>和<strong>性能优化</strong>。<br>    注意:通过<code>--mode</code>指定的参数项，会<strong>覆盖</strong>webpack.config.js 中的<code>--mode</code>选项。</p>
<p>这里的dev命令是webpack serve，就是我们装的插件，是把文件生成到内存中，可以监听文件的更改自动执行npm run dev<br>而这里build就是要执行webpack命令把文件生成到磁盘上，这里注意要改成<br>    <code>set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack --mode production</code></p>
<h3 id="优化图片和js文件存放路径"><a href="#优化图片和js文件存放路径" class="headerlink" title="优化图片和js文件存放路径"></a>优化图片和js文件存放路径</h3><ol>
<li>js文件<br>在webpack.js的output对象属性中，把filename前面加上个文件夹<br> <code>filename:&#39;js/bundle.js&#39;</code></li>
<li>图片<br>修改webpack.config.js 中的url-loader配置项，新增outputPath选项即可指定图片文件的输出路径: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jpg|png|gif$/</span> ,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">22228</span>,</span><br><span class="line">            <span class="comment">//明确指定把打包生成的图片文件，存储到dist目录下的 image 文件夹中</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者直接用?xx&#x3D;xx&amp;xx&#x3D;xx的方式在loader后面携带参数 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>, <span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&amp;outputPath=images&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置和使用clean-webpack-plugin插件自动删除dist目录"><a href="#配置和使用clean-webpack-plugin插件自动删除dist目录" class="headerlink" title="配置和使用clean-webpack-plugin插件自动删除dist目录"></a>配置和使用clean-webpack-plugin插件自动删除dist目录</h3><p><strong>webpack5已经默认封装(内置)了该插件，直接在配置文件里output设置属性clean:true即可</strong></p>
<hr>
<p>为了防止旧文件干扰我们的事件，在每次重新发布的时候会把生成的打包好的dist文件夹删掉。<br>为了在每次打包发布时自动清理掉dist目录中的旧文件，可以安装并配置dlean-webpack-plugin插件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1．安装清理dist目录的 webpack 插件</span></span><br><span class="line">npm install clean-webpack-plugin@<span class="number">3.0</span><span class="number">.0</span> -D</span><br><span class="line"><span class="comment">// 2．按需导入插件、得到插件的构造函数之后，创建插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanwebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanwebpackPlugin</span>()</span><br><span class="line"><span class="comment">// 3．把创建的 cleanPlugin 插件实例对象，挂载到plugins节点中</span></span><br><span class="line"><span class="attr">plugins</span>: [htmlPlugin,cleanPlugin],<span class="comment">//挂载插件 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检验是否是删除之后重新生产的方法</strong>：<br>可以在dist文件夹下新建如1.txt文件，重新打包，如果文件还在，说明是没有删除直接打包的，如果不再了，那就是删除之后重新打包。</li>
</ul>
<h3 id="企业级项目的打包发布"><a href="#企业级项目的打包发布" class="headerlink" title="企业级项目的打包发布"></a><font color="red">企业级项目的打包发布</font></h3><p>企业级的项目在进行打包发布时，远比刚才的方式要复杂的多，主要的发布流程如下:</p>
<ul>
<li>生成打包报告，根据报告分析具体的优化方案</li>
<li>Tree-Shaking</li>
<li>为第三方库启用CDN加载</li>
<li>配置组件的按需加载</li>
<li>开启路由懒加载</li>
<li>自定制首页内容</li>
</ul>
<h2 id="source-Map-–-开发阶段检错"><a href="#source-Map-–-开发阶段检错" class="headerlink" title="source Map – 开发阶段检错"></a>source Map – 开发阶段检错</h2><p>告诉你文件的报错位置，用于调试bug<br>开发阶段 npm run dev 检错的<br><strong>在发布项目的时候，处于安全性考虑，建议关闭SourceMap</strong>。防止一些人通过报错位置来拿到我们的源代码(通过修改页面代码来主动让页面某功能报错来拿到该功能位置的源码这样吗？)<br>新版本开发环境建议使用cheap-module-source-map？</p>
<ol>
<li>什么是 source Map<br> <strong>Source Map就是一个信息文件，里面储存着位置信息</strong>。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的<strong>转换前的位置</strong>。<br> 有了它，出错的时候，<strong>除错工具将直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</li>
</ol>
<p>即是：页面报错，控制台会显示错误以及错误文件及其报错位置，如果没有配置这个，它显示的就是打包压缩后的代码的位置</p>
<ol start="2">
<li><p>webpack <strong>开发环境下的</strong> Source Map<br> <strong>在开发环境下</strong>，webpack<strong>默认启用了</strong>Source Map功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。<br> 但是，开发环境下默认生成的Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</p>
</li>
<li><p>解决默认的Source Map的问题<br> 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="comment">// eval-source-map 仅限在&quot;开发模式&quot;下使用，不建议在&quot;生产模式&quot;下使用。</span></span><br><span class="line">    <span class="comment">//此选项生成的 Source Map 能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span></span><br><span class="line">    <span class="comment">// 在开发调试阶段，建议大家都把devtool的值设置为eval-source-map</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">//省略其它配置项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack <strong>生产环境下的</strong> Source Map<br>在生产环境下，如果省略了devtool选项，则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人</p>
</li>
<li><p><strong>只定位行数不暴露源码</strong> – 对调试和安全都比较友好<br>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以<strong>将devtool的值设置为nosources-source-map</strong>。<br>知道了行号，我们就可以定位到源码的行位置来解决bug</p>
</li>
<li><p>定位行数且暴露源码<br>在生产环境下，如果<strong>想在定位报错行数的同时，展示具体报错的源码</strong>。此时可以将devtool的值设置为source-map。<br>坚决不推荐。(但是这不是和eval-source-map一样吗？？)<br>这种方式会生成一个SourceMap(但是nosources-source-map也有，eval-soure-map应该也有吧)<br>可以看到在dist的js目录下，除了有bundle.js还有个bundle.js.map，这就是我们的SourceMap</p>
</li>
</ol>
<h3 id="Source-Map的最佳实践"><a href="#Source-Map的最佳实践" class="headerlink" title="Source Map的最佳实践"></a>Source Map的最佳实践</h3><ol>
<li>开发环境下:<ul>
<li>建议把devtool的值设置为<strong>eval-source-map</strong></li>
<li>好处: 可以精准定位到具体的错误行</li>
</ul>
</li>
<li>生产环境下:<ul>
<li>建议<strong>关闭Source Map</strong> 或 将devtool的值设置为<strong>nosources-source-map</strong></li>
<li>好处: 防止源码泄露，提高网站的安全性</li>
</ul>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="快速终止服务器"><a href="#快速终止服务器" class="headerlink" title="快速终止服务器"></a>快速终止服务器</h3><p><font color="red">两次 ctrl + c 可以直接结束 webpack serve，不需要再去输入y结束</font><br>Vue CLI也一样，因为它是内置了webpack</p>
<h3 id="webpack中-的原理和好处"><a href="#webpack中-的原理和好处" class="headerlink" title="webpack中 @ 的原理和好处"></a>webpack中 @ 的原理和好处</h3><p>这样一个场景：<br>src目录下 有一个info文件 js&#x2F;text&#x2F;info<br>而这个info文件要导入src目录下的msg.js文件<br>就需要这样导入: import msg from ‘..&#x2F;..&#x2F;msg’<br>如果info的文件层级再深一点，这个..&#x2F;会让人不知道翻了几层<br>所以<br><strong>建议大家都使用 @ 符号表示src源代码目录，从外往里查找，不要使用..&#x2F;从里往外查找</strong><br>import msg from ‘@&#x2F;msg.js’</p>
<p>在webpack里面，@不能直接用，需要先配置一下<br>在webpack.config.js中，module.exports中增加一个resolve属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 告诉webpack，程序员写的代码中，@符号表示src这一层目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在浏览器安装vue-devtools调试工具"><a href="#在浏览器安装vue-devtools调试工具" class="headerlink" title="在浏览器安装vue-devtools调试工具"></a>在浏览器安装vue-devtools调试工具</h3><p>edge扩展中直接搜，有一个vue.js-devtools<br><strong>在详情设置中，有个允许访问文件URL(文件网址)的设置，默认是关闭的状态，需要我们手动打开</strong></p>
<h2 id="实际开发中不需要自己配置webpack"><a href="#实际开发中不需要自己配置webpack" class="headerlink" title="实际开发中不需要自己配置webpack"></a><strong>实际开发中不需要自己配置webpack</strong></h2><ul>
<li>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</li>
<li>开箱即用，所有webpack配置项都是现成的!</li>
<li>我们只需要知道webpack 中的基本概念即可!</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Webpack</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 基本使用 &amp; 常用指令</title>
    <url>/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&amp;%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>使用Vue指令完成页面结构的渲染<br>使用Vue调试工具辅助Vue的开发</p>
</blockquote>
<blockquote>
<p><strong>掌握Vue的两个特性：数据驱动视图、双向数据绑定<br>    掌握Vue的底层原理 MVVM – model数据源、view视图&#x2F;页面结构、viewmodel vue实例<br>    掌握Vue六大类指令的使用</strong><br>    vue2指令新学到的东西：<br>    属性绑定指令中的：<a href="#obj">对象写法</a><br>    事件绑定指令中的：<a href="#param">参数问题</a>、<a href="#event">$event</a>、<a href="#modifier">事件修饰符</a>、<a href="#keyModifier">按键修饰符</a><br>    双向绑定指令中的：<a href="#v-model">v-model修饰符</a><br>    条件渲染指令中的：<a href="#if">v-if配套的v-else指令</a><br>    列表渲染指令中的：<a href="#key">key属性绑定</a></p>
</blockquote>
<blockquote>
<p>vscode插件推荐：Volar、Vue VSCode Snippets。 <a href="https://blog.csdn.net/weixin_40808668/article/details/134277604">简单说明</a>(CSDN)</p>
</blockquote>
<blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://v2.cn.vuejs.org/v2/guide/">Vue 2.x 官方文档</a>(已不再维护)<br>Vue是一套<strong>用于构建用户界面的前端框架</strong><br>构建用户界面：用vue往html页面填充数据<br>框架：一套现成的解决方案，程序员只能遵守框架的规范去编写业务功能</p>
<p>学习vue就是学习vue框架中规定的用法<br><strong>vue的指令、组件(是对UI结构的复用)、路由、Vuex、vue组件库</strong></p>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
<h3 id="vue的两个特性："><a href="#vue的两个特性：" class="headerlink" title="vue的两个特性："></a>vue的两个特性：</h3><ol>
<li><strong>数据驱动视图</strong><br> vue会监听数据的变化，自动重新渲染页面的结构<br> 注意：<span style="color:red;" >数据驱动视图是单向的数据绑定<span></li>
<li><strong>双向数据绑定</strong><br> 填写表单时，自动把内容同步到数据源中<blockquote>
<p>在网页中，form表单负责<font color='green'>采集数据</font>，Ajax负责<font color='green'>提交数据</font></p>
</blockquote>
</li>
</ol>
<h3 id="MVVM-–-vue的底层原理"><a href="#MVVM-–-vue的底层原理" class="headerlink" title="MVVM – vue的底层原理"></a>MVVM – vue的底层原理</h3><p><font color='red'>MVVM是 vue 实现数据驱动视图和双向数据绑定的核心原理。</font><br>MVVM 指的是 <strong>M</strong>odel(数据源)、<strong>V</strong>iew(视图) 和 <strong>V</strong>iew<strong>M</strong>odel(vue实例)，它把每个 HTML 页面都拆分成了这三个部分。</p>
<p>在MVVM概念中:<br><strong>Model</strong> 表示当前页面渲染时所依赖的<strong>数据源</strong>。<br><strong>View</strong> 表示当前页面所渲染的 DOM 结构。(<strong>页面结构，也即是视图</strong>)<br><strong>ViewModel</strong> 表示 <strong>vue 的实例</strong>，它是<strong>MVVM的核心</strong>。(也就是vue)<br><img src="/tsukimiya.github.io/images/vue/MVVM%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p>
<ul>
<li>MVVM的工作原理：<br>  ViewModel作为MVVM的核心，是它把当前页面的<font color="green">数据源</font>(Model)和<font color="green">页面的结构</font>(View)连接在了一起。<br>  <img src="/tsukimiya.github.io/images/vue/MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image"><br>  <strong>当数据源发生变化时</strong>，会被ViewModel监听到，VM会根据最新的数据源<strong>自动更新</strong>页面的结构<br>  <strong>当表单元素的值发生变化时</strong>，也会被VM监听到，VM会把变化过后最新的值<strong>自动同步</strong>到Model数据源中</li>
</ul>
<h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><p>当前，vue共有3个大版本，其中:<br>3.x版本的vue 于2020-09-19发布<br>2.x版本的vue 已于 2023 年 12 月 31 日停止维护<br>1.x版本的vue几乎被淘汰，不再建议学习与使用</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p>基本使用步骤</p>
<ol>
<li>导入VUE.js脚本文件<br> 可以借助 script 标签直接通过 CDN(提供 npm 包服务) 来使用 Vue：<br> <code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在页面声明一个将要被vue所控制的区域</li>
<li>创建vm实例对象(vue实例对象)</li>
</ol>
</li>
<li><p>基本代码与MVVM的对应关系<br> model：data指向的对象<br> view：el指向的选择器<br> ViewModel：new Vue()构造函数得到的实例对象</p>
</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。<br>指令是vue开发中最基础、最常用、最简单的知识点</p>
<p>vue的指令 <strong>按照不同用途</strong> 可以分为如下6大类：</p>
<ol>
<li><p>内容渲染指令：<code>v-text</code> 、<code>&#123;&#123;&#125;&#125;</code>  、 <code>v-html</code></p>
<blockquote>
<p>v-test 会覆盖默认文本内容，一般使用<code>&#123;&#123;&#125;&#125;</code>插值表达式<br> v-text和差值表达式只能渲染纯文本内容<br> v-html可以把带标签的字符串渲染成HTML内容</p>
</blockquote>
</li>
<li><p>属性绑定指令: <code>v-bind</code> &#x2F; <code>:xxx=</code> </p>
<blockquote>
<p>差值表达式只能用在元素的内容节点中，不能用在属性节点中<br> v-bind用法：<code>&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;</code><br> <strong>vue规定 <code>v-bind:</code> 指令可以简写为<code>:</code></strong></p>
</blockquote>
<blockquote>
<p>在vue提供的<strong>模版渲染语法中</strong>，除了支持绑定简单的数据值之外，还<font color="green">支持JS表达式的运算</font><br> 但是<font color="green">只能写简单的JS表达式，不能写if等复杂的JS语句</font>，如字符串拼接等：<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;number + <span class="number">1</span>&#125;&#125;、&#123;&#123;ok?<span class="string">&#x27;YES&#x27;</span>:<span class="string">&#x27;NO&#x27;</span>&#125;&#125;、&#123;&#123;msg.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reserve</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)&#125;&#125;<span class="comment">//反转字符串</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><font id="obj" color="red">v-bind的<strong>对象写法</strong></font><br> <code>&lt;xxx v-bind=&quot;&#123;x:100,y:200&#125;&quot;/&gt;</code> 等同于：<code>&lt;xxx :x=&quot;100&quot; :y=&quot;200&quot;/&gt;</code></li>
</ul>
</li>
<li><p>事件绑定指令：<code>v-on</code> &#x2F; <code>@</code></p>
<blockquote>
<p>语法如 <code>v-on:clock=&quot;add&quot;</code> 简写<code>@click=&quot;add&quot;</code><br> methods下的函数变量也支持简写：<code>add:function()&#123;&#125; --&gt; add()&#123;&#125;</code><br> 在处理函数中<strong>修改数据的值</strong>可以通过vm(接受vue实例的变量名)来修改：vm.count,但是不推荐，<strong>推荐用this</strong></p>
</blockquote>
<ul>
<li><p>绑定事件并传参</p>
<blockquote>
<p>在调用的地方传参 <code>@click=&quot;add(1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="param" color="red">参数问题</font></p>
<blockquote>
<ul>
<li>如果定义的函数变量是有参数的<br>1. <code>add(n)&#123;&#125; -- @click=&quot;add(1)&quot;</code> 正常传参 n&#x2F;&#x2F;1<br>2. <code>add(n)&#123;&#125; -- @click=&quot;add()&quot;</code> n&#x2F;&#x2F;undefined<br>3. <code>add(n)&#123;&#125; -- @click=&quot;add&quot;</code> n被认定为事件对象PointerEvent，通常我们会定义为e&#x2F;event</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果是多个参数，如<br>1. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1,2)&quot;</code> 正常传参 a&#x2F;&#x2F;1 b&#x2F;&#x2F;2<br>2. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1)&quot;</code> a&#x2F;&#x2F;1 b&#x2F;&#x2F;undefined<br>3. <code>add(a,b)&#123;&#125; -- @click=&quot;add()&quot;</code> a&#x2F;un b&#x2F;&#x2F;un<br>4. <code>add(a,b)&#123;&#125; -- @click=&quot;add&quot;</code> a&#x2F;&#x2F;事件对象PointerEvent ，b&#x2F;&#x2F;undefined</li>
</ul>
</blockquote>
</li>
<li><p><font id="event" color="red">事件对象$event</font>(不常用)</p>
<blockquote>
<p>vue提供了内置变量<code>$event</code>,它就是原生DOM的事件对象e<br>  在绑定事件的时候，如果不传参 <code>add(e)&#123;&#125; -- @click=&quot;add&quot;</code> , 我们会接受到一个事件对象e<br>  如果传参，<code>@click=&quot;add(1)&quot;</code>,我们就接收不到这个事件对象了<br>  <strong>我们既要传参，又要用到事件对象e</strong>，如想要从事件对象上拿到e.target(触发事件的事件源) ，这个时候就可以用<code>$event</code><br>  <strong><code>$event</code>使用：传<code>$event</code>作参数进去，拿形参接收</strong><br>  <code>add(n,e)&#123;&#125; --  @click=&quot;add(1,$event)&quot;</code><br>  或<code>add(e,n)&#123;&#125; --  @click=&quot;add($event,1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="modifier" color="red">事件修饰符</font></p>
<blockquote>
<p>在事件处理函数中，调用<code>event.preventDefault()</code>(阻止默认行为)或<code>event.stopPropagation()</code>(阻止冒泡)是非常常见的需求。<br>  因此，vue提供了<strong>事件修饰符</strong>的概念，辅助程序员更方便的<strong>对事件的触发进行控制</strong>。<br>  如 <code>@click.prevent=&quot;show&quot;</code>绑定了show事件，同时阻止了默认行为<br>  常见的5个事件修饰符如下：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>.prevent</strong></td>
<td><strong>阻止默认行为</strong>(例如：阻止a链接的跳转、表单的提交等)</td>
</tr>
<tr>
<td align="center"><strong>.stop</strong></td>
<td><strong>阻止事件冒泡</strong></td>
</tr>
<tr>
<td align="center">.capture</td>
<td>以 捕获模式 触发当前的 事件处理函数</td>
</tr>
<tr>
<td align="center">.once</td>
<td>绑定的事件只触发1次</td>
</tr>
<tr>
<td align="center">.self</td>
<td>只有在 event.target 是当前元素自身时 触发事件处理函数</td>
</tr>
</tbody></table>
<ul>
<li><font id="keyModifier" color="red">按键修饰符</font>(用的不是很多)<blockquote>
<p>在<strong>监听键盘事件</strong>时，经常需要<strong>判断详细的按键</strong>。<br>  此时，可以为键盘的相关事件添加<strong>按键修饰符</strong>，如：<br>  <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> – 只有在<code>key</code>是<code>Enter</code>时，调用<code>vm.submit()</code><br>  <code>&lt;input @keyup.esc=&quot;clearInput&quot;&gt;</code> – 只有在<code>key</code>是<code>Esc</code>时，调用<code>vm.clearInput()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>双向绑定指令 <code>v-model</code></p>
<blockquote>
<p>用来辅助程序员在<strong>不操作DOM</strong>的前提下，<strong>快速获取表单的数据</strong>。<br>     能够产生数据交互的只有表单元素，所以只有表单元素才能使用<code>v-model</code>,才有意义<br>     表单元素 input、textarea、select<br>     v-model内部会判断绑定元素的类型，根据元素类型来决定将绑定的值给哪个属性。如复选框checkbox就是给checked属性，如果是text框就是value属性</p>
</blockquote>
<ul>
<li><font id="v-model" color="red">v-model修饰符</font><blockquote>
<p>为了方便对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.number</td>
<td>自动将用户的输入值转为数值类型</td>
<td><code>&lt;input v-model.number=&quot;age&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.trim</td>
<td>自动过滤用户输入的首尾空白字符</td>
<td><code>&lt;input v-model.trim=&quot;msg&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.lazy</td>
<td>在”change”时而非”input”时更新</td>
<td><code>&lt;input v-model.lazy=&quot;msg&quot;/&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>lazy的作用是input事件(表单处于焦点时候)不更新，失去焦点触发change事件才更新</p>
</blockquote>
</li>
<li><p>条件渲染指令 <code>v-if</code>、<code>v-show</code></p>
<blockquote>
<p>辅助开发者<strong>按需控制DOM的显示与隐藏</strong><br> v-if动态的把元素DOM从页面添加和移除<br> v-show是通过css动态添加display：none样式来显示和隐藏<br> <strong>如果要频繁切换元素的显示状态，show的性能更好</strong><br> <strong>如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好</strong><br> 这个只是说给面试官听的，<font color="green">在实际开发中，绝大多数情况不用考虑性能问题，直接使用v-if就好了！</font><br> 因为在大多数情况下，这种性能差异是微不足道的，除非在处理大量组件或频繁切换时才会产生明显影响。</p>
</blockquote>
<ul>
<li><p><font color="green">页面的执行(一个v-if的好问题)</font></p>
<blockquote>
<p>Q：如果我们页面有一个<code>&lt;p v-if=&quot;flag&quot;&gt;&lt;/p&gt; -- flag=false</code>，因为页面是从上往下执行的，那么页面是先创建p标签再移除呢，还是一开始就不创建呢？<br>  A：<strong>当我们用了vue-cli以后，用到单文件组件(.vue文件)的时候，它是先编译，然后再去运行。</strong><br>  先把整个网页编译成js，然后完整的去执行。标签也是被当做js去运行的，去加载的，这个问题就不存在了<br>  在 Vue 中，会根据 <code>v-if</code> 指令来决定是否渲染 DOM 元素。当 <code>flag</code> 初始值为 <code>false</code> 时，<code>&lt;p&gt;</code> 标签不会被创建到 DOM 中，<strong>Vue 在编译阶段会将 <code>v-if</code> 条件为 <code>false</code> 的元素直接移除</strong>。<br>  具体的流程如下：<br>      1. Vue 开始解析模板，并执行编译步骤。<br>      2. 当解析到带有 <code>v-if</code> 指令的元素时，Vue 会根据条件的真假决定是否将该元素包含在虚拟 DOM 中。<br>      3. 如果 <code>flag</code> 的初始值为 <code>false</code>，则 Vue 不会将 <code>&lt;p&gt;</code> 标签添加到虚拟 DOM 中。<br>      4. 最终，Vue 将虚拟 DOM 渲染为真实的 DOM，此时 <code>&lt;p&gt;</code> 标签不会出现在页面上。<br>  因此，页面上不会先创建 <code>&lt;p&gt;</code> 标签再移除，而是在一开始就不会创建 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
</li>
<li><p><font id="if" color="green">v-if配套的指令 – <code>v-else</code></font></p>
<blockquote>
<p>多个元素按需展示<br>  注意：v-else指令<strong>必须配合v-if指令一起使用</strong>，否则不会被识别：<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表渲染指令 <code>v-for</code> 和 <code>:key</code> <font color="red">重要</font></p>
<blockquote>
<p>辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。<br>     v-for指令需要使用<code>item in items</code>形式的特殊语法<br>     v-for支持一个可选的第二个参数，即当前项的索引<code>(item,index) in items</code><br>     注意：v-for指令中的 item项 和 index索引 都是形参，可以根据需要命名</p>
</blockquote>
<ul>
<li><font id="key" color="red">强调v-for循环中key值的绑定</font><blockquote>
<p>官方推荐在用v-for的时候一定要绑定一个key属性，既提升性能、又防止列表状态紊乱。而且尽量把id作为key的值(id唯一)<br>  <font color="#000">官方对key的值类型有要求，只能是字符串或数字类型，并且key的值必须唯一，不能重复(相当于id)</font><br>  也不能以index为值，如果key以索引为值，会数据紊乱，<strong>key必须唯一且稳定，不唯一就会终端报错，唯一又不稳定就会数据紊乱。</strong><br>  <code>&lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</code><br>  如果使用v-for<strong>只是为了循环渲染出内容</strong>，<code>:key</code><strong>可以绑定为index索引</strong>，因为这个时候并没有实际的作用，只是<strong>为了不让报错</strong>而已<br>  <font color="green">不懂key到底有什么用的可以去了解下diff算法和虚拟dom？</font><br>  <font color="purple">key是元素的标识，具有唯一性，diff算法同层比较会根据key判断，dom是在原基础上更新，还是删除再重新创建，若key不唯一，会造成dom额外的删除再创建，消耗性能</font></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="lable复选框的for属性"><a href="#lable复选框的for属性" class="headerlink" title="lable复选框的for属性"></a>lable复选框的for属性</h3><p>下面这个示例中,如果要选中男，应该点击对应的复选框，点击男不行，这样用户的体验很不好，可操作区域非常窄。<br>应该把它的可操作区域给放大，点击复选框还是男都可以选中，此时就用到了for属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>for指向id，希望点这个lable让谁被选中，就for那个元素的id</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="a元素的JavaScript-伪协议"><a href="#a元素的JavaScript-伪协议" class="headerlink" title="a元素的JavaScript 伪协议"></a>a元素的JavaScript 伪协议</h3><p><code>&lt;a href=&quot;javascript:;&quot; @click=&quot;remove&quot;&gt;删除&lt;/a&gt;</code><br>这段代码是一个 HTML 锚点元素 <code>&lt;a&gt;</code> 的写法，其中<code>javascript:;</code> 是一个 JavaScript 伪协议，用于在点击链接时执行 JavaScript 代码或阻止默认行为。</p>
<p>通常情况下，当用户点击这个链接时，浏览器会执行 <code>JavaScript:;</code> 这里的 JavaScript 代码是空的，所以实际上不会发生任何操作。<br>这种写法通常用于创建一个占位符链接，或者作为一个“空链接”，<strong>用于在不跳转页面的情况下执行一些 JavaScript 操作，比如触发事件或者执行某些函数</strong>。</p>
<h3 id="JS-filter-方法-–-Array-prototype-filter"><a href="#JS-filter-方法-–-Array-prototype-filter" class="headerlink" title="JS - filter() 方法 – Array.prototype.filter()"></a>JS - filter() 方法 – Array.prototype.filter()</h3><p><code>filter()</code> 方法是 JavaScript 中数组的一个内置方法，用于过滤数组中的元素，并返回一个符合条件的新数组。<br>如：<br><code>let arr = [1,2,3].filter(item=&gt;item&gt;1) //[1,2]</code><br><code>let arr = [&#123;id:1,name:&quot;zs&quot;&#125;,&#123;id:2..&#125;].filter(item =&gt; item.id !=2) // [&#123;id:1,name:&quot;zs&quot;&#125;]</code></p>
<p>但是，除了数组外，<code>filter()</code> 方法还可以应用于类数组对象和可迭代对象。例如，字符串也可以通过 <code>filter()</code> 方法进行过滤操作。</p>
<p>下面是一个例子，演示如何在字符串中使用 <code>filter()</code> 方法来过滤出特定的字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filteredStr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(str, <span class="function"><span class="params">char</span> =&gt;</span> char !== <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredStr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// 输出：Heo Word!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先使用 <code>Array.prototype.filter.call()</code> 来调用 <code>filter()</code> 方法，并将字符串 <code>str</code> 当作第一个参数传入。然后，我们定义了一个过滤条件，即过滤掉所有的 ‘l’ 字符。最后，我们将过滤后的字符数组通过 <code>join()</code> 方法连接成一个新的字符串，并输出结果。</p>
<p>总之，虽然 <code>filter()</code> 方法通常用于数组，但通过一些技巧，我们也可以在其他类型的对象上使用它。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件与生命周期</title>
    <url>/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>掌握.vue单文件组件的基本用法<br>组件的props(自定义属性)：数组写法、对象写法<br>解决多个组件间的样式冲突 – scoped<br><a href="#deep"><strong>&#x2F;deep&#x2F;样式穿透</strong></a>应用场景：<strong>修改第三方组件库组件的默认样式</strong></p>
</blockquote>
<blockquote>
<p>掌握组件生命周期的执行顺序和应用场景：创建阶段、运行阶段、销毁阶段<br>vue 中常用的生命周期函数&#x2F;生命周期钩子：<strong>created、mounted</strong></p>
</blockquote>
<blockquote>
<p>能够掌握组件通讯的三种方式：父-&gt; 子（自定义属性）、子-&gt; 父（自定义事件）、兄弟组件（EventBus）</p>
</blockquote>
<p>[toc]</p>
<h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><ol>
<li><p>什么是组件化开发<br><strong>组件化开发</strong>指的是∶根据<strong>封装</strong>的思想，<strong>把页面上可重用的UI结构封装为组件</strong>，从而方便项目的开发和维护。</p>
</li>
<li><p>vue中的组件化开发<br>vue是一个<strong>支持组件化开发</strong>的前端框架。<br>vue中规定：<strong>组件的后缀名是.vue</strong><br>vue中，root就是根，而这个根就是el所控制的那个区域。在main.js文件里，vue实例中通过 render 函数指定组件渲染到HTML页面中，替换了el区域。即：<strong>render函数中，渲染的是哪个.vue组件，那么这个组件就叫做“根组件”</strong></p>
</li>
<li><p><font color='green'>vue组件的三个组成部分</font></p>
<ul>
<li><font color='green'>template -&gt; 组件的模板结构</font></li>
<li><font color='green'>script -&gt; 组件的JavaScript行为</font></li>
<li><font color='green'>style -&gt; 组件的样式</font></li>
</ul>
<p> 注意：<font color='red'>每个组件中必须包含template模板结构，而script行为和style样式是可选的组成部分</font></p>
</li>
</ol>
<p>简单示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 组件的模版结构中，应该包含一个根元素，这个最外层的div不能有兄弟元素 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span> &gt;</span>这是用户自定义的Test.vue -- &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">// 默认导出，固定写法！</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 注意：.vue组件中的data不能像之前一样，不能指向对象,必须是一个函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">// data数据源</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span>&#123;<span class="comment">// 这个return出去的对象中，可以定义数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">// 在组件中，this就表示当前组件的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">username</span> = <span class="string">&#x27;aaa&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.text-box</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">background-color</span>: pink;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">h3</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>组件之间的<font color='red'>父子关系</font><br>组件之间的父子关系、兄弟关系，<strong>是在使用时候才会产生的</strong><br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB.png" alt="image"></li>
</ol>
<h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的<strong>三个步骤</strong></h3><p><img src="/tsukimiya.github.io/images/vue/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt="image"><br><font color="green">注意：在components节点中，注册组件是一个对象的写法，前面是定义的名称，后面是要注册的组件。在对象里面，键名和值如果一样，可以省略值只写键名。如’Left’:Left可以简写成Left</font></p>
<ul>
<li><p>通过components注册的是<font color='red'>私有子组件</font><br>例如：<br>在组件A的components节点下，注册了组件F。<br>则组件F只能用在组件A中;不能被用在组件C中。</p>
</li>
<li><p>注册<font color='red'>全局组件</font><br>如果某个组件，使用非常频繁，好多组件中都要用到它，那么每次都要导入注册并使用，就很麻烦。所以可以注册全局组件</p>
<p>  <font color='green'>在vue项目的 main.js入口文件中，通过Vue.component()方法，可以注册全局组件。</font>示例代码如下:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Count</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Count.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：字符串格式，表示组件的“注册名称”</span></span><br><span class="line"><span class="comment">// 参数2：需要被全局注册的那个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyCount&#x27;</span>,<span class="title class_">Count</span>)</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：在自己的组件中，不能使用自己！</strong></p>
</li>
</ul>
<h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的<strong>自定义属性</strong>，<strong>在封装通用组件的时候</strong>，合理地使用 props 可以极大的<font color='red' size='5'>提高组件的复用性！</font><br>它的语法格式如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性,允许使用者指定初始值</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其它自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font fcolor='green'>props中的数据，可以直接在模板结构中被使用</font>。使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;init&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left.vue组件中，使用注册了的Count组件</span></span><br><span class="line"><span class="comment">// 指定初始值，但是这里传入的是一个字符串，并不是一个真正的数值</span></span><br><span class="line">&lt;<span class="title class_">Count</span> init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color='red'>结合v-bind使用自定义属性</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 这样就传入的是数值6了</span><br><span class="line"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color='green'>官网文档-&gt;即便 <code>9</code> 是静态的，我们仍然需要 <code>v-bind</code> 来告诉 Vue，这是一个 JavaScript 表达式而不是一个字符串</font></p>
</li>
<li><p><font color='red'>props对子组件是只读的 (父组件-&gt;子组件 单向数据传递)</font><br>Vue规定:组件中封装的自定义属性是只读的，程序员不能直接修改props的值。否则会直接报错。<br>注意：props是对定义该属性的子组件只读，<font color='red'>在父组件中，你可以通过v-bind绑定props的值，并且这个值是可以更改的。</font><strong>当父组件中的值改变时，Vue会自动将新值传递给子组件，并且子组件会根据新的值重新渲染</strong>。这种方式实际上是通过props属性进行了<strong>单向数据流</strong>，确保数据流动的可预测性和可维护性。<br><font color='red'>如果子组件需要修改传递过来的值，通常应该通过触发事件并将修改传递给父组件来实现。</font><br><font color='green'>props可以被作为初始值使用的，把它传给data的属性进行初始赋值使用：</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count+=1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>, &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Count</span> :init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="props的default默认值"><a href="#props的default默认值" class="headerlink" title="props的default默认值"></a>props的default默认值</h3><p>在声明自定义属性时，可以通过default来定义属性的默认值。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="comment">// 自定义属性：&#123; /* 配置选项 */ &#125;</span></span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="comment">// 如果外界使用Count组件，没有传递默认值，则默认值生效</span></span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props的-type-值类型"><a href="#props的-type-值类型" class="headerlink" title="props的 type 值类型"></a>props的 type 值类型</h3><p>在声明自定义属性时，<font color='red'>可以通过type来定义属性的值类型。</font>示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="comment">// 用type属性定义属性的值类型</span></span><br><span class="line">            <span class="comment">// init的值类型必须是Number数字</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>还可以通过数组形式，为当前属性定义多个可能的类型：<code>type: [Number, String]</code></font><br><font color='green'>如果是带有默认值的对象类型，对象或数组默认值必须从一个工厂函数获取：</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封面的信息对象</span></span><br><span class="line"><span class="attr">cover</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="comment">// 默认值是一个空对象</span></span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="props的-required-必填项"><a href="#props的-required-必填项" class="headerlink" title="props的 required 必填项"></a>props的 required 必填项</h3><p>加上required必填项之后，哪怕有默认值，不传也会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">require</span>: <span class="literal">true</span>,<span class="comment">//必填项校验</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props属性的命名规定"><a href="#props属性的命名规定" class="headerlink" title="props属性的命名规定"></a>props属性的命名规定</h3><p>Vue里面有一个规定，如果<strong>某一个属性</strong>在定义的时候，里面<strong>包含了一个大写的字符</strong>（是一个<strong>小驼峰</strong>），在进行<strong>绑定的时候</strong>，可以直接写成原名字，不过<strong>建议改成连字符格式</strong>，因为这样看起来会<strong>更舒服</strong>一些<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="attr">props</span>:[cmtCount]</span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;xxx :cmtCount=<span class="string">&quot;...&quot;</span>&gt;&lt;/xxx&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">xxx</span> <span class="attr">:cmt-count</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span> <span class="comment">// 建议</span></span><br></pre></td></tr></table></figure>


<h3 id="组件间的样式冲突-scoped"><a href="#组件间的样式冲突-scoped" class="headerlink" title="组件间的样式冲突 - scoped"></a>组件间的样式冲突 - scoped</h3><p>默认情况下，<strong>写在.vue组件中的样式会全局生效</strong>，因此很容易造成<strong>多个组件之间的样式冲突问题</strong>。<br>导致组件之间样式冲突的<strong>根本原因</strong>是:<br>    <font color='purple'>1. 单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</font><br>    <font color='purple'>2. 每个组件中的样式，都会影响整个index.html页面中的DOM元素</font></p>
<p>注意：单页面应用程序中，HTML页面是只有一个的，我们的所有组件都是在这个HTML中生效的</p>
<ul>
<li><p>解决方案 – <font color='red'>核心原理：css属性选择器</font><br>给当前页面标签都加一个固定的自定义属性，不同的组件之间的自定义属性不一样</p>
</li>
<li><p>vue简化：<strong>scoped属性</strong><br>只要给当前组件的style加上scoped的属性，vue底层在生成组件的时候，会自动给每个标签自动生成一个data-v-xxx</p>
</li>
</ul>
<h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="&#x2F;deep&#x2F;样式穿透"></a><font id='deep' color='red'>&#x2F;deep&#x2F;样式穿透</font></h4><p><font color='#00a86b'>作用：在父组件中改造子组件里的样式</font><br><font color='red'>应用场景：当使用第三方组件库的时候，如果有修改组件默认样式的需求，需要用到&#x2F;deep&#x2F;</font></p>
<ul>
<li><p>scoped有一个缺陷，场景：<br>Left 和 Right 都注册使用了 Count组件<br>Left加了scoped属性，而Right没加<br>如果想在Left中的style里修改Count里面的样式，会发现不起作用，而如果在Right中修改，会发现Left和Right里面的Count组件样式都变了。</p>
</li>
<li><p>原因：<br>在Left中修改，比如h5{..},因为加了scoped，所以会变成h5[data-v-xx]{..}，而count中的标签并没有data-v-xx属性，所以不会生效。<br>而在没有scoped属性的Right中修改，则产生的就是样式冲突</p>
</li>
<li><p>解决方案：&#x2F;deep&#x2F;样式穿透<br>&#x2F;deep&#x2F; h5{ … }<br>在选择器前面加个前缀+空格，在浏览器可以查看到，这个h5标签被加上了一个[data-v-xx] 的前缀<br><font color='red'>加上<code>/deep/</code>之后就不再是 <code>类名[data-v-xxx]</code> 的 选择特定属性的选择器 了，而是变成了 <code>[data-v-xxx] 类名</code> 的 后代选择器 。</font></p>
</li>
</ul>
<h2 id="Vue运行原理"><a href="#Vue运行原理" class="headerlink" title="Vue运行原理"></a><strong>Vue运行原理</strong></h2><p>在把app渲染到页面的过程中，不是把页面的模板结构直接丢到页面上，而是有个编译的过程。<br>浏览器能够直接解析HTML页面，但是不识别vue页面。<br>在<code>package.json</code>里面，<code>devDependencies</code>里面有个<code>vue-template-complier</code>包，就是vue模板编译器，作用就是把.vue文件编译成js交给浏览器解析运行。<br>在.vue中写的任何代码，要渲染到浏览器中，都依赖于这个包的解析与转换。</p>
<p>我们上面在页面上渲染了2次Count.vue组件，我们在页面上看到的两个Count组件，就是两个组件的实例。<br>实例，就是相当于new一个构造函数得到一个实例。我们编写的Count.vue，可以理解为它就是一个构造函数，new这个构造函数就会得到一个Count实例。<br>我们没有直接new，而是通过标签形式去用这个组件，这个用的过程可以理解为一个new的过程<br>所以说，<strong>这个组件，在定义的时候，它只是一个模板结构，当用标签的形式去使用的时候，才是在创建一个它的实例。</strong><br>如果在components下声明一个组件，不去用它不会创建组件实例。</p>
<blockquote>
<p><font color='red'>整个项目如何跑起来的：</font><br><font color='#00a86b'>webpack从main.js(入口文件)开始打包，发现main里面用到了app，于是把app创建一个实例出来。然后app里面又用到了Left和Right，然后这两个里面又用到了Count，就这样一直通过一个树的形式，把整个树都解析转换，最后编译成纯js代码。然后把js文件放到首页里面去，浏览器就会解析和执行这里面的代码，把组件都给渲染到页面上</font></p>
</blockquote>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol>
<li><p>生命周期 &amp; 生命周期函数<br><font color='red'>生命周期</font>(Life Cycle)是指一个组件从<font color='red'>创建-&gt;运行-&gt;销毁</font>的整个阶段，<font color='red'>强调的是一个时间段</font>。</p>
<p> <font color='red'>生命周期函数</font>:是由vue框架提供的<font color='red'>内置函数</font>，会伴随着组件的生命周期，<font color='red'>自动按次序执行</font>。<br> 注意:<font color='#00a86b'>生命周期</font>强调的是<font color='#00a86b'>时间段</font>，<font color='#00a86b'>生命周期函数</font>强调的是<font color='#00a86b'>时间点</font>。</p>
</li>
<li><p>组件生命周期函数(<strong>生命周期钩子</strong>)的分类<br>在生命周期里面，它会按顺序依次执行这些函数。<br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="img"></p>
</li>
<li><p>生命周期图示<br>可以官方给出的<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">“生命周期图示”</a>，<a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=106">进一步理解组件生命周期执行过程</a>。<br><a href="/tsukimiya.github.io/custom/pages/lifecycle.html" target="_blank"><font color='red'>中文详解图示</font></a></p>
</li>
</ol>
<ul>
<li><p><font color='green'>执行次数</font><br>创建阶段：1次<br>运行阶段：0-N次<br>销毁阶段：1次</p>
</li>
<li><p><font color='red'>最重要的生命周期钩子</font></p>
<ol>
<li><font color='red'>created</font><br> data、props、methods都是可用状态<br> 常用它发起ajax请求来拿数据，转存到data中，供template模板渲染时候使用。</li>
<li><font color='red'>mounted</font><br> 第一次把DOM元素结构渲染好，最早去操作DOM</li>
<li><font color='red'>updated</font><br> 可以操作最新的更新过后的DOM</li>
</ol>
<p>  其他的很少会用到，记不住也没关系</p>
</li>
</ul>
<h2 id="组件之间的通讯-数据共享"><a href="#组件之间的通讯-数据共享" class="headerlink" title="组件之间的通讯(数据共享)"></a>组件之间的通讯(数据共享)</h2><ol>
<li><p>组件之间的关系<br>最常见的：兄弟关系、父子关系<br>离的比较远的，也可以认为是一种变态的兄弟关系</p>
</li>
<li><p><strong>父向子传值</strong> – <strong>自定义属性</strong><br><font color='red'>再次注意: props是只读的！</font><br><img src="/tsukimiya.github.io/images/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.png" alt="image"></p>
</li>
<li><p><strong>子向父传值</strong> – <strong>自定义事件</strong><br>第一步是绑定了一个事件，这是个处理函数。<font color='red'><code>$emit</code>就代表触发这个事件</font>，谁触发这个事件，谁传一个值过来。<br><font color='#00a86b'>子向父传值：在子组件调用$emit，父组件<font color='red'>在子组件标签上</font>用@绑定(监听)这个自定义事件</font><br><font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。<br><img src="/tsukimiya.github.io/images/vue/%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<blockquote>
<p>vue在内部要想触发click事件，它也是用this或vm<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">method</span>:&#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">e</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">vm.$emit(<span class="string">&#x27;click&#x27;</span>,&#123;<span class="comment">//事件对象e</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">clientX</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">clientY</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">target</span>:dom元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p><strong>兄弟组件之间的数据共享</strong> – <strong>EventBus</strong><br>在<font color='red'>vue2.x</font>中，兄弟组件之间数据共享的方案是<font color='red'>EventBus</font>。</p>
<ul>
<li>EventBus使用步骤</li>
</ul>
<ol>
<li>创建<code>eventBus.js</code>模块，并向外共享一个<strong>Vue的实例对象</strong></li>
<li>在数据<strong>发送方</strong>，调用<code>bus.$emit(&#39;事件名称&#39;,要发送的数据)</code>方法<strong>触发自定义事件</strong></li>
<li>在数据<strong>接收方</strong>，调用<code>bus.$on(&#39;事件名称&#39;,事件处理函数)</code>方法<strong>注册一个自定义事件</strong><br> 数据在事件处理函数的形参中拿到。</li>
</ol>
<p> <font color='#00a86b'>依旧是发送方触发事件，发送数据，接收方绑定事件监听，接受数据。</font><br> 这里的<code>$on</code>就相当于jQuery的on绑定事件<br> <strong>为什么这里要用到一个共享的实例EventBus</strong> ？因为<font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。</p>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/vue/%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<p>注意：虽然可以使用EventBus来在父子组件之间传值，但是这不是Vue官方推荐的做法。<strong>props和自定义事件更适合处理父子组件之间的通信，因为它们更直观和易于理解</strong>。 Event Bus 通常更适用于非父子关系的组件之间的通信，例如兄弟组件之间。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="vscode插件-Path-Autocomplete-路径提示"><a href="#vscode插件-Path-Autocomplete-路径提示" class="headerlink" title="vscode插件 Path Autocomplete - @路径提示"></a>vscode插件 Path Autocomplete - @路径提示</h3><p>下载插件之后，要在自己配置项里面添加如下配置,添加在头部就行<br>设置 – setting.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入文件时是否携带文件的扩展名</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 配置 @ 的路径提示</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.pathMappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><font color="red">注意：只有vscode打开的文件夹根目录是项目根目录时才起作用！！</font></p>
<blockquote>
<p>总觉得这个功能vscode也集成进去了？一开始没装的时候，好像就触发了，也懒得验证了hh</p>
</blockquote>
<h3 id="Auto-Close-Tag插件"><a href="#Auto-Close-Tag插件" class="headerlink" title="Auto Close Tag插件"></a>Auto Close Tag插件</h3><p>输入<code>&lt;xx&gt;</code>标签前半部分，会自动补全后半部分<br>不过新版vscode好像已经集成了这个功能，没有安装也是这样，装了没啥变化</p>
<h3 id="方法简写形式"><a href="#方法简写形式" class="headerlink" title="方法简写形式"></a>方法简写形式</h3><p><strong>如果方法只有一行，可以简写到行内</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count += 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>先指令，后绑定，最后绑事件<br>这是一个子组件的绑定示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Goods</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    :state=<span class="string">&quot;item.goods_state&quot;</span></span><br><span class="line">    @state_change=<span class="string">&quot;getNewState&quot;</span></span><br><span class="line">&gt;&lt;/<span class="title class_">Goods</span>&gt;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>生命周期</tag>
        <tag>组件</tag>
        <tag>Vue2</tag>
        <tag>组件的porps</tag>
        <tag>组件通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 过滤器、侦听器、计算属性、axios &amp; vue-cli</title>
    <url>/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&amp;vue-cli/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>在实际开发中合理运用过滤器、侦听器、计算属性解决问题<br>使用axios发起Ajax请求<br>使用vue-cli工具生成工程化的Vue项目</p>
</blockquote>
<p>[toc]</p>
<h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><blockquote>
<p>2020年9月 vue3发布。增加了很多新功能，但是也删掉了一些功能。 比如删掉了vue2中的过滤器filter功能。<br>与此同时，官方建议： <strong>用方法调用或计算属性替换过滤器</strong>。<br>filter过滤器能加工数据，computed计算属性和methods方法也都可以加工数据，这样的话，就功能重复了…(于是filter被开除了XDD)</p>
</blockquote>
<p>vue3已经把过滤器删掉了，只能在vue2中使用，会基础语法就行了。</p>
<ul>
<li><font color="green">过滤器要点</font><ol>
<li>必须被定义到 <code>filters节点</code> 之下，本质是一个函数</li>
<li>强调：过滤器中一定要有一个返回值</li>
<li>过滤器函数中的 形参<code>val</code>(随意命名)，永远都是管道符前面的那个值。(多个形参，则第一个外都是undefined)</li>
<li>过滤器函数 由 管道符 <code>|</code> 调用</li>
<li>过滤器只能在 <code>差值表达式</code> 或 <code>属性绑定指令v-bind</code> 中调用</li>
<li>最终得到的结果是过滤器的返回值</li>
</ol>
</li>
</ul>
<p><strong>过滤器常用于文本的格式化</strong>,应该被添加在JavaScript表达式的尾部，由“<strong>管道符</strong>”进行调用。示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在花括号中通过管道符调用capitalize过滤器，对message的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中通过管道符调用formatId过滤器，对rawId的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="私有过滤器-和-全局过滤器"><a href="#私有过滤器-和-全局过滤器" class="headerlink" title="私有过滤器 和 全局过滤器"></a>私有过滤器 和 全局过滤器</h3><p><strong>在 <code>filters节点</code> 下定义的过滤器</strong>，称为“<strong>私有过滤器</strong>”，因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器，则可以按照如下的格式<strong>定义全局过滤器</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器–独立于每个vm实例之外 </span></span><br><span class="line"><span class="comment">// Vue.filter()方法接收两个参数:</span></span><br><span class="line"><span class="comment">// 第1个参数，是全局过滤器的&quot;名字”</span></span><br><span class="line"><span class="comment">// 第2个参数，是全局过滤器的&quot;处理函数&quot;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>( <span class="string">&#x27;capitalize&#x27;</span>, <span class="function">(<span class="params">str</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;~~&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果想要定义多个全局过滤器就再写一个</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capi2&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&#x27;--全局2&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">注意：如果私有过滤器和全局过滤器名字一致，此时按就近原则</font></p>
<h3 id="其他用法-–-连续调用、传参"><a href="#其他用法-–-连续调用、传参" class="headerlink" title="其他用法 – 连续调用、传参"></a>其他用法 – 连续调用、传参</h3><ol>
<li><p>连续调用多个过滤器 – 串联地调用<br>如：<code>&#123;&#123;message | filterA | filterB&#125;&#125;</code></p>
</li>
<li><p>过滤器传参</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | filterA(arg1,arg2)&#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;filterA&#x27;</span>,<span class="function">(<span class="params">msg,arg1,arg2</span>)=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器的兼容性<br>仅在vue 2.x 和 1.x中受支持<br>3.x建议使用 <strong>计算属性</strong> 或 <strong>方法</strong> 代替<br>具体的迁移指南参考官方文档给出的<a href="https://v3.vuejs.org/guide/migration/filters.html#migration-strategy">说明</a></p>
</li>
</ol>
<h2 id="Watch侦听器"><a href="#Watch侦听器" class="headerlink" title="Watch侦听器"></a>Watch侦听器</h2><p>Watch侦听器 <strong>监视数据的变化，做出特定操作</strong>，变量名与监听的值对应。语法格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">// 监视username变化</span></span><br><span class="line">        <span class="comment">// newVal - 变化后的新值，oldVal - 旧值</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">应用场景如：侦听用户输入的用户名，每次变化就去查找是否被占用</font></p>
<h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><ol>
<li>方法格式的侦听器<ul>
<li>缺点1: 无法在刚进入页面的时候，自动触发！！</li>
<li>缺点2: 如果侦听的是一个对象，对象中的属性发生了变化，不会触发侦听器！！</li>
</ul>
</li>
<li><strong>对象格式的侦听器</strong><ul>
<li>好处1: 可以通过<strong>immediate选项</strong>，让侦听器自动触发！！</li>
<li>好处2：可以通过<strong>deep选项</strong>，让侦听器深度监听对象中每个属性的变化！！</li>
</ul>
</li>
</ol>
<ul>
<li><font color="green">推荐：为了写起来方便，建议定义成方法格式，如果确实需要，再改成对象格式。</font></li>
</ul>
<h3 id="immediate选项"><a href="#immediate选项" class="headerlink" title="immediate选项"></a>immediate选项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// true表示一进入页面就触发，false是默认值，不写这个参数也是false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦听-–-deep选项"><a href="#深度侦听-–-deep选项" class="headerlink" title="深度侦听 – deep选项"></a>深度侦听 – deep选项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125; &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">info</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 对象里任意属性变化了，都会触发侦听器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要侦听的是对象的子属性的变化，则必须包裹一层单引号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>(newVal)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ol>
<li>什么是计算属性<br>计算属性指的是通过一系列运算之后，最终得到一个属性值。<br>这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</li>
<li>应用场景：<font color='red'>实现代码复用</font></li>
</ol>
<ul>
<li>计算属性的使用<ol>
<li>计算属性要定义到computed节点下，定义成方法格式</li>
<li>虽然声明的方法格式，但是要当做普通的属性来用<blockquote>
<p>打印出vue实例，可以发现定义的计算属性是被挂到属性上面的，和data节点上的属性一样</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>示例代码如下︰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">r</span>:<span class="number">0</span>,<span class="attr">g</span>:<span class="number">0</span>,<span class="attr">b</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 计算属性要定义到computed节点下，定义成方法格式</span></span><br><span class="line">        <span class="title function_">rgb</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rgb</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h2><blockquote>
<p>axios是一个<strong>专注于网络请求</strong>的库！它只负责发请求和拿数据<br>    中文官网地址：<a href="http://www.axios-js.com/">http://www.axios-js.com/</a></p>
</blockquote>
<ul>
<li><p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// url中的查询参数，get请求体传参，可选</span></span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用axios得到的返回值是一个 Promise 对象<br>axios在请求到数据之后，在真正的数据之外，套了一层壳,result得到的就是套完壳之后的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123; 真实的数据 &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">status</span>: xxx,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><font color='red'>结合async和await调用axios</font></strong><br>这个<code>.then</code>用起来有点麻烦，我们可以使用await来进行简化<br><font color='green'>如果调用某个方法的返回值是 Promise 实例，则前面可以添加await！（这样得到的就直接是result）</font><br><font color='red'>await 只能用在被 async 修饰 的方法中</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用解构赋值来获取data</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于axios-get和axios-post发起请求"><a href="#基于axios-get和axios-post发起请求" class="headerlink" title="基于axios.get和axios.post发起请求"></a>基于axios.get和axios.post发起请求</h3><ol>
<li>axois.get<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//GET参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure></li>
<li>axios.post<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意await要在async修饰的函数中使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">unit</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">    <span class="attr">contact</span>: <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">    <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">    <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-cli的安装和使用"><a href="#vue-cli的安装和使用" class="headerlink" title="vue-cli的安装和使用"></a>vue-cli的安装和使用</h2><p>中文官网：<a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<ol>
<li><p>什么是单页面应用程序？<br><strong>单页面应用程序</strong>（英文名: Single Page Application）简称SPA，顾名思义，<strong>指的是一个Web 网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p>
</li>
<li><p>什么是vue-cli<br><strong>vue-cli是Vue.js开发的标准工具</strong>。它简化了程序员基于webpack创建工程化的Vue项目的过程。</p>
</li>
<li><p>安装<br>vue-cli是npm上的一个全局包，使用<code>npm i</code>命令，即可方便的把它安装到自己电脑上：<code>npm i -g @vue/cli</code></p>
<ul>
<li><code>vue -V</code>查看安装的版本号</li>
</ul>
</li>
<li><p>使用<br>基于vue-cli快速生成工程化的Vue项目：<code>vue create 项目名称</code>(建议名称用不带空格的英文)<br> 在想要创建项目的文件夹执行此命令，即会生成项目文件夹，命名即为 项目名称</p>
<ul>
<li>选择预设(用方向键)<br>  <strong>初学者建议选择最后一项 – 手动选择要安装哪些功能</strong><br>  按空格选中要安装的预设<br>  一开始建议选择：<br>  Choose Vue version(新版没有这个)、Babel、CSS Pre-processors,其他的不要选<br>  下面接着选择vue版本为2.x，css预处理器为less</li>
</ul>
</li>
<li><p>vue项目中src目录的构成：</p>
<ol>
<li>assets 文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源</li>
<li>components 文件夹：程序员封装的、可复用的组件，都要放到components目录下。<br> 里面有一个默认组件HelloWorld.vue，给它删除</li>
<li>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</li>
<li>app.Vue 是项目的根组件。我们创建项目之后，看到的页面就是app.Vue，如果想重新换一个页面出来，只需要把它给清空掉。里面的template是一个模版结构。</li>
</ol>
</li>
<li><p>vue项目的运行流程<br> 在工程化的项目中，vue要做的事情很单纯: <strong>通过main.js把 App.vue渲染到index.html的指定区域中</strong>。<br> 其中：</p>
<ul>
<li><strong>App.vue</strong>用来编写待渲染的<strong>模板结构</strong></li>
<li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li>
<li><strong>main.js</strong> 把 App.vue渲染到了index.html所预留的区域中  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 vue 这个包，得到Vue构造函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入App.vue根组件，将来要把App.vue中的模板结构，渲染到HTML页面中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// 把 render 函数指定的组件渲染到HTML页面中，这里指定了App</span></span><br><span class="line">    <span class="comment">// 我们最终的结果是，把这个指定的组件，放到id为app的所在的这个位置，把它给替换掉了</span></span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// vue实例的$mount()方法，作用和el属性完全一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="字符串函数charAt"><a href="#字符串函数charAt" class="headerlink" title="字符串函数charAt()"></a>字符串函数charAt()</h3><p>接收索引值，从字符串中获取对应字符，如：<br><code>&#39;hello&#39;.charAt(4) //&#39;o&#39;</code></p>
<h3 id="将字符串第一个字符变为大写"><a href="#将字符串第一个字符变为大写" class="headerlink" title="将字符串第一个字符变为大写"></a>将字符串第一个字符变为大写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> first = str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="keyword">const</span> other = str.<span class="title function_">slice</span>(<span class="number">1</span>)<span class="comment">//从指定索引往后截取字符串，返回得到的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first+other)</span><br></pre></td></tr></table></figure>

<h3 id="ajax原生写法"><a href="#ajax原生写法" class="headerlink" title="ajax原生写法"></a>ajax原生写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>计算属性</tag>
        <tag>侦听器</tag>
        <tag>Vue2</tag>
        <tag>过滤器</tag>
        <tag>axios</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>ref引用DOM元素和组件实例</title>
    <url>/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>能够使用<code>ref</code>获取页面上DOM或组件的引用：<br>给元素或组件添加<code>ref=&quot;xxx&quot;</code>的引用名称，通过<code>this.$refs.xxx</code>获取元素或组件的实例</p>
</blockquote>
<blockquote>
<p>能够知道<code>$nextTick</code>的应用场景并合理地使用：把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</p>
</blockquote>
<blockquote>
<p>通过<a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=127">“购物车案例”</a>巩固前4天所有学知识</p>
</blockquote>
<h2 id="ref引用-引用DOM元素-组件实例"><a href="#ref引用-引用DOM元素-组件实例" class="headerlink" title="ref引用 - 引用DOM元素 &#x2F; 组件实例"></a>ref引用 - 引用DOM元素 &#x2F; 组件实例</h2><blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<ol>
<li><p>什么是ref 引用<br> ref用来辅助开发者在<strong>不依赖于jQuery的情况下</strong>且<strong>在不调用DOM API的前提下</strong>，<strong>获取页面上DOM元素或组件的引用</strong>。</p>
<p> 每个vue的组件实例上，都包含一个<code>$refs</code>对象，里面存储着对应的DOM元素或组件的引用。<strong>默认情况下，组件的<code>$refs</code> 指向一个空对象</strong>。</p>
<blockquote>
<p>打印出vue实例对象this，可以看到，凡是$开头的，都是vue内置的一些成员。</p>
</blockquote>
</li>
<li><p>使用ref引用 DOM元素<br> 在标签上通过ref属性来指定一个名字，这个名字就指向这个标签，并添加到<code>$ref</code>对象中。如：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;myh1&quot;</span>&gt;</span>APP根组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">$refs</span>:&#123;<span class="comment">//vue实例上的$refs属性值</span></span><br><span class="line">    <span class="attr">myh1</span>: h1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myh1</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//操作DOM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ref引用 组件实例<br> 只要<strong>在引用的子组件的标签上，加一个ref</strong>，这个名字就指向了这个子组件的vue实例，就可以通过它来调用这个子组件的属性和方法。</p>
</li>
</ol>
<p><font color='red'>建议：只要是ref的引用，尽量都以Ref后缀结尾，这样一看名字就知道是个引用</font></p>
<h2 id="this-nextTick的应用场景"><a href="#this-nextTick的应用场景" class="headerlink" title="this.$nextTick的应用场景"></a><code>this.$nextTick</code>的应用场景</h2><ul>
<li><strong>问题</strong></li>
</ul>
<p>在app组件中，控制组件内按钮和输入框元素的切换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;inputVisible&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;showButton&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iptRef&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> @<span class="attr">click</span>=<span class="string">&quot;showinput&quot;</span>&gt;</span>显示输入框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们想要在切换到输入框的时候，直接进入输入框焦点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">showButton</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是<code>this.$refs.iptRef.focus()</code>这样却报错了<br><code>TypeError: Cannot read properties of undefined (reading &#39;focus&#39;)</code><br>这个错误代表说，我要调用一个focus方法，或我要访问一个focus属性，但是它前面那个东西是undefined<br>当我们打印<code>console.log(this.$refs.iptRef);</code>会发现它是<code>undefined</code>！</p>
<ul>
<li><strong>分析原因</strong></li>
</ul>
<p>在这个函数中，我们是更改inputVisible的值让文本框显示出来，但是现在页面上文本框还未显示出来，所以拿不到这个元素，因此是undefined<br>在Vue的生命周期中，当data里面的数据变化，会触发DOM元素的更新，根据最新的数据，重新渲染页面的UI结构。<strong>在updated之前，页面还没来得及重新渲染，所以数据是新的，但是页面的结构是旧的。</strong><br>所以<code>this.inputVisible = true;</code>这句执行之后，页面上还是按钮，文本框还未被展示，还需要一个更新的过程，需要一定的时间。如果立马去执行<code>this.$refs.iptRef.focus()</code>是拿不到文本框的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><font color='red'>总结：<code>this.inputVisible = true</code>这行代码执行完，只是数据是最新的，页面还没来得及重新渲染，没有文本框，拿不到它的引用，所以是undefined</font><br>要想不报错，<code>this.$refs.iptRef.focus()</code>这一行调用应该放在页面重新渲染完毕之后</p>
<ul>
<li><strong>解决</strong> – <code>this.$nextTick(cb)</code>方法<br>里面接收一个回调，cb是callback<br>代表：<strong>把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</strong><br>保证cb回调函数可以操作到最新的DOM元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>ref引用</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件高级用法 - 动态组件&amp;插槽&amp;自定义指令&amp;ESlint</title>
    <url>/tsukimiya.github.io/2024/05/01/Vue2/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&amp;%E6%8F%92%E6%A7%BD&amp;%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4&amp;ESlint/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>掌握keep-alive实现组件的缓存：keep-alive标签、include 属性<br>能够使用插槽提高组件的复用性：slot标签、具名插槽、<strong>作用域插槽</strong>(接收数据并使用)、后备内容<br><strong><code>v-slot</code>指令</strong>：<strong>把内容填充到指定名称的插槽中，只能被用在 组件components 或 template标签</strong><br><code>v-slot:</code> 简写 <code>#</code> 如：<code>&lt;template #title&gt;&lt;/template&gt;</code></p>
</blockquote>
<blockquote>
<p>能够知道如何自定义指令：<br>私有自定义指令<code>directives: &#123; &#125;</code><br>全局自定义指令<code>Vue.directive()</code></p>
</blockquote>
<blockquote>
<p>了解常见的ESLint语法规则、习惯在ESLint下进行开发<br>配置VSCode插件及设置，帮助我们规范代码格式，高效开发</p>
</blockquote>
<h2 id="动态组件的使用"><a href="#动态组件的使用" class="headerlink" title="动态组件的使用"></a>动态组件的使用</h2><p>动态组件指的是<strong>动态切换组件的显示与隐藏</strong>。实现不同组件的按需展示。</p>
<ol>
<li><p>如何实现动态组件的渲染<br> vue提供了一个内置的<code>component</code>组件，作用：组件的占位符。专门用来实现动态组件的渲染。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1．当前要渲染的组件名称</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">comName</span>: <span class="string">&#x27;Left&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;! -- <span class="number">2</span>．通过is属性，动态指定要渲染的组件--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>．点击按钮，动态切换组件的名称 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Left&#x27;&quot;</span>&gt;</span>展示 Left 组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Right&#x27;&quot;</span>&gt;</span>展示 Right组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内置标签keep-alive – 保持组件的状态</strong><br>每次切换组件都是上一个组件被销毁和下一个组件被创建-&gt;运行<br>如果再次创建同一个组件，它会重新初始化一遍数据，和上一个组件是没有关系的<br> 如果我们希望切换回来之后原来的数据状态还在，就可以使用<font color="red">keep-alive：防止组件被隐藏的时候被销毁</font></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 这样隐藏Left的时候不会移除这个组件，而是打上一个inactive标记(被缓存了)（未使用的、不活动的）<br> <font color="green">总结：keep-alive可以把内部的组件进行缓存，而不是销毁组件</font></p>
</li>
<li><p><strong>keep-alive 对应的生命周期函数</strong><br> 当组件<strong>被缓存</strong>时，会自动触发组件的<strong>deactivated</strong>生命周期函数。<br> 当组件<strong>被激活</strong>时，会自动触发组件的<strong>activated</strong>生命周期函数。</p>
</li>
<li><p><strong>keep-alive的include属性 – 指定哪些组件可以被缓存</strong><br> 只有名称匹配的组件会被缓存</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;Left,Right&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 除了include，还有个exclude属性，表示排除项<br> 注意：这两个属性不能同时使用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive exclude=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="了解组件-注册名称-和-组件声明时name-的区别"><a href="#了解组件-注册名称-和-组件声明时name-的区别" class="headerlink" title="了解组件 注册名称 和 组件声明时name 的区别"></a>了解组件 注册名称 和 组件声明时name 的区别</h2><p>如果在声明组件(定义组件模板结构)的时候，没有为组件指定 name 名称，则组件的名称默认就是“注册时候的名称”。当提供了name属性之后，组件的名称就是name属性的值。</p>
<ul>
<li><strong>对比</strong>(3、4 is my think):</li>
</ul>
<ol>
<li>组件的“<strong>注册名称</strong>”的主要应用场景是: 以<strong>标签</strong>的形式，把注册好的组件，渲染和使用到页面结构之中</li>
<li>组件声明时候的“<strong>name</strong>”名称的主要应用场景: <strong>结合keep-alive标签实现组件缓存功能</strong>;以及在<strong>调试工具</strong>中看到组件的 name <strong>名称</strong></li>
<li>一般情况下，注册名称可以将name属性完全替代，不去注册name属性</li>
<li><strong>name属性的独特应用场景：递归组件</strong>。指在组件的模板中，使用该组件自身的情况。(这样场景下，注册名称是替代不了name属性的)</li>
</ol>
<p>开发中，为了标准、方便，<strong>建议给每个组件起一个name名称</strong>。(虽然我还是不理解除了4的情况有什么必要)</p>
<h2 id="插槽的使用-默认插槽、具名插槽、作用域插槽"><a href="#插槽的使用-默认插槽、具名插槽、作用域插槽" class="headerlink" title="插槽的使用(默认插槽、具名插槽、作用域插槽)"></a>插槽的使用(默认插槽、具名插槽、作用域插槽)</h2><p><strong>插槽</strong>（Slot）是vue为<strong>组件的封装者</strong>提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。</p>
<p><font color="red">在组件的内容节点填写内容，然后把它给渲染出来</font><br><img src="/tsukimiya.github.io/images/vue/%E6%8F%92%E6%A7%BD.png" alt="image"></p>
<h3 id="v-slot指令-–-简写："><a href="#v-slot指令-–-简写：" class="headerlink" title="v-slot指令  – 简写：#"></a>v-slot指令  – 简写：#</h3><p><strong>vue官方规定：每一个 slot 插槽，都要有一个 name 名称</strong><br>如果省略了 slot 的 name 属性，则有一个<strong>默认名称</strong>叫做 <strong>default</strong></p>
<p>默认情况下，在使用组件的时候，提供的内容都会被填充到名字为default的插槽中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有一个插槽的话，name不写也可以</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color="green">如果要把内容填充到指定名称的插槽中，需要使用<code>v-slot：</code>这个指令</font><font color="red"> – 简写：#</font><br><font color="red">注意：v-slot指令，只能被用在 组件components 或 template标签</font><br>template是个虚拟的标签，只起到一个包裹性的作用，不会被渲染成任何真实的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    //或</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="插槽的默认内容-后备内容"><a href="#插槽的默认内容-后备内容" class="headerlink" title="插槽的默认内容&#x2F;后备内容"></a>插槽的默认内容&#x2F;后备内容</h3><p>官方的专业术语：后备内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>带有名字的插槽就叫做具名插槽。</p>
<p>它也是一个具名插槽，或者叫默认插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>在预留插槽的时候，声明数据项。在使用的时候可以接收数据并使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Left</span><br><span class="line"><span class="comment">&lt;!-- 在封装组件的时候，为预留的slot提供属性对应的值，这种用法叫做“作用域插槽” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;hello vue.js&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果插槽没有声明数据项，则形参scope是个空对象<br><font color="green">接收数据的形参建议用 scope(作用域) 来命名</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// app.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; scope.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽的解构赋值"><a href="#作用域插槽的解构赋值" class="headerlink" title="作用域插槽的解构赋值"></a>作用域插槽的解构赋值</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote>
<p>vue允许开发者自定义指令</p>
</blockquote>
<p>vue中的自定义指令分为两类，分别是:</p>
<ul>
<li>私有自定义指令</li>
<li>全局自定义指令</li>
</ul>
<h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>在每个vue 组件中，可以在 <strong>directives节点</strong>下声明<strong>私有自定义指令</strong>。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="comment">//为绑定到的 HTML 元素设置红色的文字</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el</span>)&#123; </span><br><span class="line">            <span class="comment">// 形参中的 el是绑定了此指令的、原生的DOM对象(固定的写法)</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当指令第一次被绑定到元素上的时候，会立即触发bind方法</span></span><br><span class="line">&lt;<span class="title class_">Left</span> v-color&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>binding.value</code>获取指令绑定的值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//官方推荐用binding</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Left</span> v-color=<span class="string">&quot;&#x27;green&#x27;&quot;</span>&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>update函数</strong><br><strong>bind</strong>函数<strong>只调用1次</strong>：当指令<strong>第一次绑定到元素时</strong>调用；当DOM更新时bind函数不会被触发。<br><strong>update</strong>函数会在<strong>每次DOM更新时被调用</strong>，绑定的时候不会触发：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//每次DOM更新时被调用，绑定的时候不会触发</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">          el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-color=<span class="string">&quot;color&quot;</span>&gt;<span class="variable constant_">APP</span>根组件&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;color=&#x27;red&#x27;&quot;</span>&gt;</span>变成红色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数简写形式</strong><br>如果 bind 和 update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 bind 和 update 时，会触发相同的业务逻辑</span></span><br><span class="line">    <span class="title function_">color</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>和定义过滤器filter一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1: 字符串，表示全局自定义指令的名字</span></span><br><span class="line"><span class="comment">// 参数2: 对象，用来接收指令的参数值</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,<span class="keyword">function</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//简写形式</span></span><br><span class="line">    el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象形式：</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,&#123; <span class="comment">//简写形式</span></span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ESLint工具"><a href="#ESLint工具" class="headerlink" title="ESLint工具"></a>ESLint工具</h2><p>可组装的JS和JSX检查工具 – 约束代码风格<br>在你的js代码里面 帮你发现问题，并且解决问题</p>
<p>两个中文官网 <a href="https://nodejs.cn/eslint/">官网1</a> <a href="https://eslint.nodejs.cn/docs/latest/">官网2</a></p>
<p>当在项目里面配置了ESLint以后，它就会去检查代码风格，有问题就会报错</p>
<ul>
<li><p>vscode 设置<br>缩进：设置 -  搜索 Editor:Tab Size 设置为2<br>保存：设置 - 文本编辑器 - 格式化 - Format on Save(保存时格式化文件) </p>
</li>
<li><p>使用ESLint – 创建新的vue项目<br>在选择预设的时候，加上一个Linter &#x2F; Formatter(默认被选上的)<br>然后后面的选项中就多了一项：选择要安装的ESLint的语法规范<br>选择倒数第二项 – Standard config 标准配置<br>然后选择：<br>Lint on save（ctrl s保存的时候进行检查）<br>Lint and fix on commit（提交代码的时候进行代码规范的检查，并且把检查到的问题自动修复）<br>只勾选第一项默认的就行，第二项不建议勾选。</p>
</li>
<li><p>ESLint配置文件 eslintrc.js<br>这里是定义的一些规则：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">//固定格式 只在发布阶段会报一个黄色警告，开发阶段不会</span></span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们可以去 <a href="https://eslint.nodejs.cn/">官网</a> 的开发文档的规则参考部分来查看这些规则的作用：<br>  no-console 禁止使用console，no-debugger 禁止使用debugger</p>
</li>
</ul>
<h3 id="ESLint-规则"><a href="#ESLint-规则" class="headerlink" title="ESLint 规则"></a>ESLint 规则</h3><p>不符合规则会报对应的错误，以及错误所在的行列数<br>具体报错规则可以去 <a href="https://nodejs.cn/eslint/">ESLint 中文文档</a> 直接搜索</p>
<ol>
<li>不能出现连续的空行</li>
<li>在文件的末尾必须要有空行</li>
<li>不能有多余的空格</li>
<li>字符串要用单引号</li>
<li>对象和属性之间，需要有一个空格分隔</li>
<li>要求或禁止末尾逗号</li>
<li>在注释中的 <code>//</code> 或 <code>/*</code> 后强制使用一致的间距<blockquote>
<p>&#x2F;&#x2F; 这里是正确注释，<code>//</code>后最少要有一个空格</p>
</blockquote>
</li>
<li>强制一致的缩进（该缩进的要缩进，不该缩进的不能缩进）</li>
<li><code>import</code>导入模块的语句必须声明在文件的顶部</li>
<li>定义变量而没有使用会报错</li>
<li>方法的形参之前需要保留一个空格<blockquote>
<p>show () {} 括号前后都要有一个空格</p>
</blockquote>
</li>
</ol>
<h3 id="禁用某规则"><a href="#禁用某规则" class="headerlink" title="禁用某规则"></a>禁用某规则</h3><p>如果不想遵守某个规则，和ESLint反着来，可以禁止这个规则<br>在官方文档中，找到这个规则，会说明如何更改，直接复制想要更改的规则呢么的代码即可<br>配置如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="comment">// 在方法的形参 () 之前，是否必须有空格</span></span><br><span class="line">    <span class="comment">// always代表需要这个空格，不满足这个规则会报一个warn警告</span></span><br><span class="line">    <span class="string">&quot;space-before-function-paren&quot;</span>: [<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：只要修改了配置文件，都需要重启服务器</p>
<h3 id="配置VSCode"><a href="#配置VSCode" class="headerlink" title="配置VSCode"></a>配置VSCode</h3><p>我们不能保证写的代码完全符合ESLint的要求，所以可以装一些插件，在保存文件的时候自动对文件进行格式化。</p>
<ul>
<li><p>ESLint插件<br>装过之后需要再配置文件中加一下配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 -- settingsjson</span></span><br><span class="line"><span class="comment">// ESLint 插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 老师是这样的</span></span><br><span class="line">    <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 搜的一个是这样</span></span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prettier - Code formatter 插件<br>在<code>C:\Users\lenovo</code>目录下新建<code>.prettierrc</code>配置文件<br>填入 <code>&#123;&quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;printWidth&quot;: 300, &quot;bracketSpacing&quot;: true&#125;</code><br>然后在vscode设置 – settings.json里面添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\lenovo\\.prettierrc&quot;</span>,</span><br><span class="line"><span class="string">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"><span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 每行文字个数超过此限制将会被迫换行</span></span><br><span class="line"><span class="string">&quot;prettier.printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line"><span class="comment">// 使用单引号替换双引号</span></span><br><span class="line"><span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line"><span class="comment">// 设置vue文件中，HTML代码的格式化插件</span></span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line"><span class="string">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;printWidth&quot;</span>: <span class="number">300</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ESLint 插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：</p>
<ol>
<li>开发哪个项目，就用vscode直接打开该项目目录(保证两个插件能够正常生效)</li>
<li>在vue文件 – ctrl + s 能够格式化文件<blockquote>
<p>前提：在.vue文件右键 – 选择“使用..格式化文档&#x2F;格式化文档的方式” – 点击 配置默认格式化程序，点击 Prettier 将其设置为默认值<br>问题：设置默认格式后保存出现逗号的，在setting.json文件中 通过ctrl+f 搜索找到editor.formatOnSave，将其注释就可以解决这个问题</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a><font color="red">项目初始化</font></h3><p>每次新建项目，如果开启了ESLint，一定要进行下面配置，便于我们开发：</p>
<ol>
<li>配置默认格式化程序为prettier<br> 在项目中，任意某文件中 右键 – 使用…格式化文档 – 配置默认格式化程序 – prettier</li>
<li>ESLint配置文件添加配置以下两条规则： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 方法名 和 括号 之间不强制加空格</span></span><br><span class="line">    <span class="comment">// 注意这里none不是正确的值，应该是never！！！</span></span><br><span class="line">    <span class="string">&#x27;space-before-function-paren&#x27;</span>: [<span class="string">&#x27;warn&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="comment">// 组件名可以使用单个单词</span></span><br><span class="line">    <span class="string">&#x27;vue/multi-word-component-names&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于不符合ESLint格式的显示标记问题</strong>，如果我们添加的规则，值的格式错误，或者输入的是没有的值，会不起作用。如none就不是正确的值。</p>
</blockquote>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="自定义事件使用-event"><a href="#自定义事件使用-event" class="headerlink" title="自定义事件使用$event"></a>自定义事件使用$event</h3><p>内置变量<code>$event</code>，是在我们需要向绑定事件传递参数时候，用来接收事件对象e使用的<br><code>@click=&quot;add(1,$event)&quot; --- add(n,e)&#123;&#125;</code></p>
<p><font color="green">只要自定义事件里面接收到的值被覆盖了，就可以考虑使用<code>$event</code></font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Count</span> @num-change=<span class="string">&quot;getNewNum(item,$event)&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自定义事件</span></span><br><span class="line"><span class="title function_">getNewNum</span>(<span class="params">item,val</span>)&#123; </span><br><span class="line">    item.<span class="property">goods_count</span> = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于main-js中的小提示"><a href="#关于main-js中的小提示" class="headerlink" title="关于main.js中的小提示"></a>关于main.js中的小提示</h3><p>main.js的第四行：<br><code>Vue.config.productionTip = false</code><br>默认是false，改为true会在终端给出一个温馨提示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br><span class="line">See more tips at https://vuejs.org/guide/deployment.html</span><br></pre></td></tr></table></figure>
<p>把这句代码删了就相当于是true</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>动态组件</tag>
        <tag>插槽</tag>
        <tag>自定义指令</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex - 组件全局状态(数据)管理机制</title>
    <url>/tsukimiya.github.io/2024/05/08/Vue2/8.vuex/</url>
    <content><![CDATA[<blockquote>
<p>总结：<br>组件全局状态(数据)管理机制<strong>Vuex</strong>的安装、<strong>导入及使用</strong>：<br><strong>四大核心概念使用</strong>：<br>    1. <strong>State 存储数据</strong><br>    (1) <code>this.$store.state.全局数据名称</code><br>    (2) <code>import &#123; mapState &#125; from &#39;vuex&#39;</code> —— <code>computed: &#123; ...mapState([&#39;count&#39;]) &#125;</code><br>    2. <strong>Mutation 修改数据</strong>（同步）<br>    (1) <code>this.$store.commit(&#39;addN&#39;, 3) // 触发时，携带参数</code><br>    (2) <code>import &#123; mapMutations &#125; from &#39;vuex&#39;</code> —— <code>methods: &#123; ...mapMutations([&#39;add&#39;,&#39;addN&#39;]) &#125;</code><br>    3. <strong>Action 处理异步逻辑</strong>，并触发 Mutation 以间接更新 State<br>    (1) <code>this.$store.dispatch(&#39;addNAsync&#39;, 3) // 携带参数</code><br>    (2) <code>import &#123; mapActions &#125; from &#39;vuex&#39;</code> —— <code>methods: &#123; ...mapAction([&#39;addAsync&#39;,&#39;addNAsync&#39;]) &#125;</code><br>    4. <strong>Getter 提供数据加工</strong><br>    (1) <code>this.$store.getters.名称</code><br>    (2) <code>import &#123; mapGetters &#125; from &#39;vuex&#39;</code> —— <code>computed: &#123; ...mapGetters([&#39;showNum&#39;]) &#125;</code></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>组件之间共享数据的方式<br> 父向子：porps自定义属性<br> 子向父：自定义事件<code>$.emit</code>、<code>v-on/@</code><br> 兄弟组件之间：EventBus<code>$.emit</code>、<code>$.on</code></p>
<p> 这三种的方式，<strong>只适合在小范围内来进行数据的共享</strong><br> 如果需要频繁的，或者大范围的来实现数据的共享，这三种方案就有些力不从心</p>
</li>
<li><p><strong>Vuex</strong><br><strong>Vuex</strong>是<strong>实现组件全局状态(数据)管理</strong>的一种机制，可以方便的实现组件之间<strong>数据的共享</strong>。<br><img src="/tsukimiya.github.io/images/vue/vuex.png" alt="vuex"><br>Vuex就相当于在这些组件旁边定义了<strong>一个共享的数据状态对象Store</strong></p>
</li>
<li><p>使用Vuex统一管理状态的<strong>好处</strong></p>
<ul>
<li>能够在vuex中<strong>集中管理共享的数据</strong>，易于开发和后期维护   </li>
<li>能够<strong>高效</strong>地实现组件之间的<strong>数据共享</strong>，提高开发效率</li>
<li>存储在vuex中的数据都是响应式的，能够<strong>实时</strong>保持数据与页面的<strong>同步</strong></li>
</ul>
</li>
<li><p>什么样的数据适合存储到Vuex中<br> 一般情况下，<strong>只有组件之间共享的数据</strong>，<strong>才有必要存储到vuex中</strong>;对于组件中的私有数据，依旧存储在组件自身的data中即可。</p>
</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>安装vuex依赖包：<code>npm i vuex -S</code></li>
<li>导入vuex包<br> <code>import Vuex from &#39;vuex&#39;</code><br> <code>Vue.use(Vuex)</code></li>
<li>创建store对象 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// state中存放的就是全局共享的数据</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>将store对象挂载到vue实例中 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(app),</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 将创建的共享数据对象，挂载到Vue实例中</span></span><br><span class="line">  <span class="comment">// 所有的组件，就可以直接从store中获取全局的数据了</span></span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>创建vue项目时，如果添加了vuex的配置，会自动帮我们配置好这些</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Vuex中主要的核心概念如下：</p>
<ul>
<li>State</li>
<li>Mutation</li>
<li>Action</li>
<li>Getter</li>
</ul>
<p>总结来说，<strong>State 存储数据</strong>，<strong>Getter 提供数据加工</strong>，<strong>Mutation 修改数据（同步）</strong>，而 <strong>Action 处理异步逻辑</strong>并触发 Mutation 以间接更新 State。这四者共同构成了 Vuex 的核心机制，帮助开发者更好地管理和维护应用的状态。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State<strong>提供唯一的公共数据源</strong>，所有共享的数据都要统一放到Store的State中进行存储。</p>
<ul>
<li><p><strong>组件访问State中数据</strong>的<strong>方式一</strong>：<strong>直接访问</strong><br><code>this.$store.state.全局数据名称</code>，如<code>this.$store.state.count</code></p>
</li>
<li><p>组件访问State中数据的<strong>方式二</strong>：<strong>使用mapState辅助函数</strong></p>
<ol>
<li>从vuex中按需导入mapState函数<br>  <code>import &#123; mapState &#125; from &#39;vuex&#39;</code></li>
<li>通过mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者使用对象展开语法进行更细致的映射： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">localCount</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>使用方式建议</strong></p>
<ul>
<li>只需要<strong>访问一两个State属性</strong>，且<strong>不频繁</strong>使用 —— <strong>直接访问</strong></li>
<li><strong>访问多个State属性</strong>，或者需要<strong>对State数据</strong>进行一些<strong>转换处理</strong> —— <strong>mapState辅助函数</strong><blockquote>
<p>更加清晰和高效，使代码更模块化，易于阅读和维护。</p>
</blockquote>
</li>
<li>项目<strong>使用了TS</strong> —— <strong>mapState辅助函数</strong><blockquote>
<p>mapState配合类型注解可以提供更好的类型安全性。</p>
</blockquote>
</li>
</ul>
<p>总的来说，选择哪种方式取决于具体场景和个人偏好，但通常<strong>推荐使用mapState</strong>，因为它可以让你的<strong>代码更加整洁、易于维护</strong>，并且在<strong>处理复杂逻辑时更为灵活</strong>。</p>
</li>
</ul>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><blockquote>
<p>在组件中，虽然可以<code>this.$store.state.count = 1</code>直接修改全局的数据，且不报错，<br>但是在Vuex中，它<font color="red"><strong>不允许组件直接去修改Store的数据</strong></font>，而是推荐使用Mutation</p>
</blockquote>
<p>Mutation用于变更Store中的数据。<br>通过这种方式虽然操作稍微繁琐一些，但是<strong>可以集中监控所有数据的变化</strong></p>
<blockquote>
<p>通过<code>this.$store.state.count = 1</code>修改数据，如果想看一下是谁修改的，需要挨个组件去翻，不利于后期维护。<br>通过<code>Mutation</code>里面的函数修改数据，如果发现数据修改有问题，可以直接找对应的Mutation</p>
</blockquote>
<h4 id="定义Mutations"><a href="#定义Mutations" class="headerlink" title="定义Mutations"></a>定义Mutations</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++ <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>传递参数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state, step</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> += step <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="触发方式一"><a href="#触发方式一" class="headerlink" title="触发方式一"></a>触发方式一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">handlel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 注意这里是**小写**store！！！</span></span><br><span class="line">    <span class="comment">// commit的作用，就是调用某个mutation函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>, <span class="number">3</span>) <span class="comment">// 触发时，携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="触发方式二"><a href="#触发方式二" class="headerlink" title="触发方式二"></a>触发方式二</h4><ol>
<li>从Vuex中按需导入 mapMutations 函数：<br><code>import &#123; mapMutations &#125; from &#39;vuex&#39;</code><blockquote>
<p>注意是<strong>小写</strong>的<strong>vuex</strong></p>
</blockquote>
</li>
<li><strong>通过mapMutations函数</strong>，将需要的mutations函数，<strong>映射为当前组件的methods方法</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用</span></span><br><span class="line">&lt;button @click=<span class="string">&quot;add&quot;</span>&gt;count +<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addN(3)&quot;</span>&gt;</span>count +3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> <span class="comment">// 携带参数</span></span><br><span class="line"><span class="comment">// 也可以在方法中调用 -- 推荐</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>]),</span><br><span class="line">  <span class="title function_">btnHandle1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">add</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">btnHandle2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addN</span>(<span class="number">3</span>) <span class="comment">// 携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote>
<p>在Mutations函数中，不能写异步的代码(setTimeout、setIterval等)，虽然页面效果没有问题，但是数据没有传到state，会导致在devtools提交更新后，页面的数据又恢复原来的了</p>
</blockquote>
<p><strong>Action 用于处理异步任务</strong><br>但是在Action中，还是要通过触发Mutation的方式间接变更数据</p>
<h4 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 只有mutations函数中，才有权利修改state中的数据</span></span><br><span class="line">    <span class="comment">// 在actions中，必须通过context.commit()触发某个mutation才行</span></span><br><span class="line">    <span class="title function_">addAsync</span>(<span class="params">context</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>传参</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state, step</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">addNAsync</span>(<span class="params">context,step</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>,step)</span><br><span class="line">      &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="触发Action-方式一"><a href="#触发Action-方式一" class="headerlink" title="触发Action - 方式一"></a>触发Action - 方式一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的dispatch函数，站门用来触发action</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">addN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addNAsync&#x27;</span>, <span class="number">3</span>) <span class="comment">// 携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="触发Action-方式二"><a href="#触发Action-方式二" class="headerlink" title="触发Action - 方式二"></a>触发Action - 方式二</h4><blockquote>
<p>和Mutations一样</p>
</blockquote>
<ol>
<li>从Vuex中按需导入 mapActions 函数：<br><code>import &#123; mapActions &#125; from &#39;vuex&#39;</code><blockquote>
<p>注意是<strong>小写</strong>的vuex</p>
</blockquote>
</li>
<li><strong>通过mapActions函数</strong>，将需要的actions函数，<strong>映射为当前组件的methods方法</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>([<span class="string">&#x27;addAsync&#x27;</span>,<span class="string">&#x27;addNAsync&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter用于对Store中的<strong>数据进行加工处理</strong>形成新的数据。起到一个<strong>包装数据</strong>的作用，<strong>类似计算属性</strong>computed</p>
<ul>
<li>定义Getter<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">showNum</span>: <span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span> + state.<span class="property">count</span> +<span class="string">&#x27;】&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Getters的使用同样<strong>和State一致</strong></p>
<ul>
<li><p>使用Getter方式一<br><code>this.$store.getters.名称</code>如：<code>this.$store.getters.showNum</code></p>
</li>
<li><p>使用Getter方式二 —— mapGetters</p>
<ol>
<li>从vuex中按需导入mapGetters函数<br>  <code>import &#123; mapGetters &#125; from &#39;vuex&#39;</code></li>
<li>通过mapGetters函数，将当前组件需要的getters，映射为当前组件的computed计算属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="关于核心概念的使用方式"><a href="#关于核心概念的使用方式" class="headerlink" title="关于核心概念的使用方式"></a>关于核心概念的使用方式</h2><p>就像state中说到的那样：</p>
<ul>
<li>使用<strong>不频繁</strong> —— <strong>直接访问</strong></li>
<li><strong>访问多次</strong>，或者需要进行<strong>转换处理</strong> —— <strong>mapXXX辅助函数</strong><blockquote>
<p>更加清晰和高效，使代码更模块化，易于阅读和维护。</p>
</blockquote>
</li>
<li>项目<strong>使用了TS</strong> —— <strong>mapXXX辅助函数</strong><blockquote>
<p>mapXXX辅助函数配合类型注解可以提供更好的类型安全性。</p>
</blockquote>
</li>
</ul>
<p>总的来说，选择哪种方式取决于具体场景和个人偏好，但通常<strong>推荐使用mapXXX辅助函数</strong>，因为它可以让你的<strong>代码更加整洁、易于维护</strong>，并且在<strong>处理复杂逻辑时更为灵活</strong>。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>路由(vue-router)</title>
    <url>/tsukimiya.github.io/2024/05/02/Vue2/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>能够在项目中安装和配置路由：<code>createRouter</code>、<code>app.use(router)</code><br>能够使用路由实现单页面应用程序的开发<br>能够使用嵌套路由：通过<code>children</code>属性进行路由嵌套<br>能够实现动态路由匹配：使用冒号声明参数项、<code>this.$route.params</code>、<code>props: true</code><br>能够使用编程式导航：<code>this.$router.push</code>、<code>this.$router.go</code><br>能够使用导航守卫控制路由的访问权限：<br><code>路由实例.beforeEach((to, from, next) =&gt; &#123; /* 必须调 next 函数*/ &#125;)</code></p>
</blockquote>
<h2 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用"></a>axios的使用</h2><ol>
<li><p>首先安装axios包<br><code>npm i axios</code> ，结果报错<code>ERR! ERESOLVE could not resolve ERESOLVE could not resolve</code><br>解决办法是在后面加 <code>--legacy-peer-deps</code> 即可<br><code>npm install axios -save --legacy-peer-deps</code><br>报错的原因是由于npm不同版本库之间命令不兼容。</p>
</li>
<li><p>在left组件发送get请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;getInfo&quot;</span>&gt;发起<span class="title class_">Get</span>请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在right组件发送post请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;postInfo&quot;</span>&gt;发起 <span class="title class_">Post</span> 请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">postInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="考虑问题-–-优化"><a href="#考虑问题-–-优化" class="headerlink" title="考虑问题 – 优化"></a>考虑问题 – 优化</h3><ul>
<li><p>问题</p>
<ol>
<li>每个组件中，都可能会有发请求的需求，都需要先导入axios，然后调用这些方法，每次用都很麻烦</li>
<li>每次请求地址都需要写完整地址，但是我们的请求根路径都完全一样。如果将来后端把根路径改了，我们就需要修改每一个组件，不利于后期维护。</li>
</ol>
</li>
<li><p>思考<br>每一个.vue组件都相当于一个vue实例，我们可以理解为：每一个.vue组件都是new Vue()这个构造函数得到的</p>
</li>
<li><p>优化1 – <strong>在Vue的原型链上挂载一个axios</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 一般我们不叫axios，而是$http</span></span><br><span class="line"><span class="comment">// 因为vue内置的一些成员都是以$开头的(模仿内置成员)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span> = axios</span><br></pre></td></tr></table></figure>
<p>这样我们<strong>在每一个组件中</strong>，就不需要再导入axios，<strong>直接通过this&#x2F;原型访问</strong></p>
</li>
<li><p>优化2 – <strong>全局配置 axios 的请求根路径</strong><br>在往原型上挂之前，通过axios做一下局域的配置：<br><code>axios.defaults.baseURL = &#39;请求根路径&#39; // axios自带的属性</code><br>组件使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点<br><strong>无法实现api接口的复用</strong>：如果这个api在多个页面都需要被用到，每一次都需要重新调这个api接口</p>
</li>
</ul>
<h3 id="axios最优使用-–-实现api接口的复用"><a href="#axios最优使用-–-实现api接口的复用" class="headerlink" title="axios最优使用 – 实现api接口的复用"></a>axios最优使用 – 实现api接口的复用</h3><p>使用axios的最优解 —— <strong>封装！</strong>（也就是模块化）</p>
<blockquote>
<p>将axios接口作为可导入的工具包进行封装</p>
</blockquote>
<p><font color="green">推荐：将其放在utils文件夹下(工具类的意思)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// 指定请求根路径</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://applet-base-api-t.itheima.net&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request</span><br></pre></td></tr></table></figure>

<p>需要几个服务器的接口，就封装几个，用哪个就导入哪个。如：request1封装TB的接口，2封装JD的接口</p>
<h3 id="进一步的封装-模块化"><a href="#进一步的封装-模块化" class="headerlink" title="进一步的封装&#x2F;模块化"></a>进一步的封装&#x2F;模块化</h3><p>如果有多个组件，都要调用request的articles接口，那么每个组件都要这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span>,  <span class="comment">// 页码值</span></span><br><span class="line">      <span class="attr">limit</span>: <span class="number">10</span> <span class="comment">// 每页显示多少条数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initArticleList</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 封装获取文章列表数据的方法</span></span><br><span class="line">    <span class="keyword">async</span> initArticleList () &#123;</span><br><span class="line">      <span class="comment">// 发起get请求，获取文章的列表数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/articles&#x27;</span>, &#123;</span><br><span class="line">         <span class="comment">// 请求参数，一般会把参数值定义在data结点，在这里传进去</span></span><br><span class="line">         <span class="comment">// 具体是否需要传参，是什么参数取决于后端API</span></span><br><span class="line">        <span class="attr">params</span>: &#123; <span class="attr">_page</span>: page, <span class="attr">_limit</span>: limit &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await后面返回的是一个Promise类型的值，所以我们可以把这一块单独拿出去<br>可以将其<strong>进一步的封装</strong><br>所有的API调用都可以放进 API 文件夹<br>封装的API文件都以API的命名结尾，可以一眼看出这是个API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// API/articleAPI.js</span></span><br><span class="line"><span class="comment">// 文章相关的API接口，都封装到这个模块中</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不是默认导出，是按需导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getArticleListAPI = <span class="keyword">function</span> (<span class="params">_page, _limit</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/articles&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; _page, _limit &#125; <span class="comment">// 请求参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后每个组件都可以这样调用接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getArticleListAPI &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/articleAPI&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span>,  <span class="comment">// 页码值</span></span><br><span class="line">      <span class="attr">limit</span>: <span class="number">10</span> <span class="comment">// 每页显示多少条数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initArticleList</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 封装获取文章列表数据的方法</span></span><br><span class="line">    <span class="keyword">async</span> initArticleList () &#123;</span><br><span class="line">      <span class="comment">// 发起get请求，获取文章的列表数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="title function_">getArticleListAPI</span>(<span class="variable language_">this</span>.<span class="property">page</span>, <span class="variable language_">this</span>.<span class="property">limit</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">这样才达到了axios真正的用法</font></p>
<h2 id="路由的基本配置与使用"><a href="#路由的基本配置与使用" class="headerlink" title="路由的基本配置与使用"></a>路由的基本配置与使用</h2><ol>
<li><p>什么是路由<br>路由(router) 就是 <strong>对应关系</strong></p>
</li>
<li><p>SPA(单页面应用程序) 与 前端路由<br>SPA指的是一个web网站只有唯一的一个HTML页面，<strong>所有组件的展示与切换</strong>都在这唯一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</li>
<li><p>什么是前端路由<br>通俗易懂的概念：<strong>Hash地址</strong>(就是#锚链接) 与 <strong>组件</strong> 之间的 <strong>对应关系</strong><br>不同的哈希，会展示出不同的组件页面</p>
</li>
<li><p><strong>前端路由的工作方式</strong></p>
<ol>
<li>用户点击了页面上的路由链接</li>
<li>导致了URL地址栏中的Hash值发生了变化</li>
<li>前端路由监听了到Hash地址的变化</li>
<li>前端路由把当前Hash地址对应的组件渲染都浏览器中</li>
</ol>
<p> <font color="green">结论：前端路由，指的是 Hash地址 与 组件之间 的 对应关系</font><br> <img src="/tsukimiya.github.io/images/vue/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.png" alt="image"></p>
</li>
</ol>
<h3 id="vue-router的基本使用"><a href="#vue-router的基本使用" class="headerlink" title="vue-router的基本使用"></a>vue-router的基本使用</h3><blockquote>
<p>前端路由的底层原理是监听了浏览器的onhashchange事件，自己去封装前端路由是非常麻烦的一件事，我们可以用现成的包去实现前端路由的处理 – vue-router(vue项目中的一个路由的包，只能在vue项目中用)</p>
</blockquote>
<ol>
<li><p>什么是vue-router<br><strong>vue-router</strong>是vue.js官方给出的<strong>路由解决方案</strong>。它只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换。<br>vue-router 的官方文档地址: <a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p>
</li>
<li><p><strong>vue-router 安装和配置的步骤</strong></p>
<ol>
<li><p>安装vue-router包：<code>npm i vue-router@3.5.2 -S</code><br>   如果因为ESLint安装报错，可以加上后缀：<code>npm i vue-router@3.5.2 -S --legacy-peer-deps</code><br>   vue-router最新版本Vue Router 4 是为 Vue 3 设计的，不兼容Vue2。<br>   所以想在 Vue 2 中使用 Vue Router，安装包的时候需要指定 Vue Router 3 的版本</p>
</li>
<li><p>创建路由模块<br>   在src源代码目录下，新建router&#x2F;index.js路由模块，并初始化如下代码：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js 就是当前项目的路由模块</span></span><br><span class="line"><span class="comment">// 1. 导入 Vue 和 VueRouter 的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外共享路由的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入并挂载路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由模块，目的：拿到路由的实例对象</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="comment">// 在 Vue 项目中，要想把路由用起来，必须把路由实例对象，通过下面的方式进行挂载</span></span><br><span class="line">  <span class="comment">// router：路由的实例对象</span></span><br><span class="line">  router <span class="comment">// 这里是简写</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 导入路由的时候，index.js可以省略 – <code>import router from &#39;@/router&#39;</code><br> <font color="green">在模块化导入的时候，如果只给了一层路径，默认会导入和加载路径下面名字叫index.js的文件</font></p>
</li>
<li><p>声明路由链接和占位符&#x2F;<strong>声明路由的对应关系(路由规则)</strong><br> 声明占位符：<br> <font color="red">App.vue甚至不需要导入组件，只需要声明一个占位符即可，通过a链接切换对应的组件</font></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/left&quot;</span>&gt;</span>left <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/right&quot;</span>&gt;</span> right<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只要在项目中安装和配置了 vue-router，则就可以使用 router-view 这个组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用：占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在路由模块声明路由的对应关系 – <strong>路由规则</strong>：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Left</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Left-item.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Right</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Right-item.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用router-link代替a链接<br>   router-link本质上也会被渲染成a链接</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当安装和配置了 vue-router 后，就可以使用 router-link来替代普通的a链接 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 优势：不用写前面的#，它会在点这个router-link的时候自动在前面加上# --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="路由重定向-–-redirect"><a href="#路由重定向-–-redirect" class="headerlink" title="路由重定向 – redirect"></a>路由重定向 – redirect</h2><p><strong>路由重定向</strong>指的是:用户在访问<strong>地址A</strong>的时候，<strong>强制用户跳转</strong>到地址C，从而展示特定的组件页面。通过路由规则的<strong>redirect</strong>属性，指定一个新的路由地址，可以很方便地设置路由的重定向:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 在routers数组中，声明路由的匹配规则</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span>&#125;, </span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>通过路由实现<strong>组件的嵌套展示</strong>，叫做嵌套路由。</p>
<p>如果某个组件本身就是通过路由的方式呈现出来的，在这个组件里又放一些路由规则，这样就形成了路由嵌套。<br><img src="/tsukimiya.github.io/images/vue/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt="image"></p>
<ul>
<li><p>声明子级路由标签和占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Right.vue</span><br><span class="line"><span class="comment">&lt;!-- 子级路由链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子级路由占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明嵌套路由的规则 – 路由对应关系</strong><br>通过<strong>Children</strong>属性声明<strong>子路由规则</strong><br>在src&#x2F;router&#x2F;index.js路由模块中，导入需要的组件，并通过children属性声明子路由规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tab1</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab2</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">      <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：子路由规则，不要以斜线开头！</font></p>
</li>
<li><p>嵌套路由的路由重定向<br>在right的路由规则中加上redirect即可，这样路径&#x2F;right就直接跳转到了&#x2F;right&#x2F;tab2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">  &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/right/tab2&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认子路由</strong><br>除了使用redirect路由重定向，还可以使用默认子路由<br>默认子路由：如果children数组中，某个路由规则的path值为空字符串，则这条路由规则，叫做“默认子路由”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // right页面的路由规则(父级路由规则)</span><br><span class="line">  path: &#x27;/right&#x27;,</span><br><span class="line">  component: Right,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; path: &#x27;&#x27;, component: Tab1 &#125;,</span><br><span class="line">    &#123; path: &#x27;tab1&#x27;, component: Tab1 &#125;,//也可以不写这条规则，而是把tab1的路由标签改为/right</span><br><span class="line">    &#123; path: &#x27;tab2&#x27;, component: Tab2 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认子路由和重定向都可以展示出children里面的某一个子组件。</strong></p>
</li>
</ul>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>思考：有如下3个路由链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义如下3个路由规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/3&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：路由规则的复用性差</strong></p>
<ol>
<li><p>动态路由的概念<br>动态路由指的是:把 Hash地址 中<strong>可变的部分</strong>定义为<strong>参数项</strong>，从而<strong>提高路由规则的复用性</strong>。<br>在vue-router中使用<strong>英文的冒号</strong>( <strong>:</strong> )来定义路由的参数项。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由中的动态参数以︰进行声明，冒号后面的是动态参数的名称</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>将多个路由规则，合并成了一个，提高了路由规则的复用性</strong><br><font color="red">注意：路由链接的跳转地址是不能出现冒号<code>:</code>的！<code>&lt;router-link to=&quot;/movie/1&quot;&gt;电影1&lt;/router-link&gt;</code></font></p>
</li>
<li><p>在组件中拿到动态参数项的值<br>  <code>this.$route</code>是路由的<strong>“参数对象”</strong><br>  <code>this.$router</code>是路由的<strong>“导航对象”</strong><br>  要想拿到上面movie的id值应该通过：<code>this.$route.params.id</code></p>
</li>
</ol>
<h3 id="为路由规则开启prop传参"><a href="#为路由规则开启prop传参" class="headerlink" title="为路由规则开启prop传参"></a>为路由规则开启prop传参</h3><p>简化拿参数的方式。这种方式和<code>this.$route.params.id</code>是彼此独立的，想用哪个就用哪个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="comment">// 为当前这条路由规则开启props传参</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// movie.vue</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>] <span class="comment">// 这样就拿到了</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展-query-和-fullPath"><a href="#拓展-query-和-fullPath" class="headerlink" title="拓展 query 和 fullPath"></a>拓展 query 和 fullPath</h3><ol>
<li><p>在 hash 地址中，&#x2F; 后面的参数项，叫做 “路径参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.params</code> 来访问路径参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 hash 地址中，？后面的参数项，叫做 “查询参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.query</code> 来访问查询参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2?name=zs age=20&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>this.$route</code>中，path只是路径部分; fullPath是完整的地址<br>  <code>/movie/2</code> 是 path 的值<br>  <code>/movie/2?name=zs age=20</code> 是 fullPath 的值</p>
</li>
</ol>
<h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>导航就是跳转的意思，组件之间的切换，它专业的术语叫导航。</p>
<h3 id="声明式导航-编程式导航"><a href="#声明式导航-编程式导航" class="headerlink" title="声明式导航 &amp; 编程式导航"></a>声明式导航 &amp; 编程式导航</h3><ul>
<li><p>在浏览器中，<strong>点击链接</strong>实现导航的方式，叫做<strong>声明式导航</strong>。<br>例如：<br>普通网页中点击a链接、vue 项目中点击router-link都属于声明式导航</p>
</li>
<li><p>在浏览器中，<strong>调用API方法</strong>实现导航的方式，叫做<strong>编程式导航</strong>。<br>例如<br>普通网页中调用<code>location.href</code>跳转到新页面的方式，属于编程式导航</p>
</li>
</ul>
<h4 id="vue-router-中的编程式导航API"><a href="#vue-router-中的编程式导航API" class="headerlink" title="vue-router 中的编程式导航API"></a>vue-router 中的编程式导航API</h4><p>vue-router(导航对象)提供了许多编程式导航的API，其中最常用的导航API分别是:</p>
<ol>
<li><p><code>this.$router.push(&#39;hash地址&#39;)</code><br>  跳转到指定 hash 地址，并<strong>增加</strong>一条历史记录</p>
</li>
<li><p><code>this.$router.replace(&#39;hash地址&#39;)</code><br>  跳转到指定的hash地址，并<strong>替换掉当前的</strong>历史记录</p>
</li>
<li><p><code>this.$router.go(数值n)</code><br>  n可以是正数也可以是负数，在浏览历史里面进行<strong>前进和后退</strong></p>
</li>
<li><p><code>$router.go</code>的简化用法<br>在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法:<br>  (1) <code>$router.back()</code>：在历史记录中，<strong>后退</strong>到上一个页面<br>  (2) <code>$router.forward()</code>：在历史记录中，<strong>前进</strong>到下一个页面</p>
</li>
</ol>
<p><font color="red">注意：在行内使用编程式导航跳转的时候，this必须要省略，否则会报错！</font></p>
<h3 id="路由导航守卫-–-控制路由的访问权限"><a href="#路由导航守卫-–-控制路由的访问权限" class="headerlink" title="路由导航守卫 – 控制路由的访问权限"></a>路由导航守卫 – 控制路由的访问权限</h3><p><strong>导航守卫</strong>可以<strong>控制路由的访问权限</strong>。</p>
<p>假设规定，当前项目中，main这个后台主页只有登陆以后才允许被访问(前提)<br>怎么证明你有没有登陆————token<br>可以读你的localStorage，看里面有没有token值，如果有就认为你已经是登录了，没有就认为你没有登陆。</p>
<p><img src="/tsukimiya.github.io/images/vue/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB.png" alt="image"></p>
<ol>
<li><p>全局前置守卫<br>  前置：比如从a跳到b，还没跳过去，就会触发守卫。<br>  每次发生路由的<strong>导航跳转</strong>时，都会触发<strong>全局前置守卫</strong>。因此，在全局前置守卫中，程序员可以<strong>对每个路由进行访问权限的控制</strong>:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"><span class="comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫”</span></span><br><span class="line"><span class="comment">//每次发生路由导航跳转的时候，都会自动触发 fn 这个“回调函数”</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(fn)</span><br></pre></td></tr></table></figure>
</li>
<li><p>守卫方法的3个形参<br>  全局前置守卫的回调函数中接收3个形参，格式为:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局前置守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ro 是将要访问的路由的信息对象</span></span><br><span class="line">  <span class="comment">// from 是将要离开的路由的信息对象</span></span><br><span class="line">  <span class="comment">// next 是一个函数，调用next() 表示放行，允许这次路由导航</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>next函数的3种调用方式<br>具体使用哪一种，看自己的需求<br><img src="/tsukimiya.github.io/images/vue/next%E5%87%BD%E6%95%B0%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="image"></p>
</li>
</ol>
<ul>
<li>全局前置守卫控制访问权限简单示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为router实例对象，声明全局前置导航守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 分析：</span></span><br><span class="line">  <span class="comment">// 1. 要拿到用户将要访问的hash地址 </span></span><br><span class="line">  <span class="comment">// 2. 判断hash地址是否等于/main</span></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; <span class="comment">// 等于 /main ，证明需要登陆之后才能访问成功，</span></span><br><span class="line">    <span class="comment">// 需要读取 localStorage 中的 token值</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() <span class="comment">// 有token值，则已登录 放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 无 token值 则强制跳转到login登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不等于则访问的不是后台主页,不需要登陆 直接放行 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
vue的导航守卫中除了全局前置守卫之外，还有全局解析守卫、全局后置钩子、路由独享的守卫、组件内的守卫，共5种<br>其中，<strong>全局前置守卫的用法是最常见的</strong>，后面的几种后续会进行补充</li>
</ul>
<h2 id="案例练习"><a href="#案例练习" class="headerlink" title="案例练习"></a>案例练习</h2><ul>
<li><p><a href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=87.0&p=193">路由应用案例</a></p>
<blockquote>
<p>后台管理案例</p>
</blockquote>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=204">黑马头条</a></p>
<blockquote>
<p>SPA单页面应用程序 移动端 简单案例<br>  实现下拉刷新、上拉加载更多功能、Vant组件库的使用</p>
</blockquote>
<p>  配置：Babel、Router、CSS Pre-processors、Linter &#x2F; Formatter、Vue 2.x<br>  选择路由模式 – Use history mode for router？ – N</p>
<blockquote>
<p>history mode for router 需要和后端配合使用，兼容性比较差<br>#开头的hash值所表示的路由，通用性更强，低级还是高级的浏览器都支持</p>
</blockquote>
<p>  css预处理器 – less<br>  ESLint – Standard config 标准配置<br>  Lint on save 在保存的时候进行格式的检查</p>
<p>  项目结构：<br>  views文件夹</p>
<blockquote>
<p>如果某个组件，是通过路由进行动态展示和切换的，这种组件要放到views里面<br>  如果某个组件不是通过路由切换的，是一个可复用的组件，那么这个组件要放到components里面</p>
</blockquote>
</li>
</ul>
<h3 id="Vant组件库"><a href="#Vant组件库" class="headerlink" title="Vant组件库"></a>Vant组件库</h3><p>轻量、可靠的移动端组件库<br><a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">Vant2官方文档</a>(适用于 Vue2 开发) <a href="https://vant-ui.github.io/vant/#/zh-CN/">Vant4官方文档</a>(适用于 Vue3 开发)</p>
<ol>
<li><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Vue 3 项目，安装最新版 Vant：</span><br><span class="line">npm i vant -S</span><br><span class="line"></span><br><span class="line"># Vue 2 项目，安装 Vant 2：</span><br><span class="line">npm i vant@latest-v2 -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入组件<br>我们选择最便捷的方式 – 导入所有组件</p>
<blockquote>
<p>虽然官方推荐的做法是：自动按需引入组件。但是配起来太复杂了，成本太高了<br>引入所有组件会增加代码包体积，但是开发的时候我们怎么快怎么来，不用考虑体积的问题<br>在发布的时候，我们可以进行项目体积的优化，可以直接把Vant从项目里面抽出去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vant</span> <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vant</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br>查阅官方文档即可<br><a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">Vant2官方文档</a>(适用于 Vue2 开发)<br><a href="https://vant-ui.github.io/vant/#/zh-CN/">Vant4官方文档</a>(适用于 Vue3 开发)<br><font color="red">注意：在使用Vant组件的时候，如果某个组件的某个属性默认值是false，希望把它改成true，直接把这个属性写上就可以了</font><br>如：<code>&lt;van-nav-bar title=&quot;标题&quot; fixed placeholder /&gt;</code><br>相当于<code>&lt;van-nav-bar title=&quot;标题&quot; :fixed=&#39;ture&#39; :placeholder=&#39;true&#39; /&gt;</code><br>这里给属性值类型是布尔值，所以要用v-bind绑定，否则是字符串</p>
</li>
<li><p><strong>覆盖Vant组件的样式</strong>： <a href="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F#deep-%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F"><strong>&#x2F;deep&#x2F; 样式穿透</strong></a></p>
<p> 还可以通过Vant组件库提供的定制主题，来直接改变组件的样式，这样在每个组件使用该组件都不需要再去修改。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main.js中 引入全部样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="comment">// 这个文件是 vue-cli 创建出来的项目的配置文件</span></span><br><span class="line"><span class="comment">// 在vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">          <span class="attr">modifyVars</span>: &#123;</span><br><span class="line">            <span class="comment">// 直接覆盖变量</span></span><br><span class="line">            <span class="comment">// 这里是覆盖了 NavBar 导航栏 的背景色</span></span><br><span class="line">            <span class="string">&#x27;nav-bar-background-color&#x27;</span>: <span class="string">&#x27;red&#x27;</span> <span class="comment">// #007bff</span></span><br><span class="line">            <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            <span class="comment">// hack: `true; @import &quot;your-less-file-path.less&quot;;`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 缺点：需要修改配置文件，必须重启打包服务器，太过麻烦，所以了解即可，实际开发不会这么使用<br> 而是通过 less 文件覆盖进行主题的定制：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">hack</span>: <span class="string">`true; @import &quot;your-less-file-path.less&quot;;`</span></span><br></pre></td></tr></table></figure>
<p> <strong>好处：不用重启打包服务器，直接改就能生效</strong></p>
</li>
</ol>
<h3 id="通过less文件覆盖进行主题定制"><a href="#通过less文件覆盖进行主题定制" class="headerlink" title="通过less文件覆盖进行主题定制"></a>通过less文件覆盖进行主题定制</h3><p>如：在src目录下新建一个theme.less</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在theme.less文件中，覆盖Vant官方的less变量值</span></span><br><span class="line"><span class="variable">@blue:</span> <span class="number">#007bff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖 Navbar 的 less 样式</span></span><br><span class="line"><span class="variable">@nav-bar-background-color:</span> <span class="variable">@blue</span>;</span><br></pre></td></tr></table></figure>
<p>然后配置vue.config.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个文件是 vue-cli 创建出来的项目的配置文件</span></span><br><span class="line"><span class="comment">// 在vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack在进行打包的时候，底层用到了node .js</span></span><br><span class="line"><span class="comment">// 因此，在vue.config.js 配置文件中，可以导入并使用node.js中的核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> themePath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;/src/theme.less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">          <span class="attr">modifyVars</span>: &#123;</span><br><span class="line">            <span class="comment">// 通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            <span class="attr">hack</span>: <span class="string">`true; @import &quot;<span class="subst">$&#123;themePath&#125;</span>&quot;;`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h2><p>这个文件是 vue-cli 创建出来的项目的配置文件<br>在这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</p>
<p>项目开发完成之后，可以npm run build进行打包<br>最终项目里面会有个dist文件夹，里面有个index.html首页</p>
<p>但是有个问题：我们直接进入dist目录，双击这个首页打开，是看不到效果的。<br>因为：默认情况下，我们运行npm run build打包生成的dist，里面的这些文件，只能发布到服务器上，通过http协议才可以正常被打开。而双击打开的是file协议，所以看不到效果</p>
<p>如果想要看到效果，需要做一下打包发布的配置：<a href="https://cli.vuejs.org/zh/config/#publicpath">vue.config.js-publicPath</a><br>在vue.config.js配置文件中设置publicPath为’.&#x2F;‘，再次打包文件，即可在文件夹中双击打开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>publicPath</strong><br>部署应用包时的基本 URL。<br>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <a href="https://www.my-app.com/">https://www.my-app.com/</a><br><strong>如果应用被部署在一个子路径上</strong>，你就需要<strong>用这个选项指定这个子路径</strong>。例如，如果你的应用被部署在 <a href="https://www.my-app.com/my-app/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AE">https://www.my-app.com/my-app/，则设置</a> publicPath 为 &#x2F;my-app&#x2F; 。</p>
<p>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘.&#x2F;‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p>
<p>相对路径的 publicPath 有一些使用上的限制。在以下情况下，应当避免使用相对 publicPath:</p>
<ul>
<li>当使用基于 HTML5 history.pushState 的路由时；</li>
<li>当使用 pages 选项构建多页面应用时。</li>
</ul>
</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="hash地址注意点"><a href="#hash地址注意点" class="headerlink" title="hash地址注意点"></a>hash地址注意点</h3><p>hash地址里面字母都要是小写，<font color="red">url地址里面不要出现大写字符或字母</font>。<br>除非是一些 搜索关键字 可以出现大写</p>
<h3 id="有权限的hash地址"><a href="#有权限的hash地址" class="headerlink" title="有权限的hash地址"></a>有权限的hash地址</h3><p>在导航守卫 – 全局前置守卫中<br>这个if是判断我们访问的是否是一个有权限的hash地址：<code>if (to.path === &#39;/main&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们项目中有多个页面，都需要访问权限，这一个判断肯定满足不了我们的需求<br>我们可以在后面加 或 <code>|</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home/users&#x27;</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是条件会变的越来越长</p>
<p>我们还可以通过数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pathArr = [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> (pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>后面有任何的地址，都可以放到数组里面去<br>如果觉得多了以后，数组也会变的特别长，可以把这个数组单独处理为js文件，需要的时候再导入过来。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/pathArr.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="keyword">import</span> pathArr <span class="keyword">from</span> <span class="string">&#x27;@/router/pathArr.js&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//不需再声明</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>)!=-<span class="number">1</span>)&#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用meta属性进行权限处理"><a href="#使用meta属性进行权限处理" class="headerlink" title="使用meta属性进行权限处理"></a><font color="green">使用meta属性进行权限处理</font></h3><p><font color="red">可以配置meta属性，使用前置守卫进行判断是否需要进行权限处理，会方便很多</font></p>
<ol>
<li><p>配置 <code>meta</code> 属性<br>  在路由配置中，可以在每个路由的 <code>meta</code> 属性中指定需要进行权限处理的信息。例如:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Admin</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">requiresAuth</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] <span class="comment">// 用于指定可以访问特定路由的用户的角色</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他路由...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>/admin</code> 路由需要进行权限处理，只有具有 <code>admin</code> 角色的用户才能访问。</p>
</li>
<li><p>使用前置守卫<br>  在 Vue Router 中，使用 <code>beforeEach</code> 前置守卫来拦截导航并执行权限检查：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span>) &#123;<span class="comment">// 检查是否需要进行权限处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isAuthenticated</span>()) &#123;<span class="comment">// 检查用户是否已登录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasRequiredRoles</span>(to.<span class="property">meta</span>.<span class="property">roles</span>))&#123; <span class="comment">// 检查用户是否具有所需的权限</span></span><br><span class="line">          <span class="title function_">next</span>()<span class="comment">// 允许导航</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">&#x27;/no-access&#x27;</span>) <span class="comment">// 无权限，重定向到无权限页面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)<span class="comment">// 未登录，重定向到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不需要权限处理，允许导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  其中，isAuthenticated() 和 hasRequiredRoles() 是自定义函数，用于检查用户是否已登录以及是否具有所需的权限。</p>
</li>
</ol>
<ul>
<li><p><strong>isAuthenticated()函数 ：用于检查用户是否已登录</strong><br><strong>通常用于判断用户是否携带有效的 token</strong>。<br>实际应用中，可以根据自己的后端 API 设计来实现 isAuthenticated() 函数：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的 token。</li>
<li>向后端 API 发送一个请求，携带用户的 token。</li>
<li>后端 API 验证 token 的有效性。</li>
<li>如果 token 有效，后端 API 返回成功响应。</li>
<li>isAuthenticated() 函数返回 true，表示用户已登录。</li>
<li>否则，isAuthenticated() 函数返回 false，表示用户未登录或 token 无效。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isAuthenticated</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取 token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;<span class="comment">// 如果 token 存在，向后端 API 发送请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/verify-token&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;  <span class="comment">// &#x27;data&#x27; 是一个 JavaScript 对象，包含从服务器接收到的 JSON 数据</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果 token 有效，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 无效，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 不存在，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>.then(res =&gt; res.json())</code> 是 JavaScript Promise 链中的一个回调函数。<br>作用: 将服务器返回的 HTTP 响应对象 (res)————服务器响应的主体部分（JSON 字符串） 转换为一个纯 JavaScript 对象，并将其传递给下一个 .then() 回调函数。<br>注意：<br>只有当服务器响应的 Content-Type 头部设置为 <code>application/json</code> 时，<code>res.json()</code> 方法才能正常工作。<br>如果服务器响应的主体部分不是有效的 JSON 字符串，<code>res.json()</code> 方法会抛出一个错误。</li>
</ol>
</li>
<li><p><strong>hasRequiredRoles() 函数用于检查用户是否具有访问特定路由所需的权限。</strong><br>它的实现方式取决于你的具体应用程序和后端 API 设计。<br>一种常见的方法：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的角色。</li>
<li>将用户的角色与路由配置中指定的所需角色进行比较。</li>
<li>如果用户具有所有必需的角色，则返回 true，表示用户具有访问权限。</li>
<li>否则，返回 false，表示用户没有访问权限。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userRoles = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;roles&#x27;</span>)<span class="comment">// 从本地存储中获取用户的角色</span></span><br><span class="line">  <span class="comment">// 将用户的角色与所需的权限进行比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; requiredRoles.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!userRoles.<span class="title function_">includes</span>(requiredRoles[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果用户具有所有必需的角色，返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>另一种方法：<br>向后端 API 发送一个请求，携带用户的 token 和路由的所需角色。后端 API 检查用户的权限并返回一个响应，指示用户是否具有访问权限。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取用户的 token</span></span><br><span class="line">  <span class="comment">// 向后端 API 发送请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/check-permissions&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">requiredRoles</span>: requiredRoles</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果用户具有访问权限，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果用户没有访问权限，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h3><p><a href="https://less.bootcss.com/">Less</a> 是一种可编程的样式语言。</p>
<p><code>@</code>是在less语法里面，专门定义变量的一种格式<br>支持我们以编程的方式来写CSS代码</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@width:</span> <span class="number">10px</span>;</span><br><span class="line"><span class="variable">@height:</span> <span class="variable">@width</span> + <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>路由</tag>
        <tag>动态路由</tag>
        <tag>路由重定向</tag>
        <tag>Vue2</tag>
        <tag>axios</tag>
        <tag>路由嵌套</tag>
        <tag>路由导航</tag>
        <tag>Vant</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/tsukimiya.github.io/hello%20world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/tsukimiya.github.io/guestbook/index.html</url>
    <content><![CDATA[<h1 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的博客！</h1><blockquote>
<p>欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的。目前留言板块尚未配置完全，暂时无法使用，如有问题请邮箱：<br><a href="mailto:&#104;&#97;&#x72;&#105;&#105;&#106;&#105;&#99;&#111;&#x40;&#111;&#117;&#116;&#108;&#111;&#x6f;&#x6b;&#x2e;&#x63;&#x6f;&#x6d;">&#104;&#97;&#x72;&#105;&#105;&#106;&#105;&#99;&#111;&#x40;&#111;&#117;&#116;&#108;&#111;&#x6f;&#x6b;&#x2e;&#x63;&#x6f;&#x6d;</a><br><a href="mailto:&#49;&#x38;&#x33;&#x32;&#55;&#49;&#x35;&#56;&#51;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#49;&#x38;&#x33;&#x32;&#55;&#49;&#x35;&#56;&#51;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a><br>欢迎给我发送邮件</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Hello Front-end</title>
    <url>/tsukimiya.github.io/index.html</url>
    <content><![CDATA[<p>Welcome to my study blog! This is my continuously make up a main post. If you get any problems when using my blog, you can send the email to <a href="mailto:&#x68;&#x61;&#x72;&#x69;&#105;&#106;&#x69;&#99;&#111;&#64;&#x6f;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;">&#x68;&#x61;&#x72;&#x69;&#105;&#106;&#x69;&#99;&#111;&#64;&#x6f;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;</a></p>
<h2 id="Study-Guide"><a href="#Study-Guide" class="headerlink" title="Study Guide"></a>Study Guide</h2><center>Here provide you some study sources and study route.</center>
<!-- This is [main tech](#Main-Line) -->
<center>This is <a href='#Main-Line'>main tech</a></center>


<h3 id="Guide-Docs"><a href="#Guide-Docs" class="headerlink" title="Guide Docs"></a>Guide Docs</h3><ul>
<li>ES6<ul>
<li>《ECMAScript 6 教程》– 阮一峰 <a href="https://es6.ruanyifeng.com/"><font color='red'>官方</font></a> <a href="https://wangdoc.com/es6/">网道镜像</a> <blockquote>
<p>网道(<a href="https://wangdoc.com/">https://wangdoc.com/</a>) 是一个文档网站，提供互联网开发文档。PC显示更佳。<br>  阮一峰博客的移动端显示更佳  推荐</p>
</blockquote>
</li>
</ul>
</li>
<li>Vue<ul>
<li><a href="https://cn.vuejs.org/guide/introduction.html"><font color='red'>Vue.js 官方文档</font></a></li>
</ul>
</li>
</ul>
<h3 id="Nice-Tools"><a href="#Nice-Tools" class="headerlink" title="Nice Tools"></a>Nice Tools</h3><ul>
<li><p><a href="https://www.lodashjs.com/">Loadsh 中文文档</a>(鲁大师) <font color='red'> 推荐 </font></p>
<blockquote>
<p>鲁大师 提供了许多牛逼的函数 节流、防抖、操作数组、对象的一系列函数（对象的深拷贝、浅拷贝）<br>轶事：lodash为什么叫lodash? lodash可以理解为low dash，dash就是中划线-，比较low的dash就是下划线_，因为之前有一个underscore类库，也是用下划线表示，开发一个新类，沿用以前的传统，所以就用了一个同义词lodash(low dash)。</p>
</blockquote>
</li>
<li><p><a href="https://cn.vuejs.org/guide/introduction.html"><font color='red'>Vue.js 官方文档</font></a> </p>
</li>
<li><p>JQuery API 中文在线文档&#x2F;速查表</p>
<ul>
<li><p>by Shifone <a href="https://www.bejson.com/apidoc/jquery/">地址1</a> 地址2(<a href="https://jquery.cuishifeng.cn/">失效了</a>)（不过看过的一些API的解释和案例都写的不好）</p>
</li>
<li><p>by hemin <a href="http://hemin.cn/jq/"><font color='red'>地址</font></a> (解释和案例写的比较好)</p>
</li>
</ul>
</li>
<li><p><a href="https://regexr-cn.com/">正则表达式测试工具</a>(<a href="https://regexr-cn.com/">https://regexr-cn.com/</a>)</p>
</li>
<li><p><a href="https://base64.us/">Base64 在线编码解码</a>(<a href="https://base64.us/">https://base64.us/</a>)</p>
<blockquote>
<p>也可以选择图片文件来获取它的 Base64 编码的 DataURI 形式</p>
</blockquote>
</li>
<li><p><a href="https://www.iconfont.cn/">阿里巴巴矢量他图标库</a>(<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a>) <font color='red'> 推荐 </font></p>
</li>
<li><p><a href="https://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a>(<a href="https://www.xuanfengge.com/funny/html5/element/">https://www.xuanfengge.com/funny/html5/element/</a>)</p>
</li>
</ul>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><ol>
<li><p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">鱼皮前端学习路线</a></p>
<blockquote>
<p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">https://www.codefather.cn/前端学习路线-by-程序员鱼皮/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习路线</a></p>
<blockquote>
<p><a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
</ol>
<h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ol>
<li><p><a href="https://www.freecodecamp.org/chinese/learn">freecodecamp编程免费教学慈善组织</a></p>
<blockquote>
<p>编程学习课程(可以获得认证，有官方中文) <a href="https://www.freecodecamp.org/chinese/learn">https://www.freecodecamp.org/chinese/learn</a></p>
</blockquote>
<blockquote>
<p>也有程序员英文学习课程——<a href="https://www.freecodecamp.org/chinese/learn/a2-english-for-developers/">学习面向开发者的英语课程</a></p>
</blockquote>
<blockquote>
<p>对应的<a href="https://www.freecodecamp.org/chinese/news/">专栏</a> 可以阅读学习一些技术文章</p>
</blockquote>
<blockquote>
<p>对应的<a href="https://forum.freecodecamp.org/c/chinese/533">学习论坛</a> 也是支持中文的</p>
</blockquote>
</li>
<li><p><a href="https://www.w3cschool.cn/codecamp/">w3c编程入门实战训练</a></p>
<blockquote>
<p><a href="https://www.w3cschool.cn/codecamp/">https://www.w3cschool.cn/codecamp/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习</a></p>
<blockquote>
<p>同样是阿里云学习路线的网页，两者都在一个界面<br> <a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
<li><p><a href="https://time.geekbang.org/column/intro/154">极客时间前端基础 ￥59</a></p>
<blockquote>
<p>主讲人 程劭非（winter）  前手机淘宝前端负责人<br> 讲解JS、HTML、CSS、浏览器<br> <a href="https://time.geekbang.org/column/intro/154">https://time.geekbang.org/column/intro/154</a></p>
</blockquote>
</li>
</ol>
<h3 id="Necessary-Tech"><a href="#Necessary-Tech" class="headerlink" title="Necessary Tech"></a>Necessary Tech</h3><p><a href="https://www.bilibili.com/video/BV1eC411p73m/">前端技术的十八年风雨(2006-2024)-bilibili</a></p>
<h4 id="Main-Line"><a href="#Main-Line" class="headerlink" title="Main Line"></a><font id='Main-Line' color='red'>Main Line</font></h4><ol>
<li><p>前端三剑客基础 HTML5 – CSS3 – JS5&#x2F;ES5</p>
<blockquote>
<p>H5引入了许多新特性和API，如语义化元素、表单控件、图形和多媒体元素，以及各种Web API等等<br>CSS3的新特性：如圆角(border-radius)、阴影(box-shadow、text-shadow)、渐变(gradient)、动画(animation)、过渡(transition)、弹性布局(flex)等</p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马JS最新教程</a> (2023.1.31 | 60:10:24)<br> Pink老师最新版JS课程，主要讲解JS核心知识，包含最新ES6语法、API、js高级等<br> <a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">https://www.bilibili.com/video/BV1Y84y1L7Nn</a></p>
</blockquote>
</li>
<li><p>三剑客进阶 移动Web&#x2F;<font color='red'>web API</font> – Less – Sass – <font color='red'>ES6</font></p>
<blockquote>
<p>移动web要学习一些web API、布局来更好的适配页面，如Flex 或是em vw vh等</p>
</blockquote>
<blockquote>
<p>Less、Sass可以说是css的超类</p>
</blockquote>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br> Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
<blockquote>
<p>ES6对JS进行了语法改进，还增加了<strong>类和继承、Promise等特性</strong>，最重要的是<strong>制定了模块化标准</strong>，为开发者提供了更好的开发工具和语言特性，使得JS变的更加现代化、强大灵活<br> <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">黑马ES6教程</a> (19.7.31 | 91-122p)<br> 阮一峰es6教程 – <a href="https://es6.ruanyifeng.com/">官方</a> | <a href="https://wangdoc.com/es6/intro">网道镜像</a> <font color="red">推荐</font></p>
</blockquote>
</li>
<li><p>前端库&#x2F;工具 jQuery – bootStrap – ajax</p>
<blockquote>
<p>bootStrap是使用jQuery库来实现的？</p>
</blockquote>
</li>
<li><p>版本管理工具 git</p>
<blockquote>
<p>不过一开始应该不会用到，可以在学过node之后再学更好些</p>
</blockquote>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">黑马Git教程</a>(17.1.16 | 75-101p | 4h5min)</p>
<blockquote>
<p>很细，可以结合下面的文章补充<br>  建议先看廖雪峰的教程到git安装的地方，再开始学这个，然后廖雪峰教程跟进<br>  <a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">https://www.bilibili.com/video/BV1zs411h74a?t=8.1&amp;p=75</a></p>
</blockquote>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a> – 廖雪峰 </p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a><br>  因为是文章，所以会有地方不如视频直观明了，也有一些没说到的地方，但是也有很多视频中没有的东西</p>
</blockquote>
</li>
</ul>
</li>
<li><p>JS运行环境 ———— <font color='red'>Node.js</font></p>
<blockquote>
<p>Node.js是一个基于Chrome V8引擎的JS运行时环境，用于构建快速、可扩展的网络应用程序。之后，开发者就可以用JS来写服务端程序。</p>
<blockquote>
<p>node主要学习npm包管理器及各种包(工具)的使用<br> 学习node之后会让你更顺利的学习各种框架以及git<br> 学习node也会加深你对前后端交互以及后端的理解<br>Node.js采用非阻塞I&#x2F;O模型，能够高效处理大量并发请求，从响应效率上比同时代PHP更有优势</p>
</blockquote>
</blockquote>
<ul>
<li><strong>KoaJS</strong>(2013)<blockquote>
<p>Koa是Express的下一代框架，旨在解决Express中一些设计上的限制和缺陷，使得异步编程更加优雅、代码更加清晰、应用更急啊灵活</p>
</blockquote>
</li>
</ul>
</li>
<li><p>目前主流框架 <font color='red'>Vue(2014 尤雨溪) &#x2F; React(2013 Facebook)</font> &#x2F; <font color='#555'>Angular(2009 Google)</font></p>
<blockquote>
<ol>
<li><strong>Angular</strong>（不必要学，很多银行国企在用）(2009)<br>  2009年 由Google发布，引入了许多新概念，如双向数据绑定、依赖注入和模板化，为Web开发带来了革命性的变化，也为后续的SPA框架(单页面应用程序)发展奠定了基础。<br>  然而AngularJS是典型的“精英”框架，用后端思维设计的前端框架，直接沿用了MVC思想，加上很多首创的概念，比较晦涩难懂，因此不怎么流行<br>  angularjs和.net在国内同等命运，先进但无人问津，招人困难所以转vue+java</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>Vue</strong>(2014)<br>  Vue结合了Angular和React的优点，同时提供了更简洁的API和更灵活的设计，Vue的开发方式更像之前的套模版，使得开发者无缝过度，深受喜爱。<br>  Vue极为接地气，组件了活跃的社区，由社区编写了各语种的开发文档，每项说明都配上实例，还提供了各种应用场景的代码 DEMO<blockquote>
<p>Vue支持Webpack构建工具的使用<br>  原生Vue组件在js文件中的使用、Vue Cli脚手架、Element UI<br>  vue的核心原理（MVVM）、了解vue生命周期、组件传值、路由、vuex</p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>2.1 <strong>Nuxt.js</strong>(2016)<br>     在Next.js的启发下，Vue阵营出现了Nuxt，功能和Next几乎一模一样，给Vue提供了开箱即用的丰富功能和工具，使得Vue开发应用更加高效便捷<br>2.2 <strong>Uni-App</strong>(2018)（uni,unique,是统一的意思）<br>     是一款 使用Vue.js开发所有前端应用的 跨平台应用开发框架，开发者编写一套代码 基于Vue开发应用，可发布到iOS、Android、Web（响应式）&#x2F;H5、以及各种小程序、快应用等多个平台。<br>2.3 <strong>Vue3</strong>(2020)<br>     Vue3增加了组合式开发模式、增加了TS支持、引入了全新的Composition API，更加适应现代化前端的开发模式。同时，尤雨溪还推出了现代化前端构建工具Vite。<br>2.4 <strong>Vite</strong>(2020)<br>     Vite利用模块 热更新、按需编译等特性，为开发者提供了一种快速、轻量级、现代化的前端构建工具，填补了Webpack的性能瓶颈。</p>
</blockquote>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>React</strong>(2013)<br>  React引入了虚拟DOM的概念、组件化开发、单向数据流、使用JSX语法等等，极大的改变了前端的开发方式，推动了前端开发向组件化、高性能、高效率的方向发展。</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>3.1 <strong>React Native</strong>(2015)<br>     基于React开发的框架，使用JS和React的语法来构建原生移动应用。通过它，开发者可以使用相同的代码库构建同时运行在ios和Android平台上的原生应用。<br>3.2 <strong>Next.JS</strong>(2016)<br>     Next.JS是一个基于React的轻量级框架，提供了服务器端渲染、静态导出等功能，简化了React应用的开发和部署，使得React应用更易于优化和扩展，同时提供了更好的性能和SEO支持，成为构建现代Web应用的流行选择。 </p>
<blockquote>
<p>3.2.1 <strong>Server Actions</strong>(2023)<br>     2023年，Next.js14版本推出Server Actions，允许开发者直接在组件编写服务端代码,这张图被称作“科技圈最讨厌图片”，不少开发者困惑，这不就是PHP吗，因此Next.js也被戏称为Next.php<br>     <img width='300px' src='./images/Server%20Actions.png' /></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.3 <strong>Taro</strong>（2018）<br>     Taro除了是基于react之外，其他的功能与UniApp一模一样<br>     <code>2019年疫情爆发，人员统计、表单收集、健康码等等都是临时性、紧迫性的业务需求，没有现成的产品使用，过去呢种动辄上月甚至数年的开发周期显然不能满足，此时小程序承载了这一巨任，经常会有数天开发周期的小程序出现供防疫工作使用。在这里头UniApp和Taro充分发挥了它们的作用，尽管小程序是畸形发展的产物、UniApp和Taro开发会出现数不尽的兼容问题，但不可否认，这三年，它们对防疫工作的贡献是巨大的。</code></p>
</blockquote>
</blockquote>
<blockquote>
<ol start="4">
<li>React与Vue的对比<ol>
<li>国内比较推崇vue，而国外则比较偏爱React。目前国内中小公司仍以vue为主，不过部分也开始转向React，大公司则比较倾向React。</li>
<li>Vue使用模版语法，对元素实行绑定，是传统的HTML、CSS、JS分离式编程</li>
<li>React将用户界面抽象为组件的集合，强调组件之间的高度重用性，采用了反直觉的将HTML、CSS、JS封装在一起</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="PC-or-408-or-ELSE"><a href="#PC-or-408-or-ELSE" class="headerlink" title="PC or 408 or ELSE"></a>PC or 408 or ELSE</h4><ul>
<li><p>理解 OSI 模型和 TCP&#x2F;IP 协议族</p>
</li>
<li><p>学习 SSL&#x2F;TLS 协议和加密通信技术，保障网络通信的安全性。</p>
</li>
<li><p>掌握常见的安全协议如 HTTPS、SSH 等的原理和使用方法。</p>
</li>
<li><p><font color='red'>XXS 跨站脚本</font></p>
<blockquote>
<p>学习 XSS 攻击的基本原理，包括攻击者向网站注入恶意脚本代码，以及受害者浏览网站时执行恶意脚本的过程。</p>
</blockquote>
<blockquote>
<p>学习如何发现网站中的 XSS 漏洞，包括手动审查源代码、使用自动化工具进行漏洞扫描等方法。</p>
</blockquote>
<blockquote>
<p>学习反射型 XSS、存储型 XSS 和 DOM 型 XSS 等不同类型的 XSS 攻击，了解它们的区别和特点。</p>
</blockquote>
<blockquote>
<p>了解攻击者利用 XSS 漏洞进行的一些常见攻击，如窃取用户信息、会话劫持、网站篡改等。</p>
</blockquote>
</li>
<li><p>DDOS 分布式拒绝服务攻击</p>
<blockquote>
<p>网络攻击，旨在使目标系统或网络资源不可用，通常是通过使目标系统或网络过载或崩溃来实现的。攻击者利用大量的合法或非法的网络流量向目标系统发送请求，导致目标系统无法处理正常的用户请求，从而使其服务不可用。</p>
</blockquote>
</li>
</ul>
<h4 id="Else-Tech"><a href="#Else-Tech" class="headerlink" title="Else Tech"></a>Else Tech</h4><p>一些分支以及完全不是前端的技术</p>
<ul>
<li><p>构建工具 <strong>Webpack</strong>(2012)、Parcel</p>
<blockquote>
<p>在2016年，在ES6&#x2F;ES 2015的一剂强心丸的影响下，Webpack支持ES Module，Webpack开始在前端社区迅速流行。特别是在React和Vue等流行框架的支持下，Webpack的使用逐渐成为前端开发的标配</p>
</blockquote>
</li>
<li><p>包管理器<strong>npm</strong>、Yarn</p>
</li>
<li><p><strong>TypeScript</strong>（TS）(2012)</p>
<blockquote>
<p>2012年问世，由于JS是动态语言，意味着JS基本与大型项目无缘，或者需要承担巨大的维护代价，而TS的出现，使得JS可以像静态语言一样开发项目，赋予JS无限的可能。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV14Z4y1u7pi?t=27.0">黑马TS教程</a>(2020年 时长11:46:00)</li>
<li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TS入门教程</a> – 个人博客所作(作者xcatliu) <font color='red'>推荐</font><blockquote>
<p><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">https://ts.xcatliu.com/introduction/what-is-typescript.html</a><br>  是部署在GitHub Pages上的，很好的教程！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Electron(2013 GitHub)</p>
<blockquote>
<p>基于Chromium和Node.js的跨平台桌面应用程序开发框架，允许开发者使用Web技术来构建原生桌面应用</p>
</blockquote>
</li>
<li><p>Svelte(2016)</p>
<blockquote>
<p>Svelte 和 Vue、React一样都是现代化前端框架。<br>      不同的是，Svelte没有采用虚拟DOM技术，使得其更加轻巧。近年来，随着开发者对其性能优势和开发体验的认可，Svelte逐渐成为前端开发中备受推崇的框架之一。</p>
</blockquote>
<p>  SvelteKit(2021 Svelte官方)</p>
<blockquote>
<p>和Next、Nuxt相同功能的框架，极大丰富了Svelte生态系统</p>
</blockquote>
</li>
<li><p><strong>Tailwind CSS</strong>(2017)</p>
<blockquote>
<p>在React和Vue等组件化开发框架的发展下，DOM的复用不再是难题，在大型项目下，CSS的复用已经名存实亡，于是Tailwind CSS出现了。<br>  Tailwind CSS的设计理念是提供一组原子类，以快速构建样式，而不需要编写自定义的CSS，这一开发方式深受开发者喜爱，并成为Next框架的默认组件。至此，Sass、Less完成了它们的历史使命。</p>
</blockquote>
</li>
<li><p>Flutter(2017 Google)</p>
<blockquote>
<p>Flutter是一种用于构建跨平台移动应用的框架。可以同时在IOS、Android、Web和桌面平台运行。</p>
</blockquote>
</li>
<li><p>NestJS(2017)</p>
<blockquote>
<p>NestJS设计灵感来源于 Angular 框架，借鉴了其模块化、依赖注入和装饰器等概念，用于构建高效且可扩展的服务端应用程序，弥补了Node生态中的一些框架空白，加上对TS的支持，为JS开发大型后端应用打下基础</p>
</blockquote>
</li>
<li><p>ArkTS语言(2022 华为)</p>
<blockquote>
<p>华为确定改语言用于鸿蒙APP开发。是基于TS扩展的语言，意味着如果会Web前端，也就会鸿蒙应用开发。<br>  华为使用ArkTS语言，意味着瞬间拥有了大量的开发者基础，同时很可能促进所有的终端开发都采用JS，而那时前端技术将迎来大一统</p>
</blockquote>
</li>
<li><p>PHP(后端服务器)</p>
<blockquote>
<p>PHP是世界上最好的语言。</p>
</blockquote>
</li>
<li><p>Python(爬虫、脚本、大数据分析)</p>
</li>
<li><p>Java – Java框架 –Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud&#x2F;&#x2F;Sprint家族</p>
</li>
</ul>
<h2 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h2><ol>
<li><p><a href="https://www.xuanfengge.com/it-job-seekers-resume-how-to-write.html">IT求职者的简历该如何编写</a>(轩枫阁)</p>
<blockquote>
<p>2014&#x2F;10&#x2F;14的帖子，不过还是有很多值得学习的地方</p>
</blockquote>
</li>
<li><p><a href="https://www.laoyujianli.com/">老鱼简历</a>(鱼皮)</p>
<blockquote>
<p>根据模板快速制作简历</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Pulled Post</title>
    <url>/tsukimiya.github.io/PulledPost/index.html</url>
    <content><![CDATA[<blockquote>
<p><code>Here are many posts pulling for you, hope you&#39;ll gain something.</code></p>
</blockquote>
<h1 id="Pulled-Bloger-or-Community"><a href="#Pulled-Bloger-or-Community" class="headerlink" title="Pulled Bloger or Community"></a>Pulled Bloger or Community</h1><ol>
<li><p>沧沧凉凉 – <a href="https://juejin.cn/user/1380642337065421/posts">掘金</a> | <a href="https://www.zhihu.com/people/hatsune-87/posts">知乎</a></p>
</li>
<li><p>freecodecamp编程免费教学慈善组织 – <a href="https://www.freecodecamp.org/chinese/learn">官网</a> | <a href="https://www.freecodecamp.org/chinese/news/">专栏</a> | <a href="https://forum.freecodecamp.org/c/chinese/533">论坛</a></p>
<blockquote>
<p>官方支持中文，专栏和论坛有很多优质文章</p>
</blockquote>
</li>
<li><p><a href="https://www.xuanfengge.com/">轩枫阁</a> <font color="red">墙裂Pull!!</font></p>
<blockquote>
<p>前端大神的个人博客！腾讯微信前端工程师！ orz_<br> <a href="https://www.xuanfengge.com/funny/">SOME NB H5&amp;C3&amp;Animation orz_</a>(H5元素周期表就出自这里)<br> look older，but niubility build from 2013</p>
</blockquote>
</li>
</ol>
<h1 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h1><center><font>`工欲善其事，必先利其器`</font></center>

<ul>
<li><p><a href="https://u.tools/">uTools</a></p>
<blockquote>
<p>本地搜索、聚合翻译、OCR文字识别、MD笔记、文件批量重命名。一切皆插件，效率利器！</p>
</blockquote>
</li>
<li><p>Snipaste</p>
<blockquote>
<p>Windows截图工具，尚硅谷张天禹老师用的，可以缩放图片，比qq自带的强大！</p>
</blockquote>
</li>
<li><p>Xmind</p>
<blockquote>
<p>思维导图，黑马老师有用过</p>
</blockquote>
</li>
<li><p>Pxcook</p>
<blockquote>
<p>用来做一些网页样式设计图，可以测量尺寸和吸取颜色，渡一老师有用过</p>
</blockquote>
</li>
</ul>
<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><ul>
<li><p><a href="https://blog.csdn.net/weixin_40004212/article/details/113627387">VSCode 的快捷键及常用插件总结</a></p>
<blockquote>
<p>快速复制当前代码到下一行、移动行、新建窗口、行缩进<br>ctrl + alt + ↓ 在下一行末尾增加一个光标</p>
</blockquote>
</li>
<li><p>ctrl + i ———— <strong>唤起代码提示</strong></p>
</li>
</ul>
<h1 id="MD"><a href="#MD" class="headerlink" title="MD"></a>MD</h1><ul>
<li><p><a href="https://markdown.com.cn/extended-syntax/">Markdown官方教程</a><font color="red">Pull!!</font></p>
</li>
<li><p><a href="https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/">markdown语法</a> <font color="red">Pull!!</font></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_40896997/article/details/106551767">markdown表情大全</a> <font color="red">Pull!!</font></p>
<blockquote>
<p>emoji表情，及其表情符号简码</p>
</blockquote>
</li>
<li><p><a href="https://www.runoob.com/markdown/md-table.html">markdown表格语法</a>(菜鸟教程)</p>
</li>
</ul>
<h1 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h1><ul>
<li>推荐书籍<ol>
<li>JavaScript高级程序设计</li>
<li>JavaScript权威指南</li>
<li>你不知道的JavaScript</li>
</ol>
</li>
</ul>
<ol>
<li><a href="https://www.xuanfengge.com/fe-books.html">Web前端开发推荐阅读书籍、学习课程下载</a> <font color="green">推荐书籍可参考!!</font>(轩枫阁)<blockquote>
<p>可惜太老了，15年的推荐，可以参考一下一些推荐的书籍</p>
</blockquote>
</li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li><a href="https://cloud.tencent.com/developer/article/1682440">谈谈HTML中锚点及其使用</a>(腾讯云)<blockquote>
<p>深度理解a元素 超文本锚点</p>
</blockquote>
</li>
</ol>
<h3 id="H5页面应用？"><a href="#H5页面应用？" class="headerlink" title="H5页面应用？"></a>H5页面应用？</h3><ol>
<li><a href="https://www.xuanfengge.com/funny/html5/spider/">逼真的蜘蛛</a>(轩枫阁)<blockquote>
<p>有时间仿一下，感觉和之前见到的一个博客磁吸线条成网的背景原理相似<br>又见到一个，不过这个不太明显 -&gt; <a href="https://www.cnblogs.com/wwj007/p/14308569.html">这里</a></p>
</blockquote>
</li>
</ol>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><ol>
<li><a href="https://juejin.cn/post/7075162881498562590">Varlet，被尤雨溪推荐，这款开箱即用的Vue3组件库做对了什么</a>(掘金22&#x2F;3&#x2F;15)<blockquote>
<p>Varlet：一个基于 Vue3 开发的 Material 风格移动端组件库</p>
</blockquote>
</li>
</ol>
<h1 id="Blog-Build"><a href="#Blog-Build" class="headerlink" title="Blog Build"></a>Blog Build</h1><ul>
<li><a href="https://iknowwang.com/">如何架設網站：一個完全免費的教學（Blog推薦 + 網頁製作軟體 ）</a>(Wordpress)<blockquote>
<p>讲到了很多建设网站的东西</p>
</blockquote>
</li>
</ul>
<h2 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/37896471">WordPress搭建教程：手把手教你搭建WordPress博客</a>(知乎)<blockquote>
<p>域名推荐在 <a href="https://www.namesilo.com/?rid=d27fa32do">Namesilo</a> 购买，价格便宜，赠送永久免费的隐私保护。(0.99$&#x2F;第一年)<br>注册账户。注册信息建议如实填写，并勾选“Keep my information private”默认使用隐私保护。<br> 设置域名续费规则、注册时长等。在“Have a Coupon……”处输入优惠码 okoff 或者 go2think，点击“Submit”应用，优惠一美元。<br> 完成后点击“CONTINUE”付款，支持支付宝和 Paypal 等。</p>
</blockquote>
</li>
</ol>
<h2 id="Hexo-Next"><a href="#Hexo-Next" class="headerlink" title="Hexo + Next"></a>Hexo + Next</h2><ul>
<li><a href="https://hexo-next.readthedocs.io/zh-cn/latest/">Hexo-NexT官网文档</a></li>
</ul>
<ol>
<li><p><a href="https://cloud.tencent.com/developer/article/2065803">Hexo图标样式参考</a>(腾讯云)</p>
<blockquote>
<p>Hexo 支持FontAwesome图标，就是在代码中出现名字以fa fa开头的类名，本文介绍具具体图标来源和使用方法。</p>
</blockquote>
</li>
<li><p>post页面图片引用(self) </p>
<blockquote>
<p>hexo + next 似乎并不支持@作为索引根目录或source目录，至少试了不起作用<br> 可以将图片放到source的images文件下，然后用markdown引用<br> <code>![img](/images/xxx.png)</code><br> 在images前面有一个&#x2F;,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,如果想要更改可以修改_config.yml下的source_dir参数</p>
</blockquote>
<ul>
<li>参考文章 – <a href="https://blog.csdn.net/Miracle_ps/article/details/114791335">Hexo 添加图片</a>(CSDN)</li>
</ul>
</li>
<li><p>博客字体修改</p>
<blockquote>
<p>NexT默认使用微软雅黑，这里我将blog title修改为了 <a href="https://fonts.google.com/selection/embed">Miniver</a> 字体，size: 1.5<br> 详细请参考该文章：<a href="https://blog.csdn.net/sailist/article/details/104114578">Hexo-Next主题更改字体</a><br> 文中提到的字体网站：<a href="https://fonts.google.com/">Google Fonts</a></p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">添加自定义html页面</a>(CSDN)</p>
</li>
</ol>
<h1 id="408"><a href="#408" class="headerlink" title="408"></a>408</h1><h2 id="计算机网络原理"><a href="#计算机网络原理" class="headerlink" title="计算机网络原理"></a>计算机网络原理</h2><ul>
<li><p>计算机网络原理 谢希仁（第8版）课后习题 及 参考答案</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126150861">第一章–分组交换 &#x2F; 时延 &#x2F; 性能指标 &#x2F; OSI七层模型和TCP&#x2F;IP五层模型–网络体系结构</a>(CSDN&#x2F;答案不全)<br>  不全的部分参考这个 <a href="https://cloud.tencent.com/developer/article/2055618">Post</a> (腾讯云&#x2F;Q10开始排版不好)</li>
<li><a href="https://blog.csdn.net/weixin_62985813/article/details/134105653">第二章–物理层</a>(CSDN)</li>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126276788">第三章–数据链路层</a>(CSDN)</li>
<li><a href="https://blog.csdn.net/qq_56919740/article/details/128908573">第四章–网络层</a>(CSDN)</li>
<li><a href="https://blog.csdn.net/qq_56919740/article/details/129649988">第五章–运输层</a>(CSDN&#x2F;答案不全)<br>  <a href="https://zhuanlan.zhihu.com/p/496603918?eqid=c1eba5ff0000988f00000006648b3851">参考这个，答案解释的比较详细</a>(知乎)</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/weixin_51261234/article/details/121876379"><font color="red">计算机网络重点回顾</font></a>(CSDN&#x2F;总结) —— 作者: <a href="https://blog.csdn.net/weixin_51261234?type=blog">高稚气菌</a></p>
</li>
</ul>
<h1 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h1><ol>
<li><p><a href="https://www.xuanfengge.com/it-job-seekers-resume-how-to-write.html">IT求职者的简历该如何编写</a>(轩枫阁)</p>
<blockquote>
<p>2014&#x2F;10&#x2F;14的帖子，不过还是有很多值得学习的地方</p>
</blockquote>
</li>
<li><p><a href="https://www.laoyujianli.com/">老鱼简历</a>(鱼皮)</p>
<blockquote>
<p>根据模板快速制作简历</p>
</blockquote>
</li>
</ol>
<h1 id="ELSE"><a href="#ELSE" class="headerlink" title="ELSE"></a>ELSE</h1>]]></content>
  </entry>
  <entry>
    <title>日程表</title>
    <url>/tsukimiya.github.io/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/tsukimiya.github.io/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Task</title>
    <url>/tsukimiya.github.io/schedule/task.html</url>
    <content><![CDATA[<center style="width:100%;height:1px;position:relative">
    <!-- 一直想不出令我满意的词，无灯夜航虽然意味上很好，但是音韵上总是差点 -->
    <p title="知无行则空，梦里看花。行非知犹盲，无灯夜航。" style="position:absolute;top:-50px;left:50%;transform: translateX(-48%);font-size:16px;cursor:help">知行合一</p>
</center>

<blockquote>
<p>快给我滚去学习！给你一拳 👊👊👊</p>
</blockquote>
<h2 id="Study-Tech"><a href="#Study-Tech" class="headerlink" title="Study Tech"></a>Study Tech</h2><h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h3><ol>
<li><p>vue框架</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
黑马vue课程（21.8 | vue2 - 12h）<br>  <a href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&p=32">https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&amp;p=32</a><br>  <a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=296">vue3-p296</a></p>
<blockquote>
<p>vue3的部分和vue2的东西弄到一块了，不太好<br>  从这里往后是vue3的内容，但是和vue2的内容，有绝大程度上的重合，vue2的部分挺不错，3的部分就不推荐了</p>
</blockquote>
</li>
<li><p>邓瑞编程 3小时学会Vue3 (24.1.23 | 2h16min)</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1nV411Q7RX">https://www.bilibili.com/video/BV1nV411Q7RX</a><br>  有个人博客教程<a href="https://www.dengruicode.com/">https://www.dengruicode.com/</a><br>  可以看看这个，反正很短</p>
</blockquote>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
尚硅谷 禹神 Vue3+TS（23.12.19 | 14h）</p>
<blockquote>
<p>基于Vue3的setup语法糖讲解，全程采用TypeScript+组合式API编码，贴心准备TypeScript快速上手笔记！带你快速上手纯血版Vue3！<br>      <a href="https://www.bilibili.com/video/BV1Za4y1r7KE">https://www.bilibili.com/video/BV1Za4y1r7KE</a><br>      讲的很好，就是有些东西没讲到，可以看官方文档补一下</p>
</blockquote>
</li>
<li><p><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a> <font color='red'> 推荐 </font></p>
<blockquote>
<p>写的很细，无论是基础还是进阶都可以看</p>
</blockquote>
</li>
</ul>
</li>
<li><p>pink html + css + 移动端后面这部分看一下</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV14J4114768/?p=389">https://www.bilibili.com/video/BV14J4114768/?p=389</a><br> p357-388为 CSS2D、3D(这里有空也看一下吧，正好做一下笔记)<br> 后面<br> p389-p502大致都是移动端，包括流式布局，Less，响应式相关<br> p503-513为bootStrap<br> bootStrap BS 以 Less (Sass), OOCSS 与 SMACSS 为基础<br> 最后是项目</p>
</blockquote>
</li>
<li><p>es6</p>
<ul>
<li>黑马视频<br> <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&amp;p=91</a></li>
<li>阮一峰es6书(手机进行中)<br> <a href="https://wangdoc.com/es6/intro">https://wangdoc.com/es6/intro</a></li>
</ul>
</li>
<li><p>ajax + git</p>
</li>
<li><p>面试</p>
<ul>
<li>模拟面试 - p2 强烈推荐！！<br> <a href="https://www.bilibili.com/video/BV1gB4y1V7cN?t=10.8">https://www.bilibili.com/video/BV1gB4y1V7cN?t=10.8</a></li>
</ul>
</li>
</ol>
<h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><ul>
<li><p>微信小程序 + uni-app （2021-12-17 | 30h）<br><a href="https://www.bilibili.com/video/BV1834y1676P?t=75.0">https://www.bilibili.com/video/BV1834y1676P?t=75.0</a></p>
<blockquote>
<p>有点老了，看下面这个尚硅谷的吧？或者直接下面的小兔鲜uniapp项目</p>
</blockquote>
</li>
<li><p>尚硅谷微信小程序开发教程，2024最新版微信小程序项目实战！（2024-02-20 | 35h42min）<br><a href="https://www.bilibili.com/video/BV1LF4m1E7kB?p=1">https://www.bilibili.com/video/BV1LF4m1E7kB?p=1</a></p>
<blockquote>
<p>微信小程序教程 + 项目</p>
</blockquote>
</li>
<li><p>react<br><a href="https://www.bilibili.com/video/BV1gh411U7JD?t=50.3">https://www.bilibili.com/video/BV1gh411U7JD?t=50.3</a></p>
</li>
<li><p>js面试<br>  黑马程序员前端面试必看视频教程（手写Promise+js设计模式+继承+函数柯里化等）（2023-9-5 | 12h）<br>  <a href="https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1">https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1</a></p>
<p>  尚硅谷经典前端面试题精讲第一季(web前端大咖总结) （2018-11-1 | 5h07min）<br>  <a href="https://www.bilibili.com/video/BV1nb411P7tQ/?vd_source=8a77e97d04f83a8e2b569f53a587210a">https://www.bilibili.com/video/BV1nb411P7tQ/?vd_source=8a77e97d04f83a8e2b569f53a587210a</a></p>
</li>
<li><p>项目</p>
<ul>
<li><p>黑马程序员前端Vue项目《iHRM人力资源后台管理》全套教程，从vue基础模板开发到整体开发、nginx部署上线（2023-11-07 | 26h）<br>  <a href="https://www.bilibili.com/video/BV1Te411X7Wz?p=1">https://www.bilibili.com/video/BV1Te411X7Wz?p=1</a></p>
<blockquote>
<p>Vue2项目 </p>
</blockquote>
</li>
<li><p>黑马程序员前端Vue3小兔鲜电商项目实战，vue3全家桶从入门到实战电商项目一套通关（2023-5-9 | 17h）<br>  <a href="https://www.bilibili.com/video/BV1Ac411K7EQ?p=1">https://www.bilibili.com/video/BV1Ac411K7EQ?p=1</a></p>
<blockquote>
<p>Vue3项目 </p>
</blockquote>
</li>
<li><p>黑马程序员前端项目uniapp小兔鲜儿微信小程序项目视频教程，基于Vue3+Ts+Pinia+uni-app的最新组合技术栈开发的电商业务全流程（2023-8-8 | 20h40min）<br>  <a href="https://www.bilibili.com/video/BV1Bp4y1379L?p=1">https://www.bilibili.com/video/BV1Bp4y1379L?p=1</a></p>
<blockquote>
<p>Vue3移动端uni-app项目<br>老师也许是个大牛，但是讲课不行，不适合初学者，适合有经验的听一下</p>
</blockquote>
</li>
<li><p>尚硅谷Vue项目实战硅谷甄选，vue3项目+TypeScript前端项目一套通关（2023-5-16 | 46h32min）<br>  <a href="https://www.bilibili.com/video/BV1Xh411V7b5?p=1">https://www.bilibili.com/video/BV1Xh411V7b5?p=1</a></p>
<blockquote>
<p>有时间还是学一遍这个吧！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>vue项目 双元 day9-p14 路由懒加载 、p15上线<br>  p12 通过CDN优化打包<br>  day10 - vuex</p>
</li>
<li><p>TS</p>
<ul>
<li>小满TypeScript基础教程全集（完结）（2021-12-28 | 6h31min）<br>  <a href="https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.999.0.0&vd_source=8a77e97d04f83a8e2b569f53a587210a">https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.999.0.0&amp;vd_source=8a77e97d04f83a8e2b569f53a587210a</a></li>
</ul>
</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><p>排序算法——冒泡排序原理动图详解及实现<br><a href="https://blog.csdn.net/qq_43792385/article/details/99466879">https://blog.csdn.net/qq_43792385/article/details/99466879</a></p>
<blockquote>
<p>小满模拟面试p1的图很好，老师讲的很好</p>
</blockquote>
</li>
<li><p>学习TS<br>  <a href="https://xiaoman.blog.csdn.net/article/details/122167155?spm=1001.2014.3001.5502">https://xiaoman.blog.csdn.net/article/details/122167155?spm=1001.2014.3001.5502</a><br>  作者 小满zs B站有视频，讲的很好？<br>  <a href="https://blog.csdn.net/qq1195566313?type=blog">https://blog.csdn.net/qq1195566313?type=blog</a></p>
</li>
<li><p>防盗链<br>cdn资源如果不设置防盗链，会被爬虫或者别的网站引用，但是流量还是消耗你的，到时候你的流量嘎嘎跑，月底缴费直接破产，设置了防盗链就只能自己的网站才能拿这个资源</p>
</li>
<li><p>html页面如何使用emoji表情？js如何使用emoji？ <a href="https://zhuanlan.zhihu.com/p/328516890">参考一篇文章</a></p>
</li>
<li><p>面试必问之 JS 事件循环(Event Loop)，看这一篇足够 <a href="https://zhuanlan.zhihu.com/p/580956436">https://zhuanlan.zhihu.com/p/580956436</a></p>
</li>
<li><p>axios<br>结合async和await调用axios<br>如果想要处理报错 – try catch<br>更优雅的处理 – 拦截器 – 可以处理全部的错误</p>
</li>
<li><p>如果想要本地搜索排除某些页面，其余全部页面都会被搜索到<br>目前只有一个办法：将想要排除搜索的页面，排除渲染，不被渲染的页面上的内容是搜索不到的，<br>所以还是得手搓页面XD</p>
</li>
<li><p>移动端使用js的控制台<br>【探秘JavaScript移动调试神器：JS-Mobile-Console】<a href="https://mbd.baidu.com/ma/s/WNjqoqqA">https://mbd.baidu.com/ma/s/WNjqoqqA</a><br>【移动端调试神器vConsole】<a href="https://mbd.baidu.com/ma/s/ZTdBK5C1">https://mbd.baidu.com/ma/s/ZTdBK5C1</a><br>可以直接使用js在线工具就行了，因为我只是需要在移动端使用控制台来进行验证一些代码，所以js在线工具完全可以满足</p>
</li>
<li><p>写一个sleep函数？研究过promise的应该写个sleep函数很简单？</p>
</li>
<li><p>为什么v-if是把元素移除和添加进页面的，然而v-if添加进页面的元素上带有的id属性，页面上的a链接指向它的锚点不起作用，为什么？如果换成v-show就没关系，因为控制的是display的值<br>也就是说，新添加进页面的元素的id属性不能作为锚点使用？</p>
</li>
<li><p>制作一个简历制作模板网页</p>
<blockquote>
<p>参考这个的功能<a href="https://www.laoyujianli.com/">老鱼简历</a>(鱼皮)<br>  因为这个没会员做出来的会有水印，所以还是自己做一个比较好</p>
</blockquote>
</li>
<li><p>如何记录网站每天的访问量及访问IP？</p>
</li>
<li><p>在首页和标签页添加 字数统计+阅读时长 以及 打赏 &#x2F;&#x2F; 应该要修改源模版文件代码</p>
<blockquote>
<p>要将字数统计和阅读时长设置添加到首页和标签页，你需要在网站的主题或模板文件中进行修改。具体来说，你需要找到首页和标签页的模板文件，并在其中添加相应的代码以显示字数统计和阅读时长。<br>  通常，这些模板文件可以在你的网站主题文件夹中找到。你可以查看主题的文档或者在主题文件夹中搜索包含首页和标签页内容的模板文件。<br>  一旦找到了这些模板文件，你可以根据需要修改它们，添加类似以下的代码来显示字数统计和阅读时长：<br>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.symbols %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>字数统计: &#123;&#123; page.symbols &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if page.time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阅读时长: &#123;&#123; page.time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><br>请注意，具体的代码可能会因为你使用的网站平台或主题而有所不同。最好查阅你使用的平台或主题的文档，以确保正确添加字数统计和阅读时长功能。</p>
</blockquote>
</li>
<li><p>markdown解析a标签或<code>[]()</code>的地址链接会把参数去掉，所以如果是带参数的连接会失效，最好标注一下连接地址，在浏览器点击未被解析的链接地址(解决一下这个问题，然后写一篇post)</p>
<blockquote>
<p>但是hexo解析之后生成的HTML页面上点击是没有问题的，把参数带上了<br>  hexo生成的HTML页面很多样式也和MD显示有区别，应该是内部处理了？</p>
</blockquote>
</li>
<li><p>CSS 布局经典问题大全<br><a href="https://www.html-js.com/article/5889">https://www.html-js.com/article/5889</a></p>
</li>
<li><p>网站会DDOS攻击会有哪些反应，如何应对此现象？<br><a href="https://www.html-js.com/article/6657">https://www.html-js.com/article/6657</a></p>
</li>
<li><p>响应式网页设计——怎样让一个网站在手机、平板上好看<br><a href="https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/">https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/</a></p>
</li>
<li><p>什么是 XSS？如何保护网站免受 DOM 跨站脚本攻击<br><a href="https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/">https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/</a></p>
</li>
<li><p>SEO优化？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=4.5&p=311">https://www.bilibili.com/video/BV14J4114768?t=4.5&amp;p=311</a></p>
</li>
<li><p>上传服务器？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=2.5&p=355">https://www.bilibili.com/video/BV14J4114768?t=2.5&amp;p=355</a></p>
</li>
<li><p>多栏布局<br>多栏布局是最常见的css布局之一，实现的方式不下10种，它们分别应对各种各样的业务场景，而bs的流式布局堪称撑起一片天，它的响应式看似独霸天下能满足80%的要求，但开发者们仍会保留20%用于追逐更高效的技巧，而且随着前端的发展，原生bs流式布局已然有更优的实现方式了。</p>
</li>
<li><p>Layui – 快速实现页面布局效果，</p>
</li>
<li><p>防抖 节流<br><a href="https://www.bilibili.com/video/BV1zs411h74a?t=5.0&p=66">https://www.bilibili.com/video/BV1zs411h74a?t=5.0&amp;p=66</a></p>
</li>
<li><p>web APIs(页面适配，less，Sass等一些)</p>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br>  Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
</li>
<li><p>es6，模块化，组件化，css3，less，scss</p>
</li>
<li><p>QQ的卡片是怎么写的？随机给一张图片的那种卡片</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Array API | 数组方法 | 数组函数</title>
    <url>/tsukimiya.github.io/custom/api.html</url>
    <content><![CDATA[
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <title>API | Ayu's Study Blog</title> -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.js"></script>
    <style>
        ul{
            list-style: decimal;
        }
        .nav-level-3::marker{
            display: none;
        }
        h3{
            margin-left: -30px;
        }
    </style>
</head>

<body>
    <div id="app">
        <button @click="toggleMode(1)">按照首字母排序</button>
        <button @click="toggleMode(2)">按照功能归类排序</button>
        <!-- 让带有h3标题的mode2在上，好让hexo解析不带::marker的h3标题 -->
        <ul v-show="mode==2">
            <ul v-for="(t,i) in types">
                <h3 :id="'t' + (i+1)" v-text="i+1 + '. ' + t">这里是功能排序</h3>
                <!-- 为了让id正确，必须过滤一下符合type的方法，否则是按照原来api对象的位置索引 -->
                <li v-for="(item,index) in apioftype(t)">
                    <h4 v-text="item.name" v-if="false"></h4>
                    <details><summary><span :id="'t' + (i+1) +'f' + (index+1)" class="h4List1" v-text="item.name"></span>&nbsp;&nbsp;&nbsp;<a :href="item.address" target="_blank">more in MDN</a></summary>
                        <pre><span v-html="item.describe"></span><br v-if="item.describe"><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.use"></code><br v-if="item.use"><br v-if="item.use"><span v-if="item.syntax">语法:<br></span><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.syntax"></code><br v-if="item.syntax"><span v-if="item.param">参数:</span><p v-if="item.param" v-text="item.param"></p><span v-if="item.return">返回值：</span><span v-text="item.return"></span></pre>
                    </details>
                </li>
            </ul>
        </ul>

        <ul v-show="mode==1">
            <!-- <h3>字母排序</h3> -->
            <li v-for="(item,index) in apiofletter()">
                <!-- hexo不支持插值表达式 -->
                <!-- h4是为了让hexo解析出来 .nav-level-4 层级的目录，并不让它出现在页面上 -->
                <!-- 因为把mode2放在了上面，所以不需要这里再有了 -->
                <!-- <h4 v-text="item.name" v-if="false" :id="'n' + index"></h4> -->
                <details><summary><span :id="'n' + (index+1)" class="h4List1" v-text="item.name"></span>&nbsp;&nbsp;&nbsp;<a :href="item.address" target="_blank">more in MDN</a></summary>
                    <pre><span v-html="item.describe"></span><br v-if="item.describe"><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.use"></code><br v-if="item.use"><br v-if="item.use"><span v-if="item.syntax">语法:<br></span><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.syntax"></code><br v-if="item.syntax"><span v-if="item.param">参数:</span><p v-if="item.param" v-text="item.param"></p><span v-if="item.return">返回值：</span><span v-text="item.return"></span></pre>
                </details>
            </li>
        </ul>
        <!-- <div style="width:100%;height:1600px;background-color: red;"></div> -->
    </div>


    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="./api.js"></script>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tsukimiya.github.io/custom/api.js</url>
    <content><![CDATA[let vm = new Vue({
    el: '#app',
    data: {
        mode: 1,//值为1 和 2 代表两个种类
        types:[ // 这个依旧按照首字母排序
            "过滤 | 筛选",
            '循环 | 遍历',
            "查找 | 查询",
            "判断",
            "累加器",   
        ],
        node1:'',
        node2:'',
        // forEach 遍历
        api: {
            //这个模板可以删掉，只是方便添加数据，不影响页面
            like: {
                type: '',
                name: '',
                address: '',
                describe: ``,
                use:
                    ``,
                syntax:
                    ``,
                param:
                    ``,
                return: '',
            },
            every: {
                type: '循环 | 遍历 | 判断',
                name: 'Array.prototype.every()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every',
                describe: '每一项都满足判断条件就得到true，只要有任何一项不满足就是false，后面的元素都不会再执行。<br>不会对空数组进行检测，不会改变原始数组',
                use:
`[1,2,3,4,5].erver((num)=>num<10) // true
[1,2,3,4,5].erver((num)=>num>1) // false`,
                syntax:
`every(callbackFn)
every(callbackFn(element,index,array), thisArg)`,
                param:
                    ``,
                return: '布尔值 true/false',
            },
            filter: {//按照首字母排序
                type:'过滤 | 筛选',
                name: 'Array.prototype.filter()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter',
                describe: 
`filter()方法创建给定数组一部分的浅拷贝 -- 返回一个新数组
filter对空数组不会进行检测，不会改变原始数组。`,
                use:
`[1,2,3,4,5].filter((num)=>num>3) // [4, 5]
[1,2,3,4,5].filter((num)=>true) // [1,2,3,4,5]`,
                syntax: 
`filter(callbackFn)
filter(callbackFn(element,index,array), thisArg)`,
                param: 
`1. callbackFn: 为数组中的每个元素执行的函数。它应该返回一个真值以将元素保留在结果数组中，否则返回一个假值。
    该函数被调用时将传入以下参数：
    element: 数组中当前正在处理的元素。
    index: 正在处理的元素在数组中的索引。
    array: 调用了 filter() 的数组本身。
2. thisArg(可选): 执行 callbackFn 时用作 this 的值。参见迭代方法。`,
                return: '返回给定数组的一部分的浅拷贝，其中只包括通过提供的函数实现的测试的元素。如果没有元素通过测试，则返回一个空数组。',
            },
            forEach: {
                type: '循环 | 遍历',
                name: 'Array.prototype.forEach()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach',
                describe: 
`forEach() 方法对数组的每个元素执行一次给定的函数。是一个迭代方法。
不会改变其调用的数组，不过可以在callbackFn函数中操作原数组参数array来实现修改
除非抛出异常，否则没有办法停止或中断 forEach() 循环。`,
                use:
`let arr = [1,2,3,4,5]
arr.forEach((num)=>{ num++ })
arr // [1,2,3,4,5],不会改变原数组

arr.forEach((num,index,arr)=>{ arr[index]=index; })
arr // [0,1,2,3,4] , 可以这样来修改原数组`,
                syntax:
`forEach(callbackFn)
forEach(callbackFn(element,index,array), thisArg)`,
                param:
                    ``,
                return: 'undefined',
            },
            reduce: {
                type: '累加器',
                name: 'Array.prototype.reduce()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce',
                describe: `累加器。<br>可以用来计算一组数据的和，每次循环return的值，都会作为下次循环的初始值`,
                use:
`[1,2,3,4,5].reduce( (total,num)=>total+num ) // 15 -- 所有数值的累加和 循环4次
[1,2,3,4,5].reduce((total,num)=>total+num),20) // 35 -- 从初始值20开始累加 循环5次

[1,2,3,4,5].reduce((total,num)=>{
    //没有初始值，第一个数值被赋值给了total作为初始值，函数执行4次
    console.log(total + ' ' + num); // 1 2, 3 3, 6 4 , 10 5
    return total + num;
}) // 15
[1,2,3,4,5].reduce((total,num)=>{
    //传了初始值，函数执行5次
    console.log(total + ' ' + num); // 20 1, 21 2, 23 3, 26 4, 30 5
    return total + num;
},20) // 35

// reduce()函数还可以进行一些复杂的处理，如：融合对象
// 简单的示例：
let c = {c:'c'}; 
[{a:'a'},{b:'b'}].reduce((mix,item)=>Object.assign(mix,item),c)
// 这里作用等同于
Object.assign(c,...[{a:'a'},{b:'b'}]) // c: {a:'a',b:'b',c:'c'}
更复杂的实例参考：
ES6 - 对象的新增方法 - Object.getOwnPropertyDescriptors方法最后一个例子
https://es6.ruanyifeng.com/#docs/object-methods#Object-getOwnPropertyDescriptors`,
                syntax:
`array.reduce(callbackFn(total,currentValue)) //必选的参数
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`,
                param:
                    ``,
                return: '返回最终的累加值 total',
            },
            some: {
                type: '循环 | 遍历 | 查找 | 查询 | 判断',
                name: 'Array.prototype.some()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some',
                describe: `forEach虽然能实现我们的需求，但是性能比较差，不能被终止。<br>从数组里面找元素用some比较合适，因为some找到那一项之后，就可以终止后续的循环`,
                use:
`[1,2,3,4,5].some((item,index)=>{
    console.log(item);// 1 2 3
    if(item == 3){
        return true;//在找到对应的项之后，可以通过 return true 固定语法终止some循环
    }
}) // 这里函数会返回个true，是因为找到了3执行了我们写的return true
[1,2,3,4,5].some(item=>item==3)  
[1,2,3,4,5].some(item=>item>6) //这里返回的false，是数组中没找到符合的元素`,
                syntax: 
`forEach(callbackFn)
forEach(callbackFn(element,index,array), thisArg)`,
                param: 
``,
                return: '可以认为返回true就是找到了，false就是没找到.因为基本上是会给一个判断来查找数组元素的',
            },
            like: {
                type: '',
                name:'',
                address:'',
                describe:``,
                use: 
``,                
                syntax: 
``,
                param:
``,
                return:'',
            },
            like: {
                type: '',
                name: '',
                address: '',
                describe: ``,
                use:
                    ``,
                syntax:
                    ``,
                param:
                    ``,
                return: '',
            },
        }
    },
    computed: {
        
    },
    methods: {
        apioftype(type) {
            return Object.values(this.api).filter((obj) => obj.type.includes(type));
        },
        apiofletter() {
            return Object.values(this.api).filter((obj) => obj.name !='');
        },
        initNavList(){
            // 1. 获取nav列表第三级别的li元素 和 第四级别的li
            let list3 = document.querySelector('.nav-level-3');
            let list4 = document.querySelector('.nav-level-4');
            // 这里只有一个四级子元素，用于后面克隆用
            let originList3 = list3.cloneNode(true);
            
            // 2.获取列表的nav父元素,等后面往里面添加生成的div节点，包住li目录
            let nav = list3.parentNode;
            // console.log(nav);
            // 包着两个列表的div，用来控制显示
            this.node1 = document.createElement('div');
            this.node2 = document.createElement('div');

            // 3. 生成按照功能排序的列表内容，并将其封装到node2中
            this.types.forEach((item, index1) => {
                // console.log(item + ' ' + index);
                let index = index1 + 1;//让索引从零开始
                if(index == 1){// 第一个，修改得到的list3的值
                    this.changeTypeList(list3, index, item);
                    this.node2.append(list3);
                } else {//克隆一份修改
                    let cloneList = originList3.cloneNode(true);
                    this.changeTypeList(cloneList, index, item);
                    this.node2.append(cloneList);
                }
            })
            // 4. 生成按照字母排序的列表内容，并将其封装到node1中
            // 过滤得到所有的存在name的方法，遍历
            Object.values(this.api).filter((obj) => obj.name).forEach((obj, i) => {
                let index = i + 1; // 所以从1开始
                // 这里就不需要分情况了，直接全部克隆自 list4(因为这是list3下的)
                let cloneList = list4.cloneNode(true);
                this.changeList(cloneList, index, obj.name, 'n');
                // 直接添加到node1节点中
                this.node1.append(cloneList);
            })

            // 5. 将nav中的原来的列表移除，然后把node1 node2节点添加进去
            nav.innerHTml = '';
            nav.append(this.node1,this.node2);
            this.toggleDisplay(1);//默认是node1显示
        },
        changeTypeList(node,index,item){//完成每一个type目录及其子目录的初始化
            // 这里只修改了三级索引的值,t是三级的type
            // 如果传入的是t，返回里面的四级li子元素
            let child = this.changeList(node, index, item, 't');
            let id = 't'+index;//用来做这个类下方法的id前缀，防止每个类下的id重复(第一个都是f1)
            // 过滤得到所有的该item分类的方法
            Object.values(this.api).filter((obj) => obj.type.includes(item)).forEach((obj,index) => {
                index++;//索引从1开始
                if (index == 1) {//修改值
                    this.changeList(child, index, obj.name, id+'f');
                } else {//克隆一份再修改
                    let cloneList = child.cloneNode(true);
                    this.changeList(cloneList, index, obj.name, id +'f');
                    // 添加到node节点的第二个子元素ol中
                    node.children[1].append(cloneList);
                }
            })
        },
        // id传 t、f、n三种，对应功能排序的三级、四级 和 字母排序的四级
        changeList(node,index,name,id){//修改List的内容
            let a = node.children[0];
            a.href = '#' + id + index; 
            // console.log();
            let number = a.children[0];
            let text = a.children[1];
            number.textContent = index + '.';
            text.textContent = name;
            if(id == 't'){// 返回三级索引子元素
                return node.children[1].children[0];
            }
        },
        toggleDisplay(m){
            // m = 1，node1显示，node2消失
            // m = 2，node1消失，node2显示
            let show = ['none','block','none']
            this.node1.style.display = show[m];
            this.node2.style.display = show[m-1];
        },
        toggleMode(m){
            if(this.mode == m) // 已经是当前模式，直接return
            return ;
            this.mode = m;
            this.toggleDisplay(m);
        }
    },
    mounted(){
        this.initNavList();
        // console.log(this.node1);
    }
})]]></content>
  </entry>
  <entry>
    <title>Cuntom Page</title>
    <url>/tsukimiya.github.io/custom/index.html</url>
    <content><![CDATA[<blockquote>
<p>Take a look at some of the pages created by me.<br>  <font color=violet>Tips: Unrendered pages are not searchable.</font></p>
</blockquote>
<ol start="0">
<li><p><a href="api.html">Array API | 数组方法 | 数组函数</a></p>
</li>
<li><p><a href="./npmAPI.html">npm - 常用包 | 第三方模块</a></p>
</li>
<li><p><a href="pages/MakeCV.html" target='_blank'>MakeCV</a></p>
<blockquote>
<p>制作简历</p>
</blockquote>
</li>
<li><p>根据数据生成数据折线图</p>
<blockquote>
<p>输入对应的数据，可以生成对应的数据折线图<br>   修改某个数据，折线图会动态更新，且附带动画过渡效果<br>   可以设置折线图的颜色：线条、背景、节点圆圈<br>用vue2 + echarts?实现？<br>先用vue2+js实现，再考虑用vue3+echarts重构吧</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tsukimiya.github.io/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>常用包 | 第三方模块</title>
    <url>/tsukimiya.github.io/custom/npmAPI.html</url>
    <content><![CDATA[<blockquote>
<p>Here are some common Node package.<br>    在这里 -&gt; <a href="https://www.npmjs.com/">https://www.npmjs.com</a> 可以查询包及其用法</p>
</blockquote>
<h2 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h2><blockquote>
<p>全局包会被安装到C:\Users\用户目录\AppData\Roaming\npm\node _modules目录下。<br>    <code>npm i 包名 -g</code> #全局安装指定的包<br>    <code>npm uninstall 包名 -g</code> #卸载全局安装的包</p>
</blockquote>
<ul>
<li>npm i xxx</li>
</ul>
<h2 id="项目包-开发依赖包"><a href="#项目包-开发依赖包" class="headerlink" title="项目包 - 开发依赖包"></a>项目包 - 开发依赖包</h2><blockquote>
<p>被记录到devDependencies节点中的包，只在开发期间会用到<br>    简写：<code>npm i 包名-D</code>  (<code>npm install包名 --save-dev</code>)</p>
</blockquote>
<ul>
<li><code>npm i xxx</code></li>
</ul>
<h2 id="项目包-核心依赖包"><a href="#项目包-核心依赖包" class="headerlink" title="项目包 - 核心依赖包"></a>项目包 - 核心依赖包</h2><blockquote>
<p>被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到<br>    简写：<code>npm i 包名</code>  (<code>npm install包名 -S(--save)</code>)<br>    从npm 5.0.0版本开始，–save已经变成默认行为，所以即使不加-S或–save，安装的包也会自动被加入到dependencies。</p>
</blockquote>
<ul>
<li><p><code>npm i axios</code></p>
</li>
<li><p><code>npm i vue-router@3.5.2 -S</code> (Vue2使用路由需制定为Router3版本)</p>
<blockquote>
<p>最新版的 Vue Router4 是为vue3设计的，不兼容Vue2。<br>  所以想在 Vue 2 中使用 Vue Router，安装包的时候需要指定 Vue Router 3 的版本</p>
</blockquote>
</li>
<li><p><code>npm i vue-router</code> (Vue3路由使用最新版即可)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ACGNCollections</title>
    <url>/tsukimiya.github.io/%E6%AC%A1%E5%85%83/AC.html</url>
    <content><![CDATA[<pre><center>汝等即将踏入此地的人，舍弃所有的希望吧</center></pre>

<h1 id="Anime"><a href="#Anime" class="headerlink" title="Anime"></a>Anime</h1><h2 id="Sakuga"><a href="#Sakuga" class="headerlink" title="Sakuga"></a>Sakuga</h2><h3 id="Sakugaer"><a href="#Sakugaer" class="headerlink" title="Sakugaer"></a>Sakugaer</h3><ul>
<li><a href="https://space.bilibili.com/1905952529?spm_id_from=333.337.0.0">O_bscure</a>(TW)</li>
</ul>
<h3 id="Animetor"><a href="#Animetor" class="headerlink" title="Animetor"></a>Animetor</h3><ol>
<li><p>文森特 Vincent Chansard（France）</p>
<blockquote>
<p>V圣<br>近两年引人注目的超新星，以及备受争议的新人原画，在ONE PIECE、咒術迴戰等片场大放异彩。以及，大魔镜的OP非常出色，光影感很强烈，魔法少女ED那段是谁画的来着？当时好像都误以为是文森特？（待修改） —— 24.5<br>以及路飞五档的超抽象大举、and 路奇 vs 路飞那段都令人影响深刻 —— 24.5</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/opus/927643447686332480?spm_id_from=333.999.0.0">访谈</a> - 24.5 ，译 O_bscure</li>
</ul>
</li>
<li><p>长田宽人（SHAFT）</p>
<blockquote>
<p>和川田和树并为沙发套强力新人 —— 23.8</p>
</blockquote>
<blockquote>
<p>shaft所属新人原画 1994年生人<br> 创形美术学校视觉设计科媒体影像专攻2016毕业生，毕业后开始在shaft参与补间动画工作，因沙发套大批员工出走，长田宽人和川田和树在shaft作品中作为主要原画输出，在魔法纪录中的超亮眼表现让其备受瞩目，其后在rwby也持续贡献优秀作画。细线条锯齿，金属质感的块状阴影和头发的飘动让其辨识度极高，但也因画面太乱受人诟病，是一位个人风格强烈的原画师。今年（23年）也在五等分初次担当了OP分镜，表现依旧出色，期待进一步突破！—— 23.8</p>
</blockquote>
<blockquote>
<p>好久没见到长田宽人的身影了，也不能咬定不活跃了，上一次见到他还是在推上见他吐槽，以及提到了回老家？休假？沙发套的物语新作就在7月！魔圆剧场版就在今年冬！大的一定在后面！ —— 24.5</p>
</blockquote>
</li>
<li><p>太田晃博</p>
<blockquote>
<p>活跃在海贼片场的超级新星，22-23年是其超进化的一年<br>路飞开启五档（ep？，23.？），太田终于与自己的偶像大平共舞，为作画史添上了浓墨重彩的一笔！</p>
</blockquote>
</li>
</ol>
<h3 id="老害"><a href="#老害" class="headerlink" title="老害"></a>老害</h3><ol>
<li>大平</li>
</ol>
<h1 id="Comic"><a href="#Comic" class="headerlink" title="Comic"></a>Comic</h1><h1 id="Gyaruge"><a href="#Gyaruge" class="headerlink" title="Gyaruge"></a>Gyaruge</h1><h1 id="Novel"><a href="#Novel" class="headerlink" title="Novel"></a>Novel</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tsukimiya.github.io/custom/pages/js/pdf.3.11.174.min.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
!(function webpackUniversalModuleDefinition(t, e) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = t.pdfjsLib = e())
    : 'function' == typeof define && define.amd
    ? define('pdfjs-dist/build/pdf', [], () => (t.pdfjsLib = e()))
    : 'object' == typeof exports
    ? (exports['pdfjs-dist/build/pdf'] = t.pdfjsLib = e())
    : (t['pdfjs-dist/build/pdf'] = t.pdfjsLib = e())
})(globalThis, () =>
  (() => {
    'use strict'
    var __webpack_modules__ = [
        ,
        (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.VerbosityLevel =
            e.Util =
            e.UnknownErrorException =
            e.UnexpectedResponseException =
            e.TextRenderingMode =
            e.RenderingIntentFlag =
            e.PromiseCapability =
            e.PermissionFlag =
            e.PasswordResponses =
            e.PasswordException =
            e.PageActionEventType =
            e.OPS =
            e.MissingPDFException =
            e.MAX_IMAGE_SIZE_TO_CACHE =
            e.LINE_FACTOR =
            e.LINE_DESCENT_FACTOR =
            e.InvalidPDFException =
            e.ImageKind =
            e.IDENTITY_MATRIX =
            e.FormatError =
            e.FeatureTest =
            e.FONT_IDENTITY_MATRIX =
            e.DocumentActionEventType =
            e.CMapCompressionType =
            e.BaseException =
            e.BASELINE_FACTOR =
            e.AnnotationType =
            e.AnnotationReplyType =
            e.AnnotationPrefix =
            e.AnnotationMode =
            e.AnnotationFlag =
            e.AnnotationFieldFlag =
            e.AnnotationEditorType =
            e.AnnotationEditorPrefix =
            e.AnnotationEditorParamsType =
            e.AnnotationBorderStyleType =
            e.AnnotationActionEventType =
            e.AbortException =
              void 0
          e.assert = function assert(t, e) {
            t || unreachable(e)
          }
          e.bytesToString = bytesToString
          e.createValidAbsoluteUrl = function createValidAbsoluteUrl(t, e = null, i = null) {
            if (!t) return null
            try {
              if (i && 'string' == typeof t) {
                if (i.addDefaultProtocol && t.startsWith('www.')) {
                  const e = t.match(/\./g)
                  e?.length >= 2 && (t = `http://${t}`)
                }
                if (i.tryConvertEncoding)
                  try {
                    t = stringToUTF8String(t)
                  } catch {}
              }
              const s = e ? new URL(t, e) : new URL(t)
              if (
                (function _isValidProtocol(t) {
                  switch (t?.protocol) {
                    case 'http:':
                    case 'https:':
                    case 'ftp:':
                    case 'mailto:':
                    case 'tel:':
                      return !0
                    default:
                      return !1
                  }
                })(s)
              )
                return s
            } catch {}
            return null
          }
          e.getModificationDate = function getModificationDate(t = new Date()) {
            return [t.getUTCFullYear().toString(), (t.getUTCMonth() + 1).toString().padStart(2, '0'), t.getUTCDate().toString().padStart(2, '0'), t.getUTCHours().toString().padStart(2, '0'), t.getUTCMinutes().toString().padStart(2, '0'), t.getUTCSeconds().toString().padStart(2, '0')].join('')
          }
          e.getUuid = function getUuid() {
            if ('undefined' != typeof crypto && 'function' == typeof crypto?.randomUUID) return crypto.randomUUID()
            const t = new Uint8Array(32)
            if ('undefined' != typeof crypto && 'function' == typeof crypto?.getRandomValues) crypto.getRandomValues(t)
            else for (let e = 0; e < 32; e++) t[e] = Math.floor(255 * Math.random())
            return bytesToString(t)
          }
          e.getVerbosityLevel = function getVerbosityLevel() {
            return n
          }
          e.info = function info(t) {
            n >= s.INFOS && console.log(`Info: ${t}`)
          }
          e.isArrayBuffer = function isArrayBuffer(t) {
            return 'object' == typeof t && void 0 !== t?.byteLength
          }
          e.isArrayEqual = function isArrayEqual(t, e) {
            if (t.length !== e.length) return !1
            for (let i = 0, s = t.length; i < s; i++) if (t[i] !== e[i]) return !1
            return !0
          }
          e.isNodeJS = void 0
          e.normalizeUnicode = function normalizeUnicode(t) {
            if (!l) {
              l =
                /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu
              h = new Map([['ﬅ', 'ſt']])
            }
            return t.replaceAll(l, (t, e, i) => (e ? e.normalize('NFKC') : h.get(i)))
          }
          e.objectFromMap = function objectFromMap(t) {
            const e = Object.create(null)
            for (const [i, s] of t) e[i] = s
            return e
          }
          e.objectSize = function objectSize(t) {
            return Object.keys(t).length
          }
          e.setVerbosityLevel = function setVerbosityLevel(t) {
            Number.isInteger(t) && (n = t)
          }
          e.shadow = shadow
          e.string32 = function string32(t) {
            return String.fromCharCode((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, 255 & t)
          }
          e.stringToBytes = stringToBytes
          e.stringToPDFString = function stringToPDFString(t) {
            if (t[0] >= 'ï') {
              let e
              'þ' === t[0] && 'ÿ' === t[1] ? (e = 'utf-16be') : 'ÿ' === t[0] && 'þ' === t[1] ? (e = 'utf-16le') : 'ï' === t[0] && '»' === t[1] && '¿' === t[2] && (e = 'utf-8')
              if (e)
                try {
                  const i = new TextDecoder(e, { fatal: !0 }),
                    s = stringToBytes(t)
                  return i.decode(s)
                } catch (t) {
                  warn(`stringToPDFString: "${t}".`)
                }
            }
            const e = []
            for (let i = 0, s = t.length; i < s; i++) {
              const s = o[t.charCodeAt(i)]
              e.push(s ? String.fromCharCode(s) : t.charAt(i))
            }
            return e.join('')
          }
          e.stringToUTF8String = stringToUTF8String
          e.unreachable = unreachable
          e.utf8StringToString = function utf8StringToString(t) {
            return unescape(encodeURIComponent(t))
          }
          e.warn = warn
          const i = !('object' != typeof process || process + '' != '[object process]' || process.versions.nw || (process.versions.electron && process.type && 'browser' !== process.type))
          e.isNodeJS = i
          e.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]
          e.FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]
          e.MAX_IMAGE_SIZE_TO_CACHE = 1e7
          e.LINE_FACTOR = 1.35
          e.LINE_DESCENT_FACTOR = 0.35
          e.BASELINE_FACTOR = 0.25925925925925924
          e.RenderingIntentFlag = { ANY: 1, DISPLAY: 2, PRINT: 4, SAVE: 8, ANNOTATIONS_FORMS: 16, ANNOTATIONS_STORAGE: 32, ANNOTATIONS_DISABLE: 64, OPLIST: 256 }
          e.AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }
          e.AnnotationEditorPrefix = 'pdfjs_internal_editor_'
          e.AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, STAMP: 13, INK: 15 }
          e.AnnotationEditorParamsType = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23 }
          e.PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }
          e.TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }
          e.ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }
          e.AnnotationType = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26,
          }
          e.AnnotationReplyType = { GROUP: 'Group', REPLY: 'R' }
          e.AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 }
          e.AnnotationFieldFlag = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864,
          }
          e.AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }
          e.AnnotationActionEventType = { E: 'Mouse Enter', X: 'Mouse Exit', D: 'Mouse Down', U: 'Mouse Up', Fo: 'Focus', Bl: 'Blur', PO: 'PageOpen', PC: 'PageClose', PV: 'PageVisible', PI: 'PageInvisible', K: 'Keystroke', F: 'Format', V: 'Validate', C: 'Calculate' }
          e.DocumentActionEventType = { WC: 'WillClose', WS: 'WillSave', DS: 'DidSave', WP: 'WillPrint', DP: 'DidPrint' }
          e.PageActionEventType = { O: 'PageOpen', C: 'PageClose' }
          const s = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }
          e.VerbosityLevel = s
          e.CMapCompressionType = { NONE: 0, BINARY: 1 }
          e.OPS = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91,
          }
          e.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }
          let n = s.WARNINGS
          function warn(t) {
            n >= s.WARNINGS && console.log(`Warning: ${t}`)
          }
          function unreachable(t) {
            throw new Error(t)
          }
          function shadow(t, e, i, s = !1) {
            Object.defineProperty(t, e, { value: i, enumerable: !s, configurable: !0, writable: !1 })
            return i
          }
          const a = (function BaseExceptionClosure() {
            function BaseException(t, e) {
              this.constructor === BaseException && unreachable('Cannot initialize BaseException.')
              this.message = t
              this.name = e
            }
            BaseException.prototype = new Error()
            BaseException.constructor = BaseException
            return BaseException
          })()
          e.BaseException = a
          e.PasswordException = class PasswordException extends a {
            constructor(t, e) {
              super(t, 'PasswordException')
              this.code = e
            }
          }
          e.UnknownErrorException = class UnknownErrorException extends a {
            constructor(t, e) {
              super(t, 'UnknownErrorException')
              this.details = e
            }
          }
          e.InvalidPDFException = class InvalidPDFException extends a {
            constructor(t) {
              super(t, 'InvalidPDFException')
            }
          }
          e.MissingPDFException = class MissingPDFException extends a {
            constructor(t) {
              super(t, 'MissingPDFException')
            }
          }
          e.UnexpectedResponseException = class UnexpectedResponseException extends a {
            constructor(t, e) {
              super(t, 'UnexpectedResponseException')
              this.status = e
            }
          }
          e.FormatError = class FormatError extends a {
            constructor(t) {
              super(t, 'FormatError')
            }
          }
          e.AbortException = class AbortException extends a {
            constructor(t) {
              super(t, 'AbortException')
            }
          }
          function bytesToString(t) {
            ;('object' == typeof t && void 0 !== t?.length) || unreachable('Invalid argument for bytesToString')
            const e = t.length,
              i = 8192
            if (e < i) return String.fromCharCode.apply(null, t)
            const s = []
            for (let n = 0; n < e; n += i) {
              const a = Math.min(n + i, e),
                r = t.subarray(n, a)
              s.push(String.fromCharCode.apply(null, r))
            }
            return s.join('')
          }
          function stringToBytes(t) {
            'string' != typeof t && unreachable('Invalid argument for stringToBytes')
            const e = t.length,
              i = new Uint8Array(e)
            for (let s = 0; s < e; ++s) i[s] = 255 & t.charCodeAt(s)
            return i
          }
          e.FeatureTest = class FeatureTest {
            static get isLittleEndian() {
              return shadow(
                this,
                'isLittleEndian',
                (function isLittleEndian() {
                  const t = new Uint8Array(4)
                  t[0] = 1
                  return 1 === new Uint32Array(t.buffer, 0, 1)[0]
                })()
              )
            }
            static get isEvalSupported() {
              return shadow(
                this,
                'isEvalSupported',
                (function isEvalSupported() {
                  try {
                    new Function('')
                    return !0
                  } catch {
                    return !1
                  }
                })()
              )
            }
            static get isOffscreenCanvasSupported() {
              return shadow(this, 'isOffscreenCanvasSupported', 'undefined' != typeof OffscreenCanvas)
            }
            static get platform() {
              return 'undefined' == typeof navigator ? shadow(this, 'platform', { isWin: !1, isMac: !1 }) : shadow(this, 'platform', { isWin: navigator.platform.includes('Win'), isMac: navigator.platform.includes('Mac') })
            }
            static get isCSSRoundSupported() {
              return shadow(this, 'isCSSRoundSupported', globalThis.CSS?.supports?.('width: round(1.5px, 1px)'))
            }
          }
          const r = [...Array(256).keys()].map((t) => t.toString(16).padStart(2, '0'))
          e.Util = class Util {
            static makeHexColor(t, e, i) {
              return `#${r[t]}${r[e]}${r[i]}`
            }
            static scaleMinMax(t, e) {
              let i
              if (t[0]) {
                if (t[0] < 0) {
                  i = e[0]
                  e[0] = e[1]
                  e[1] = i
                }
                e[0] *= t[0]
                e[1] *= t[0]
                if (t[3] < 0) {
                  i = e[2]
                  e[2] = e[3]
                  e[3] = i
                }
                e[2] *= t[3]
                e[3] *= t[3]
              } else {
                i = e[0]
                e[0] = e[2]
                e[2] = i
                i = e[1]
                e[1] = e[3]
                e[3] = i
                if (t[1] < 0) {
                  i = e[2]
                  e[2] = e[3]
                  e[3] = i
                }
                e[2] *= t[1]
                e[3] *= t[1]
                if (t[2] < 0) {
                  i = e[0]
                  e[0] = e[1]
                  e[1] = i
                }
                e[0] *= t[2]
                e[1] *= t[2]
              }
              e[0] += t[4]
              e[1] += t[4]
              e[2] += t[5]
              e[3] += t[5]
            }
            static transform(t, e) {
              return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]]
            }
            static applyTransform(t, e) {
              return [t[0] * e[0] + t[1] * e[2] + e[4], t[0] * e[1] + t[1] * e[3] + e[5]]
            }
            static applyInverseTransform(t, e) {
              const i = e[0] * e[3] - e[1] * e[2]
              return [(t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / i, (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / i]
            }
            static getAxialAlignedBoundingBox(t, e) {
              const i = this.applyTransform(t, e),
                s = this.applyTransform(t.slice(2, 4), e),
                n = this.applyTransform([t[0], t[3]], e),
                a = this.applyTransform([t[2], t[1]], e)
              return [Math.min(i[0], s[0], n[0], a[0]), Math.min(i[1], s[1], n[1], a[1]), Math.max(i[0], s[0], n[0], a[0]), Math.max(i[1], s[1], n[1], a[1])]
            }
            static inverseTransform(t) {
              const e = t[0] * t[3] - t[1] * t[2]
              return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e]
            }
            static singularValueDecompose2dScale(t) {
              const e = [t[0], t[2], t[1], t[3]],
                i = t[0] * e[0] + t[1] * e[2],
                s = t[0] * e[1] + t[1] * e[3],
                n = t[2] * e[0] + t[3] * e[2],
                a = t[2] * e[1] + t[3] * e[3],
                r = (i + a) / 2,
                o = Math.sqrt((i + a) ** 2 - 4 * (i * a - n * s)) / 2,
                l = r + o || 1,
                h = r - o || 1
              return [Math.sqrt(l), Math.sqrt(h)]
            }
            static normalizeRect(t) {
              const e = t.slice(0)
              if (t[0] > t[2]) {
                e[0] = t[2]
                e[2] = t[0]
              }
              if (t[1] > t[3]) {
                e[1] = t[3]
                e[3] = t[1]
              }
              return e
            }
            static intersect(t, e) {
              const i = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])),
                s = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]))
              if (i > s) return null
              const n = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])),
                a = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]))
              return n > a ? null : [i, n, s, a]
            }
            static bezierBoundingBox(t, e, i, s, n, a, r, o) {
              const l = [],
                h = [[], []]
              let c, d, u, p, g, m, f, b
              for (let h = 0; h < 2; ++h) {
                if (0 === h) {
                  d = 6 * t - 12 * i + 6 * n
                  c = -3 * t + 9 * i - 9 * n + 3 * r
                  u = 3 * i - 3 * t
                } else {
                  d = 6 * e - 12 * s + 6 * a
                  c = -3 * e + 9 * s - 9 * a + 3 * o
                  u = 3 * s - 3 * e
                }
                if (Math.abs(c) < 1e-12) {
                  if (Math.abs(d) < 1e-12) continue
                  p = -u / d
                  0 < p && p < 1 && l.push(p)
                } else {
                  f = d * d - 4 * u * c
                  b = Math.sqrt(f)
                  if (!(f < 0)) {
                    g = (-d + b) / (2 * c)
                    0 < g && g < 1 && l.push(g)
                    m = (-d - b) / (2 * c)
                    0 < m && m < 1 && l.push(m)
                  }
                }
              }
              let A,
                _ = l.length
              const v = _
              for (; _--; ) {
                p = l[_]
                A = 1 - p
                h[0][_] = A * A * A * t + 3 * A * A * p * i + 3 * A * p * p * n + p * p * p * r
                h[1][_] = A * A * A * e + 3 * A * A * p * s + 3 * A * p * p * a + p * p * p * o
              }
              h[0][v] = t
              h[1][v] = e
              h[0][v + 1] = r
              h[1][v + 1] = o
              h[0].length = h[1].length = v + 2
              return [Math.min(...h[0]), Math.min(...h[1]), Math.max(...h[0]), Math.max(...h[1])]
            }
          }
          const o = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382,
            0, 8364,
          ]
          function stringToUTF8String(t) {
            return decodeURIComponent(escape(t))
          }
          e.PromiseCapability = class PromiseCapability {
            #t = !1
            constructor() {
              this.promise = new Promise((t, e) => {
                this.resolve = (e) => {
                  this.#t = !0
                  t(e)
                }
                this.reject = (t) => {
                  this.#t = !0
                  e(t)
                }
              })
            }
            get settled() {
              return this.#t
            }
          }
          let l = null,
            h = null
          e.AnnotationPrefix = 'pdfjs_internal_id_'
        },
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          Object.defineProperty(exports, '__esModule', { value: !0 })
          exports.RenderTask =
            exports.PDFWorkerUtil =
            exports.PDFWorker =
            exports.PDFPageProxy =
            exports.PDFDocumentProxy =
            exports.PDFDocumentLoadingTask =
            exports.PDFDataRangeTransport =
            exports.LoopbackPort =
            exports.DefaultStandardFontDataFactory =
            exports.DefaultFilterFactory =
            exports.DefaultCanvasFactory =
            exports.DefaultCMapReaderFactory =
              void 0
          Object.defineProperty(exports, 'SVGGraphics', {
            enumerable: !0,
            get: function () {
              return _displaySvg.SVGGraphics
            },
          })
          exports.build = void 0
          exports.getDocument = getDocument
          exports.version = void 0
          var _util = __w_pdfjs_require__(1),
            _annotation_storage = __w_pdfjs_require__(3),
            _display_utils = __w_pdfjs_require__(6),
            _font_loader = __w_pdfjs_require__(9),
            _displayNode_utils = __w_pdfjs_require__(10),
            _canvas = __w_pdfjs_require__(11),
            _worker_options = __w_pdfjs_require__(14),
            _message_handler = __w_pdfjs_require__(15),
            _metadata = __w_pdfjs_require__(16),
            _optional_content_config = __w_pdfjs_require__(17),
            _transport_stream = __w_pdfjs_require__(18),
            _displayFetch_stream = __w_pdfjs_require__(19),
            _displayNetwork = __w_pdfjs_require__(22),
            _displayNode_stream = __w_pdfjs_require__(23),
            _displaySvg = __w_pdfjs_require__(24),
            _xfa_text = __w_pdfjs_require__(25)
          const DEFAULT_RANGE_CHUNK_SIZE = 65536,
            RENDERING_CANCELLED_TIMEOUT = 100,
            DELAYED_CLEANUP_TIMEOUT = 5e3,
            DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory
          exports.DefaultCanvasFactory = DefaultCanvasFactory
          const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory
          const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory
          exports.DefaultFilterFactory = DefaultFilterFactory
          const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory
          function getDocument(t) {
            'string' == typeof t || t instanceof URL ? (t = { url: t }) : (0, _util.isArrayBuffer)(t) && (t = { data: t })
            if ('object' != typeof t) throw new Error('Invalid parameter in getDocument, need parameter object.')
            if (!t.url && !t.data && !t.range) throw new Error('Invalid parameter object: need either .data, .range or .url')
            const e = new PDFDocumentLoadingTask(),
              { docId: i } = e,
              s = t.url ? getUrlProp(t.url) : null,
              n = t.data ? getDataProp(t.data) : null,
              a = t.httpHeaders || null,
              r = !0 === t.withCredentials,
              o = t.password ?? null,
              l = t.range instanceof PDFDataRangeTransport ? t.range : null,
              h = Number.isInteger(t.rangeChunkSize) && t.rangeChunkSize > 0 ? t.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE
            let c = t.worker instanceof PDFWorker ? t.worker : null
            const d = t.verbosity,
              u = 'string' != typeof t.docBaseUrl || (0, _display_utils.isDataScheme)(t.docBaseUrl) ? null : t.docBaseUrl,
              p = 'string' == typeof t.cMapUrl ? t.cMapUrl : null,
              g = !1 !== t.cMapPacked,
              m = t.CMapReaderFactory || DefaultCMapReaderFactory,
              f = 'string' == typeof t.standardFontDataUrl ? t.standardFontDataUrl : null,
              b = t.StandardFontDataFactory || DefaultStandardFontDataFactory,
              A = !0 !== t.stopAtErrors,
              _ = Number.isInteger(t.maxImageSize) && t.maxImageSize > -1 ? t.maxImageSize : -1,
              v = !1 !== t.isEvalSupported,
              y = 'boolean' == typeof t.isOffscreenCanvasSupported ? t.isOffscreenCanvasSupported : !_util.isNodeJS,
              S = Number.isInteger(t.canvasMaxAreaInBytes) ? t.canvasMaxAreaInBytes : -1,
              E = 'boolean' == typeof t.disableFontFace ? t.disableFontFace : _util.isNodeJS,
              x = !0 === t.fontExtraProperties,
              w = !0 === t.enableXfa,
              C = t.ownerDocument || globalThis.document,
              T = !0 === t.disableRange,
              P = !0 === t.disableStream,
              M = !0 === t.disableAutoFetch,
              k = !0 === t.pdfBug,
              F = l ? l.length : t.length ?? NaN,
              R = 'boolean' == typeof t.useSystemFonts ? t.useSystemFonts : !_util.isNodeJS && !E,
              D = 'boolean' == typeof t.useWorkerFetch ? t.useWorkerFetch : m === _display_utils.DOMCMapReaderFactory && b === _display_utils.DOMStandardFontDataFactory && p && f && (0, _display_utils.isValidFetchUrl)(p, document.baseURI) && (0, _display_utils.isValidFetchUrl)(f, document.baseURI),
              I = t.canvasFactory || new DefaultCanvasFactory({ ownerDocument: C }),
              L = t.filterFactory || new DefaultFilterFactory({ docId: i, ownerDocument: C })
            ;(0, _util.setVerbosityLevel)(d)
            const O = { canvasFactory: I, filterFactory: L }
            if (!D) {
              O.cMapReaderFactory = new m({ baseUrl: p, isCompressed: g })
              O.standardFontDataFactory = new b({ baseUrl: f })
            }
            if (!c) {
              const t = { verbosity: d, port: _worker_options.GlobalWorkerOptions.workerPort }
              c = t.port ? PDFWorker.fromPort(t) : new PDFWorker(t)
              e._worker = c
            }
            const N = {
                docId: i,
                apiVersion: '3.11.174',
                data: n,
                password: o,
                disableAutoFetch: M,
                rangeChunkSize: h,
                length: F,
                docBaseUrl: u,
                enableXfa: w,
                evaluatorOptions: { maxImageSize: _, disableFontFace: E, ignoreErrors: A, isEvalSupported: v, isOffscreenCanvasSupported: y, canvasMaxAreaInBytes: S, fontExtraProperties: x, useSystemFonts: R, cMapUrl: D ? p : null, standardFontDataUrl: D ? f : null },
              },
              B = { ignoreErrors: A, isEvalSupported: v, disableFontFace: E, fontExtraProperties: x, enableXfa: w, ownerDocument: C, disableAutoFetch: M, pdfBug: k, styleElement: null }
            c.promise
              .then(function () {
                if (e.destroyed) throw new Error('Loading aborted')
                const t = _fetchDocument(c, N),
                  o = new Promise(function (t) {
                    let e
                    if (l) e = new _transport_stream.PDFDataTransportStream({ length: F, initialData: l.initialData, progressiveDone: l.progressiveDone, contentDispositionFilename: l.contentDispositionFilename, disableRange: T, disableStream: P }, l)
                    else if (!n) {
                      e = ((t) => (_util.isNodeJS ? new _displayNode_stream.PDFNodeStream(t) : (0, _display_utils.isValidFetchUrl)(t.url) ? new _displayFetch_stream.PDFFetchStream(t) : new _displayNetwork.PDFNetworkStream(t)))({
                        url: s,
                        length: F,
                        httpHeaders: a,
                        withCredentials: r,
                        rangeChunkSize: h,
                        disableRange: T,
                        disableStream: P,
                      })
                    }
                    t(e)
                  })
                return Promise.all([t, o]).then(function ([t, s]) {
                  if (e.destroyed) throw new Error('Loading aborted')
                  const n = new _message_handler.MessageHandler(i, t, c.port),
                    a = new WorkerTransport(n, e, s, B, O)
                  e._transport = a
                  n.send('Ready', null)
                })
              })
              .catch(e._capability.reject)
            return e
          }
          async function _fetchDocument(t, e) {
            if (t.destroyed) throw new Error('Worker was destroyed')
            const i = await t.messageHandler.sendWithPromise('GetDocRequest', e, e.data ? [e.data.buffer] : null)
            if (t.destroyed) throw new Error('Worker was destroyed')
            return i
          }
          function getUrlProp(t) {
            if (t instanceof URL) return t.href
            try {
              return new URL(t, window.location).href
            } catch {
              if (_util.isNodeJS && 'string' == typeof t) return t
            }
            throw new Error('Invalid PDF url data: either string or URL-object is expected in the url property.')
          }
          function getDataProp(t) {
            if (_util.isNodeJS && 'undefined' != typeof Buffer && t instanceof Buffer) throw new Error('Please provide binary data as `Uint8Array`, rather than `Buffer`.')
            if (t instanceof Uint8Array && t.byteLength === t.buffer.byteLength) return t
            if ('string' == typeof t) return (0, _util.stringToBytes)(t)
            if (('object' == typeof t && !isNaN(t?.length)) || (0, _util.isArrayBuffer)(t)) return new Uint8Array(t)
            throw new Error('Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.')
          }
          class PDFDocumentLoadingTask {
            static #e = 0
            constructor() {
              this._capability = new _util.PromiseCapability()
              this._transport = null
              this._worker = null
              this.docId = 'd' + PDFDocumentLoadingTask.#e++
              this.destroyed = !1
              this.onPassword = null
              this.onProgress = null
            }
            get promise() {
              return this._capability.promise
            }
            async destroy() {
              this.destroyed = !0
              try {
                this._worker?.port && (this._worker._pendingDestroy = !0)
                await this._transport?.destroy()
              } catch (t) {
                this._worker?.port && delete this._worker._pendingDestroy
                throw t
              }
              this._transport = null
              if (this._worker) {
                this._worker.destroy()
                this._worker = null
              }
            }
          }
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask
          class PDFDataRangeTransport {
            constructor(t, e, i = !1, s = null) {
              this.length = t
              this.initialData = e
              this.progressiveDone = i
              this.contentDispositionFilename = s
              this._rangeListeners = []
              this._progressListeners = []
              this._progressiveReadListeners = []
              this._progressiveDoneListeners = []
              this._readyCapability = new _util.PromiseCapability()
            }
            addRangeListener(t) {
              this._rangeListeners.push(t)
            }
            addProgressListener(t) {
              this._progressListeners.push(t)
            }
            addProgressiveReadListener(t) {
              this._progressiveReadListeners.push(t)
            }
            addProgressiveDoneListener(t) {
              this._progressiveDoneListeners.push(t)
            }
            onDataRange(t, e) {
              for (const i of this._rangeListeners) i(t, e)
            }
            onDataProgress(t, e) {
              this._readyCapability.promise.then(() => {
                for (const i of this._progressListeners) i(t, e)
              })
            }
            onDataProgressiveRead(t) {
              this._readyCapability.promise.then(() => {
                for (const e of this._progressiveReadListeners) e(t)
              })
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const t of this._progressiveDoneListeners) t()
              })
            }
            transportReady() {
              this._readyCapability.resolve()
            }
            requestDataRange(t, e) {
              ;(0, _util.unreachable)('Abstract method PDFDataRangeTransport.requestDataRange')
            }
            abort() {}
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport
          class PDFDocumentProxy {
            constructor(t, e) {
              this._pdfInfo = t
              this._transport = e
              Object.defineProperty(this, 'getJavaScript', {
                value: () => {
                  ;(0, _display_utils.deprecated)('`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead.')
                  return this.getJSActions().then((t) => {
                    if (!t) return t
                    const e = []
                    for (const i in t) e.push(...t[i])
                    return e
                  })
                },
              })
            }
            get annotationStorage() {
              return this._transport.annotationStorage
            }
            get filterFactory() {
              return this._transport.filterFactory
            }
            get numPages() {
              return this._pdfInfo.numPages
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, 'isPureXfa', !!this._transport._htmlForXfa)
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa
            }
            getPage(t) {
              return this._transport.getPage(t)
            }
            getPageIndex(t) {
              return this._transport.getPageIndex(t)
            }
            getDestinations() {
              return this._transport.getDestinations()
            }
            getDestination(t) {
              return this._transport.getDestination(t)
            }
            getPageLabels() {
              return this._transport.getPageLabels()
            }
            getPageLayout() {
              return this._transport.getPageLayout()
            }
            getPageMode() {
              return this._transport.getPageMode()
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences()
            }
            getOpenAction() {
              return this._transport.getOpenAction()
            }
            getAttachments() {
              return this._transport.getAttachments()
            }
            getJSActions() {
              return this._transport.getDocJSActions()
            }
            getOutline() {
              return this._transport.getOutline()
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig()
            }
            getPermissions() {
              return this._transport.getPermissions()
            }
            getMetadata() {
              return this._transport.getMetadata()
            }
            getMarkInfo() {
              return this._transport.getMarkInfo()
            }
            getData() {
              return this._transport.getData()
            }
            saveDocument() {
              return this._transport.saveDocument()
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise
            }
            cleanup(t = !1) {
              return this._transport.startCleanup(t || this.isPureXfa)
            }
            destroy() {
              return this.loadingTask.destroy()
            }
            get loadingParams() {
              return this._transport.loadingParams
            }
            get loadingTask() {
              return this._transport.loadingTask
            }
            getFieldObjects() {
              return this._transport.getFieldObjects()
            }
            hasJSActions() {
              return this._transport.hasJSActions()
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds()
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy
          class PDFPageProxy {
            #i = null
            #s = !1
            constructor(t, e, i, s = !1) {
              this._pageIndex = t
              this._pageInfo = e
              this._transport = i
              this._stats = s ? new _display_utils.StatTimer() : null
              this._pdfBug = s
              this.commonObjs = i.commonObjs
              this.objs = new PDFObjects()
              this._maybeCleanupAfterRender = !1
              this._intentStates = new Map()
              this.destroyed = !1
            }
            get pageNumber() {
              return this._pageIndex + 1
            }
            get rotate() {
              return this._pageInfo.rotate
            }
            get ref() {
              return this._pageInfo.ref
            }
            get userUnit() {
              return this._pageInfo.userUnit
            }
            get view() {
              return this._pageInfo.view
            }
            getViewport({ scale: t, rotation: e = this.rotate, offsetX: i = 0, offsetY: s = 0, dontFlip: n = !1 } = {}) {
              return new _display_utils.PageViewport({ viewBox: this.view, scale: t, rotation: e, offsetX: i, offsetY: s, dontFlip: n })
            }
            getAnnotations({ intent: t = 'display' } = {}) {
              const e = this._transport.getRenderingIntent(t)
              return this._transport.getAnnotations(this._pageIndex, e.renderingIntent)
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex)
            }
            get filterFactory() {
              return this._transport.filterFactory
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, 'isPureXfa', !!this._transport._htmlForXfa)
            }
            async getXfa() {
              return this._transport._htmlForXfa?.children[this._pageIndex] || null
            }
            render({ canvasContext: t, viewport: e, intent: i = 'display', annotationMode: s = _util.AnnotationMode.ENABLE, transform: n = null, background: a = null, optionalContentConfigPromise: r = null, annotationCanvasMap: o = null, pageColors: l = null, printAnnotationStorage: h = null }) {
              this._stats?.time('Overall')
              const c = this._transport.getRenderingIntent(i, s, h)
              this.#s = !1
              this.#n()
              r || (r = this._transport.getOptionalContentConfig())
              let d = this._intentStates.get(c.cacheKey)
              if (!d) {
                d = Object.create(null)
                this._intentStates.set(c.cacheKey, d)
              }
              if (d.streamReaderCancelTimeout) {
                clearTimeout(d.streamReaderCancelTimeout)
                d.streamReaderCancelTimeout = null
              }
              const u = !!(c.renderingIntent & _util.RenderingIntentFlag.PRINT)
              if (!d.displayReadyCapability) {
                d.displayReadyCapability = new _util.PromiseCapability()
                d.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }
                this._stats?.time('Page Request')
                this._pumpOperatorList(c)
              }
              const complete = (t) => {
                  d.renderTasks.delete(p)
                  ;(this._maybeCleanupAfterRender || u) && (this.#s = !0)
                  this.#a(!u)
                  if (t) {
                    p.capability.reject(t)
                    this._abortOperatorList({ intentState: d, reason: t instanceof Error ? t : new Error(t) })
                  } else p.capability.resolve()
                  this._stats?.timeEnd('Rendering')
                  this._stats?.timeEnd('Overall')
                },
                p = new InternalRenderTask({
                  callback: complete,
                  params: { canvasContext: t, viewport: e, transform: n, background: a },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  annotationCanvasMap: o,
                  operatorList: d.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: this._transport.canvasFactory,
                  filterFactory: this._transport.filterFactory,
                  useRequestAnimationFrame: !u,
                  pdfBug: this._pdfBug,
                  pageColors: l,
                })
              ;(d.renderTasks ||= new Set()).add(p)
              const g = p.task
              Promise.all([d.displayReadyCapability.promise, r])
                .then(([t, e]) => {
                  if (this.destroyed) complete()
                  else {
                    this._stats?.time('Rendering')
                    p.initializeGraphics({ transparency: t, optionalContentConfig: e })
                    p.operatorListChanged()
                  }
                })
                .catch(complete)
              return g
            }
            getOperatorList({ intent: t = 'display', annotationMode: e = _util.AnnotationMode.ENABLE, printAnnotationStorage: i = null } = {}) {
              const s = this._transport.getRenderingIntent(t, e, i, !0)
              let n,
                a = this._intentStates.get(s.cacheKey)
              if (!a) {
                a = Object.create(null)
                this._intentStates.set(s.cacheKey, a)
              }
              if (!a.opListReadCapability) {
                n = Object.create(null)
                n.operatorListChanged = function operatorListChanged() {
                  if (a.operatorList.lastChunk) {
                    a.opListReadCapability.resolve(a.operatorList)
                    a.renderTasks.delete(n)
                  }
                }
                a.opListReadCapability = new _util.PromiseCapability()
                ;(a.renderTasks ||= new Set()).add(n)
                a.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }
                this._stats?.time('Page Request')
                this._pumpOperatorList(s)
              }
              return a.opListReadCapability.promise
            }
            streamTextContent({ includeMarkedContent: t = !1, disableNormalization: e = !1 } = {}) {
              return this._transport.messageHandler.sendWithStream('GetTextContent', { pageIndex: this._pageIndex, includeMarkedContent: !0 === t, disableNormalization: !0 === e }, { highWaterMark: 100, size: (t) => t.items.length })
            }
            getTextContent(t = {}) {
              if (this._transport._htmlForXfa) return this.getXfa().then((t) => _xfa_text.XfaText.textContent(t))
              const e = this.streamTextContent(t)
              return new Promise(function (t, i) {
                const s = e.getReader(),
                  n = { items: [], styles: Object.create(null) }
                !(function pump() {
                  s.read().then(function ({ value: e, done: i }) {
                    if (i) t(n)
                    else {
                      Object.assign(n.styles, e.styles)
                      n.items.push(...e.items)
                      pump()
                    }
                  }, i)
                })()
              })
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex)
            }
            _destroy() {
              this.destroyed = !0
              const t = []
              for (const e of this._intentStates.values()) {
                this._abortOperatorList({ intentState: e, reason: new Error('Page was destroyed.'), force: !0 })
                if (!e.opListReadCapability)
                  for (const i of e.renderTasks) {
                    t.push(i.completed)
                    i.cancel()
                  }
              }
              this.objs.clear()
              this.#s = !1
              this.#n()
              return Promise.all(t)
            }
            cleanup(t = !1) {
              this.#s = !0
              const e = this.#a(!1)
              t && e && (this._stats &&= new _display_utils.StatTimer())
              return e
            }
            #a(t = !1) {
              this.#n()
              if (!this.#s || this.destroyed) return !1
              if (t) {
                this.#i = setTimeout(() => {
                  this.#i = null
                  this.#a(!1)
                }, DELAYED_CLEANUP_TIMEOUT)
                return !1
              }
              for (const { renderTasks: t, operatorList: e } of this._intentStates.values()) if (t.size > 0 || !e.lastChunk) return !1
              this._intentStates.clear()
              this.objs.clear()
              this.#s = !1
              return !0
            }
            #n() {
              if (this.#i) {
                clearTimeout(this.#i)
                this.#i = null
              }
            }
            _startRenderPage(t, e) {
              const i = this._intentStates.get(e)
              if (i) {
                this._stats?.timeEnd('Page Request')
                i.displayReadyCapability?.resolve(t)
              }
            }
            _renderPageChunk(t, e) {
              for (let i = 0, s = t.length; i < s; i++) {
                e.operatorList.fnArray.push(t.fnArray[i])
                e.operatorList.argsArray.push(t.argsArray[i])
              }
              e.operatorList.lastChunk = t.lastChunk
              e.operatorList.separateAnnots = t.separateAnnots
              for (const t of e.renderTasks) t.operatorListChanged()
              t.lastChunk && this.#a(!0)
            }
            _pumpOperatorList({ renderingIntent: t, cacheKey: e, annotationStorageSerializable: i }) {
              const { map: s, transfers: n } = i,
                a = this._transport.messageHandler.sendWithStream('GetOperatorList', { pageIndex: this._pageIndex, intent: t, cacheKey: e, annotationStorage: s }, n).getReader(),
                r = this._intentStates.get(e)
              r.streamReader = a
              const pump = () => {
                a.read().then(
                  ({ value: t, done: e }) => {
                    if (e) r.streamReader = null
                    else if (!this._transport.destroyed) {
                      this._renderPageChunk(t, r)
                      pump()
                    }
                  },
                  (t) => {
                    r.streamReader = null
                    if (!this._transport.destroyed) {
                      if (r.operatorList) {
                        r.operatorList.lastChunk = !0
                        for (const t of r.renderTasks) t.operatorListChanged()
                        this.#a(!0)
                      }
                      if (r.displayReadyCapability) r.displayReadyCapability.reject(t)
                      else {
                        if (!r.opListReadCapability) throw t
                        r.opListReadCapability.reject(t)
                      }
                    }
                  }
                )
              }
              pump()
            }
            _abortOperatorList({ intentState: t, reason: e, force: i = !1 }) {
              if (t.streamReader) {
                if (t.streamReaderCancelTimeout) {
                  clearTimeout(t.streamReaderCancelTimeout)
                  t.streamReaderCancelTimeout = null
                }
                if (!i) {
                  if (t.renderTasks.size > 0) return
                  if (e instanceof _display_utils.RenderingCancelledException) {
                    let i = RENDERING_CANCELLED_TIMEOUT
                    e.extraDelay > 0 && e.extraDelay < 1e3 && (i += e.extraDelay)
                    t.streamReaderCancelTimeout = setTimeout(() => {
                      t.streamReaderCancelTimeout = null
                      this._abortOperatorList({ intentState: t, reason: e, force: !0 })
                    }, i)
                    return
                  }
                }
                t.streamReader.cancel(new _util.AbortException(e.message)).catch(() => {})
                t.streamReader = null
                if (!this._transport.destroyed) {
                  for (const [e, i] of this._intentStates)
                    if (i === t) {
                      this._intentStates.delete(e)
                      break
                    }
                  this.cleanup()
                }
              }
            }
            get stats() {
              return this._stats
            }
          }
          exports.PDFPageProxy = PDFPageProxy
          class LoopbackPort {
            #r = new Set()
            #o = Promise.resolve()
            postMessage(t, e) {
              const i = { data: structuredClone(t, e ? { transfer: e } : null) }
              this.#o.then(() => {
                for (const t of this.#r) t.call(this, i)
              })
            }
            addEventListener(t, e) {
              this.#r.add(e)
            }
            removeEventListener(t, e) {
              this.#r.delete(e)
            }
            terminate() {
              this.#r.clear()
            }
          }
          exports.LoopbackPort = LoopbackPort
          const PDFWorkerUtil = { isWorkerDisabled: !1, fallbackWorkerSrc: null, fakeWorkerId: 0 }
          exports.PDFWorkerUtil = PDFWorkerUtil
          if (_util.isNodeJS && 'function' == typeof require) {
            PDFWorkerUtil.isWorkerDisabled = !0
            PDFWorkerUtil.fallbackWorkerSrc = './pdf.worker.js'
          } else if ('object' == typeof document) {
            const t = document?.currentScript?.src
            t && (PDFWorkerUtil.fallbackWorkerSrc = t.replace(/(\.(?:min\.)?js)(\?.*)?$/i, '.worker$1$2'))
          }
          PDFWorkerUtil.isSameOrigin = function (t, e) {
            let i
            try {
              i = new URL(t)
              if (!i.origin || 'null' === i.origin) return !1
            } catch {
              return !1
            }
            const s = new URL(e, i)
            return i.origin === s.origin
          }
          PDFWorkerUtil.createCDNWrapper = function (t) {
            const e = `importScripts("${t}");`
            return URL.createObjectURL(new Blob([e]))
          }
          class PDFWorker {
            static #l
            constructor({ name: t = null, port: e = null, verbosity: i = (0, _util.getVerbosityLevel)() } = {}) {
              this.name = t
              this.destroyed = !1
              this.verbosity = i
              this._readyCapability = new _util.PromiseCapability()
              this._port = null
              this._webWorker = null
              this._messageHandler = null
              if (e) {
                if (PDFWorker.#l?.has(e)) throw new Error('Cannot use more than one PDFWorker per port.')
                ;(PDFWorker.#l ||= new WeakMap()).set(e, this)
                this._initializeFromPort(e)
              } else this._initialize()
            }
            get promise() {
              return this._readyCapability.promise
            }
            get port() {
              return this._port
            }
            get messageHandler() {
              return this._messageHandler
            }
            _initializeFromPort(t) {
              this._port = t
              this._messageHandler = new _message_handler.MessageHandler('main', 'worker', t)
              this._messageHandler.on('ready', function () {})
              this._readyCapability.resolve()
              this._messageHandler.send('configure', { verbosity: this.verbosity })
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
                let { workerSrc: t } = PDFWorker
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, t) || (t = PDFWorkerUtil.createCDNWrapper(new URL(t, window.location).href))
                  const e = new Worker(t),
                    i = new _message_handler.MessageHandler('main', 'worker', e),
                    terminateEarly = () => {
                      e.removeEventListener('error', onWorkerError)
                      i.destroy()
                      e.terminate()
                      this.destroyed ? this._readyCapability.reject(new Error('Worker was destroyed')) : this._setupFakeWorker()
                    },
                    onWorkerError = () => {
                      this._webWorker || terminateEarly()
                    }
                  e.addEventListener('error', onWorkerError)
                  i.on('test', (t) => {
                    e.removeEventListener('error', onWorkerError)
                    if (this.destroyed) terminateEarly()
                    else if (t) {
                      this._messageHandler = i
                      this._port = e
                      this._webWorker = e
                      this._readyCapability.resolve()
                      i.send('configure', { verbosity: this.verbosity })
                    } else {
                      this._setupFakeWorker()
                      i.destroy()
                      e.terminate()
                    }
                  })
                  i.on('ready', (t) => {
                    e.removeEventListener('error', onWorkerError)
                    if (this.destroyed) terminateEarly()
                    else
                      try {
                        sendTest()
                      } catch {
                        this._setupFakeWorker()
                      }
                  })
                  const sendTest = () => {
                    const t = new Uint8Array()
                    i.send('test', t, [t.buffer])
                  }
                  sendTest()
                  return
                } catch {
                  ;(0, _util.info)('The worker has been disabled.')
                }
              }
              this._setupFakeWorker()
            }
            _setupFakeWorker() {
              if (!PDFWorkerUtil.isWorkerDisabled) {
                ;(0, _util.warn)('Setting up fake worker.')
                PDFWorkerUtil.isWorkerDisabled = !0
              }
              PDFWorker._setupFakeWorkerGlobal
                .then((t) => {
                  if (this.destroyed) {
                    this._readyCapability.reject(new Error('Worker was destroyed'))
                    return
                  }
                  const e = new LoopbackPort()
                  this._port = e
                  const i = 'fake' + PDFWorkerUtil.fakeWorkerId++,
                    s = new _message_handler.MessageHandler(i + '_worker', i, e)
                  t.setup(s, e)
                  const n = new _message_handler.MessageHandler(i, i + '_worker', e)
                  this._messageHandler = n
                  this._readyCapability.resolve()
                  n.send('configure', { verbosity: this.verbosity })
                })
                .catch((t) => {
                  this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`))
                })
            }
            destroy() {
              this.destroyed = !0
              if (this._webWorker) {
                this._webWorker.terminate()
                this._webWorker = null
              }
              PDFWorker.#l?.delete(this._port)
              this._port = null
              if (this._messageHandler) {
                this._messageHandler.destroy()
                this._messageHandler = null
              }
            }
            static fromPort(t) {
              if (!t?.port) throw new Error('PDFWorker.fromPort - invalid method signature.')
              const e = this.#l?.get(t.port)
              if (e) {
                if (e._pendingDestroy) throw new Error('PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.')
                return e
              }
              return new PDFWorker(t)
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc) return _worker_options.GlobalWorkerOptions.workerSrc
              if (null !== PDFWorkerUtil.fallbackWorkerSrc) {
                _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.')
                return PDFWorkerUtil.fallbackWorkerSrc
              }
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.')
            }
            static get _mainThreadWorkerMessageHandler() {
              try {
                return globalThis.pdfjsWorker?.WorkerMessageHandler || null
              } catch {
                return null
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler
                if (mainWorkerMessageHandler) return mainWorkerMessageHandler
                if (_util.isNodeJS && 'function' == typeof require) {
                  const worker = eval('require')(this.workerSrc)
                  return worker.WorkerMessageHandler
                }
                await (0, _display_utils.loadScript)(this.workerSrc)
                return window.pdfjsWorker.WorkerMessageHandler
              }
              return (0, _util.shadow)(this, '_setupFakeWorkerGlobal', loader())
            }
          }
          exports.PDFWorker = PDFWorker
          class WorkerTransport {
            #h = new Map()
            #c = new Map()
            #d = new Map()
            #u = null
            constructor(t, e, i, s, n) {
              this.messageHandler = t
              this.loadingTask = e
              this.commonObjs = new PDFObjects()
              this.fontLoader = new _font_loader.FontLoader({ ownerDocument: s.ownerDocument, styleElement: s.styleElement })
              this._params = s
              this.canvasFactory = n.canvasFactory
              this.filterFactory = n.filterFactory
              this.cMapReaderFactory = n.cMapReaderFactory
              this.standardFontDataFactory = n.standardFontDataFactory
              this.destroyed = !1
              this.destroyCapability = null
              this._networkStream = i
              this._fullReader = null
              this._lastProgress = null
              this.downloadInfoCapability = new _util.PromiseCapability()
              this.setupMessageHandler()
            }
            #p(t, e = null) {
              const i = this.#h.get(t)
              if (i) return i
              const s = this.messageHandler.sendWithPromise(t, e)
              this.#h.set(t, s)
              return s
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, 'annotationStorage', new _annotation_storage.AnnotationStorage())
            }
            getRenderingIntent(t, e = _util.AnnotationMode.ENABLE, i = null, s = !1) {
              let n = _util.RenderingIntentFlag.DISPLAY,
                a = _annotation_storage.SerializableEmpty
              switch (t) {
                case 'any':
                  n = _util.RenderingIntentFlag.ANY
                  break
                case 'display':
                  break
                case 'print':
                  n = _util.RenderingIntentFlag.PRINT
                  break
                default:
                  ;(0, _util.warn)(`getRenderingIntent - invalid intent: ${t}`)
              }
              switch (e) {
                case _util.AnnotationMode.DISABLE:
                  n += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE
                  break
                case _util.AnnotationMode.ENABLE:
                  break
                case _util.AnnotationMode.ENABLE_FORMS:
                  n += _util.RenderingIntentFlag.ANNOTATIONS_FORMS
                  break
                case _util.AnnotationMode.ENABLE_STORAGE:
                  n += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE
                  a = (n & _util.RenderingIntentFlag.PRINT && i instanceof _annotation_storage.PrintAnnotationStorage ? i : this.annotationStorage).serializable
                  break
                default:
                  ;(0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${e}`)
              }
              s && (n += _util.RenderingIntentFlag.OPLIST)
              return { renderingIntent: n, cacheKey: `${n}_${a.hash}`, annotationStorageSerializable: a }
            }
            destroy() {
              if (this.destroyCapability) return this.destroyCapability.promise
              this.destroyed = !0
              this.destroyCapability = new _util.PromiseCapability()
              this.#u?.reject(new Error('Worker was destroyed during onPassword callback'))
              const t = []
              for (const e of this.#c.values()) t.push(e._destroy())
              this.#c.clear()
              this.#d.clear()
              this.hasOwnProperty('annotationStorage') && this.annotationStorage.resetModified()
              const e = this.messageHandler.sendWithPromise('Terminate', null)
              t.push(e)
              Promise.all(t).then(() => {
                this.commonObjs.clear()
                this.fontLoader.clear()
                this.#h.clear()
                this.filterFactory.destroy()
                this._networkStream?.cancelAllRequests(new _util.AbortException('Worker was terminated.'))
                if (this.messageHandler) {
                  this.messageHandler.destroy()
                  this.messageHandler = null
                }
                this.destroyCapability.resolve()
              }, this.destroyCapability.reject)
              return this.destroyCapability.promise
            }
            setupMessageHandler() {
              const { messageHandler: t, loadingTask: e } = this
              t.on('GetReader', (t, e) => {
                ;(0, _util.assert)(this._networkStream, 'GetReader - no `IPDFStream` instance available.')
                this._fullReader = this._networkStream.getFullReader()
                this._fullReader.onProgress = (t) => {
                  this._lastProgress = { loaded: t.loaded, total: t.total }
                }
                e.onPull = () => {
                  this._fullReader
                    .read()
                    .then(function ({ value: t, done: i }) {
                      if (i) e.close()
                      else {
                        ;(0, _util.assert)(t instanceof ArrayBuffer, 'GetReader - expected an ArrayBuffer.')
                        e.enqueue(new Uint8Array(t), 1, [t])
                      }
                    })
                    .catch((t) => {
                      e.error(t)
                    })
                }
                e.onCancel = (t) => {
                  this._fullReader.cancel(t)
                  e.ready.catch((t) => {
                    if (!this.destroyed) throw t
                  })
                }
              })
              t.on('ReaderHeadersReady', (t) => {
                const i = new _util.PromiseCapability(),
                  s = this._fullReader
                s.headersReady.then(() => {
                  if (!s.isStreamingSupported || !s.isRangeSupported) {
                    this._lastProgress && e.onProgress?.(this._lastProgress)
                    s.onProgress = (t) => {
                      e.onProgress?.({ loaded: t.loaded, total: t.total })
                    }
                  }
                  i.resolve({ isStreamingSupported: s.isStreamingSupported, isRangeSupported: s.isRangeSupported, contentLength: s.contentLength })
                }, i.reject)
                return i.promise
              })
              t.on('GetRangeReader', (t, e) => {
                ;(0, _util.assert)(this._networkStream, 'GetRangeReader - no `IPDFStream` instance available.')
                const i = this._networkStream.getRangeReader(t.begin, t.end)
                if (i) {
                  e.onPull = () => {
                    i.read()
                      .then(function ({ value: t, done: i }) {
                        if (i) e.close()
                        else {
                          ;(0, _util.assert)(t instanceof ArrayBuffer, 'GetRangeReader - expected an ArrayBuffer.')
                          e.enqueue(new Uint8Array(t), 1, [t])
                        }
                      })
                      .catch((t) => {
                        e.error(t)
                      })
                  }
                  e.onCancel = (t) => {
                    i.cancel(t)
                    e.ready.catch((t) => {
                      if (!this.destroyed) throw t
                    })
                  }
                } else e.close()
              })
              t.on('GetDoc', ({ pdfInfo: t }) => {
                this._numPages = t.numPages
                this._htmlForXfa = t.htmlForXfa
                delete t.htmlForXfa
                e._capability.resolve(new PDFDocumentProxy(t, this))
              })
              t.on('DocException', function (t) {
                let i
                switch (t.name) {
                  case 'PasswordException':
                    i = new _util.PasswordException(t.message, t.code)
                    break
                  case 'InvalidPDFException':
                    i = new _util.InvalidPDFException(t.message)
                    break
                  case 'MissingPDFException':
                    i = new _util.MissingPDFException(t.message)
                    break
                  case 'UnexpectedResponseException':
                    i = new _util.UnexpectedResponseException(t.message, t.status)
                    break
                  case 'UnknownErrorException':
                    i = new _util.UnknownErrorException(t.message, t.details)
                    break
                  default:
                    ;(0, _util.unreachable)('DocException - expected a valid Error.')
                }
                e._capability.reject(i)
              })
              t.on('PasswordRequest', (t) => {
                this.#u = new _util.PromiseCapability()
                if (e.onPassword) {
                  const updatePassword = (t) => {
                    t instanceof Error ? this.#u.reject(t) : this.#u.resolve({ password: t })
                  }
                  try {
                    e.onPassword(updatePassword, t.code)
                  } catch (t) {
                    this.#u.reject(t)
                  }
                } else this.#u.reject(new _util.PasswordException(t.message, t.code))
                return this.#u.promise
              })
              t.on('DataLoaded', (t) => {
                e.onProgress?.({ loaded: t.length, total: t.length })
                this.downloadInfoCapability.resolve(t)
              })
              t.on('StartRenderPage', (t) => {
                if (this.destroyed) return
                this.#c.get(t.pageIndex)._startRenderPage(t.transparency, t.cacheKey)
              })
              t.on('commonobj', ([e, i, s]) => {
                if (!this.destroyed && !this.commonObjs.has(e))
                  switch (i) {
                    case 'Font':
                      const n = this._params
                      if ('error' in s) {
                        const t = s.error
                        ;(0, _util.warn)(`Error during font loading: ${t}`)
                        this.commonObjs.resolve(e, t)
                        break
                      }
                      const a = n.pdfBug && globalThis.FontInspector?.enabled ? (t, e) => globalThis.FontInspector.fontAdded(t, e) : null,
                        r = new _font_loader.FontFaceObject(s, { isEvalSupported: n.isEvalSupported, disableFontFace: n.disableFontFace, ignoreErrors: n.ignoreErrors, inspectFont: a })
                      this.fontLoader
                        .bind(r)
                        .catch((i) => t.sendWithPromise('FontFallback', { id: e }))
                        .finally(() => {
                          !n.fontExtraProperties && r.data && (r.data = null)
                          this.commonObjs.resolve(e, r)
                        })
                      break
                    case 'FontPath':
                    case 'Image':
                    case 'Pattern':
                      this.commonObjs.resolve(e, s)
                      break
                    default:
                      throw new Error(`Got unknown common object type ${i}`)
                  }
              })
              t.on('obj', ([t, e, i, s]) => {
                if (this.destroyed) return
                const n = this.#c.get(e)
                if (!n.objs.has(t))
                  switch (i) {
                    case 'Image':
                      n.objs.resolve(t, s)
                      if (s) {
                        let t
                        if (s.bitmap) {
                          const { width: e, height: i } = s
                          t = e * i * 4
                        } else t = s.data?.length || 0
                        t > _util.MAX_IMAGE_SIZE_TO_CACHE && (n._maybeCleanupAfterRender = !0)
                      }
                      break
                    case 'Pattern':
                      n.objs.resolve(t, s)
                      break
                    default:
                      throw new Error(`Got unknown object type ${i}`)
                  }
              })
              t.on('DocProgress', (t) => {
                this.destroyed || e.onProgress?.({ loaded: t.loaded, total: t.total })
              })
              t.on('FetchBuiltInCMap', (t) => (this.destroyed ? Promise.reject(new Error('Worker was destroyed.')) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(t) : Promise.reject(new Error('CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.'))))
              t.on('FetchStandardFontData', (t) => (this.destroyed ? Promise.reject(new Error('Worker was destroyed.')) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(t) : Promise.reject(new Error('StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.'))))
            }
            getData() {
              return this.messageHandler.sendWithPromise('GetData', null)
            }
            saveDocument() {
              this.annotationStorage.size <= 0 && (0, _util.warn)('saveDocument called while `annotationStorage` is empty, please use the getData-method instead.')
              const { map: t, transfers: e } = this.annotationStorage.serializable
              return this.messageHandler.sendWithPromise('SaveDocument', { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: t, filename: this._fullReader?.filename ?? null }, e).finally(() => {
                this.annotationStorage.resetModified()
              })
            }
            getPage(t) {
              if (!Number.isInteger(t) || t <= 0 || t > this._numPages) return Promise.reject(new Error('Invalid page request.'))
              const e = t - 1,
                i = this.#d.get(e)
              if (i) return i
              const s = this.messageHandler.sendWithPromise('GetPage', { pageIndex: e }).then((t) => {
                if (this.destroyed) throw new Error('Transport destroyed')
                const i = new PDFPageProxy(e, t, this, this._params.pdfBug)
                this.#c.set(e, i)
                return i
              })
              this.#d.set(e, s)
              return s
            }
            getPageIndex(t) {
              return 'object' != typeof t || null === t || !Number.isInteger(t.num) || t.num < 0 || !Number.isInteger(t.gen) || t.gen < 0 ? Promise.reject(new Error('Invalid pageIndex request.')) : this.messageHandler.sendWithPromise('GetPageIndex', { num: t.num, gen: t.gen })
            }
            getAnnotations(t, e) {
              return this.messageHandler.sendWithPromise('GetAnnotations', { pageIndex: t, intent: e })
            }
            getFieldObjects() {
              return this.#p('GetFieldObjects')
            }
            hasJSActions() {
              return this.#p('HasJSActions')
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise('GetCalculationOrderIds', null)
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise('GetDestinations', null)
            }
            getDestination(t) {
              return 'string' != typeof t ? Promise.reject(new Error('Invalid destination request.')) : this.messageHandler.sendWithPromise('GetDestination', { id: t })
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise('GetPageLabels', null)
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise('GetPageLayout', null)
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise('GetPageMode', null)
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise('GetViewerPreferences', null)
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise('GetOpenAction', null)
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise('GetAttachments', null)
            }
            getDocJSActions() {
              return this.#p('GetDocJSActions')
            }
            getPageJSActions(t) {
              return this.messageHandler.sendWithPromise('GetPageJSActions', { pageIndex: t })
            }
            getStructTree(t) {
              return this.messageHandler.sendWithPromise('GetStructTree', { pageIndex: t })
            }
            getOutline() {
              return this.messageHandler.sendWithPromise('GetOutline', null)
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise('GetOptionalContentConfig', null).then((t) => new _optional_content_config.OptionalContentConfig(t))
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise('GetPermissions', null)
            }
            getMetadata() {
              const t = 'GetMetadata',
                e = this.#h.get(t)
              if (e) return e
              const i = this.messageHandler.sendWithPromise(t, null).then((t) => ({ info: t[0], metadata: t[1] ? new _metadata.Metadata(t[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }))
              this.#h.set(t, i)
              return i
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise('GetMarkInfo', null)
            }
            async startCleanup(t = !1) {
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise('Cleanup', null)
                for (const t of this.#c.values()) {
                  if (!t.cleanup()) throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`)
                }
                this.commonObjs.clear()
                t || this.fontLoader.clear()
                this.#h.clear()
                this.filterFactory.destroy(!0)
              }
            }
            get loadingParams() {
              const { disableAutoFetch: t, enableXfa: e } = this._params
              return (0, _util.shadow)(this, 'loadingParams', { disableAutoFetch: t, enableXfa: e })
            }
          }
          class PDFObjects {
            #g = Object.create(null)
            #m(t) {
              return (this.#g[t] ||= { capability: new _util.PromiseCapability(), data: null })
            }
            get(t, e = null) {
              if (e) {
                const i = this.#m(t)
                i.capability.promise.then(() => e(i.data))
                return null
              }
              const i = this.#g[t]
              if (!i?.capability.settled) throw new Error(`Requesting object that isn't resolved yet ${t}.`)
              return i.data
            }
            has(t) {
              const e = this.#g[t]
              return e?.capability.settled || !1
            }
            resolve(t, e = null) {
              const i = this.#m(t)
              i.data = e
              i.capability.resolve()
            }
            clear() {
              for (const t in this.#g) {
                const { data: e } = this.#g[t]
                e?.bitmap?.close()
              }
              this.#g = Object.create(null)
            }
          }
          class RenderTask {
            #f = null
            constructor(t) {
              this.#f = t
              this.onContinue = null
            }
            get promise() {
              return this.#f.capability.promise
            }
            cancel(t = 0) {
              this.#f.cancel(null, t)
            }
            get separateAnnots() {
              const { separateAnnots: t } = this.#f.operatorList
              if (!t) return !1
              const { annotationCanvasMap: e } = this.#f
              return t.form || (t.canvas && e?.size > 0)
            }
          }
          exports.RenderTask = RenderTask
          class InternalRenderTask {
            static #b = new WeakSet()
            constructor({ callback: t, params: e, objs: i, commonObjs: s, annotationCanvasMap: n, operatorList: a, pageIndex: r, canvasFactory: o, filterFactory: l, useRequestAnimationFrame: h = !1, pdfBug: c = !1, pageColors: d = null }) {
              this.callback = t
              this.params = e
              this.objs = i
              this.commonObjs = s
              this.annotationCanvasMap = n
              this.operatorListIdx = null
              this.operatorList = a
              this._pageIndex = r
              this.canvasFactory = o
              this.filterFactory = l
              this._pdfBug = c
              this.pageColors = d
              this.running = !1
              this.graphicsReadyCallback = null
              this.graphicsReady = !1
              this._useRequestAnimationFrame = !0 === h && 'undefined' != typeof window
              this.cancelled = !1
              this.capability = new _util.PromiseCapability()
              this.task = new RenderTask(this)
              this._cancelBound = this.cancel.bind(this)
              this._continueBound = this._continue.bind(this)
              this._scheduleNextBound = this._scheduleNext.bind(this)
              this._nextBound = this._next.bind(this)
              this._canvas = e.canvasContext.canvas
            }
            get completed() {
              return this.capability.promise.catch(function () {})
            }
            initializeGraphics({ transparency: t = !1, optionalContentConfig: e }) {
              if (this.cancelled) return
              if (this._canvas) {
                if (InternalRenderTask.#b.has(this._canvas)) throw new Error('Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.')
                InternalRenderTask.#b.add(this._canvas)
              }
              if (this._pdfBug && globalThis.StepperManager?.enabled) {
                this.stepper = globalThis.StepperManager.create(this._pageIndex)
                this.stepper.init(this.operatorList)
                this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()
              }
              const { canvasContext: i, viewport: s, transform: n, background: a } = this.params
              this.gfx = new _canvas.CanvasGraphics(i, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: e }, this.annotationCanvasMap, this.pageColors)
              this.gfx.beginDrawing({ transform: n, viewport: s, transparency: t, background: a })
              this.operatorListIdx = 0
              this.graphicsReady = !0
              this.graphicsReadyCallback?.()
            }
            cancel(t = null, e = 0) {
              this.running = !1
              this.cancelled = !0
              this.gfx?.endDrawing()
              InternalRenderTask.#b.delete(this._canvas)
              this.callback(t || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, e))
            }
            operatorListChanged() {
              if (this.graphicsReady) {
                this.stepper?.updateOperatorList(this.operatorList)
                this.running || this._continue()
              } else this.graphicsReadyCallback ||= this._continueBound
            }
            _continue() {
              this.running = !0
              this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext())
            }
            _scheduleNext() {
              this._useRequestAnimationFrame
                ? window.requestAnimationFrame(() => {
                    this._nextBound().catch(this._cancelBound)
                  })
                : Promise.resolve().then(this._nextBound).catch(this._cancelBound)
            }
            async _next() {
              if (!this.cancelled) {
                this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper)
                if (this.operatorListIdx === this.operatorList.argsArray.length) {
                  this.running = !1
                  if (this.operatorList.lastChunk) {
                    this.gfx.endDrawing()
                    InternalRenderTask.#b.delete(this._canvas)
                    this.callback()
                  }
                }
              }
            }
          }
          const version = '3.11.174'
          exports.version = version
          const build = 'ce8716743'
          exports.build = build
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.SerializableEmpty = e.PrintAnnotationStorage = e.AnnotationStorage = void 0
          var s = i(1),
            n = i(4),
            a = i(8)
          const r = Object.freeze({ map: null, hash: '', transfers: void 0 })
          e.SerializableEmpty = r
          class AnnotationStorage {
            #A = !1
            #_ = new Map()
            constructor() {
              this.onSetModified = null
              this.onResetModified = null
              this.onAnnotationEditor = null
            }
            getValue(t, e) {
              const i = this.#_.get(t)
              return void 0 === i ? e : Object.assign(e, i)
            }
            getRawValue(t) {
              return this.#_.get(t)
            }
            remove(t) {
              this.#_.delete(t)
              0 === this.#_.size && this.resetModified()
              if ('function' == typeof this.onAnnotationEditor) {
                for (const t of this.#_.values()) if (t instanceof n.AnnotationEditor) return
                this.onAnnotationEditor(null)
              }
            }
            setValue(t, e) {
              const i = this.#_.get(t)
              let s = !1
              if (void 0 !== i) {
                for (const [t, n] of Object.entries(e))
                  if (i[t] !== n) {
                    s = !0
                    i[t] = n
                  }
              } else {
                s = !0
                this.#_.set(t, e)
              }
              s && this.#v()
              e instanceof n.AnnotationEditor && 'function' == typeof this.onAnnotationEditor && this.onAnnotationEditor(e.constructor._type)
            }
            has(t) {
              return this.#_.has(t)
            }
            getAll() {
              return this.#_.size > 0 ? (0, s.objectFromMap)(this.#_) : null
            }
            setAll(t) {
              for (const [e, i] of Object.entries(t)) this.setValue(e, i)
            }
            get size() {
              return this.#_.size
            }
            #v() {
              if (!this.#A) {
                this.#A = !0
                'function' == typeof this.onSetModified && this.onSetModified()
              }
            }
            resetModified() {
              if (this.#A) {
                this.#A = !1
                'function' == typeof this.onResetModified && this.onResetModified()
              }
            }
            get print() {
              return new PrintAnnotationStorage(this)
            }
            get serializable() {
              if (0 === this.#_.size) return r
              const t = new Map(),
                e = new a.MurmurHash3_64(),
                i = [],
                s = Object.create(null)
              let o = !1
              for (const [i, a] of this.#_) {
                const r = a instanceof n.AnnotationEditor ? a.serialize(!1, s) : a
                if (r) {
                  t.set(i, r)
                  e.update(`${i}:${JSON.stringify(r)}`)
                  o ||= !!r.bitmap
                }
              }
              if (o) for (const e of t.values()) e.bitmap && i.push(e.bitmap)
              return t.size > 0 ? { map: t, hash: e.hexdigest(), transfers: i } : r
            }
          }
          e.AnnotationStorage = AnnotationStorage
          class PrintAnnotationStorage extends AnnotationStorage {
            #y
            constructor(t) {
              super()
              const { map: e, hash: i, transfers: s } = t.serializable,
                n = structuredClone(e, s ? { transfer: s } : null)
              this.#y = { map: n, hash: i, transfers: s }
            }
            get print() {
              ;(0, s.unreachable)('Should not call PrintAnnotationStorage.print')
            }
            get serializable() {
              return this.#y
            }
          }
          e.PrintAnnotationStorage = PrintAnnotationStorage
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.AnnotationEditor = void 0
          var s = i(5),
            n = i(1),
            a = i(6)
          class AnnotationEditor {
            #S = ''
            #E = !1
            #x = null
            #w = null
            #C = null
            #T = !1
            #P = null
            #M = this.focusin.bind(this)
            #k = this.focusout.bind(this)
            #F = !1
            #R = !1
            #D = !1
            _initialOptions = Object.create(null)
            _uiManager = null
            _focusEventsAllowed = !0
            _l10nPromise = null
            #I = !1
            #L = AnnotationEditor._zIndex++
            static _borderLineWidth = -1
            static _colorManager = new s.ColorManager()
            static _zIndex = 1
            static SMALL_EDITOR_SIZE = 0
            constructor(t) {
              this.constructor === AnnotationEditor && (0, n.unreachable)('Cannot initialize AnnotationEditor.')
              this.parent = t.parent
              this.id = t.id
              this.width = this.height = null
              this.pageIndex = t.parent.pageIndex
              this.name = t.name
              this.div = null
              this._uiManager = t.uiManager
              this.annotationElementId = null
              this._willKeepAspectRatio = !1
              this._initialOptions.isCentered = t.isCentered
              this._structTreeParentId = null
              const {
                rotation: e,
                rawDims: { pageWidth: i, pageHeight: s, pageX: a, pageY: r },
              } = this.parent.viewport
              this.rotation = e
              this.pageRotation = (360 + e - this._uiManager.viewParameters.rotation) % 360
              this.pageDimensions = [i, s]
              this.pageTranslation = [a, r]
              const [o, l] = this.parentDimensions
              this.x = t.x / o
              this.y = t.y / l
              this.isAttachedToDOM = !1
              this.deleted = !1
            }
            get editorType() {
              return Object.getPrototypeOf(this).constructor._type
            }
            static get _defaultLineColor() {
              return (0, n.shadow)(this, '_defaultLineColor', this._colorManager.getHexCode('CanvasText'))
            }
            static deleteAnnotationElement(t) {
              const e = new FakeEditor({ id: t.parent.getNextId(), parent: t.parent, uiManager: t._uiManager })
              e.annotationElementId = t.annotationElementId
              e.deleted = !0
              e._uiManager.addToAnnotationStorage(e)
            }
            static initialize(t, e = null) {
              AnnotationEditor._l10nPromise ||= new Map(['editor_alt_text_button_label', 'editor_alt_text_edit_button_label', 'editor_alt_text_decorative_tooltip'].map((e) => [e, t.get(e)]))
              if (e?.strings) for (const i of e.strings) AnnotationEditor._l10nPromise.set(i, t.get(i))
              if (-1 !== AnnotationEditor._borderLineWidth) return
              const i = getComputedStyle(document.documentElement)
              AnnotationEditor._borderLineWidth = parseFloat(i.getPropertyValue('--outline-width')) || 0
            }
            static updateDefaultParams(t, e) {}
            static get defaultPropertiesToUpdate() {
              return []
            }
            static isHandlingMimeForPasting(t) {
              return !1
            }
            static paste(t, e) {
              ;(0, n.unreachable)('Not implemented')
            }
            get propertiesToUpdate() {
              return []
            }
            get _isDraggable() {
              return this.#I
            }
            set _isDraggable(t) {
              this.#I = t
              this.div?.classList.toggle('draggable', t)
            }
            center() {
              const [t, e] = this.pageDimensions
              switch (this.parentRotation) {
                case 90:
                  this.x -= (this.height * e) / (2 * t)
                  this.y += (this.width * t) / (2 * e)
                  break
                case 180:
                  this.x += this.width / 2
                  this.y += this.height / 2
                  break
                case 270:
                  this.x += (this.height * e) / (2 * t)
                  this.y -= (this.width * t) / (2 * e)
                  break
                default:
                  this.x -= this.width / 2
                  this.y -= this.height / 2
              }
              this.fixAndSetPosition()
            }
            addCommands(t) {
              this._uiManager.addCommands(t)
            }
            get currentLayer() {
              return this._uiManager.currentLayer
            }
            setInBackground() {
              this.div.style.zIndex = 0
            }
            setInForeground() {
              this.div.style.zIndex = this.#L
            }
            setParent(t) {
              if (null !== t) {
                this.pageIndex = t.pageIndex
                this.pageDimensions = t.pageDimensions
              }
              this.parent = t
            }
            focusin(t) {
              this._focusEventsAllowed && (this.#F ? (this.#F = !1) : this.parent.setSelected(this))
            }
            focusout(t) {
              if (!this._focusEventsAllowed) return
              if (!this.isAttachedToDOM) return
              const e = t.relatedTarget
              if (!e?.closest(`#${this.id}`)) {
                t.preventDefault()
                this.parent?.isMultipleSelection || this.commitOrRemove()
              }
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit()
            }
            commit() {
              this.addToAnnotationStorage()
            }
            addToAnnotationStorage() {
              this._uiManager.addToAnnotationStorage(this)
            }
            setAt(t, e, i, s) {
              const [n, a] = this.parentDimensions
              ;[i, s] = this.screenToPageTranslation(i, s)
              this.x = (t + i) / n
              this.y = (e + s) / a
              this.fixAndSetPosition()
            }
            #O([t, e], i, s) {
              ;[i, s] = this.screenToPageTranslation(i, s)
              this.x += i / t
              this.y += s / e
              this.fixAndSetPosition()
            }
            translate(t, e) {
              this.#O(this.parentDimensions, t, e)
            }
            translateInPage(t, e) {
              this.#O(this.pageDimensions, t, e)
              this.div.scrollIntoView({ block: 'nearest' })
            }
            drag(t, e) {
              const [i, s] = this.parentDimensions
              this.x += t / i
              this.y += e / s
              if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                const { x: t, y: e } = this.div.getBoundingClientRect()
                if (this.parent.findNewParent(this, t, e)) {
                  this.x -= Math.floor(this.x)
                  this.y -= Math.floor(this.y)
                }
              }
              let { x: n, y: a } = this
              const [r, o] = this.#N()
              n += r
              a += o
              this.div.style.left = `${(100 * n).toFixed(2)}%`
              this.div.style.top = `${(100 * a).toFixed(2)}%`
              this.div.scrollIntoView({ block: 'nearest' })
            }
            #N() {
              const [t, e] = this.parentDimensions,
                { _borderLineWidth: i } = AnnotationEditor,
                s = i / t,
                n = i / e
              switch (this.rotation) {
                case 90:
                  return [-s, n]
                case 180:
                  return [s, n]
                case 270:
                  return [s, -n]
                default:
                  return [-s, -n]
              }
            }
            fixAndSetPosition() {
              const [t, e] = this.pageDimensions
              let { x: i, y: s, width: n, height: a } = this
              n *= t
              a *= e
              i *= t
              s *= e
              switch (this.rotation) {
                case 0:
                  i = Math.max(0, Math.min(t - n, i))
                  s = Math.max(0, Math.min(e - a, s))
                  break
                case 90:
                  i = Math.max(0, Math.min(t - a, i))
                  s = Math.min(e, Math.max(n, s))
                  break
                case 180:
                  i = Math.min(t, Math.max(n, i))
                  s = Math.min(e, Math.max(a, s))
                  break
                case 270:
                  i = Math.min(t, Math.max(a, i))
                  s = Math.max(0, Math.min(e - n, s))
              }
              this.x = i /= t
              this.y = s /= e
              const [r, o] = this.#N()
              i += r
              s += o
              const { style: l } = this.div
              l.left = `${(100 * i).toFixed(2)}%`
              l.top = `${(100 * s).toFixed(2)}%`
              this.moveInDOM()
            }
            static #B(t, e, i) {
              switch (i) {
                case 90:
                  return [e, -t]
                case 180:
                  return [-t, -e]
                case 270:
                  return [-e, t]
                default:
                  return [t, e]
              }
            }
            screenToPageTranslation(t, e) {
              return AnnotationEditor.#B(t, e, this.parentRotation)
            }
            pageTranslationToScreen(t, e) {
              return AnnotationEditor.#B(t, e, 360 - this.parentRotation)
            }
            #U(t) {
              switch (t) {
                case 90: {
                  const [t, e] = this.pageDimensions
                  return [0, -t / e, e / t, 0]
                }
                case 180:
                  return [-1, 0, 0, -1]
                case 270: {
                  const [t, e] = this.pageDimensions
                  return [0, t / e, -e / t, 0]
                }
                default:
                  return [1, 0, 0, 1]
              }
            }
            get parentScale() {
              return this._uiManager.viewParameters.realScale
            }
            get parentRotation() {
              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360
            }
            get parentDimensions() {
              const {
                  parentScale: t,
                  pageDimensions: [e, i],
                } = this,
                s = e * t,
                a = i * t
              return n.FeatureTest.isCSSRoundSupported ? [Math.round(s), Math.round(a)] : [s, a]
            }
            setDims(t, e) {
              const [i, s] = this.parentDimensions
              this.div.style.width = `${((100 * t) / i).toFixed(2)}%`
              this.#T || (this.div.style.height = `${((100 * e) / s).toFixed(2)}%`)
              this.#x?.classList.toggle('small', t < AnnotationEditor.SMALL_EDITOR_SIZE || e < AnnotationEditor.SMALL_EDITOR_SIZE)
            }
            fixDims() {
              const { style: t } = this.div,
                { height: e, width: i } = t,
                s = i.endsWith('%'),
                n = !this.#T && e.endsWith('%')
              if (s && n) return
              const [a, r] = this.parentDimensions
              s || (t.width = `${((100 * parseFloat(i)) / a).toFixed(2)}%`)
              this.#T || n || (t.height = `${((100 * parseFloat(e)) / r).toFixed(2)}%`)
            }
            getInitialTranslation() {
              return [0, 0]
            }
            #j() {
              if (this.#P) return
              this.#P = document.createElement('div')
              this.#P.classList.add('resizers')
              const t = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft']
              this._willKeepAspectRatio || t.push('topMiddle', 'middleRight', 'bottomMiddle', 'middleLeft')
              for (const e of t) {
                const t = document.createElement('div')
                this.#P.append(t)
                t.classList.add('resizer', e)
                t.addEventListener('pointerdown', this.#z.bind(this, e))
                t.addEventListener('contextmenu', a.noContextMenu)
              }
              this.div.prepend(this.#P)
            }
            #z(t, e) {
              e.preventDefault()
              const { isMac: i } = n.FeatureTest.platform
              if (0 !== e.button || (e.ctrlKey && i)) return
              const s = this.#H.bind(this, t),
                a = this._isDraggable
              this._isDraggable = !1
              const r = { passive: !0, capture: !0 }
              window.addEventListener('pointermove', s, r)
              const o = this.x,
                l = this.y,
                h = this.width,
                c = this.height,
                d = this.parent.div.style.cursor,
                u = this.div.style.cursor
              this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e.target).cursor
              const pointerUpCallback = () => {
                this._isDraggable = a
                window.removeEventListener('pointerup', pointerUpCallback)
                window.removeEventListener('blur', pointerUpCallback)
                window.removeEventListener('pointermove', s, r)
                this.parent.div.style.cursor = d
                this.div.style.cursor = u
                const t = this.x,
                  e = this.y,
                  i = this.width,
                  n = this.height
                ;(t === o && e === l && i === h && n === c) ||
                  this.addCommands({
                    cmd: () => {
                      this.width = i
                      this.height = n
                      this.x = t
                      this.y = e
                      const [s, a] = this.parentDimensions
                      this.setDims(s * i, a * n)
                      this.fixAndSetPosition()
                    },
                    undo: () => {
                      this.width = h
                      this.height = c
                      this.x = o
                      this.y = l
                      const [t, e] = this.parentDimensions
                      this.setDims(t * h, e * c)
                      this.fixAndSetPosition()
                    },
                    mustExec: !0,
                  })
              }
              window.addEventListener('pointerup', pointerUpCallback)
              window.addEventListener('blur', pointerUpCallback)
            }
            #H(t, e) {
              const [i, s] = this.parentDimensions,
                n = this.x,
                a = this.y,
                r = this.width,
                o = this.height,
                l = AnnotationEditor.MIN_SIZE / i,
                h = AnnotationEditor.MIN_SIZE / s,
                round = (t) => Math.round(1e4 * t) / 1e4,
                c = this.#U(this.rotation),
                transf = (t, e) => [c[0] * t + c[2] * e, c[1] * t + c[3] * e],
                d = this.#U(360 - this.rotation)
              let u,
                p,
                g = !1,
                m = !1
              switch (t) {
                case 'topLeft':
                  g = !0
                  u = (t, e) => [0, 0]
                  p = (t, e) => [t, e]
                  break
                case 'topMiddle':
                  u = (t, e) => [t / 2, 0]
                  p = (t, e) => [t / 2, e]
                  break
                case 'topRight':
                  g = !0
                  u = (t, e) => [t, 0]
                  p = (t, e) => [0, e]
                  break
                case 'middleRight':
                  m = !0
                  u = (t, e) => [t, e / 2]
                  p = (t, e) => [0, e / 2]
                  break
                case 'bottomRight':
                  g = !0
                  u = (t, e) => [t, e]
                  p = (t, e) => [0, 0]
                  break
                case 'bottomMiddle':
                  u = (t, e) => [t / 2, e]
                  p = (t, e) => [t / 2, 0]
                  break
                case 'bottomLeft':
                  g = !0
                  u = (t, e) => [0, e]
                  p = (t, e) => [t, 0]
                  break
                case 'middleLeft':
                  m = !0
                  u = (t, e) => [0, e / 2]
                  p = (t, e) => [t, e / 2]
              }
              const f = u(r, o),
                b = p(r, o)
              let A = transf(...b)
              const _ = round(n + A[0]),
                v = round(a + A[1])
              let y = 1,
                S = 1,
                [E, x] = this.screenToPageTranslation(e.movementX, e.movementY)
              ;[E, x] = ((w = E / i), (C = x / s), [d[0] * w + d[2] * C, d[1] * w + d[3] * C])
              var w, C
              if (g) {
                const t = Math.hypot(r, o)
                y = S = Math.max(Math.min(Math.hypot(b[0] - f[0] - E, b[1] - f[1] - x) / t, 1 / r, 1 / o), l / r, h / o)
              } else m ? (y = Math.max(l, Math.min(1, Math.abs(b[0] - f[0] - E))) / r) : (S = Math.max(h, Math.min(1, Math.abs(b[1] - f[1] - x))) / o)
              const T = round(r * y),
                P = round(o * S)
              A = transf(...p(T, P))
              const M = _ - A[0],
                k = v - A[1]
              this.width = T
              this.height = P
              this.x = M
              this.y = k
              this.setDims(i * T, s * P)
              this.fixAndSetPosition()
            }
            async addAltTextButton() {
              if (this.#x) return
              const t = (this.#x = document.createElement('button'))
              t.className = 'altText'
              const e = await AnnotationEditor._l10nPromise.get('editor_alt_text_button_label')
              t.textContent = e
              t.setAttribute('aria-label', e)
              t.tabIndex = '0'
              t.addEventListener('contextmenu', a.noContextMenu)
              t.addEventListener('pointerdown', (t) => t.stopPropagation())
              t.addEventListener(
                'click',
                (t) => {
                  t.preventDefault()
                  this._uiManager.editAltText(this)
                },
                { capture: !0 }
              )
              t.addEventListener('keydown', (e) => {
                if (e.target === t && 'Enter' === e.key) {
                  e.preventDefault()
                  this._uiManager.editAltText(this)
                }
              })
              this.#W()
              this.div.append(t)
              if (!AnnotationEditor.SMALL_EDITOR_SIZE) {
                const e = 40
                AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(t.getBoundingClientRect().width * (1 + e / 100)))
              }
            }
            async #W() {
              const t = this.#x
              if (!t) return
              if (!this.#S && !this.#E) {
                t.classList.remove('done')
                this.#w?.remove()
                return
              }
              AnnotationEditor._l10nPromise.get('editor_alt_text_edit_button_label').then((e) => {
                t.setAttribute('aria-label', e)
              })
              let e = this.#w
              if (!e) {
                this.#w = e = document.createElement('span')
                e.className = 'tooltip'
                e.setAttribute('role', 'tooltip')
                const i = (e.id = `alt-text-tooltip-${this.id}`)
                t.setAttribute('aria-describedby', i)
                const s = 100
                t.addEventListener('mouseenter', () => {
                  this.#C = setTimeout(() => {
                    this.#C = null
                    this.#w.classList.add('show')
                    this._uiManager._eventBus.dispatch('reporttelemetry', { source: this, details: { type: 'editing', subtype: this.editorType, data: { action: 'alt_text_tooltip' } } })
                  }, s)
                })
                t.addEventListener('mouseleave', () => {
                  clearTimeout(this.#C)
                  this.#C = null
                  this.#w?.classList.remove('show')
                })
              }
              t.classList.add('done')
              e.innerText = this.#E ? await AnnotationEditor._l10nPromise.get('editor_alt_text_decorative_tooltip') : this.#S
              e.parentNode || t.append(e)
            }
            getClientDimensions() {
              return this.div.getBoundingClientRect()
            }
            get altTextData() {
              return { altText: this.#S, decorative: this.#E }
            }
            set altTextData({ altText: t, decorative: e }) {
              if (this.#S !== t || this.#E !== e) {
                this.#S = t
                this.#E = e
                this.#W()
              }
            }
            render() {
              this.div = document.createElement('div')
              this.div.setAttribute('data-editor-rotation', (360 - this.rotation) % 360)
              this.div.className = this.name
              this.div.setAttribute('id', this.id)
              this.div.setAttribute('tabIndex', 0)
              this.setInForeground()
              this.div.addEventListener('focusin', this.#M)
              this.div.addEventListener('focusout', this.#k)
              const [t, e] = this.parentDimensions
              if (this.parentRotation % 180 != 0) {
                this.div.style.maxWidth = `${((100 * e) / t).toFixed(2)}%`
                this.div.style.maxHeight = `${((100 * t) / e).toFixed(2)}%`
              }
              const [i, n] = this.getInitialTranslation()
              this.translate(i, n)
              ;(0, s.bindEvents)(this, this.div, ['pointerdown'])
              return this.div
            }
            pointerdown(t) {
              const { isMac: e } = n.FeatureTest.platform
              if (0 !== t.button || (t.ctrlKey && e)) t.preventDefault()
              else {
                this.#F = !0
                this.#G(t)
              }
            }
            #G(t) {
              if (!this._isDraggable) return
              const e = this._uiManager.isSelected(this)
              this._uiManager.setUpDragSession()
              let i, s
              if (e) {
                i = { passive: !0, capture: !0 }
                s = (t) => {
                  const [e, i] = this.screenToPageTranslation(t.movementX, t.movementY)
                  this._uiManager.dragSelectedEditors(e, i)
                }
                window.addEventListener('pointermove', s, i)
              }
              const pointerUpCallback = () => {
                window.removeEventListener('pointerup', pointerUpCallback)
                window.removeEventListener('blur', pointerUpCallback)
                e && window.removeEventListener('pointermove', s, i)
                this.#F = !1
                if (!this._uiManager.endDragSession()) {
                  const { isMac: e } = n.FeatureTest.platform
                  ;(t.ctrlKey && !e) || t.shiftKey || (t.metaKey && e) ? this.parent.toggleSelected(this) : this.parent.setSelected(this)
                }
              }
              window.addEventListener('pointerup', pointerUpCallback)
              window.addEventListener('blur', pointerUpCallback)
            }
            moveInDOM() {
              this.parent?.moveEditorInDOM(this)
            }
            _setParentAndPosition(t, e, i) {
              t.changeParent(this)
              this.x = e
              this.y = i
              this.fixAndSetPosition()
            }
            getRect(t, e) {
              const i = this.parentScale,
                [s, n] = this.pageDimensions,
                [a, r] = this.pageTranslation,
                o = t / i,
                l = e / i,
                h = this.x * s,
                c = this.y * n,
                d = this.width * s,
                u = this.height * n
              switch (this.rotation) {
                case 0:
                  return [h + o + a, n - c - l - u + r, h + o + d + a, n - c - l + r]
                case 90:
                  return [h + l + a, n - c + o + r, h + l + u + a, n - c + o + d + r]
                case 180:
                  return [h - o - d + a, n - c + l + r, h - o + a, n - c + l + u + r]
                case 270:
                  return [h - l - u + a, n - c - o - d + r, h - l + a, n - c - o + r]
                default:
                  throw new Error('Invalid rotation')
              }
            }
            getRectInCurrentCoords(t, e) {
              const [i, s, n, a] = t,
                r = n - i,
                o = a - s
              switch (this.rotation) {
                case 0:
                  return [i, e - a, r, o]
                case 90:
                  return [i, e - s, o, r]
                case 180:
                  return [n, e - s, r, o]
                case 270:
                  return [n, e - a, o, r]
                default:
                  throw new Error('Invalid rotation')
              }
            }
            onceAdded() {}
            isEmpty() {
              return !1
            }
            enableEditMode() {
              this.#D = !0
            }
            disableEditMode() {
              this.#D = !1
            }
            isInEditMode() {
              return this.#D
            }
            shouldGetKeyboardEvents() {
              return !1
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM
            }
            rebuild() {
              this.div?.addEventListener('focusin', this.#M)
              this.div?.addEventListener('focusout', this.#k)
            }
            serialize(t = !1, e = null) {
              ;(0, n.unreachable)('An editor must be serializable')
            }
            static deserialize(t, e, i) {
              const s = new this.prototype.constructor({ parent: e, id: e.getNextId(), uiManager: i })
              s.rotation = t.rotation
              const [n, a] = s.pageDimensions,
                [r, o, l, h] = s.getRectInCurrentCoords(t.rect, a)
              s.x = r / n
              s.y = o / a
              s.width = l / n
              s.height = h / a
              return s
            }
            remove() {
              this.div.removeEventListener('focusin', this.#M)
              this.div.removeEventListener('focusout', this.#k)
              this.isEmpty() || this.commit()
              this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this)
              this.#x?.remove()
              this.#x = null
              this.#w = null
            }
            get isResizable() {
              return !1
            }
            makeResizable() {
              if (this.isResizable) {
                this.#j()
                this.#P.classList.remove('hidden')
              }
            }
            select() {
              this.makeResizable()
              this.div?.classList.add('selectedEditor')
            }
            unselect() {
              this.#P?.classList.add('hidden')
              this.div?.classList.remove('selectedEditor')
              this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus()
            }
            updateParams(t, e) {}
            disableEditing() {
              this.#x && (this.#x.hidden = !0)
            }
            enableEditing() {
              this.#x && (this.#x.hidden = !1)
            }
            enterInEditMode() {}
            get contentDiv() {
              return this.div
            }
            get isEditing() {
              return this.#R
            }
            set isEditing(t) {
              this.#R = t
              if (this.parent)
                if (t) {
                  this.parent.setSelected(this)
                  this.parent.setActiveEditor(this)
                } else this.parent.setActiveEditor(null)
            }
            setAspectRatio(t, e) {
              this.#T = !0
              const i = t / e,
                { style: s } = this.div
              s.aspectRatio = i
              s.height = 'auto'
            }
            static get MIN_SIZE() {
              return 16
            }
          }
          e.AnnotationEditor = AnnotationEditor
          class FakeEditor extends AnnotationEditor {
            constructor(t) {
              super(t)
              this.annotationElementId = t.annotationElementId
              this.deleted = !0
            }
            serialize() {
              return { id: this.annotationElementId, deleted: !0, pageIndex: this.pageIndex }
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.KeyboardManager = e.CommandManager = e.ColorManager = e.AnnotationEditorUIManager = void 0
          e.bindEvents = function bindEvents(t, e, i) {
            for (const s of i) e.addEventListener(s, t[s].bind(t))
          }
          e.opacityToHex = function opacityToHex(t) {
            return Math.round(Math.min(255, Math.max(1, 255 * t)))
              .toString(16)
              .padStart(2, '0')
          }
          var s = i(1),
            n = i(6)
          class IdManager {
            #q = 0
            getId() {
              return `${s.AnnotationEditorPrefix}${this.#q++}`
            }
          }
          class ImageManager {
            #V = (0, s.getUuid)()
            #q = 0
            #$ = null
            static get _isSVGFittingCanvas() {
              const t = new OffscreenCanvas(1, 3).getContext('2d'),
                e = new Image()
              e.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>'
              const i = e.decode().then(() => {
                t.drawImage(e, 0, 0, 1, 1, 0, 0, 1, 3)
                return 0 === new Uint32Array(t.getImageData(0, 0, 1, 1).data.buffer)[0]
              })
              return (0, s.shadow)(this, '_isSVGFittingCanvas', i)
            }
            async #X(t, e) {
              this.#$ ||= new Map()
              let i = this.#$.get(t)
              if (null === i) return null
              if (i?.bitmap) {
                i.refCounter += 1
                return i
              }
              try {
                i ||= { bitmap: null, id: `image_${this.#V}_${this.#q++}`, refCounter: 0, isSvg: !1 }
                let t
                if ('string' == typeof e) {
                  i.url = e
                  const s = await fetch(e)
                  if (!s.ok) throw new Error(s.statusText)
                  t = await s.blob()
                } else t = i.file = e
                if ('image/svg+xml' === t.type) {
                  const e = ImageManager._isSVGFittingCanvas,
                    s = new FileReader(),
                    n = new Image(),
                    a = new Promise((t, a) => {
                      n.onload = () => {
                        i.bitmap = n
                        i.isSvg = !0
                        t()
                      }
                      s.onload = async () => {
                        const t = (i.svgUrl = s.result)
                        n.src = (await e) ? `${t}#svgView(preserveAspectRatio(none))` : t
                      }
                      n.onerror = s.onerror = a
                    })
                  s.readAsDataURL(t)
                  await a
                } else i.bitmap = await createImageBitmap(t)
                i.refCounter = 1
              } catch (t) {
                console.error(t)
                i = null
              }
              this.#$.set(t, i)
              i && this.#$.set(i.id, i)
              return i
            }
            async getFromFile(t) {
              const { lastModified: e, name: i, size: s, type: n } = t
              return this.#X(`${e}_${i}_${s}_${n}`, t)
            }
            async getFromUrl(t) {
              return this.#X(t, t)
            }
            async getFromId(t) {
              this.#$ ||= new Map()
              const e = this.#$.get(t)
              if (!e) return null
              if (e.bitmap) {
                e.refCounter += 1
                return e
              }
              return e.file ? this.getFromFile(e.file) : this.getFromUrl(e.url)
            }
            getSvgUrl(t) {
              const e = this.#$.get(t)
              return e?.isSvg ? e.svgUrl : null
            }
            deleteId(t) {
              this.#$ ||= new Map()
              const e = this.#$.get(t)
              if (e) {
                e.refCounter -= 1
                0 === e.refCounter && (e.bitmap = null)
              }
            }
            isValidId(t) {
              return t.startsWith(`image_${this.#V}_`)
            }
          }
          class CommandManager {
            #K = []
            #Y = !1
            #J
            #Q = -1
            constructor(t = 128) {
              this.#J = t
            }
            add({ cmd: t, undo: e, mustExec: i, type: s = NaN, overwriteIfSameType: n = !1, keepUndo: a = !1 }) {
              i && t()
              if (this.#Y) return
              const r = { cmd: t, undo: e, type: s }
              if (-1 === this.#Q) {
                this.#K.length > 0 && (this.#K.length = 0)
                this.#Q = 0
                this.#K.push(r)
                return
              }
              if (n && this.#K[this.#Q].type === s) {
                a && (r.undo = this.#K[this.#Q].undo)
                this.#K[this.#Q] = r
                return
              }
              const o = this.#Q + 1
              if (o === this.#J) this.#K.splice(0, 1)
              else {
                this.#Q = o
                o < this.#K.length && this.#K.splice(o)
              }
              this.#K.push(r)
            }
            undo() {
              if (-1 !== this.#Q) {
                this.#Y = !0
                this.#K[this.#Q].undo()
                this.#Y = !1
                this.#Q -= 1
              }
            }
            redo() {
              if (this.#Q < this.#K.length - 1) {
                this.#Q += 1
                this.#Y = !0
                this.#K[this.#Q].cmd()
                this.#Y = !1
              }
            }
            hasSomethingToUndo() {
              return -1 !== this.#Q
            }
            hasSomethingToRedo() {
              return this.#Q < this.#K.length - 1
            }
            destroy() {
              this.#K = null
            }
          }
          e.CommandManager = CommandManager
          class KeyboardManager {
            constructor(t) {
              this.buffer = []
              this.callbacks = new Map()
              this.allKeys = new Set()
              const { isMac: e } = s.FeatureTest.platform
              for (const [i, s, n = {}] of t)
                for (const t of i) {
                  const i = t.startsWith('mac+')
                  if (e && i) {
                    this.callbacks.set(t.slice(4), { callback: s, options: n })
                    this.allKeys.add(t.split('+').at(-1))
                  } else if (!e && !i) {
                    this.callbacks.set(t, { callback: s, options: n })
                    this.allKeys.add(t.split('+').at(-1))
                  }
                }
            }
            #Z(t) {
              t.altKey && this.buffer.push('alt')
              t.ctrlKey && this.buffer.push('ctrl')
              t.metaKey && this.buffer.push('meta')
              t.shiftKey && this.buffer.push('shift')
              this.buffer.push(t.key)
              const e = this.buffer.join('+')
              this.buffer.length = 0
              return e
            }
            exec(t, e) {
              if (!this.allKeys.has(e.key)) return
              const i = this.callbacks.get(this.#Z(e))
              if (!i) return
              const {
                callback: s,
                options: { bubbles: n = !1, args: a = [], checker: r = null },
              } = i
              if (!r || r(t, e)) {
                s.bind(t, ...a)()
                if (!n) {
                  e.stopPropagation()
                  e.preventDefault()
                }
              }
            }
          }
          e.KeyboardManager = KeyboardManager
          class ColorManager {
            static _colorsMapping = new Map([
              ['CanvasText', [0, 0, 0]],
              ['Canvas', [255, 255, 255]],
            ])
            get _colors() {
              const t = new Map([
                ['CanvasText', null],
                ['Canvas', null],
              ])
              ;(0, n.getColorValues)(t)
              return (0, s.shadow)(this, '_colors', t)
            }
            convert(t) {
              const e = (0, n.getRGB)(t)
              if (!window.matchMedia('(forced-colors: active)').matches) return e
              for (const [t, i] of this._colors) if (i.every((t, i) => t === e[i])) return ColorManager._colorsMapping.get(t)
              return e
            }
            getHexCode(t) {
              const e = this._colors.get(t)
              return e ? s.Util.makeHexColor(...e) : t
            }
          }
          e.ColorManager = ColorManager
          class AnnotationEditorUIManager {
            #tt = null
            #et = new Map()
            #it = new Map()
            #st = null
            #nt = null
            #at = new CommandManager()
            #rt = 0
            #ot = new Set()
            #lt = null
            #ht = null
            #ct = new Set()
            #dt = null
            #ut = new IdManager()
            #pt = !1
            #gt = !1
            #mt = null
            #ft = s.AnnotationEditorType.NONE
            #bt = new Set()
            #At = null
            #_t = this.blur.bind(this)
            #vt = this.focus.bind(this)
            #yt = this.copy.bind(this)
            #St = this.cut.bind(this)
            #Et = this.paste.bind(this)
            #xt = this.keydown.bind(this)
            #wt = this.onEditingAction.bind(this)
            #Ct = this.onPageChanging.bind(this)
            #Tt = this.onScaleChanging.bind(this)
            #Pt = this.onRotationChanging.bind(this)
            #Mt = { isEditing: !1, isEmpty: !0, hasSomethingToUndo: !1, hasSomethingToRedo: !1, hasSelectedEditor: !1 }
            #kt = [0, 0]
            #Ft = null
            #Rt = null
            #Dt = null
            static TRANSLATE_SMALL = 1
            static TRANSLATE_BIG = 10
            static get _keyboardManager() {
              const t = AnnotationEditorUIManager.prototype,
                arrowChecker = (t) => {
                  const { activeElement: e } = document
                  return e && t.#Rt.contains(e) && t.hasSomethingToControl()
                },
                e = this.TRANSLATE_SMALL,
                i = this.TRANSLATE_BIG
              return (0, s.shadow)(
                this,
                '_keyboardManager',
                new KeyboardManager([
                  [['ctrl+a', 'mac+meta+a'], t.selectAll],
                  [['ctrl+z', 'mac+meta+z'], t.undo],
                  [['ctrl+y', 'ctrl+shift+z', 'mac+meta+shift+z', 'ctrl+shift+Z', 'mac+meta+shift+Z'], t.redo],
                  [['Backspace', 'alt+Backspace', 'ctrl+Backspace', 'shift+Backspace', 'mac+Backspace', 'mac+alt+Backspace', 'mac+ctrl+Backspace', 'Delete', 'ctrl+Delete', 'shift+Delete', 'mac+Delete'], t.delete],
                  [['Escape', 'mac+Escape'], t.unselectAll],
                  [['ArrowLeft', 'mac+ArrowLeft'], t.translateSelectedEditors, { args: [-e, 0], checker: arrowChecker }],
                  [['ctrl+ArrowLeft', 'mac+shift+ArrowLeft'], t.translateSelectedEditors, { args: [-i, 0], checker: arrowChecker }],
                  [['ArrowRight', 'mac+ArrowRight'], t.translateSelectedEditors, { args: [e, 0], checker: arrowChecker }],
                  [['ctrl+ArrowRight', 'mac+shift+ArrowRight'], t.translateSelectedEditors, { args: [i, 0], checker: arrowChecker }],
                  [['ArrowUp', 'mac+ArrowUp'], t.translateSelectedEditors, { args: [0, -e], checker: arrowChecker }],
                  [['ctrl+ArrowUp', 'mac+shift+ArrowUp'], t.translateSelectedEditors, { args: [0, -i], checker: arrowChecker }],
                  [['ArrowDown', 'mac+ArrowDown'], t.translateSelectedEditors, { args: [0, e], checker: arrowChecker }],
                  [['ctrl+ArrowDown', 'mac+shift+ArrowDown'], t.translateSelectedEditors, { args: [0, i], checker: arrowChecker }],
                ])
              )
            }
            constructor(t, e, i, s, a, r) {
              this.#Rt = t
              this.#Dt = e
              this.#st = i
              this._eventBus = s
              this._eventBus._on('editingaction', this.#wt)
              this._eventBus._on('pagechanging', this.#Ct)
              this._eventBus._on('scalechanging', this.#Tt)
              this._eventBus._on('rotationchanging', this.#Pt)
              this.#nt = a.annotationStorage
              this.#dt = a.filterFactory
              this.#At = r
              this.viewParameters = { realScale: n.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 }
            }
            destroy() {
              this.#It()
              this.#Lt()
              this._eventBus._off('editingaction', this.#wt)
              this._eventBus._off('pagechanging', this.#Ct)
              this._eventBus._off('scalechanging', this.#Tt)
              this._eventBus._off('rotationchanging', this.#Pt)
              for (const t of this.#it.values()) t.destroy()
              this.#it.clear()
              this.#et.clear()
              this.#ct.clear()
              this.#tt = null
              this.#bt.clear()
              this.#at.destroy()
              this.#st.destroy()
            }
            get hcmFilter() {
              return (0, s.shadow)(this, 'hcmFilter', this.#At ? this.#dt.addHCMFilter(this.#At.foreground, this.#At.background) : 'none')
            }
            get direction() {
              return (0, s.shadow)(this, 'direction', getComputedStyle(this.#Rt).direction)
            }
            editAltText(t) {
              this.#st?.editAltText(this, t)
            }
            onPageChanging({ pageNumber: t }) {
              this.#rt = t - 1
            }
            focusMainContainer() {
              this.#Rt.focus()
            }
            findParent(t, e) {
              for (const i of this.#it.values()) {
                const { x: s, y: n, width: a, height: r } = i.div.getBoundingClientRect()
                if (t >= s && t <= s + a && e >= n && e <= n + r) return i
              }
              return null
            }
            disableUserSelect(t = !1) {
              this.#Dt.classList.toggle('noUserSelect', t)
            }
            addShouldRescale(t) {
              this.#ct.add(t)
            }
            removeShouldRescale(t) {
              this.#ct.delete(t)
            }
            onScaleChanging({ scale: t }) {
              this.commitOrRemove()
              this.viewParameters.realScale = t * n.PixelsPerInch.PDF_TO_CSS_UNITS
              for (const t of this.#ct) t.onScaleChanging()
            }
            onRotationChanging({ pagesRotation: t }) {
              this.commitOrRemove()
              this.viewParameters.rotation = t
            }
            addToAnnotationStorage(t) {
              t.isEmpty() || !this.#nt || this.#nt.has(t.id) || this.#nt.setValue(t.id, t)
            }
            #Ot() {
              window.addEventListener('focus', this.#vt)
              window.addEventListener('blur', this.#_t)
            }
            #Lt() {
              window.removeEventListener('focus', this.#vt)
              window.removeEventListener('blur', this.#_t)
            }
            blur() {
              if (!this.hasSelection) return
              const { activeElement: t } = document
              for (const e of this.#bt)
                if (e.div.contains(t)) {
                  this.#mt = [e, t]
                  e._focusEventsAllowed = !1
                  break
                }
            }
            focus() {
              if (!this.#mt) return
              const [t, e] = this.#mt
              this.#mt = null
              e.addEventListener(
                'focusin',
                () => {
                  t._focusEventsAllowed = !0
                },
                { once: !0 }
              )
              e.focus()
            }
            #Nt() {
              window.addEventListener('keydown', this.#xt, { capture: !0 })
            }
            #It() {
              window.removeEventListener('keydown', this.#xt, { capture: !0 })
            }
            #Bt() {
              document.addEventListener('copy', this.#yt)
              document.addEventListener('cut', this.#St)
              document.addEventListener('paste', this.#Et)
            }
            #Ut() {
              document.removeEventListener('copy', this.#yt)
              document.removeEventListener('cut', this.#St)
              document.removeEventListener('paste', this.#Et)
            }
            addEditListeners() {
              this.#Nt()
              this.#Bt()
            }
            removeEditListeners() {
              this.#It()
              this.#Ut()
            }
            copy(t) {
              t.preventDefault()
              this.#tt?.commitOrRemove()
              if (!this.hasSelection) return
              const e = []
              for (const t of this.#bt) {
                const i = t.serialize(!0)
                i && e.push(i)
              }
              0 !== e.length && t.clipboardData.setData('application/pdfjs', JSON.stringify(e))
            }
            cut(t) {
              this.copy(t)
              this.delete()
            }
            paste(t) {
              t.preventDefault()
              const { clipboardData: e } = t
              for (const t of e.items)
                for (const e of this.#ht)
                  if (e.isHandlingMimeForPasting(t.type)) {
                    e.paste(t, this.currentLayer)
                    return
                  }
              let i = e.getData('application/pdfjs')
              if (!i) return
              try {
                i = JSON.parse(i)
              } catch (t) {
                ;(0, s.warn)(`paste: "${t.message}".`)
                return
              }
              if (!Array.isArray(i)) return
              this.unselectAll()
              const n = this.currentLayer
              try {
                const t = []
                for (const e of i) {
                  const i = n.deserialize(e)
                  if (!i) return
                  t.push(i)
                }
                const cmd = () => {
                    for (const e of t) this.#jt(e)
                    this.#zt(t)
                  },
                  undo = () => {
                    for (const e of t) e.remove()
                  }
                this.addCommands({ cmd: cmd, undo: undo, mustExec: !0 })
              } catch (t) {
                ;(0, s.warn)(`paste: "${t.message}".`)
              }
            }
            keydown(t) {
              this.getActive()?.shouldGetKeyboardEvents() || AnnotationEditorUIManager._keyboardManager.exec(this, t)
            }
            onEditingAction(t) {
              ;['undo', 'redo', 'delete', 'selectAll'].includes(t.name) && this[t.name]()
            }
            #Ht(t) {
              Object.entries(t).some(([t, e]) => this.#Mt[t] !== e) && this._eventBus.dispatch('annotationeditorstateschanged', { source: this, details: Object.assign(this.#Mt, t) })
            }
            #Wt(t) {
              this._eventBus.dispatch('annotationeditorparamschanged', { source: this, details: t })
            }
            setEditingState(t) {
              if (t) {
                this.#Ot()
                this.#Nt()
                this.#Bt()
                this.#Ht({ isEditing: this.#ft !== s.AnnotationEditorType.NONE, isEmpty: this.#Gt(), hasSomethingToUndo: this.#at.hasSomethingToUndo(), hasSomethingToRedo: this.#at.hasSomethingToRedo(), hasSelectedEditor: !1 })
              } else {
                this.#Lt()
                this.#It()
                this.#Ut()
                this.#Ht({ isEditing: !1 })
                this.disableUserSelect(!1)
              }
            }
            registerEditorTypes(t) {
              if (!this.#ht) {
                this.#ht = t
                for (const t of this.#ht) this.#Wt(t.defaultPropertiesToUpdate)
              }
            }
            getId() {
              return this.#ut.getId()
            }
            get currentLayer() {
              return this.#it.get(this.#rt)
            }
            getLayer(t) {
              return this.#it.get(t)
            }
            get currentPageIndex() {
              return this.#rt
            }
            addLayer(t) {
              this.#it.set(t.pageIndex, t)
              this.#pt ? t.enable() : t.disable()
            }
            removeLayer(t) {
              this.#it.delete(t.pageIndex)
            }
            updateMode(t, e = null) {
              if (this.#ft !== t) {
                this.#ft = t
                if (t !== s.AnnotationEditorType.NONE) {
                  this.setEditingState(!0)
                  this.#qt()
                  this.unselectAll()
                  for (const e of this.#it.values()) e.updateMode(t)
                  if (e)
                    for (const t of this.#et.values())
                      if (t.annotationElementId === e) {
                        this.setSelected(t)
                        t.enterInEditMode()
                        break
                      }
                } else {
                  this.setEditingState(!1)
                  this.#Vt()
                }
              }
            }
            updateToolbar(t) {
              t !== this.#ft && this._eventBus.dispatch('switchannotationeditormode', { source: this, mode: t })
            }
            updateParams(t, e) {
              if (this.#ht)
                if (t !== s.AnnotationEditorParamsType.CREATE) {
                  for (const i of this.#bt) i.updateParams(t, e)
                  for (const i of this.#ht) i.updateDefaultParams(t, e)
                } else this.currentLayer.addNewEditor(t)
            }
            enableWaiting(t = !1) {
              if (this.#gt !== t) {
                this.#gt = t
                for (const e of this.#it.values()) {
                  t ? e.disableClick() : e.enableClick()
                  e.div.classList.toggle('waiting', t)
                }
              }
            }
            #qt() {
              if (!this.#pt) {
                this.#pt = !0
                for (const t of this.#it.values()) t.enable()
              }
            }
            #Vt() {
              this.unselectAll()
              if (this.#pt) {
                this.#pt = !1
                for (const t of this.#it.values()) t.disable()
              }
            }
            getEditors(t) {
              const e = []
              for (const i of this.#et.values()) i.pageIndex === t && e.push(i)
              return e
            }
            getEditor(t) {
              return this.#et.get(t)
            }
            addEditor(t) {
              this.#et.set(t.id, t)
            }
            removeEditor(t) {
              this.#et.delete(t.id)
              this.unselect(t)
              ;(t.annotationElementId && this.#ot.has(t.annotationElementId)) || this.#nt?.remove(t.id)
            }
            addDeletedAnnotationElement(t) {
              this.#ot.add(t.annotationElementId)
              t.deleted = !0
            }
            isDeletedAnnotationElement(t) {
              return this.#ot.has(t)
            }
            removeDeletedAnnotationElement(t) {
              this.#ot.delete(t.annotationElementId)
              t.deleted = !1
            }
            #jt(t) {
              const e = this.#it.get(t.pageIndex)
              e ? e.addOrRebuild(t) : this.addEditor(t)
            }
            setActiveEditor(t) {
              if (this.#tt !== t) {
                this.#tt = t
                t && this.#Wt(t.propertiesToUpdate)
              }
            }
            toggleSelected(t) {
              if (this.#bt.has(t)) {
                this.#bt.delete(t)
                t.unselect()
                this.#Ht({ hasSelectedEditor: this.hasSelection })
              } else {
                this.#bt.add(t)
                t.select()
                this.#Wt(t.propertiesToUpdate)
                this.#Ht({ hasSelectedEditor: !0 })
              }
            }
            setSelected(t) {
              for (const e of this.#bt) e !== t && e.unselect()
              this.#bt.clear()
              this.#bt.add(t)
              t.select()
              this.#Wt(t.propertiesToUpdate)
              this.#Ht({ hasSelectedEditor: !0 })
            }
            isSelected(t) {
              return this.#bt.has(t)
            }
            unselect(t) {
              t.unselect()
              this.#bt.delete(t)
              this.#Ht({ hasSelectedEditor: this.hasSelection })
            }
            get hasSelection() {
              return 0 !== this.#bt.size
            }
            undo() {
              this.#at.undo()
              this.#Ht({ hasSomethingToUndo: this.#at.hasSomethingToUndo(), hasSomethingToRedo: !0, isEmpty: this.#Gt() })
            }
            redo() {
              this.#at.redo()
              this.#Ht({ hasSomethingToUndo: !0, hasSomethingToRedo: this.#at.hasSomethingToRedo(), isEmpty: this.#Gt() })
            }
            addCommands(t) {
              this.#at.add(t)
              this.#Ht({ hasSomethingToUndo: !0, hasSomethingToRedo: !1, isEmpty: this.#Gt() })
            }
            #Gt() {
              if (0 === this.#et.size) return !0
              if (1 === this.#et.size) for (const t of this.#et.values()) return t.isEmpty()
              return !1
            }
            delete() {
              this.commitOrRemove()
              if (!this.hasSelection) return
              const t = [...this.#bt]
              this.addCommands({
                cmd: () => {
                  for (const e of t) e.remove()
                },
                undo: () => {
                  for (const e of t) this.#jt(e)
                },
                mustExec: !0,
              })
            }
            commitOrRemove() {
              this.#tt?.commitOrRemove()
            }
            hasSomethingToControl() {
              return this.#tt || this.hasSelection
            }
            #zt(t) {
              this.#bt.clear()
              for (const e of t)
                if (!e.isEmpty()) {
                  this.#bt.add(e)
                  e.select()
                }
              this.#Ht({ hasSelectedEditor: !0 })
            }
            selectAll() {
              for (const t of this.#bt) t.commit()
              this.#zt(this.#et.values())
            }
            unselectAll() {
              if (this.#tt) this.#tt.commitOrRemove()
              else if (this.hasSelection) {
                for (const t of this.#bt) t.unselect()
                this.#bt.clear()
                this.#Ht({ hasSelectedEditor: !1 })
              }
            }
            translateSelectedEditors(t, e, i = !1) {
              i || this.commitOrRemove()
              if (!this.hasSelection) return
              this.#kt[0] += t
              this.#kt[1] += e
              const [s, n] = this.#kt,
                a = [...this.#bt]
              this.#Ft && clearTimeout(this.#Ft)
              this.#Ft = setTimeout(() => {
                this.#Ft = null
                this.#kt[0] = this.#kt[1] = 0
                this.addCommands({
                  cmd: () => {
                    for (const t of a) this.#et.has(t.id) && t.translateInPage(s, n)
                  },
                  undo: () => {
                    for (const t of a) this.#et.has(t.id) && t.translateInPage(-s, -n)
                  },
                  mustExec: !1,
                })
              }, 1e3)
              for (const i of a) i.translateInPage(t, e)
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0)
                this.#lt = new Map()
                for (const t of this.#bt) this.#lt.set(t, { savedX: t.x, savedY: t.y, savedPageIndex: t.pageIndex, newX: 0, newY: 0, newPageIndex: -1 })
              }
            }
            endDragSession() {
              if (!this.#lt) return !1
              this.disableUserSelect(!1)
              const t = this.#lt
              this.#lt = null
              let e = !1
              for (const [{ x: i, y: s, pageIndex: n }, a] of t) {
                a.newX = i
                a.newY = s
                a.newPageIndex = n
                e ||= i !== a.savedX || s !== a.savedY || n !== a.savedPageIndex
              }
              if (!e) return !1
              const move = (t, e, i, s) => {
                if (this.#et.has(t.id)) {
                  const n = this.#it.get(s)
                  if (n) t._setParentAndPosition(n, e, i)
                  else {
                    t.pageIndex = s
                    t.x = e
                    t.y = i
                  }
                }
              }
              this.addCommands({
                cmd: () => {
                  for (const [e, { newX: i, newY: s, newPageIndex: n }] of t) move(e, i, s, n)
                },
                undo: () => {
                  for (const [e, { savedX: i, savedY: s, savedPageIndex: n }] of t) move(e, i, s, n)
                },
                mustExec: !0,
              })
              return !0
            }
            dragSelectedEditors(t, e) {
              if (this.#lt) for (const i of this.#lt.keys()) i.drag(t, e)
            }
            rebuild(t) {
              if (null === t.parent) {
                const e = this.getLayer(t.pageIndex)
                if (e) {
                  e.changeParent(t)
                  e.addOrRebuild(t)
                } else {
                  this.addEditor(t)
                  this.addToAnnotationStorage(t)
                  t.rebuild()
                }
              } else t.parent.addOrRebuild(t)
            }
            isActive(t) {
              return this.#tt === t
            }
            getActive() {
              return this.#tt
            }
            getMode() {
              return this.#ft
            }
            get imageManager() {
              return (0, s.shadow)(this, 'imageManager', new ImageManager())
            }
          }
          e.AnnotationEditorUIManager = AnnotationEditorUIManager
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.StatTimer = e.RenderingCancelledException = e.PixelsPerInch = e.PageViewport = e.PDFDateString = e.DOMStandardFontDataFactory = e.DOMSVGFactory = e.DOMFilterFactory = e.DOMCanvasFactory = e.DOMCMapReaderFactory = void 0
          e.deprecated = function deprecated(t) {
            console.log('Deprecated API usage: ' + t)
          }
          e.getColorValues = function getColorValues(t) {
            const e = document.createElement('span')
            e.style.visibility = 'hidden'
            document.body.append(e)
            for (const i of t.keys()) {
              e.style.color = i
              const s = window.getComputedStyle(e).color
              t.set(i, getRGB(s))
            }
            e.remove()
          }
          e.getCurrentTransform = function getCurrentTransform(t) {
            const { a: e, b: i, c: s, d: n, e: a, f: r } = t.getTransform()
            return [e, i, s, n, a, r]
          }
          e.getCurrentTransformInverse = function getCurrentTransformInverse(t) {
            const { a: e, b: i, c: s, d: n, e: a, f: r } = t.getTransform().invertSelf()
            return [e, i, s, n, a, r]
          }
          e.getFilenameFromUrl = function getFilenameFromUrl(t, e = !1) {
            e || ([t] = t.split(/[#?]/, 1))
            return t.substring(t.lastIndexOf('/') + 1)
          }
          e.getPdfFilenameFromUrl = function getPdfFilenameFromUrl(t, e = 'document.pdf') {
            if ('string' != typeof t) return e
            if (isDataScheme(t)) {
              ;(0, n.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.')
              return e
            }
            const i = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
              s = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(t)
            let a = i.exec(s[1]) || i.exec(s[2]) || i.exec(s[3])
            if (a) {
              a = a[0]
              if (a.includes('%'))
                try {
                  a = i.exec(decodeURIComponent(a))[0]
                } catch {}
            }
            return a || e
          }
          e.getRGB = getRGB
          e.getXfaPageViewport = function getXfaPageViewport(t, { scale: e = 1, rotation: i = 0 }) {
            const { width: s, height: n } = t.attributes.style,
              a = [0, 0, parseInt(s), parseInt(n)]
            return new PageViewport({ viewBox: a, scale: e, rotation: i })
          }
          e.isDataScheme = isDataScheme
          e.isPdfFile = function isPdfFile(t) {
            return 'string' == typeof t && /\.pdf$/i.test(t)
          }
          e.isValidFetchUrl = isValidFetchUrl
          e.loadScript = function loadScript(t, e = !1) {
            return new Promise((i, s) => {
              const n = document.createElement('script')
              n.src = t
              n.onload = function (t) {
                e && n.remove()
                i(t)
              }
              n.onerror = function () {
                s(new Error(`Cannot load script at: ${n.src}`))
              }
              ;(document.head || document.documentElement).append(n)
            })
          }
          e.noContextMenu = function noContextMenu(t) {
            t.preventDefault()
          }
          e.setLayerDimensions = function setLayerDimensions(t, e, i = !1, s = !0) {
            if (e instanceof PageViewport) {
              const { pageWidth: s, pageHeight: a } = e.rawDims,
                { style: r } = t,
                o = n.FeatureTest.isCSSRoundSupported,
                l = `var(--scale-factor) * ${s}px`,
                h = `var(--scale-factor) * ${a}px`,
                c = o ? `round(${l}, 1px)` : `calc(${l})`,
                d = o ? `round(${h}, 1px)` : `calc(${h})`
              if (i && e.rotation % 180 != 0) {
                r.width = d
                r.height = c
              } else {
                r.width = c
                r.height = d
              }
            }
            s && t.setAttribute('data-main-rotation', e.rotation)
          }
          var s = i(7),
            n = i(1)
          const a = 'http://www.w3.org/2000/svg'
          class PixelsPerInch {
            static CSS = 96
            static PDF = 72
            static PDF_TO_CSS_UNITS = this.CSS / this.PDF
          }
          e.PixelsPerInch = PixelsPerInch
          class DOMFilterFactory extends s.BaseFilterFactory {
            #$t
            #Xt
            #e
            #Kt
            #Yt
            #Jt
            #Qt
            #Zt
            #te
            #ee
            #q = 0
            constructor({ docId: t, ownerDocument: e = globalThis.document } = {}) {
              super()
              this.#e = t
              this.#Kt = e
            }
            get #$() {
              return (this.#$t ||= new Map())
            }
            get #ie() {
              if (!this.#Xt) {
                const t = this.#Kt.createElement('div'),
                  { style: e } = t
                e.visibility = 'hidden'
                e.contain = 'strict'
                e.width = e.height = 0
                e.position = 'absolute'
                e.top = e.left = 0
                e.zIndex = -1
                const i = this.#Kt.createElementNS(a, 'svg')
                i.setAttribute('width', 0)
                i.setAttribute('height', 0)
                this.#Xt = this.#Kt.createElementNS(a, 'defs')
                t.append(i)
                i.append(this.#Xt)
                this.#Kt.body.append(t)
              }
              return this.#Xt
            }
            addFilter(t) {
              if (!t) return 'none'
              let e,
                i,
                s,
                n,
                a = this.#$.get(t)
              if (a) return a
              if (1 === t.length) {
                const a = t[0],
                  r = new Array(256)
                for (let t = 0; t < 256; t++) r[t] = a[t] / 255
                n = e = i = s = r.join(',')
              } else {
                const [a, r, o] = t,
                  l = new Array(256),
                  h = new Array(256),
                  c = new Array(256)
                for (let t = 0; t < 256; t++) {
                  l[t] = a[t] / 255
                  h[t] = r[t] / 255
                  c[t] = o[t] / 255
                }
                e = l.join(',')
                i = h.join(',')
                s = c.join(',')
                n = `${e}${i}${s}`
              }
              a = this.#$.get(n)
              if (a) {
                this.#$.set(t, a)
                return a
              }
              const r = `g_${this.#e}_transfer_map_${this.#q++}`,
                o = `url(#${r})`
              this.#$.set(t, o)
              this.#$.set(n, o)
              const l = this.#se(r)
              this.#ne(e, i, s, l)
              return o
            }
            addHCMFilter(t, e) {
              const i = `${t}-${e}`
              if (this.#Jt === i) return this.#Qt
              this.#Jt = i
              this.#Qt = 'none'
              this.#Yt?.remove()
              if (!t || !e) return this.#Qt
              const s = this.#ae(t)
              t = n.Util.makeHexColor(...s)
              const a = this.#ae(e)
              e = n.Util.makeHexColor(...a)
              this.#ie.style.color = ''
              if (('#000000' === t && '#ffffff' === e) || t === e) return this.#Qt
              const r = new Array(256)
              for (let t = 0; t <= 255; t++) {
                const e = t / 255
                r[t] = e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4
              }
              const o = r.join(','),
                l = `g_${this.#e}_hcm_filter`,
                h = (this.#Zt = this.#se(l))
              this.#ne(o, o, o, h)
              this.#re(h)
              const getSteps = (t, e) => {
                const i = s[t] / 255,
                  n = a[t] / 255,
                  r = new Array(e + 1)
                for (let t = 0; t <= e; t++) r[t] = i + (t / e) * (n - i)
                return r.join(',')
              }
              this.#ne(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), h)
              this.#Qt = `url(#${l})`
              return this.#Qt
            }
            addHighlightHCMFilter(t, e, i, s) {
              const n = `${t}-${e}-${i}-${s}`
              if (this.#te === n) return this.#ee
              this.#te = n
              this.#ee = 'none'
              this.#Zt?.remove()
              if (!t || !e) return this.#ee
              const [a, r] = [t, e].map(this.#ae.bind(this))
              let o = Math.round(0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2]),
                l = Math.round(0.2126 * r[0] + 0.7152 * r[1] + 0.0722 * r[2]),
                [h, c] = [i, s].map(this.#ae.bind(this))
              l < o && ([o, l, h, c] = [l, o, c, h])
              this.#ie.style.color = ''
              const getSteps = (t, e, i) => {
                  const s = new Array(256),
                    n = (l - o) / i,
                    a = t / 255,
                    r = (e - t) / (255 * i)
                  let h = 0
                  for (let t = 0; t <= i; t++) {
                    const e = Math.round(o + t * n),
                      i = a + t * r
                    for (let t = h; t <= e; t++) s[t] = i
                    h = e + 1
                  }
                  for (let t = h; t < 256; t++) s[t] = s[h - 1]
                  return s.join(',')
                },
                d = `g_${this.#e}_hcm_highlight_filter`,
                u = (this.#Zt = this.#se(d))
              this.#re(u)
              this.#ne(getSteps(h[0], c[0], 5), getSteps(h[1], c[1], 5), getSteps(h[2], c[2], 5), u)
              this.#ee = `url(#${d})`
              return this.#ee
            }
            destroy(t = !1) {
              if (!t || (!this.#Qt && !this.#ee)) {
                if (this.#Xt) {
                  this.#Xt.parentNode.parentNode.remove()
                  this.#Xt = null
                }
                if (this.#$t) {
                  this.#$t.clear()
                  this.#$t = null
                }
                this.#q = 0
              }
            }
            #re(t) {
              const e = this.#Kt.createElementNS(a, 'feColorMatrix')
              e.setAttribute('type', 'matrix')
              e.setAttribute('values', '0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0')
              t.append(e)
            }
            #se(t) {
              const e = this.#Kt.createElementNS(a, 'filter')
              e.setAttribute('color-interpolation-filters', 'sRGB')
              e.setAttribute('id', t)
              this.#ie.append(e)
              return e
            }
            #oe(t, e, i) {
              const s = this.#Kt.createElementNS(a, e)
              s.setAttribute('type', 'discrete')
              s.setAttribute('tableValues', i)
              t.append(s)
            }
            #ne(t, e, i, s) {
              const n = this.#Kt.createElementNS(a, 'feComponentTransfer')
              s.append(n)
              this.#oe(n, 'feFuncR', t)
              this.#oe(n, 'feFuncG', e)
              this.#oe(n, 'feFuncB', i)
            }
            #ae(t) {
              this.#ie.style.color = t
              return getRGB(getComputedStyle(this.#ie).getPropertyValue('color'))
            }
          }
          e.DOMFilterFactory = DOMFilterFactory
          class DOMCanvasFactory extends s.BaseCanvasFactory {
            constructor({ ownerDocument: t = globalThis.document } = {}) {
              super()
              this._document = t
            }
            _createCanvas(t, e) {
              const i = this._document.createElement('canvas')
              i.width = t
              i.height = e
              return i
            }
          }
          e.DOMCanvasFactory = DOMCanvasFactory
          async function fetchData(t, e = !1) {
            if (isValidFetchUrl(t, document.baseURI)) {
              const i = await fetch(t)
              if (!i.ok) throw new Error(i.statusText)
              return e ? new Uint8Array(await i.arrayBuffer()) : (0, n.stringToBytes)(await i.text())
            }
            return new Promise((i, s) => {
              const a = new XMLHttpRequest()
              a.open('GET', t, !0)
              e && (a.responseType = 'arraybuffer')
              a.onreadystatechange = () => {
                if (a.readyState === XMLHttpRequest.DONE) {
                  if (200 === a.status || 0 === a.status) {
                    let t
                    e && a.response ? (t = new Uint8Array(a.response)) : !e && a.responseText && (t = (0, n.stringToBytes)(a.responseText))
                    if (t) {
                      i(t)
                      return
                    }
                  }
                  s(new Error(a.statusText))
                }
              }
              a.send(null)
            })
          }
          class DOMCMapReaderFactory extends s.BaseCMapReaderFactory {
            _fetchData(t, e) {
              return fetchData(t, this.isCompressed).then((t) => ({ cMapData: t, compressionType: e }))
            }
          }
          e.DOMCMapReaderFactory = DOMCMapReaderFactory
          class DOMStandardFontDataFactory extends s.BaseStandardFontDataFactory {
            _fetchData(t) {
              return fetchData(t, !0)
            }
          }
          e.DOMStandardFontDataFactory = DOMStandardFontDataFactory
          class DOMSVGFactory extends s.BaseSVGFactory {
            _createSVG(t) {
              return document.createElementNS(a, t)
            }
          }
          e.DOMSVGFactory = DOMSVGFactory
          class PageViewport {
            constructor({ viewBox: t, scale: e, rotation: i, offsetX: s = 0, offsetY: n = 0, dontFlip: a = !1 }) {
              this.viewBox = t
              this.scale = e
              this.rotation = i
              this.offsetX = s
              this.offsetY = n
              const r = (t[2] + t[0]) / 2,
                o = (t[3] + t[1]) / 2
              let l, h, c, d, u, p, g, m
              ;(i %= 360) < 0 && (i += 360)
              switch (i) {
                case 180:
                  l = -1
                  h = 0
                  c = 0
                  d = 1
                  break
                case 90:
                  l = 0
                  h = 1
                  c = 1
                  d = 0
                  break
                case 270:
                  l = 0
                  h = -1
                  c = -1
                  d = 0
                  break
                case 0:
                  l = 1
                  h = 0
                  c = 0
                  d = -1
                  break
                default:
                  throw new Error('PageViewport: Invalid rotation, must be a multiple of 90 degrees.')
              }
              if (a) {
                c = -c
                d = -d
              }
              if (0 === l) {
                u = Math.abs(o - t[1]) * e + s
                p = Math.abs(r - t[0]) * e + n
                g = (t[3] - t[1]) * e
                m = (t[2] - t[0]) * e
              } else {
                u = Math.abs(r - t[0]) * e + s
                p = Math.abs(o - t[1]) * e + n
                g = (t[2] - t[0]) * e
                m = (t[3] - t[1]) * e
              }
              this.transform = [l * e, h * e, c * e, d * e, u - l * e * r - c * e * o, p - h * e * r - d * e * o]
              this.width = g
              this.height = m
            }
            get rawDims() {
              const { viewBox: t } = this
              return (0, n.shadow)(this, 'rawDims', { pageWidth: t[2] - t[0], pageHeight: t[3] - t[1], pageX: t[0], pageY: t[1] })
            }
            clone({ scale: t = this.scale, rotation: e = this.rotation, offsetX: i = this.offsetX, offsetY: s = this.offsetY, dontFlip: n = !1 } = {}) {
              return new PageViewport({ viewBox: this.viewBox.slice(), scale: t, rotation: e, offsetX: i, offsetY: s, dontFlip: n })
            }
            convertToViewportPoint(t, e) {
              return n.Util.applyTransform([t, e], this.transform)
            }
            convertToViewportRectangle(t) {
              const e = n.Util.applyTransform([t[0], t[1]], this.transform),
                i = n.Util.applyTransform([t[2], t[3]], this.transform)
              return [e[0], e[1], i[0], i[1]]
            }
            convertToPdfPoint(t, e) {
              return n.Util.applyInverseTransform([t, e], this.transform)
            }
          }
          e.PageViewport = PageViewport
          class RenderingCancelledException extends n.BaseException {
            constructor(t, e = 0) {
              super(t, 'RenderingCancelledException')
              this.extraDelay = e
            }
          }
          e.RenderingCancelledException = RenderingCancelledException
          function isDataScheme(t) {
            const e = t.length
            let i = 0
            for (; i < e && '' === t[i].trim(); ) i++
            return 'data:' === t.substring(i, i + 5).toLowerCase()
          }
          e.StatTimer = class StatTimer {
            started = Object.create(null)
            times = []
            time(t) {
              t in this.started && (0, n.warn)(`Timer is already running for ${t}`)
              this.started[t] = Date.now()
            }
            timeEnd(t) {
              t in this.started || (0, n.warn)(`Timer has not been started for ${t}`)
              this.times.push({ name: t, start: this.started[t], end: Date.now() })
              delete this.started[t]
            }
            toString() {
              const t = []
              let e = 0
              for (const { name: t } of this.times) e = Math.max(t.length, e)
              for (const { name: i, start: s, end: n } of this.times) t.push(`${i.padEnd(e)} ${n - s}ms\n`)
              return t.join('')
            }
          }
          function isValidFetchUrl(t, e) {
            try {
              const { protocol: i } = e ? new URL(t, e) : new URL(t)
              return 'http:' === i || 'https:' === i
            } catch {
              return !1
            }
          }
          let r
          e.PDFDateString = class PDFDateString {
            static toDateObject(t) {
              if (!t || 'string' != typeof t) return null
              r ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?")
              const e = r.exec(t)
              if (!e) return null
              const i = parseInt(e[1], 10)
              let s = parseInt(e[2], 10)
              s = s >= 1 && s <= 12 ? s - 1 : 0
              let n = parseInt(e[3], 10)
              n = n >= 1 && n <= 31 ? n : 1
              let a = parseInt(e[4], 10)
              a = a >= 0 && a <= 23 ? a : 0
              let o = parseInt(e[5], 10)
              o = o >= 0 && o <= 59 ? o : 0
              let l = parseInt(e[6], 10)
              l = l >= 0 && l <= 59 ? l : 0
              const h = e[7] || 'Z'
              let c = parseInt(e[8], 10)
              c = c >= 0 && c <= 23 ? c : 0
              let d = parseInt(e[9], 10) || 0
              d = d >= 0 && d <= 59 ? d : 0
              if ('-' === h) {
                a += c
                o += d
              } else if ('+' === h) {
                a -= c
                o -= d
              }
              return new Date(Date.UTC(i, s, n, a, o, l))
            }
          }
          function getRGB(t) {
            if (t.startsWith('#')) {
              const e = parseInt(t.slice(1), 16)
              return [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e]
            }
            if (t.startsWith('rgb('))
              return t
                .slice(4, -1)
                .split(',')
                .map((t) => parseInt(t))
            if (t.startsWith('rgba('))
              return t
                .slice(5, -1)
                .split(',')
                .map((t) => parseInt(t))
                .slice(0, 3)
            ;(0, n.warn)(`Not a valid color format: "${t}"`)
            return [0, 0, 0]
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.BaseStandardFontDataFactory = e.BaseSVGFactory = e.BaseFilterFactory = e.BaseCanvasFactory = e.BaseCMapReaderFactory = void 0
          var s = i(1)
          class BaseFilterFactory {
            constructor() {
              this.constructor === BaseFilterFactory && (0, s.unreachable)('Cannot initialize BaseFilterFactory.')
            }
            addFilter(t) {
              return 'none'
            }
            addHCMFilter(t, e) {
              return 'none'
            }
            addHighlightHCMFilter(t, e, i, s) {
              return 'none'
            }
            destroy(t = !1) {}
          }
          e.BaseFilterFactory = BaseFilterFactory
          class BaseCanvasFactory {
            constructor() {
              this.constructor === BaseCanvasFactory && (0, s.unreachable)('Cannot initialize BaseCanvasFactory.')
            }
            create(t, e) {
              if (t <= 0 || e <= 0) throw new Error('Invalid canvas size')
              const i = this._createCanvas(t, e)
              return { canvas: i, context: i.getContext('2d') }
            }
            reset(t, e, i) {
              if (!t.canvas) throw new Error('Canvas is not specified')
              if (e <= 0 || i <= 0) throw new Error('Invalid canvas size')
              t.canvas.width = e
              t.canvas.height = i
            }
            destroy(t) {
              if (!t.canvas) throw new Error('Canvas is not specified')
              t.canvas.width = 0
              t.canvas.height = 0
              t.canvas = null
              t.context = null
            }
            _createCanvas(t, e) {
              ;(0, s.unreachable)('Abstract method `_createCanvas` called.')
            }
          }
          e.BaseCanvasFactory = BaseCanvasFactory
          class BaseCMapReaderFactory {
            constructor({ baseUrl: t = null, isCompressed: e = !0 }) {
              this.constructor === BaseCMapReaderFactory && (0, s.unreachable)('Cannot initialize BaseCMapReaderFactory.')
              this.baseUrl = t
              this.isCompressed = e
            }
            async fetch({ name: t }) {
              if (!this.baseUrl) throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.')
              if (!t) throw new Error('CMap name must be specified.')
              const e = this.baseUrl + t + (this.isCompressed ? '.bcmap' : ''),
                i = this.isCompressed ? s.CMapCompressionType.BINARY : s.CMapCompressionType.NONE
              return this._fetchData(e, i).catch((t) => {
                throw new Error(`Unable to load ${this.isCompressed ? 'binary ' : ''}CMap at: ${e}`)
              })
            }
            _fetchData(t, e) {
              ;(0, s.unreachable)('Abstract method `_fetchData` called.')
            }
          }
          e.BaseCMapReaderFactory = BaseCMapReaderFactory
          class BaseStandardFontDataFactory {
            constructor({ baseUrl: t = null }) {
              this.constructor === BaseStandardFontDataFactory && (0, s.unreachable)('Cannot initialize BaseStandardFontDataFactory.')
              this.baseUrl = t
            }
            async fetch({ filename: t }) {
              if (!this.baseUrl) throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.')
              if (!t) throw new Error('Font filename must be specified.')
              const e = `${this.baseUrl}${t}`
              return this._fetchData(e).catch((t) => {
                throw new Error(`Unable to load font data at: ${e}`)
              })
            }
            _fetchData(t) {
              ;(0, s.unreachable)('Abstract method `_fetchData` called.')
            }
          }
          e.BaseStandardFontDataFactory = BaseStandardFontDataFactory
          class BaseSVGFactory {
            constructor() {
              this.constructor === BaseSVGFactory && (0, s.unreachable)('Cannot initialize BaseSVGFactory.')
            }
            create(t, e, i = !1) {
              if (t <= 0 || e <= 0) throw new Error('Invalid SVG dimensions')
              const s = this._createSVG('svg:svg')
              s.setAttribute('version', '1.1')
              if (!i) {
                s.setAttribute('width', `${t}px`)
                s.setAttribute('height', `${e}px`)
              }
              s.setAttribute('preserveAspectRatio', 'none')
              s.setAttribute('viewBox', `0 0 ${t} ${e}`)
              return s
            }
            createElement(t) {
              if ('string' != typeof t) throw new Error('Invalid SVG element type')
              return this._createSVG(t)
            }
            _createSVG(t) {
              ;(0, s.unreachable)('Abstract method `_createSVG` called.')
            }
          }
          e.BaseSVGFactory = BaseSVGFactory
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.MurmurHash3_64 = void 0
          var s = i(1)
          const n = 3285377520,
            a = 4294901760,
            r = 65535
          e.MurmurHash3_64 = class MurmurHash3_64 {
            constructor(t) {
              this.h1 = t ? 4294967295 & t : n
              this.h2 = t ? 4294967295 & t : n
            }
            update(t) {
              let e, i
              if ('string' == typeof t) {
                e = new Uint8Array(2 * t.length)
                i = 0
                for (let s = 0, n = t.length; s < n; s++) {
                  const n = t.charCodeAt(s)
                  if (n <= 255) e[i++] = n
                  else {
                    e[i++] = n >>> 8
                    e[i++] = 255 & n
                  }
                }
              } else {
                if (!(0, s.isArrayBuffer)(t)) throw new Error('Wrong data format in MurmurHash3_64_update. Input must be a string or array.')
                e = t.slice()
                i = e.byteLength
              }
              const n = i >> 2,
                o = i - 4 * n,
                l = new Uint32Array(e.buffer, 0, n)
              let h = 0,
                c = 0,
                d = this.h1,
                u = this.h2
              const p = 3432918353,
                g = 461845907,
                m = 11601,
                f = 13715
              for (let t = 0; t < n; t++)
                if (1 & t) {
                  h = l[t]
                  h = ((h * p) & a) | ((h * m) & r)
                  h = (h << 15) | (h >>> 17)
                  h = ((h * g) & a) | ((h * f) & r)
                  d ^= h
                  d = (d << 13) | (d >>> 19)
                  d = 5 * d + 3864292196
                } else {
                  c = l[t]
                  c = ((c * p) & a) | ((c * m) & r)
                  c = (c << 15) | (c >>> 17)
                  c = ((c * g) & a) | ((c * f) & r)
                  u ^= c
                  u = (u << 13) | (u >>> 19)
                  u = 5 * u + 3864292196
                }
              h = 0
              switch (o) {
                case 3:
                  h ^= e[4 * n + 2] << 16
                case 2:
                  h ^= e[4 * n + 1] << 8
                case 1:
                  h ^= e[4 * n]
                  h = ((h * p) & a) | ((h * m) & r)
                  h = (h << 15) | (h >>> 17)
                  h = ((h * g) & a) | ((h * f) & r)
                  1 & n ? (d ^= h) : (u ^= h)
              }
              this.h1 = d
              this.h2 = u
            }
            hexdigest() {
              let t = this.h1,
                e = this.h2
              t ^= e >>> 1
              t = ((3981806797 * t) & a) | ((36045 * t) & r)
              e = ((4283543511 * e) & a) | (((2950163797 * ((e << 16) | (t >>> 16))) & a) >>> 16)
              t ^= e >>> 1
              t = ((444984403 * t) & a) | ((60499 * t) & r)
              e = ((3301882366 * e) & a) | (((3120437893 * ((e << 16) | (t >>> 16))) & a) >>> 16)
              t ^= e >>> 1
              return (t >>> 0).toString(16).padStart(8, '0') + (e >>> 0).toString(16).padStart(8, '0')
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.FontLoader = e.FontFaceObject = void 0
          var s = i(1)
          e.FontLoader = class FontLoader {
            #le = new Set()
            constructor({ ownerDocument: t = globalThis.document, styleElement: e = null }) {
              this._document = t
              this.nativeFontFaces = new Set()
              this.styleElement = null
              this.loadingRequests = []
              this.loadTestFontId = 0
            }
            addNativeFontFace(t) {
              this.nativeFontFaces.add(t)
              this._document.fonts.add(t)
            }
            removeNativeFontFace(t) {
              this.nativeFontFaces.delete(t)
              this._document.fonts.delete(t)
            }
            insertRule(t) {
              if (!this.styleElement) {
                this.styleElement = this._document.createElement('style')
                this._document.documentElement.getElementsByTagName('head')[0].append(this.styleElement)
              }
              const e = this.styleElement.sheet
              e.insertRule(t, e.cssRules.length)
            }
            clear() {
              for (const t of this.nativeFontFaces) this._document.fonts.delete(t)
              this.nativeFontFaces.clear()
              this.#le.clear()
              if (this.styleElement) {
                this.styleElement.remove()
                this.styleElement = null
              }
            }
            async loadSystemFont(t) {
              if (t && !this.#le.has(t.loadedName)) {
                ;(0, s.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.")
                if (this.isFontLoadingAPISupported) {
                  const { loadedName: e, src: i, style: n } = t,
                    a = new FontFace(e, i, n)
                  this.addNativeFontFace(a)
                  try {
                    await a.load()
                    this.#le.add(e)
                  } catch {
                    ;(0, s.warn)(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`)
                    this.removeNativeFontFace(a)
                  }
                } else (0, s.unreachable)('Not implemented: loadSystemFont without the Font Loading API.')
              }
            }
            async bind(t) {
              if (t.attached || (t.missingFile && !t.systemFontInfo)) return
              t.attached = !0
              if (t.systemFontInfo) {
                await this.loadSystemFont(t.systemFontInfo)
                return
              }
              if (this.isFontLoadingAPISupported) {
                const e = t.createNativeFontFace()
                if (e) {
                  this.addNativeFontFace(e)
                  try {
                    await e.loaded
                  } catch (i) {
                    ;(0, s.warn)(`Failed to load font '${e.family}': '${i}'.`)
                    t.disableFontFace = !0
                    throw i
                  }
                }
                return
              }
              const e = t.createFontFaceRule()
              if (e) {
                this.insertRule(e)
                if (this.isSyncFontLoadingSupported) return
                await new Promise((e) => {
                  const i = this._queueLoadingCallback(e)
                  this._prepareFontLoadEvent(t, i)
                })
              }
            }
            get isFontLoadingAPISupported() {
              const t = !!this._document?.fonts
              return (0, s.shadow)(this, 'isFontLoadingAPISupported', t)
            }
            get isSyncFontLoadingSupported() {
              let t = !1
              ;(s.isNodeJS || ('undefined' != typeof navigator && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent))) && (t = !0)
              return (0, s.shadow)(this, 'isSyncFontLoadingSupported', t)
            }
            _queueLoadingCallback(t) {
              const { loadingRequests: e } = this,
                i = {
                  done: !1,
                  complete: function completeRequest() {
                    ;(0, s.assert)(!i.done, 'completeRequest() cannot be called twice.')
                    i.done = !0
                    for (; e.length > 0 && e[0].done; ) {
                      const t = e.shift()
                      setTimeout(t.callback, 0)
                    }
                  },
                  callback: t,
                }
              e.push(i)
              return i
            }
            get _loadTestFont() {
              const t = atob(
                'T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=='
              )
              return (0, s.shadow)(this, '_loadTestFont', t)
            }
            _prepareFontLoadEvent(t, e) {
              function int32(t, e) {
                return (t.charCodeAt(e) << 24) | (t.charCodeAt(e + 1) << 16) | (t.charCodeAt(e + 2) << 8) | (255 & t.charCodeAt(e + 3))
              }
              function spliceString(t, e, i, s) {
                return t.substring(0, e) + s + t.substring(e + i)
              }
              let i, n
              const a = this._document.createElement('canvas')
              a.width = 1
              a.height = 1
              const r = a.getContext('2d')
              let o = 0
              const l = `lt${Date.now()}${this.loadTestFontId++}`
              let h = this._loadTestFont
              h = spliceString(h, 976, l.length, l)
              const c = 1482184792
              let d = int32(h, 16)
              for (i = 0, n = l.length - 3; i < n; i += 4) d = (d - c + int32(l, i)) | 0
              i < l.length && (d = (d - c + int32(l + 'XXX', i)) | 0)
              h = spliceString(h, 16, 4, (0, s.string32)(d))
              const u = `@font-face {font-family:"${l}";src:${`url(data:font/opentype;base64,${btoa(h)});`}}`
              this.insertRule(u)
              const p = this._document.createElement('div')
              p.style.visibility = 'hidden'
              p.style.width = p.style.height = '10px'
              p.style.position = 'absolute'
              p.style.top = p.style.left = '0px'
              for (const e of [t.loadedName, l]) {
                const t = this._document.createElement('span')
                t.textContent = 'Hi'
                t.style.fontFamily = e
                p.append(t)
              }
              this._document.body.append(p)
              !(function isFontReady(t, e) {
                if (++o > 30) {
                  ;(0, s.warn)('Load test font never loaded.')
                  e()
                  return
                }
                r.font = '30px ' + t
                r.fillText('.', 0, 20)
                r.getImageData(0, 0, 1, 1).data[3] > 0 ? e() : setTimeout(isFontReady.bind(null, t, e))
              })(l, () => {
                p.remove()
                e.complete()
              })
            }
          }
          e.FontFaceObject = class FontFaceObject {
            constructor(t, { isEvalSupported: e = !0, disableFontFace: i = !1, ignoreErrors: s = !1, inspectFont: n = null }) {
              this.compiledGlyphs = Object.create(null)
              for (const e in t) this[e] = t[e]
              this.isEvalSupported = !1 !== e
              this.disableFontFace = !0 === i
              this.ignoreErrors = !0 === s
              this._inspectFont = n
            }
            createNativeFontFace() {
              if (!this.data || this.disableFontFace) return null
              let t
              if (this.cssFontInfo) {
                const e = { weight: this.cssFontInfo.fontWeight }
                this.cssFontInfo.italicAngle && (e.style = `oblique ${this.cssFontInfo.italicAngle}deg`)
                t = new FontFace(this.cssFontInfo.fontFamily, this.data, e)
              } else t = new FontFace(this.loadedName, this.data, {})
              this._inspectFont?.(this)
              return t
            }
            createFontFaceRule() {
              if (!this.data || this.disableFontFace) return null
              const t = (0, s.bytesToString)(this.data),
                e = `url(data:${this.mimetype};base64,${btoa(t)});`
              let i
              if (this.cssFontInfo) {
                let t = `font-weight: ${this.cssFontInfo.fontWeight};`
                this.cssFontInfo.italicAngle && (t += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`)
                i = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${t}src:${e}}`
              } else i = `@font-face {font-family:"${this.loadedName}";src:${e}}`
              this._inspectFont?.(this, e)
              return i
            }
            getPathGenerator(t, e) {
              if (void 0 !== this.compiledGlyphs[e]) return this.compiledGlyphs[e]
              let i
              try {
                i = t.get(this.loadedName + '_path_' + e)
              } catch (t) {
                if (!this.ignoreErrors) throw t
                ;(0, s.warn)(`getPathGenerator - ignoring character: "${t}".`)
                return (this.compiledGlyphs[e] = function (t, e) {})
              }
              if (this.isEvalSupported && s.FeatureTest.isEvalSupported) {
                const t = []
                for (const e of i) {
                  const i = void 0 !== e.args ? e.args.join(',') : ''
                  t.push('c.', e.cmd, '(', i, ');\n')
                }
                return (this.compiledGlyphs[e] = new Function('c', 'size', t.join('')))
              }
              return (this.compiledGlyphs[e] = function (t, e) {
                for (const s of i) {
                  'scale' === s.cmd && (s.args = [e, -e])
                  t[s.cmd].apply(t, s.args)
                }
              })
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.NodeStandardFontDataFactory = e.NodeFilterFactory = e.NodeCanvasFactory = e.NodeCMapReaderFactory = void 0
          var s = i(7)
          i(1)
          const fetchData = function (t) {
            return new Promise((e, i) => {
              require('fs').readFile(t, (t, s) => {
                !t && s ? e(new Uint8Array(s)) : i(new Error(t))
              })
            })
          }
          class NodeFilterFactory extends s.BaseFilterFactory {}
          e.NodeFilterFactory = NodeFilterFactory
          class NodeCanvasFactory extends s.BaseCanvasFactory {
            _createCanvas(t, e) {
              return require('canvas').createCanvas(t, e)
            }
          }
          e.NodeCanvasFactory = NodeCanvasFactory
          class NodeCMapReaderFactory extends s.BaseCMapReaderFactory {
            _fetchData(t, e) {
              return fetchData(t).then((t) => ({ cMapData: t, compressionType: e }))
            }
          }
          e.NodeCMapReaderFactory = NodeCMapReaderFactory
          class NodeStandardFontDataFactory extends s.BaseStandardFontDataFactory {
            _fetchData(t) {
              return fetchData(t)
            }
          }
          e.NodeStandardFontDataFactory = NodeStandardFontDataFactory
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.CanvasGraphics = void 0
          var s = i(1),
            n = i(6),
            a = i(12),
            r = i(13)
          const o = 4096,
            l = 16
          class CachedCanvases {
            constructor(t) {
              this.canvasFactory = t
              this.cache = Object.create(null)
            }
            getCanvas(t, e, i) {
              let s
              if (void 0 !== this.cache[t]) {
                s = this.cache[t]
                this.canvasFactory.reset(s, e, i)
              } else {
                s = this.canvasFactory.create(e, i)
                this.cache[t] = s
              }
              return s
            }
            delete(t) {
              delete this.cache[t]
            }
            clear() {
              for (const t in this.cache) {
                const e = this.cache[t]
                this.canvasFactory.destroy(e)
                delete this.cache[t]
              }
            }
          }
          function drawImageAtIntegerCoords(t, e, i, s, a, r, o, l, h, c) {
            const [d, u, p, g, m, f] = (0, n.getCurrentTransform)(t)
            if (0 === u && 0 === p) {
              const n = o * d + m,
                b = Math.round(n),
                A = l * g + f,
                _ = Math.round(A),
                v = (o + h) * d + m,
                y = Math.abs(Math.round(v) - b) || 1,
                S = (l + c) * g + f,
                E = Math.abs(Math.round(S) - _) || 1
              t.setTransform(Math.sign(d), 0, 0, Math.sign(g), b, _)
              t.drawImage(e, i, s, a, r, 0, 0, y, E)
              t.setTransform(d, u, p, g, m, f)
              return [y, E]
            }
            if (0 === d && 0 === g) {
              const n = l * p + m,
                b = Math.round(n),
                A = o * u + f,
                _ = Math.round(A),
                v = (l + c) * p + m,
                y = Math.abs(Math.round(v) - b) || 1,
                S = (o + h) * u + f,
                E = Math.abs(Math.round(S) - _) || 1
              t.setTransform(0, Math.sign(u), Math.sign(p), 0, b, _)
              t.drawImage(e, i, s, a, r, 0, 0, E, y)
              t.setTransform(d, u, p, g, m, f)
              return [E, y]
            }
            t.drawImage(e, i, s, a, r, o, l, h, c)
            return [Math.hypot(d, u) * h, Math.hypot(p, g) * c]
          }
          class CanvasExtraState {
            constructor(t, e) {
              this.alphaIsShape = !1
              this.fontSize = 0
              this.fontSizeScale = 1
              this.textMatrix = s.IDENTITY_MATRIX
              this.textMatrixScale = 1
              this.fontMatrix = s.FONT_IDENTITY_MATRIX
              this.leading = 0
              this.x = 0
              this.y = 0
              this.lineX = 0
              this.lineY = 0
              this.charSpacing = 0
              this.wordSpacing = 0
              this.textHScale = 1
              this.textRenderingMode = s.TextRenderingMode.FILL
              this.textRise = 0
              this.fillColor = '#000000'
              this.strokeColor = '#000000'
              this.patternFill = !1
              this.fillAlpha = 1
              this.strokeAlpha = 1
              this.lineWidth = 1
              this.activeSMask = null
              this.transferMaps = 'none'
              this.startNewPathAndClipBox([0, 0, t, e])
            }
            clone() {
              const t = Object.create(this)
              t.clipBox = this.clipBox.slice()
              return t
            }
            setCurrentPoint(t, e) {
              this.x = t
              this.y = e
            }
            updatePathMinMax(t, e, i) {
              ;[e, i] = s.Util.applyTransform([e, i], t)
              this.minX = Math.min(this.minX, e)
              this.minY = Math.min(this.minY, i)
              this.maxX = Math.max(this.maxX, e)
              this.maxY = Math.max(this.maxY, i)
            }
            updateRectMinMax(t, e) {
              const i = s.Util.applyTransform(e, t),
                n = s.Util.applyTransform(e.slice(2), t)
              this.minX = Math.min(this.minX, i[0], n[0])
              this.minY = Math.min(this.minY, i[1], n[1])
              this.maxX = Math.max(this.maxX, i[0], n[0])
              this.maxY = Math.max(this.maxY, i[1], n[1])
            }
            updateScalingPathMinMax(t, e) {
              s.Util.scaleMinMax(t, e)
              this.minX = Math.min(this.minX, e[0])
              this.maxX = Math.max(this.maxX, e[1])
              this.minY = Math.min(this.minY, e[2])
              this.maxY = Math.max(this.maxY, e[3])
            }
            updateCurvePathMinMax(t, e, i, n, a, r, o, l, h, c) {
              const d = s.Util.bezierBoundingBox(e, i, n, a, r, o, l, h)
              if (c) {
                c[0] = Math.min(c[0], d[0], d[2])
                c[1] = Math.max(c[1], d[0], d[2])
                c[2] = Math.min(c[2], d[1], d[3])
                c[3] = Math.max(c[3], d[1], d[3])
              } else this.updateRectMinMax(t, d)
            }
            getPathBoundingBox(t = a.PathType.FILL, e = null) {
              const i = [this.minX, this.minY, this.maxX, this.maxY]
              if (t === a.PathType.STROKE) {
                e || (0, s.unreachable)('Stroke bounding box must include transform.')
                const t = s.Util.singularValueDecompose2dScale(e),
                  n = (t[0] * this.lineWidth) / 2,
                  a = (t[1] * this.lineWidth) / 2
                i[0] -= n
                i[1] -= a
                i[2] += n
                i[3] += a
              }
              return i
            }
            updateClipFromPath() {
              const t = s.Util.intersect(this.clipBox, this.getPathBoundingBox())
              this.startNewPathAndClipBox(t || [0, 0, 0, 0])
            }
            isEmptyClip() {
              return this.minX === 1 / 0
            }
            startNewPathAndClipBox(t) {
              this.clipBox = t
              this.minX = 1 / 0
              this.minY = 1 / 0
              this.maxX = 0
              this.maxY = 0
            }
            getClippedPathBoundingBox(t = a.PathType.FILL, e = null) {
              return s.Util.intersect(this.clipBox, this.getPathBoundingBox(t, e))
            }
          }
          function putBinaryImageData(t, e) {
            if ('undefined' != typeof ImageData && e instanceof ImageData) {
              t.putImageData(e, 0, 0)
              return
            }
            const i = e.height,
              n = e.width,
              a = i % l,
              r = (i - a) / l,
              o = 0 === a ? r : r + 1,
              h = t.createImageData(n, l)
            let c,
              d = 0
            const u = e.data,
              p = h.data
            let g, m, f, b
            if (e.kind === s.ImageKind.GRAYSCALE_1BPP) {
              const e = u.byteLength,
                i = new Uint32Array(p.buffer, 0, p.byteLength >> 2),
                b = i.length,
                A = (n + 7) >> 3,
                _ = 4294967295,
                v = s.FeatureTest.isLittleEndian ? 4278190080 : 255
              for (g = 0; g < o; g++) {
                f = g < r ? l : a
                c = 0
                for (m = 0; m < f; m++) {
                  const t = e - d
                  let s = 0
                  const a = t > A ? n : 8 * t - 7,
                    r = -8 & a
                  let o = 0,
                    l = 0
                  for (; s < r; s += 8) {
                    l = u[d++]
                    i[c++] = 128 & l ? _ : v
                    i[c++] = 64 & l ? _ : v
                    i[c++] = 32 & l ? _ : v
                    i[c++] = 16 & l ? _ : v
                    i[c++] = 8 & l ? _ : v
                    i[c++] = 4 & l ? _ : v
                    i[c++] = 2 & l ? _ : v
                    i[c++] = 1 & l ? _ : v
                  }
                  for (; s < a; s++) {
                    if (0 === o) {
                      l = u[d++]
                      o = 128
                    }
                    i[c++] = l & o ? _ : v
                    o >>= 1
                  }
                }
                for (; c < b; ) i[c++] = 0
                t.putImageData(h, 0, g * l)
              }
            } else if (e.kind === s.ImageKind.RGBA_32BPP) {
              m = 0
              b = n * l * 4
              for (g = 0; g < r; g++) {
                p.set(u.subarray(d, d + b))
                d += b
                t.putImageData(h, 0, m)
                m += l
              }
              if (g < o) {
                b = n * a * 4
                p.set(u.subarray(d, d + b))
                t.putImageData(h, 0, m)
              }
            } else {
              if (e.kind !== s.ImageKind.RGB_24BPP) throw new Error(`bad image kind: ${e.kind}`)
              f = l
              b = n * f
              for (g = 0; g < o; g++) {
                if (g >= r) {
                  f = a
                  b = n * f
                }
                c = 0
                for (m = b; m--; ) {
                  p[c++] = u[d++]
                  p[c++] = u[d++]
                  p[c++] = u[d++]
                  p[c++] = 255
                }
                t.putImageData(h, 0, g * l)
              }
            }
          }
          function putBinaryImageMask(t, e) {
            if (e.bitmap) {
              t.drawImage(e.bitmap, 0, 0)
              return
            }
            const i = e.height,
              s = e.width,
              n = i % l,
              a = (i - n) / l,
              o = 0 === n ? a : a + 1,
              h = t.createImageData(s, l)
            let c = 0
            const d = e.data,
              u = h.data
            for (let e = 0; e < o; e++) {
              const i = e < a ? l : n
              ;({ srcPos: c } = (0, r.convertBlackAndWhiteToRGBA)({ src: d, srcPos: c, dest: u, width: s, height: i, nonBlackColor: 0 }))
              t.putImageData(h, 0, e * l)
            }
          }
          function copyCtxState(t, e) {
            const i = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font', 'filter']
            for (const s of i) void 0 !== t[s] && (e[s] = t[s])
            if (void 0 !== t.setLineDash) {
              e.setLineDash(t.getLineDash())
              e.lineDashOffset = t.lineDashOffset
            }
          }
          function resetCtxToDefault(t) {
            t.strokeStyle = t.fillStyle = '#000000'
            t.fillRule = 'nonzero'
            t.globalAlpha = 1
            t.lineWidth = 1
            t.lineCap = 'butt'
            t.lineJoin = 'miter'
            t.miterLimit = 10
            t.globalCompositeOperation = 'source-over'
            t.font = '10px sans-serif'
            if (void 0 !== t.setLineDash) {
              t.setLineDash([])
              t.lineDashOffset = 0
            }
            if (!s.isNodeJS) {
              const { filter: e } = t
              'none' !== e && '' !== e && (t.filter = 'none')
            }
          }
          function composeSMaskBackdrop(t, e, i, s) {
            const n = t.length
            for (let a = 3; a < n; a += 4) {
              const n = t[a]
              if (0 === n) {
                t[a - 3] = e
                t[a - 2] = i
                t[a - 1] = s
              } else if (n < 255) {
                const r = 255 - n
                t[a - 3] = (t[a - 3] * n + e * r) >> 8
                t[a - 2] = (t[a - 2] * n + i * r) >> 8
                t[a - 1] = (t[a - 1] * n + s * r) >> 8
              }
            }
          }
          function composeSMaskAlpha(t, e, i) {
            const s = t.length
            for (let n = 3; n < s; n += 4) {
              const s = i ? i[t[n]] : t[n]
              e[n] = (e[n] * s * 0.00392156862745098) | 0
            }
          }
          function composeSMaskLuminosity(t, e, i) {
            const s = t.length
            for (let n = 3; n < s; n += 4) {
              const s = 77 * t[n - 3] + 152 * t[n - 2] + 28 * t[n - 1]
              e[n] = i ? (e[n] * i[s >> 8]) >> 8 : (e[n] * s) >> 16
            }
          }
          function composeSMask(t, e, i, s) {
            const n = s[0],
              a = s[1],
              r = s[2] - n,
              o = s[3] - a
            if (0 !== r && 0 !== o) {
              !(function genericComposeSMask(t, e, i, s, n, a, r, o, l, h, c) {
                const d = !!a,
                  u = d ? a[0] : 0,
                  p = d ? a[1] : 0,
                  g = d ? a[2] : 0,
                  m = 'Luminosity' === n ? composeSMaskLuminosity : composeSMaskAlpha,
                  f = Math.min(s, Math.ceil(1048576 / i))
                for (let n = 0; n < s; n += f) {
                  const a = Math.min(f, s - n),
                    b = t.getImageData(o - h, n + (l - c), i, a),
                    A = e.getImageData(o, n + l, i, a)
                  d && composeSMaskBackdrop(b.data, u, p, g)
                  m(b.data, A.data, r)
                  e.putImageData(A, o, n + l)
                }
              })(e.context, i, r, o, e.subtype, e.backdrop, e.transferMap, n, a, e.offsetX, e.offsetY)
              t.save()
              t.globalAlpha = 1
              t.globalCompositeOperation = 'source-over'
              t.setTransform(1, 0, 0, 1, 0, 0)
              t.drawImage(i.canvas, 0, 0)
              t.restore()
            }
          }
          function getImageSmoothingEnabled(t, e) {
            const i = s.Util.singularValueDecompose2dScale(t)
            i[0] = Math.fround(i[0])
            i[1] = Math.fround(i[1])
            const a = Math.fround((globalThis.devicePixelRatio || 1) * n.PixelsPerInch.PDF_TO_CSS_UNITS)
            return void 0 !== e ? e : i[0] <= a || i[1] <= a
          }
          const h = ['butt', 'round', 'square'],
            c = ['miter', 'round', 'bevel'],
            d = {},
            u = {}
          class CanvasGraphics {
            constructor(t, e, i, s, n, { optionalContentConfig: a, markedContentStack: r = null }, o, l) {
              this.ctx = t
              this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height)
              this.stateStack = []
              this.pendingClip = null
              this.pendingEOFill = !1
              this.res = null
              this.xobjs = null
              this.commonObjs = e
              this.objs = i
              this.canvasFactory = s
              this.filterFactory = n
              this.groupStack = []
              this.processingType3 = null
              this.baseTransform = null
              this.baseTransformStack = []
              this.groupLevel = 0
              this.smaskStack = []
              this.smaskCounter = 0
              this.tempSMask = null
              this.suspendedCtx = null
              this.contentVisible = !0
              this.markedContentStack = r || []
              this.optionalContentConfig = a
              this.cachedCanvases = new CachedCanvases(this.canvasFactory)
              this.cachedPatterns = new Map()
              this.annotationCanvasMap = o
              this.viewportScale = 1
              this.outputScaleX = 1
              this.outputScaleY = 1
              this.pageColors = l
              this._cachedScaleForStroking = [-1, 0]
              this._cachedGetSinglePixelWidth = null
              this._cachedBitmapsMap = new Map()
            }
            getObject(t, e = null) {
              return 'string' == typeof t ? (t.startsWith('g_') ? this.commonObjs.get(t) : this.objs.get(t)) : e
            }
            beginDrawing({ transform: t, viewport: e, transparency: i = !1, background: s = null }) {
              const a = this.ctx.canvas.width,
                r = this.ctx.canvas.height,
                o = this.ctx.fillStyle
              this.ctx.fillStyle = s || '#ffffff'
              this.ctx.fillRect(0, 0, a, r)
              this.ctx.fillStyle = o
              if (i) {
                const t = this.cachedCanvases.getCanvas('transparent', a, r)
                this.compositeCtx = this.ctx
                this.transparentCanvas = t.canvas
                this.ctx = t.context
                this.ctx.save()
                this.ctx.transform(...(0, n.getCurrentTransform)(this.compositeCtx))
              }
              this.ctx.save()
              resetCtxToDefault(this.ctx)
              if (t) {
                this.ctx.transform(...t)
                this.outputScaleX = t[0]
                this.outputScaleY = t[0]
              }
              this.ctx.transform(...e.transform)
              this.viewportScale = e.scale
              this.baseTransform = (0, n.getCurrentTransform)(this.ctx)
            }
            executeOperatorList(t, e, i, n) {
              const a = t.argsArray,
                r = t.fnArray
              let o = e || 0
              const l = a.length
              if (l === o) return o
              const h = l - o > 10 && 'function' == typeof i,
                c = h ? Date.now() + 15 : 0
              let d = 0
              const u = this.commonObjs,
                p = this.objs
              let g
              for (;;) {
                if (void 0 !== n && o === n.nextBreakPoint) {
                  n.breakIt(o, i)
                  return o
                }
                g = r[o]
                if (g !== s.OPS.dependency) this[g].apply(this, a[o])
                else
                  for (const t of a[o]) {
                    const e = t.startsWith('g_') ? u : p
                    if (!e.has(t)) {
                      e.get(t, i)
                      return o
                    }
                  }
                o++
                if (o === l) return o
                if (h && ++d > 10) {
                  if (Date.now() > c) {
                    i()
                    return o
                  }
                  d = 0
                }
              }
            }
            #he() {
              for (; this.stateStack.length || this.inSMaskMode; ) this.restore()
              this.ctx.restore()
              if (this.transparentCanvas) {
                this.ctx = this.compositeCtx
                this.ctx.save()
                this.ctx.setTransform(1, 0, 0, 1, 0, 0)
                this.ctx.drawImage(this.transparentCanvas, 0, 0)
                this.ctx.restore()
                this.transparentCanvas = null
              }
            }
            endDrawing() {
              this.#he()
              this.cachedCanvases.clear()
              this.cachedPatterns.clear()
              for (const t of this._cachedBitmapsMap.values()) {
                for (const e of t.values()) 'undefined' != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement && (e.width = e.height = 0)
                t.clear()
              }
              this._cachedBitmapsMap.clear()
              this.#ce()
            }
            #ce() {
              if (this.pageColors) {
                const t = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background)
                if ('none' !== t) {
                  const e = this.ctx.filter
                  this.ctx.filter = t
                  this.ctx.drawImage(this.ctx.canvas, 0, 0)
                  this.ctx.filter = e
                }
              }
            }
            _scaleImage(t, e) {
              const i = t.width,
                s = t.height
              let n,
                a,
                r = Math.max(Math.hypot(e[0], e[1]), 1),
                o = Math.max(Math.hypot(e[2], e[3]), 1),
                l = i,
                h = s,
                c = 'prescale1'
              for (; (r > 2 && l > 1) || (o > 2 && h > 1); ) {
                let e = l,
                  i = h
                if (r > 2 && l > 1) {
                  e = l >= 16384 ? Math.floor(l / 2) - 1 || 1 : Math.ceil(l / 2)
                  r /= l / e
                }
                if (o > 2 && h > 1) {
                  i = h >= 16384 ? Math.floor(h / 2) - 1 || 1 : Math.ceil(h) / 2
                  o /= h / i
                }
                n = this.cachedCanvases.getCanvas(c, e, i)
                a = n.context
                a.clearRect(0, 0, e, i)
                a.drawImage(t, 0, 0, l, h, 0, 0, e, i)
                t = n.canvas
                l = e
                h = i
                c = 'prescale1' === c ? 'prescale2' : 'prescale1'
              }
              return { img: t, paintWidth: l, paintHeight: h }
            }
            _createMaskCanvas(t) {
              const e = this.ctx,
                { width: i, height: r } = t,
                o = this.current.fillColor,
                l = this.current.patternFill,
                h = (0, n.getCurrentTransform)(e)
              let c, d, u, p
              if ((t.bitmap || t.data) && t.count > 1) {
                const e = t.bitmap || t.data.buffer
                d = JSON.stringify(l ? h : [h.slice(0, 4), o])
                c = this._cachedBitmapsMap.get(e)
                if (!c) {
                  c = new Map()
                  this._cachedBitmapsMap.set(e, c)
                }
                const i = c.get(d)
                if (i && !l) {
                  return { canvas: i, offsetX: Math.round(Math.min(h[0], h[2]) + h[4]), offsetY: Math.round(Math.min(h[1], h[3]) + h[5]) }
                }
                u = i
              }
              if (!u) {
                p = this.cachedCanvases.getCanvas('maskCanvas', i, r)
                putBinaryImageMask(p.context, t)
              }
              let g = s.Util.transform(h, [1 / i, 0, 0, -1 / r, 0, 0])
              g = s.Util.transform(g, [1, 0, 0, 1, 0, -r])
              const m = s.Util.applyTransform([0, 0], g),
                f = s.Util.applyTransform([i, r], g),
                b = s.Util.normalizeRect([m[0], m[1], f[0], f[1]]),
                A = Math.round(b[2] - b[0]) || 1,
                _ = Math.round(b[3] - b[1]) || 1,
                v = this.cachedCanvases.getCanvas('fillCanvas', A, _),
                y = v.context,
                S = Math.min(m[0], f[0]),
                E = Math.min(m[1], f[1])
              y.translate(-S, -E)
              y.transform(...g)
              if (!u) {
                u = this._scaleImage(p.canvas, (0, n.getCurrentTransformInverse)(y))
                u = u.img
                c && l && c.set(d, u)
              }
              y.imageSmoothingEnabled = getImageSmoothingEnabled((0, n.getCurrentTransform)(y), t.interpolate)
              drawImageAtIntegerCoords(y, u, 0, 0, u.width, u.height, 0, 0, i, r)
              y.globalCompositeOperation = 'source-in'
              const x = s.Util.transform((0, n.getCurrentTransformInverse)(y), [1, 0, 0, 1, -S, -E])
              y.fillStyle = l ? o.getPattern(e, this, x, a.PathType.FILL) : o
              y.fillRect(0, 0, i, r)
              if (c && !l) {
                this.cachedCanvases.delete('fillCanvas')
                c.set(d, v.canvas)
              }
              return { canvas: v.canvas, offsetX: Math.round(S), offsetY: Math.round(E) }
            }
            setLineWidth(t) {
              t !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1)
              this.current.lineWidth = t
              this.ctx.lineWidth = t
            }
            setLineCap(t) {
              this.ctx.lineCap = h[t]
            }
            setLineJoin(t) {
              this.ctx.lineJoin = c[t]
            }
            setMiterLimit(t) {
              this.ctx.miterLimit = t
            }
            setDash(t, e) {
              const i = this.ctx
              if (void 0 !== i.setLineDash) {
                i.setLineDash(t)
                i.lineDashOffset = e
              }
            }
            setRenderingIntent(t) {}
            setFlatness(t) {}
            setGState(t) {
              for (const [e, i] of t)
                switch (e) {
                  case 'LW':
                    this.setLineWidth(i)
                    break
                  case 'LC':
                    this.setLineCap(i)
                    break
                  case 'LJ':
                    this.setLineJoin(i)
                    break
                  case 'ML':
                    this.setMiterLimit(i)
                    break
                  case 'D':
                    this.setDash(i[0], i[1])
                    break
                  case 'RI':
                    this.setRenderingIntent(i)
                    break
                  case 'FL':
                    this.setFlatness(i)
                    break
                  case 'Font':
                    this.setFont(i[0], i[1])
                    break
                  case 'CA':
                    this.current.strokeAlpha = i
                    break
                  case 'ca':
                    this.current.fillAlpha = i
                    this.ctx.globalAlpha = i
                    break
                  case 'BM':
                    this.ctx.globalCompositeOperation = i
                    break
                  case 'SMask':
                    this.current.activeSMask = i ? this.tempSMask : null
                    this.tempSMask = null
                    this.checkSMaskState()
                    break
                  case 'TR':
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(i)
                }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx
            }
            checkSMaskState() {
              const t = this.inSMaskMode
              this.current.activeSMask && !t ? this.beginSMaskMode() : !this.current.activeSMask && t && this.endSMaskMode()
            }
            beginSMaskMode() {
              if (this.inSMaskMode) throw new Error('beginSMaskMode called while already in smask mode')
              const t = this.ctx.canvas.width,
                e = this.ctx.canvas.height,
                i = 'smaskGroupAt' + this.groupLevel,
                s = this.cachedCanvases.getCanvas(i, t, e)
              this.suspendedCtx = this.ctx
              this.ctx = s.context
              const a = this.ctx
              a.setTransform(...(0, n.getCurrentTransform)(this.suspendedCtx))
              copyCtxState(this.suspendedCtx, a)
              !(function mirrorContextOperations(t, e) {
                if (t._removeMirroring) throw new Error('Context is already forwarding operations.')
                t.__originalSave = t.save
                t.__originalRestore = t.restore
                t.__originalRotate = t.rotate
                t.__originalScale = t.scale
                t.__originalTranslate = t.translate
                t.__originalTransform = t.transform
                t.__originalSetTransform = t.setTransform
                t.__originalResetTransform = t.resetTransform
                t.__originalClip = t.clip
                t.__originalMoveTo = t.moveTo
                t.__originalLineTo = t.lineTo
                t.__originalBezierCurveTo = t.bezierCurveTo
                t.__originalRect = t.rect
                t.__originalClosePath = t.closePath
                t.__originalBeginPath = t.beginPath
                t._removeMirroring = () => {
                  t.save = t.__originalSave
                  t.restore = t.__originalRestore
                  t.rotate = t.__originalRotate
                  t.scale = t.__originalScale
                  t.translate = t.__originalTranslate
                  t.transform = t.__originalTransform
                  t.setTransform = t.__originalSetTransform
                  t.resetTransform = t.__originalResetTransform
                  t.clip = t.__originalClip
                  t.moveTo = t.__originalMoveTo
                  t.lineTo = t.__originalLineTo
                  t.bezierCurveTo = t.__originalBezierCurveTo
                  t.rect = t.__originalRect
                  t.closePath = t.__originalClosePath
                  t.beginPath = t.__originalBeginPath
                  delete t._removeMirroring
                }
                t.save = function ctxSave() {
                  e.save()
                  this.__originalSave()
                }
                t.restore = function ctxRestore() {
                  e.restore()
                  this.__originalRestore()
                }
                t.translate = function ctxTranslate(t, i) {
                  e.translate(t, i)
                  this.__originalTranslate(t, i)
                }
                t.scale = function ctxScale(t, i) {
                  e.scale(t, i)
                  this.__originalScale(t, i)
                }
                t.transform = function ctxTransform(t, i, s, n, a, r) {
                  e.transform(t, i, s, n, a, r)
                  this.__originalTransform(t, i, s, n, a, r)
                }
                t.setTransform = function ctxSetTransform(t, i, s, n, a, r) {
                  e.setTransform(t, i, s, n, a, r)
                  this.__originalSetTransform(t, i, s, n, a, r)
                }
                t.resetTransform = function ctxResetTransform() {
                  e.resetTransform()
                  this.__originalResetTransform()
                }
                t.rotate = function ctxRotate(t) {
                  e.rotate(t)
                  this.__originalRotate(t)
                }
                t.clip = function ctxRotate(t) {
                  e.clip(t)
                  this.__originalClip(t)
                }
                t.moveTo = function (t, i) {
                  e.moveTo(t, i)
                  this.__originalMoveTo(t, i)
                }
                t.lineTo = function (t, i) {
                  e.lineTo(t, i)
                  this.__originalLineTo(t, i)
                }
                t.bezierCurveTo = function (t, i, s, n, a, r) {
                  e.bezierCurveTo(t, i, s, n, a, r)
                  this.__originalBezierCurveTo(t, i, s, n, a, r)
                }
                t.rect = function (t, i, s, n) {
                  e.rect(t, i, s, n)
                  this.__originalRect(t, i, s, n)
                }
                t.closePath = function () {
                  e.closePath()
                  this.__originalClosePath()
                }
                t.beginPath = function () {
                  e.beginPath()
                  this.__originalBeginPath()
                }
              })(a, this.suspendedCtx)
              this.setGState([
                ['BM', 'source-over'],
                ['ca', 1],
                ['CA', 1],
              ])
            }
            endSMaskMode() {
              if (!this.inSMaskMode) throw new Error('endSMaskMode called while not in smask mode')
              this.ctx._removeMirroring()
              copyCtxState(this.ctx, this.suspendedCtx)
              this.ctx = this.suspendedCtx
              this.suspendedCtx = null
            }
            compose(t) {
              if (!this.current.activeSMask) return
              if (t) {
                t[0] = Math.floor(t[0])
                t[1] = Math.floor(t[1])
                t[2] = Math.ceil(t[2])
                t[3] = Math.ceil(t[3])
              } else t = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]
              const e = this.current.activeSMask
              composeSMask(this.suspendedCtx, e, this.ctx, t)
              this.ctx.save()
              this.ctx.setTransform(1, 0, 0, 1, 0, 0)
              this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
              this.ctx.restore()
            }
            save() {
              if (this.inSMaskMode) {
                copyCtxState(this.ctx, this.suspendedCtx)
                this.suspendedCtx.save()
              } else this.ctx.save()
              const t = this.current
              this.stateStack.push(t)
              this.current = t.clone()
            }
            restore() {
              0 === this.stateStack.length && this.inSMaskMode && this.endSMaskMode()
              if (0 !== this.stateStack.length) {
                this.current = this.stateStack.pop()
                if (this.inSMaskMode) {
                  this.suspendedCtx.restore()
                  copyCtxState(this.suspendedCtx, this.ctx)
                } else this.ctx.restore()
                this.checkSMaskState()
                this.pendingClip = null
                this._cachedScaleForStroking[0] = -1
                this._cachedGetSinglePixelWidth = null
              }
            }
            transform(t, e, i, s, n, a) {
              this.ctx.transform(t, e, i, s, n, a)
              this._cachedScaleForStroking[0] = -1
              this._cachedGetSinglePixelWidth = null
            }
            constructPath(t, e, i) {
              const a = this.ctx,
                r = this.current
              let o,
                l,
                h = r.x,
                c = r.y
              const d = (0, n.getCurrentTransform)(a),
                u = (0 === d[0] && 0 === d[3]) || (0 === d[1] && 0 === d[2]),
                p = u ? i.slice(0) : null
              for (let i = 0, n = 0, g = t.length; i < g; i++)
                switch (0 | t[i]) {
                  case s.OPS.rectangle:
                    h = e[n++]
                    c = e[n++]
                    const t = e[n++],
                      i = e[n++],
                      g = h + t,
                      m = c + i
                    a.moveTo(h, c)
                    if (0 === t || 0 === i) a.lineTo(g, m)
                    else {
                      a.lineTo(g, c)
                      a.lineTo(g, m)
                      a.lineTo(h, m)
                    }
                    u || r.updateRectMinMax(d, [h, c, g, m])
                    a.closePath()
                    break
                  case s.OPS.moveTo:
                    h = e[n++]
                    c = e[n++]
                    a.moveTo(h, c)
                    u || r.updatePathMinMax(d, h, c)
                    break
                  case s.OPS.lineTo:
                    h = e[n++]
                    c = e[n++]
                    a.lineTo(h, c)
                    u || r.updatePathMinMax(d, h, c)
                    break
                  case s.OPS.curveTo:
                    o = h
                    l = c
                    h = e[n + 4]
                    c = e[n + 5]
                    a.bezierCurveTo(e[n], e[n + 1], e[n + 2], e[n + 3], h, c)
                    r.updateCurvePathMinMax(d, o, l, e[n], e[n + 1], e[n + 2], e[n + 3], h, c, p)
                    n += 6
                    break
                  case s.OPS.curveTo2:
                    o = h
                    l = c
                    a.bezierCurveTo(h, c, e[n], e[n + 1], e[n + 2], e[n + 3])
                    r.updateCurvePathMinMax(d, o, l, h, c, e[n], e[n + 1], e[n + 2], e[n + 3], p)
                    h = e[n + 2]
                    c = e[n + 3]
                    n += 4
                    break
                  case s.OPS.curveTo3:
                    o = h
                    l = c
                    h = e[n + 2]
                    c = e[n + 3]
                    a.bezierCurveTo(e[n], e[n + 1], h, c, h, c)
                    r.updateCurvePathMinMax(d, o, l, e[n], e[n + 1], h, c, h, c, p)
                    n += 4
                    break
                  case s.OPS.closePath:
                    a.closePath()
                }
              u && r.updateScalingPathMinMax(d, p)
              r.setCurrentPoint(h, c)
            }
            closePath() {
              this.ctx.closePath()
            }
            stroke(t = !0) {
              const e = this.ctx,
                i = this.current.strokeColor
              e.globalAlpha = this.current.strokeAlpha
              if (this.contentVisible)
                if ('object' == typeof i && i?.getPattern) {
                  e.save()
                  e.strokeStyle = i.getPattern(e, this, (0, n.getCurrentTransformInverse)(e), a.PathType.STROKE)
                  this.rescaleAndStroke(!1)
                  e.restore()
                } else this.rescaleAndStroke(!0)
              t && this.consumePath(this.current.getClippedPathBoundingBox())
              e.globalAlpha = this.current.fillAlpha
            }
            closeStroke() {
              this.closePath()
              this.stroke()
            }
            fill(t = !0) {
              const e = this.ctx,
                i = this.current.fillColor
              let s = !1
              if (this.current.patternFill) {
                e.save()
                e.fillStyle = i.getPattern(e, this, (0, n.getCurrentTransformInverse)(e), a.PathType.FILL)
                s = !0
              }
              const r = this.current.getClippedPathBoundingBox()
              if (this.contentVisible && null !== r)
                if (this.pendingEOFill) {
                  e.fill('evenodd')
                  this.pendingEOFill = !1
                } else e.fill()
              s && e.restore()
              t && this.consumePath(r)
            }
            eoFill() {
              this.pendingEOFill = !0
              this.fill()
            }
            fillStroke() {
              this.fill(!1)
              this.stroke(!1)
              this.consumePath()
            }
            eoFillStroke() {
              this.pendingEOFill = !0
              this.fillStroke()
            }
            closeFillStroke() {
              this.closePath()
              this.fillStroke()
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0
              this.closePath()
              this.fillStroke()
            }
            endPath() {
              this.consumePath()
            }
            clip() {
              this.pendingClip = d
            }
            eoClip() {
              this.pendingClip = u
            }
            beginText() {
              this.current.textMatrix = s.IDENTITY_MATRIX
              this.current.textMatrixScale = 1
              this.current.x = this.current.lineX = 0
              this.current.y = this.current.lineY = 0
            }
            endText() {
              const t = this.pendingTextPaths,
                e = this.ctx
              if (void 0 !== t) {
                e.save()
                e.beginPath()
                for (const i of t) {
                  e.setTransform(...i.transform)
                  e.translate(i.x, i.y)
                  i.addToPath(e, i.fontSize)
                }
                e.restore()
                e.clip()
                e.beginPath()
                delete this.pendingTextPaths
              } else e.beginPath()
            }
            setCharSpacing(t) {
              this.current.charSpacing = t
            }
            setWordSpacing(t) {
              this.current.wordSpacing = t
            }
            setHScale(t) {
              this.current.textHScale = t / 100
            }
            setLeading(t) {
              this.current.leading = -t
            }
            setFont(t, e) {
              const i = this.commonObjs.get(t),
                n = this.current
              if (!i) throw new Error(`Can't find font for ${t}`)
              n.fontMatrix = i.fontMatrix || s.FONT_IDENTITY_MATRIX
              ;(0 !== n.fontMatrix[0] && 0 !== n.fontMatrix[3]) || (0, s.warn)('Invalid font matrix for font ' + t)
              if (e < 0) {
                e = -e
                n.fontDirection = -1
              } else n.fontDirection = 1
              this.current.font = i
              this.current.fontSize = e
              if (i.isType3Font) return
              const a = i.loadedName || 'sans-serif',
                r = i.systemFontInfo?.css || `"${a}", ${i.fallbackName}`
              let o = 'normal'
              i.black ? (o = '900') : i.bold && (o = 'bold')
              const l = i.italic ? 'italic' : 'normal'
              let h = e
              e < 16 ? (h = 16) : e > 100 && (h = 100)
              this.current.fontSizeScale = e / h
              this.ctx.font = `${l} ${o} ${h}px ${r}`
            }
            setTextRenderingMode(t) {
              this.current.textRenderingMode = t
            }
            setTextRise(t) {
              this.current.textRise = t
            }
            moveText(t, e) {
              this.current.x = this.current.lineX += t
              this.current.y = this.current.lineY += e
            }
            setLeadingMoveText(t, e) {
              this.setLeading(-e)
              this.moveText(t, e)
            }
            setTextMatrix(t, e, i, s, n, a) {
              this.current.textMatrix = [t, e, i, s, n, a]
              this.current.textMatrixScale = Math.hypot(t, e)
              this.current.x = this.current.lineX = 0
              this.current.y = this.current.lineY = 0
            }
            nextLine() {
              this.moveText(0, this.current.leading)
            }
            paintChar(t, e, i, a) {
              const r = this.ctx,
                o = this.current,
                l = o.font,
                h = o.textRenderingMode,
                c = o.fontSize / o.fontSizeScale,
                d = h & s.TextRenderingMode.FILL_STROKE_MASK,
                u = !!(h & s.TextRenderingMode.ADD_TO_PATH_FLAG),
                p = o.patternFill && !l.missingFile
              let g
              ;(l.disableFontFace || u || p) && (g = l.getPathGenerator(this.commonObjs, t))
              if (l.disableFontFace || p) {
                r.save()
                r.translate(e, i)
                r.beginPath()
                g(r, c)
                a && r.setTransform(...a)
                ;(d !== s.TextRenderingMode.FILL && d !== s.TextRenderingMode.FILL_STROKE) || r.fill()
                ;(d !== s.TextRenderingMode.STROKE && d !== s.TextRenderingMode.FILL_STROKE) || r.stroke()
                r.restore()
              } else {
                ;(d !== s.TextRenderingMode.FILL && d !== s.TextRenderingMode.FILL_STROKE) || r.fillText(t, e, i)
                ;(d !== s.TextRenderingMode.STROKE && d !== s.TextRenderingMode.FILL_STROKE) || r.strokeText(t, e, i)
              }
              if (u) {
                ;(this.pendingTextPaths ||= []).push({ transform: (0, n.getCurrentTransform)(r), x: e, y: i, fontSize: c, addToPath: g })
              }
            }
            get isFontSubpixelAAEnabled() {
              const { context: t } = this.cachedCanvases.getCanvas('isFontSubpixelAAEnabled', 10, 10)
              t.scale(1.5, 1)
              t.fillText('I', 0, 10)
              const e = t.getImageData(0, 0, 10, 10).data
              let i = !1
              for (let t = 3; t < e.length; t += 4)
                if (e[t] > 0 && e[t] < 255) {
                  i = !0
                  break
                }
              return (0, s.shadow)(this, 'isFontSubpixelAAEnabled', i)
            }
            showText(t) {
              const e = this.current,
                i = e.font
              if (i.isType3Font) return this.showType3Text(t)
              const r = e.fontSize
              if (0 === r) return
              const o = this.ctx,
                l = e.fontSizeScale,
                h = e.charSpacing,
                c = e.wordSpacing,
                d = e.fontDirection,
                u = e.textHScale * d,
                p = t.length,
                g = i.vertical,
                m = g ? 1 : -1,
                f = i.defaultVMetrics,
                b = r * e.fontMatrix[0],
                A = e.textRenderingMode === s.TextRenderingMode.FILL && !i.disableFontFace && !e.patternFill
              o.save()
              o.transform(...e.textMatrix)
              o.translate(e.x, e.y + e.textRise)
              d > 0 ? o.scale(u, -1) : o.scale(u, 1)
              let _
              if (e.patternFill) {
                o.save()
                const t = e.fillColor.getPattern(o, this, (0, n.getCurrentTransformInverse)(o), a.PathType.FILL)
                _ = (0, n.getCurrentTransform)(o)
                o.restore()
                o.fillStyle = t
              }
              let v = e.lineWidth
              const y = e.textMatrixScale
              if (0 === y || 0 === v) {
                const t = e.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK
                ;(t !== s.TextRenderingMode.STROKE && t !== s.TextRenderingMode.FILL_STROKE) || (v = this.getSinglePixelWidth())
              } else v /= y
              if (1 !== l) {
                o.scale(l, l)
                v /= l
              }
              o.lineWidth = v
              if (i.isInvalidPDFjsFont) {
                const i = []
                let s = 0
                for (const e of t) {
                  i.push(e.unicode)
                  s += e.width
                }
                o.fillText(i.join(''), 0, 0)
                e.x += s * b * u
                o.restore()
                this.compose()
                return
              }
              let S,
                E = 0
              for (S = 0; S < p; ++S) {
                const e = t[S]
                if ('number' == typeof e) {
                  E += (m * e * r) / 1e3
                  continue
                }
                let s = !1
                const n = (e.isSpace ? c : 0) + h,
                  a = e.fontChar,
                  u = e.accent
                let p,
                  v,
                  y = e.width
                if (g) {
                  const t = e.vmetric || f,
                    i = -(e.vmetric ? t[1] : 0.5 * y) * b,
                    s = t[2] * b
                  y = t ? -t[0] : y
                  p = i / l
                  v = (E + s) / l
                } else {
                  p = E / l
                  v = 0
                }
                if (i.remeasure && y > 0) {
                  const t = ((1e3 * o.measureText(a).width) / r) * l
                  if (y < t && this.isFontSubpixelAAEnabled) {
                    const e = y / t
                    s = !0
                    o.save()
                    o.scale(e, 1)
                    p /= e
                  } else y !== t && (p += (((y - t) / 2e3) * r) / l)
                }
                if (this.contentVisible && (e.isInFont || i.missingFile))
                  if (A && !u) o.fillText(a, p, v)
                  else {
                    this.paintChar(a, p, v, _)
                    if (u) {
                      const t = p + (r * u.offset.x) / l,
                        e = v - (r * u.offset.y) / l
                      this.paintChar(u.fontChar, t, e, _)
                    }
                  }
                E += g ? y * b - n * d : y * b + n * d
                s && o.restore()
              }
              g ? (e.y -= E) : (e.x += E * u)
              o.restore()
              this.compose()
            }
            showType3Text(t) {
              const e = this.ctx,
                i = this.current,
                n = i.font,
                a = i.fontSize,
                r = i.fontDirection,
                o = n.vertical ? 1 : -1,
                l = i.charSpacing,
                h = i.wordSpacing,
                c = i.textHScale * r,
                d = i.fontMatrix || s.FONT_IDENTITY_MATRIX,
                u = t.length
              let p, g, m, f
              if (!(i.textRenderingMode === s.TextRenderingMode.INVISIBLE) && 0 !== a) {
                this._cachedScaleForStroking[0] = -1
                this._cachedGetSinglePixelWidth = null
                e.save()
                e.transform(...i.textMatrix)
                e.translate(i.x, i.y)
                e.scale(c, r)
                for (p = 0; p < u; ++p) {
                  g = t[p]
                  if ('number' == typeof g) {
                    f = (o * g * a) / 1e3
                    this.ctx.translate(f, 0)
                    i.x += f * c
                    continue
                  }
                  const r = (g.isSpace ? h : 0) + l,
                    u = n.charProcOperatorList[g.operatorListId]
                  if (!u) {
                    ;(0, s.warn)(`Type3 character "${g.operatorListId}" is not available.`)
                    continue
                  }
                  if (this.contentVisible) {
                    this.processingType3 = g
                    this.save()
                    e.scale(a, a)
                    e.transform(...d)
                    this.executeOperatorList(u)
                    this.restore()
                  }
                  m = s.Util.applyTransform([g.width, 0], d)[0] * a + r
                  e.translate(m, 0)
                  i.x += m * c
                }
                e.restore()
                this.processingType3 = null
              }
            }
            setCharWidth(t, e) {}
            setCharWidthAndBounds(t, e, i, s, n, a) {
              this.ctx.rect(i, s, n - i, a - s)
              this.ctx.clip()
              this.endPath()
            }
            getColorN_Pattern(t) {
              let e
              if ('TilingPattern' === t[0]) {
                const i = t[1],
                  s = this.baseTransform || (0, n.getCurrentTransform)(this.ctx),
                  r = { createCanvasGraphics: (t) => new CanvasGraphics(t, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) }
                e = new a.TilingPattern(t, i, this.ctx, r, s)
              } else e = this._getPattern(t[1], t[2])
              return e
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments)
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments)
              this.current.patternFill = !0
            }
            setStrokeRGBColor(t, e, i) {
              const n = s.Util.makeHexColor(t, e, i)
              this.ctx.strokeStyle = n
              this.current.strokeColor = n
            }
            setFillRGBColor(t, e, i) {
              const n = s.Util.makeHexColor(t, e, i)
              this.ctx.fillStyle = n
              this.current.fillColor = n
              this.current.patternFill = !1
            }
            _getPattern(t, e = null) {
              let i
              if (this.cachedPatterns.has(t)) i = this.cachedPatterns.get(t)
              else {
                i = (0, a.getShadingPattern)(this.getObject(t))
                this.cachedPatterns.set(t, i)
              }
              e && (i.matrix = e)
              return i
            }
            shadingFill(t) {
              if (!this.contentVisible) return
              const e = this.ctx
              this.save()
              const i = this._getPattern(t)
              e.fillStyle = i.getPattern(e, this, (0, n.getCurrentTransformInverse)(e), a.PathType.SHADING)
              const r = (0, n.getCurrentTransformInverse)(e)
              if (r) {
                const { width: t, height: i } = e.canvas,
                  [n, a, o, l] = s.Util.getAxialAlignedBoundingBox([0, 0, t, i], r)
                this.ctx.fillRect(n, a, o - n, l - a)
              } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10)
              this.compose(this.current.getClippedPathBoundingBox())
              this.restore()
            }
            beginInlineImage() {
              ;(0, s.unreachable)('Should not call beginInlineImage')
            }
            beginImageData() {
              ;(0, s.unreachable)('Should not call beginImageData')
            }
            paintFormXObjectBegin(t, e) {
              if (this.contentVisible) {
                this.save()
                this.baseTransformStack.push(this.baseTransform)
                Array.isArray(t) && 6 === t.length && this.transform(...t)
                this.baseTransform = (0, n.getCurrentTransform)(this.ctx)
                if (e) {
                  const t = e[2] - e[0],
                    i = e[3] - e[1]
                  this.ctx.rect(e[0], e[1], t, i)
                  this.current.updateRectMinMax((0, n.getCurrentTransform)(this.ctx), e)
                  this.clip()
                  this.endPath()
                }
              }
            }
            paintFormXObjectEnd() {
              if (this.contentVisible) {
                this.restore()
                this.baseTransform = this.baseTransformStack.pop()
              }
            }
            beginGroup(t) {
              if (!this.contentVisible) return
              this.save()
              if (this.inSMaskMode) {
                this.endSMaskMode()
                this.current.activeSMask = null
              }
              const e = this.ctx
              t.isolated || (0, s.info)('TODO: Support non-isolated groups.')
              t.knockout && (0, s.warn)('Knockout groups not supported.')
              const i = (0, n.getCurrentTransform)(e)
              t.matrix && e.transform(...t.matrix)
              if (!t.bbox) throw new Error('Bounding box is required.')
              let a = s.Util.getAxialAlignedBoundingBox(t.bbox, (0, n.getCurrentTransform)(e))
              const r = [0, 0, e.canvas.width, e.canvas.height]
              a = s.Util.intersect(a, r) || [0, 0, 0, 0]
              const l = Math.floor(a[0]),
                h = Math.floor(a[1])
              let c = Math.max(Math.ceil(a[2]) - l, 1),
                d = Math.max(Math.ceil(a[3]) - h, 1),
                u = 1,
                p = 1
              if (c > o) {
                u = c / o
                c = o
              }
              if (d > o) {
                p = d / o
                d = o
              }
              this.current.startNewPathAndClipBox([0, 0, c, d])
              let g = 'groupAt' + this.groupLevel
              t.smask && (g += '_smask_' + (this.smaskCounter++ % 2))
              const m = this.cachedCanvases.getCanvas(g, c, d),
                f = m.context
              f.scale(1 / u, 1 / p)
              f.translate(-l, -h)
              f.transform(...i)
              if (t.smask) this.smaskStack.push({ canvas: m.canvas, context: f, offsetX: l, offsetY: h, scaleX: u, scaleY: p, subtype: t.smask.subtype, backdrop: t.smask.backdrop, transferMap: t.smask.transferMap || null, startTransformInverse: null })
              else {
                e.setTransform(1, 0, 0, 1, 0, 0)
                e.translate(l, h)
                e.scale(u, p)
                e.save()
              }
              copyCtxState(e, f)
              this.ctx = f
              this.setGState([
                ['BM', 'source-over'],
                ['ca', 1],
                ['CA', 1],
              ])
              this.groupStack.push(e)
              this.groupLevel++
            }
            endGroup(t) {
              if (!this.contentVisible) return
              this.groupLevel--
              const e = this.ctx,
                i = this.groupStack.pop()
              this.ctx = i
              this.ctx.imageSmoothingEnabled = !1
              if (t.smask) {
                this.tempSMask = this.smaskStack.pop()
                this.restore()
              } else {
                this.ctx.restore()
                const t = (0, n.getCurrentTransform)(this.ctx)
                this.restore()
                this.ctx.save()
                this.ctx.setTransform(...t)
                const i = s.Util.getAxialAlignedBoundingBox([0, 0, e.canvas.width, e.canvas.height], t)
                this.ctx.drawImage(e.canvas, 0, 0)
                this.ctx.restore()
                this.compose(i)
              }
            }
            beginAnnotation(t, e, i, a, r) {
              this.#he()
              resetCtxToDefault(this.ctx)
              this.ctx.save()
              this.save()
              this.baseTransform && this.ctx.setTransform(...this.baseTransform)
              if (Array.isArray(e) && 4 === e.length) {
                const a = e[2] - e[0],
                  o = e[3] - e[1]
                if (r && this.annotationCanvasMap) {
                  ;(i = i.slice())[4] -= e[0]
                  i[5] -= e[1]
                  ;(e = e.slice())[0] = e[1] = 0
                  e[2] = a
                  e[3] = o
                  const [r, l] = s.Util.singularValueDecompose2dScale((0, n.getCurrentTransform)(this.ctx)),
                    { viewportScale: h } = this,
                    c = Math.ceil(a * this.outputScaleX * h),
                    d = Math.ceil(o * this.outputScaleY * h)
                  this.annotationCanvas = this.canvasFactory.create(c, d)
                  const { canvas: u, context: p } = this.annotationCanvas
                  this.annotationCanvasMap.set(t, u)
                  this.annotationCanvas.savedCtx = this.ctx
                  this.ctx = p
                  this.ctx.save()
                  this.ctx.setTransform(r, 0, 0, -l, 0, o * l)
                  resetCtxToDefault(this.ctx)
                } else {
                  resetCtxToDefault(this.ctx)
                  this.ctx.rect(e[0], e[1], a, o)
                  this.ctx.clip()
                  this.endPath()
                }
              }
              this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height)
              this.transform(...i)
              this.transform(...a)
            }
            endAnnotation() {
              if (this.annotationCanvas) {
                this.ctx.restore()
                this.#ce()
                this.ctx = this.annotationCanvas.savedCtx
                delete this.annotationCanvas.savedCtx
                delete this.annotationCanvas
              }
            }
            paintImageMaskXObject(t) {
              if (!this.contentVisible) return
              const e = t.count
              ;(t = this.getObject(t.data, t)).count = e
              const i = this.ctx,
                s = this.processingType3
              if (s) {
                void 0 === s.compiled &&
                  (s.compiled = (function compileType3Glyph(t) {
                    const { width: e, height: i } = t
                    if (e > 1e3 || i > 1e3) return null
                    const s = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
                      n = e + 1
                    let a,
                      r,
                      o,
                      l = new Uint8Array(n * (i + 1))
                    const h = (e + 7) & -8
                    let c = new Uint8Array(h * i),
                      d = 0
                    for (const e of t.data) {
                      let t = 128
                      for (; t > 0; ) {
                        c[d++] = e & t ? 0 : 255
                        t >>= 1
                      }
                    }
                    let u = 0
                    d = 0
                    if (0 !== c[d]) {
                      l[0] = 1
                      ++u
                    }
                    for (r = 1; r < e; r++) {
                      if (c[d] !== c[d + 1]) {
                        l[r] = c[d] ? 2 : 1
                        ++u
                      }
                      d++
                    }
                    if (0 !== c[d]) {
                      l[r] = 2
                      ++u
                    }
                    for (a = 1; a < i; a++) {
                      d = a * h
                      o = a * n
                      if (c[d - h] !== c[d]) {
                        l[o] = c[d] ? 1 : 8
                        ++u
                      }
                      let t = (c[d] ? 4 : 0) + (c[d - h] ? 8 : 0)
                      for (r = 1; r < e; r++) {
                        t = (t >> 2) + (c[d + 1] ? 4 : 0) + (c[d - h + 1] ? 8 : 0)
                        if (s[t]) {
                          l[o + r] = s[t]
                          ++u
                        }
                        d++
                      }
                      if (c[d - h] !== c[d]) {
                        l[o + r] = c[d] ? 2 : 4
                        ++u
                      }
                      if (u > 1e3) return null
                    }
                    d = h * (i - 1)
                    o = a * n
                    if (0 !== c[d]) {
                      l[o] = 8
                      ++u
                    }
                    for (r = 1; r < e; r++) {
                      if (c[d] !== c[d + 1]) {
                        l[o + r] = c[d] ? 4 : 8
                        ++u
                      }
                      d++
                    }
                    if (0 !== c[d]) {
                      l[o + r] = 4
                      ++u
                    }
                    if (u > 1e3) return null
                    const p = new Int32Array([0, n, -1, 0, -n, 0, 0, 0, 1]),
                      g = new Path2D()
                    for (a = 0; u && a <= i; a++) {
                      let t = a * n
                      const i = t + e
                      for (; t < i && !l[t]; ) t++
                      if (t === i) continue
                      g.moveTo(t % n, a)
                      const s = t
                      let r = l[t]
                      do {
                        const e = p[r]
                        do {
                          t += e
                        } while (!l[t])
                        const i = l[t]
                        if (5 !== i && 10 !== i) {
                          r = i
                          l[t] = 0
                        } else {
                          r = i & ((51 * r) >> 4)
                          l[t] &= (r >> 2) | (r << 2)
                        }
                        g.lineTo(t % n, (t / n) | 0)
                        l[t] || --u
                      } while (s !== t)
                      --a
                    }
                    c = null
                    l = null
                    return function (t) {
                      t.save()
                      t.scale(1 / e, -1 / i)
                      t.translate(0, -i)
                      t.fill(g)
                      t.beginPath()
                      t.restore()
                    }
                  })(t))
                if (s.compiled) {
                  s.compiled(i)
                  return
                }
              }
              const n = this._createMaskCanvas(t),
                a = n.canvas
              i.save()
              i.setTransform(1, 0, 0, 1, 0, 0)
              i.drawImage(a, n.offsetX, n.offsetY)
              i.restore()
              this.compose()
            }
            paintImageMaskXObjectRepeat(t, e, i = 0, a = 0, r, o) {
              if (!this.contentVisible) return
              t = this.getObject(t.data, t)
              const l = this.ctx
              l.save()
              const h = (0, n.getCurrentTransform)(l)
              l.transform(e, i, a, r, 0, 0)
              const c = this._createMaskCanvas(t)
              l.setTransform(1, 0, 0, 1, c.offsetX - h[4], c.offsetY - h[5])
              for (let t = 0, n = o.length; t < n; t += 2) {
                const n = s.Util.transform(h, [e, i, a, r, o[t], o[t + 1]]),
                  [d, u] = s.Util.applyTransform([0, 0], n)
                l.drawImage(c.canvas, d, u)
              }
              l.restore()
              this.compose()
            }
            paintImageMaskXObjectGroup(t) {
              if (!this.contentVisible) return
              const e = this.ctx,
                i = this.current.fillColor,
                s = this.current.patternFill
              for (const r of t) {
                const { data: t, width: o, height: l, transform: h } = r,
                  c = this.cachedCanvases.getCanvas('maskCanvas', o, l),
                  d = c.context
                d.save()
                putBinaryImageMask(d, this.getObject(t, r))
                d.globalCompositeOperation = 'source-in'
                d.fillStyle = s ? i.getPattern(d, this, (0, n.getCurrentTransformInverse)(e), a.PathType.FILL) : i
                d.fillRect(0, 0, o, l)
                d.restore()
                e.save()
                e.transform(...h)
                e.scale(1, -1)
                drawImageAtIntegerCoords(e, c.canvas, 0, 0, o, l, 0, -1, 1, 1)
                e.restore()
              }
              this.compose()
            }
            paintImageXObject(t) {
              if (!this.contentVisible) return
              const e = this.getObject(t)
              e ? this.paintInlineImageXObject(e) : (0, s.warn)("Dependent image isn't ready yet")
            }
            paintImageXObjectRepeat(t, e, i, n) {
              if (!this.contentVisible) return
              const a = this.getObject(t)
              if (!a) {
                ;(0, s.warn)("Dependent image isn't ready yet")
                return
              }
              const r = a.width,
                o = a.height,
                l = []
              for (let t = 0, s = n.length; t < s; t += 2) l.push({ transform: [e, 0, 0, i, n[t], n[t + 1]], x: 0, y: 0, w: r, h: o })
              this.paintInlineImageXObjectGroup(a, l)
            }
            applyTransferMapsToCanvas(t) {
              if ('none' !== this.current.transferMaps) {
                t.filter = this.current.transferMaps
                t.drawImage(t.canvas, 0, 0)
                t.filter = 'none'
              }
              return t.canvas
            }
            applyTransferMapsToBitmap(t) {
              if ('none' === this.current.transferMaps) return t.bitmap
              const { bitmap: e, width: i, height: s } = t,
                n = this.cachedCanvases.getCanvas('inlineImage', i, s),
                a = n.context
              a.filter = this.current.transferMaps
              a.drawImage(e, 0, 0)
              a.filter = 'none'
              return n.canvas
            }
            paintInlineImageXObject(t) {
              if (!this.contentVisible) return
              const e = t.width,
                i = t.height,
                a = this.ctx
              this.save()
              if (!s.isNodeJS) {
                const { filter: t } = a
                'none' !== t && '' !== t && (a.filter = 'none')
              }
              a.scale(1 / e, -1 / i)
              let r
              if (t.bitmap) r = this.applyTransferMapsToBitmap(t)
              else if (('function' == typeof HTMLElement && t instanceof HTMLElement) || !t.data) r = t
              else {
                const s = this.cachedCanvases.getCanvas('inlineImage', e, i).context
                putBinaryImageData(s, t)
                r = this.applyTransferMapsToCanvas(s)
              }
              const o = this._scaleImage(r, (0, n.getCurrentTransformInverse)(a))
              a.imageSmoothingEnabled = getImageSmoothingEnabled((0, n.getCurrentTransform)(a), t.interpolate)
              drawImageAtIntegerCoords(a, o.img, 0, 0, o.paintWidth, o.paintHeight, 0, -i, e, i)
              this.compose()
              this.restore()
            }
            paintInlineImageXObjectGroup(t, e) {
              if (!this.contentVisible) return
              const i = this.ctx
              let s
              if (t.bitmap) s = t.bitmap
              else {
                const e = t.width,
                  i = t.height,
                  n = this.cachedCanvases.getCanvas('inlineImage', e, i).context
                putBinaryImageData(n, t)
                s = this.applyTransferMapsToCanvas(n)
              }
              for (const t of e) {
                i.save()
                i.transform(...t.transform)
                i.scale(1, -1)
                drawImageAtIntegerCoords(i, s, t.x, t.y, t.w, t.h, 0, -1, 1, 1)
                i.restore()
              }
              this.compose()
            }
            paintSolidColorImageMask() {
              if (this.contentVisible) {
                this.ctx.fillRect(0, 0, 1, 1)
                this.compose()
              }
            }
            markPoint(t) {}
            markPointProps(t, e) {}
            beginMarkedContent(t) {
              this.markedContentStack.push({ visible: !0 })
            }
            beginMarkedContentProps(t, e) {
              'OC' === t ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(e) }) : this.markedContentStack.push({ visible: !0 })
              this.contentVisible = this.isContentVisible()
            }
            endMarkedContent() {
              this.markedContentStack.pop()
              this.contentVisible = this.isContentVisible()
            }
            beginCompat() {}
            endCompat() {}
            consumePath(t) {
              const e = this.current.isEmptyClip()
              this.pendingClip && this.current.updateClipFromPath()
              this.pendingClip || this.compose(t)
              const i = this.ctx
              if (this.pendingClip) {
                e || (this.pendingClip === u ? i.clip('evenodd') : i.clip())
                this.pendingClip = null
              }
              this.current.startNewPathAndClipBox(this.current.clipBox)
              i.beginPath()
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const t = (0, n.getCurrentTransform)(this.ctx)
                if (0 === t[1] && 0 === t[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t[0]), Math.abs(t[3]))
                else {
                  const e = Math.abs(t[0] * t[3] - t[2] * t[1]),
                    i = Math.hypot(t[0], t[2]),
                    s = Math.hypot(t[1], t[3])
                  this._cachedGetSinglePixelWidth = Math.max(i, s) / e
                }
              }
              return this._cachedGetSinglePixelWidth
            }
            getScaleForStroking() {
              if (-1 === this._cachedScaleForStroking[0]) {
                const { lineWidth: t } = this.current,
                  { a: e, b: i, c: s, d: n } = this.ctx.getTransform()
                let a, r
                if (0 === i && 0 === s) {
                  const i = Math.abs(e),
                    s = Math.abs(n)
                  if (i === s)
                    if (0 === t) a = r = 1 / i
                    else {
                      const e = i * t
                      a = r = e < 1 ? 1 / e : 1
                    }
                  else if (0 === t) {
                    a = 1 / i
                    r = 1 / s
                  } else {
                    const e = i * t,
                      n = s * t
                    a = e < 1 ? 1 / e : 1
                    r = n < 1 ? 1 / n : 1
                  }
                } else {
                  const o = Math.abs(e * n - i * s),
                    l = Math.hypot(e, i),
                    h = Math.hypot(s, n)
                  if (0 === t) {
                    a = h / o
                    r = l / o
                  } else {
                    const e = t * o
                    a = h > e ? h / e : 1
                    r = l > e ? l / e : 1
                  }
                }
                this._cachedScaleForStroking[0] = a
                this._cachedScaleForStroking[1] = r
              }
              return this._cachedScaleForStroking
            }
            rescaleAndStroke(t) {
              const { ctx: e } = this,
                { lineWidth: i } = this.current,
                [s, n] = this.getScaleForStroking()
              e.lineWidth = i || 1
              if (1 === s && 1 === n) {
                e.stroke()
                return
              }
              const a = e.getLineDash()
              t && e.save()
              e.scale(s, n)
              if (a.length > 0) {
                const t = Math.max(s, n)
                e.setLineDash(a.map((e) => e / t))
                e.lineDashOffset /= t
              }
              e.stroke()
              t && e.restore()
            }
            isContentVisible() {
              for (let t = this.markedContentStack.length - 1; t >= 0; t--) if (!this.markedContentStack[t].visible) return !1
              return !0
            }
          }
          e.CanvasGraphics = CanvasGraphics
          for (const t in s.OPS) void 0 !== CanvasGraphics.prototype[t] && (CanvasGraphics.prototype[s.OPS[t]] = CanvasGraphics.prototype[t])
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.TilingPattern = e.PathType = void 0
          e.getShadingPattern = function getShadingPattern(t) {
            switch (t[0]) {
              case 'RadialAxial':
                return new RadialAxialShadingPattern(t)
              case 'Mesh':
                return new MeshShadingPattern(t)
              case 'Dummy':
                return new DummyShadingPattern()
            }
            throw new Error(`Unknown IR type: ${t[0]}`)
          }
          var s = i(1),
            n = i(6)
          const a = { FILL: 'Fill', STROKE: 'Stroke', SHADING: 'Shading' }
          e.PathType = a
          function applyBoundingBox(t, e) {
            if (!e) return
            const i = e[2] - e[0],
              s = e[3] - e[1],
              n = new Path2D()
            n.rect(e[0], e[1], i, s)
            t.clip(n)
          }
          class BaseShadingPattern {
            constructor() {
              this.constructor === BaseShadingPattern && (0, s.unreachable)('Cannot initialize BaseShadingPattern.')
            }
            getPattern() {
              ;(0, s.unreachable)('Abstract method `getPattern` called.')
            }
          }
          class RadialAxialShadingPattern extends BaseShadingPattern {
            constructor(t) {
              super()
              this._type = t[1]
              this._bbox = t[2]
              this._colorStops = t[3]
              this._p0 = t[4]
              this._p1 = t[5]
              this._r0 = t[6]
              this._r1 = t[7]
              this.matrix = null
            }
            _createGradient(t) {
              let e
              'axial' === this._type ? (e = t.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1])) : 'radial' === this._type && (e = t.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1))
              for (const t of this._colorStops) e.addColorStop(t[0], t[1])
              return e
            }
            getPattern(t, e, i, r) {
              let o
              if (r === a.STROKE || r === a.FILL) {
                const a = e.current.getClippedPathBoundingBox(r, (0, n.getCurrentTransform)(t)) || [0, 0, 0, 0],
                  l = Math.ceil(a[2] - a[0]) || 1,
                  h = Math.ceil(a[3] - a[1]) || 1,
                  c = e.cachedCanvases.getCanvas('pattern', l, h, !0),
                  d = c.context
                d.clearRect(0, 0, d.canvas.width, d.canvas.height)
                d.beginPath()
                d.rect(0, 0, d.canvas.width, d.canvas.height)
                d.translate(-a[0], -a[1])
                i = s.Util.transform(i, [1, 0, 0, 1, a[0], a[1]])
                d.transform(...e.baseTransform)
                this.matrix && d.transform(...this.matrix)
                applyBoundingBox(d, this._bbox)
                d.fillStyle = this._createGradient(d)
                d.fill()
                o = t.createPattern(c.canvas, 'no-repeat')
                const u = new DOMMatrix(i)
                o.setTransform(u)
              } else {
                applyBoundingBox(t, this._bbox)
                o = this._createGradient(t)
              }
              return o
            }
          }
          function drawTriangle(t, e, i, s, n, a, r, o) {
            const l = e.coords,
              h = e.colors,
              c = t.data,
              d = 4 * t.width
            let u
            if (l[i + 1] > l[s + 1]) {
              u = i
              i = s
              s = u
              u = a
              a = r
              r = u
            }
            if (l[s + 1] > l[n + 1]) {
              u = s
              s = n
              n = u
              u = r
              r = o
              o = u
            }
            if (l[i + 1] > l[s + 1]) {
              u = i
              i = s
              s = u
              u = a
              a = r
              r = u
            }
            const p = (l[i] + e.offsetX) * e.scaleX,
              g = (l[i + 1] + e.offsetY) * e.scaleY,
              m = (l[s] + e.offsetX) * e.scaleX,
              f = (l[s + 1] + e.offsetY) * e.scaleY,
              b = (l[n] + e.offsetX) * e.scaleX,
              A = (l[n + 1] + e.offsetY) * e.scaleY
            if (g >= A) return
            const _ = h[a],
              v = h[a + 1],
              y = h[a + 2],
              S = h[r],
              E = h[r + 1],
              x = h[r + 2],
              w = h[o],
              C = h[o + 1],
              T = h[o + 2],
              P = Math.round(g),
              M = Math.round(A)
            let k, F, R, D, I, L, O, N
            for (let t = P; t <= M; t++) {
              if (t < f) {
                const e = t < g ? 0 : (g - t) / (g - f)
                k = p - (p - m) * e
                F = _ - (_ - S) * e
                R = v - (v - E) * e
                D = y - (y - x) * e
              } else {
                let e
                e = t > A ? 1 : f === A ? 0 : (f - t) / (f - A)
                k = m - (m - b) * e
                F = S - (S - w) * e
                R = E - (E - C) * e
                D = x - (x - T) * e
              }
              let e
              e = t < g ? 0 : t > A ? 1 : (g - t) / (g - A)
              I = p - (p - b) * e
              L = _ - (_ - w) * e
              O = v - (v - C) * e
              N = y - (y - T) * e
              const i = Math.round(Math.min(k, I)),
                s = Math.round(Math.max(k, I))
              let n = d * t + 4 * i
              for (let t = i; t <= s; t++) {
                e = (k - t) / (k - I)
                e < 0 ? (e = 0) : e > 1 && (e = 1)
                c[n++] = (F - (F - L) * e) | 0
                c[n++] = (R - (R - O) * e) | 0
                c[n++] = (D - (D - N) * e) | 0
                c[n++] = 255
              }
            }
          }
          function drawFigure(t, e, i) {
            const s = e.coords,
              n = e.colors
            let a, r
            switch (e.type) {
              case 'lattice':
                const o = e.verticesPerRow,
                  l = Math.floor(s.length / o) - 1,
                  h = o - 1
                for (a = 0; a < l; a++) {
                  let e = a * o
                  for (let a = 0; a < h; a++, e++) {
                    drawTriangle(t, i, s[e], s[e + 1], s[e + o], n[e], n[e + 1], n[e + o])
                    drawTriangle(t, i, s[e + o + 1], s[e + 1], s[e + o], n[e + o + 1], n[e + 1], n[e + o])
                  }
                }
                break
              case 'triangles':
                for (a = 0, r = s.length; a < r; a += 3) drawTriangle(t, i, s[a], s[a + 1], s[a + 2], n[a], n[a + 1], n[a + 2])
                break
              default:
                throw new Error('illegal figure')
            }
          }
          class MeshShadingPattern extends BaseShadingPattern {
            constructor(t) {
              super()
              this._coords = t[2]
              this._colors = t[3]
              this._figures = t[4]
              this._bounds = t[5]
              this._bbox = t[7]
              this._background = t[8]
              this.matrix = null
            }
            _createMeshCanvas(t, e, i) {
              const s = Math.floor(this._bounds[0]),
                n = Math.floor(this._bounds[1]),
                a = Math.ceil(this._bounds[2]) - s,
                r = Math.ceil(this._bounds[3]) - n,
                o = Math.min(Math.ceil(Math.abs(a * t[0] * 1.1)), 3e3),
                l = Math.min(Math.ceil(Math.abs(r * t[1] * 1.1)), 3e3),
                h = a / o,
                c = r / l,
                d = { coords: this._coords, colors: this._colors, offsetX: -s, offsetY: -n, scaleX: 1 / h, scaleY: 1 / c },
                u = o + 4,
                p = l + 4,
                g = i.getCanvas('mesh', u, p, !1),
                m = g.context,
                f = m.createImageData(o, l)
              if (e) {
                const t = f.data
                for (let i = 0, s = t.length; i < s; i += 4) {
                  t[i] = e[0]
                  t[i + 1] = e[1]
                  t[i + 2] = e[2]
                  t[i + 3] = 255
                }
              }
              for (const t of this._figures) drawFigure(f, t, d)
              m.putImageData(f, 2, 2)
              return { canvas: g.canvas, offsetX: s - 2 * h, offsetY: n - 2 * c, scaleX: h, scaleY: c }
            }
            getPattern(t, e, i, r) {
              applyBoundingBox(t, this._bbox)
              let o
              if (r === a.SHADING) o = s.Util.singularValueDecompose2dScale((0, n.getCurrentTransform)(t))
              else {
                o = s.Util.singularValueDecompose2dScale(e.baseTransform)
                if (this.matrix) {
                  const t = s.Util.singularValueDecompose2dScale(this.matrix)
                  o = [o[0] * t[0], o[1] * t[1]]
                }
              }
              const l = this._createMeshCanvas(o, r === a.SHADING ? null : this._background, e.cachedCanvases)
              if (r !== a.SHADING) {
                t.setTransform(...e.baseTransform)
                this.matrix && t.transform(...this.matrix)
              }
              t.translate(l.offsetX, l.offsetY)
              t.scale(l.scaleX, l.scaleY)
              return t.createPattern(l.canvas, 'no-repeat')
            }
          }
          class DummyShadingPattern extends BaseShadingPattern {
            getPattern() {
              return 'hotpink'
            }
          }
          const r = 1,
            o = 2
          class TilingPattern {
            static MAX_PATTERN_SIZE = 3e3
            constructor(t, e, i, s, n) {
              this.operatorList = t[2]
              this.matrix = t[3] || [1, 0, 0, 1, 0, 0]
              this.bbox = t[4]
              this.xstep = t[5]
              this.ystep = t[6]
              this.paintType = t[7]
              this.tilingType = t[8]
              this.color = e
              this.ctx = i
              this.canvasGraphicsFactory = s
              this.baseTransform = n
            }
            createPatternCanvas(t) {
              const e = this.operatorList,
                i = this.bbox,
                a = this.xstep,
                r = this.ystep,
                o = this.paintType,
                l = this.tilingType,
                h = this.color,
                c = this.canvasGraphicsFactory
              ;(0, s.info)('TilingType: ' + l)
              const d = i[0],
                u = i[1],
                p = i[2],
                g = i[3],
                m = s.Util.singularValueDecompose2dScale(this.matrix),
                f = s.Util.singularValueDecompose2dScale(this.baseTransform),
                b = [m[0] * f[0], m[1] * f[1]],
                A = this.getSizeAndScale(a, this.ctx.canvas.width, b[0]),
                _ = this.getSizeAndScale(r, this.ctx.canvas.height, b[1]),
                v = t.cachedCanvases.getCanvas('pattern', A.size, _.size, !0),
                y = v.context,
                S = c.createCanvasGraphics(y)
              S.groupLevel = t.groupLevel
              this.setFillAndStrokeStyleToContext(S, o, h)
              let E = d,
                x = u,
                w = p,
                C = g
              if (d < 0) {
                E = 0
                w += Math.abs(d)
              }
              if (u < 0) {
                x = 0
                C += Math.abs(u)
              }
              y.translate(-A.scale * E, -_.scale * x)
              S.transform(A.scale, 0, 0, _.scale, 0, 0)
              y.save()
              this.clipBbox(S, E, x, w, C)
              S.baseTransform = (0, n.getCurrentTransform)(S.ctx)
              S.executeOperatorList(e)
              S.endDrawing()
              return { canvas: v.canvas, scaleX: A.scale, scaleY: _.scale, offsetX: E, offsetY: x }
            }
            getSizeAndScale(t, e, i) {
              t = Math.abs(t)
              const s = Math.max(TilingPattern.MAX_PATTERN_SIZE, e)
              let n = Math.ceil(t * i)
              n >= s ? (n = s) : (i = n / t)
              return { scale: i, size: n }
            }
            clipBbox(t, e, i, s, a) {
              const r = s - e,
                o = a - i
              t.ctx.rect(e, i, r, o)
              t.current.updateRectMinMax((0, n.getCurrentTransform)(t.ctx), [e, i, s, a])
              t.clip()
              t.endPath()
            }
            setFillAndStrokeStyleToContext(t, e, i) {
              const n = t.ctx,
                a = t.current
              switch (e) {
                case r:
                  const t = this.ctx
                  n.fillStyle = t.fillStyle
                  n.strokeStyle = t.strokeStyle
                  a.fillColor = t.fillStyle
                  a.strokeColor = t.strokeStyle
                  break
                case o:
                  const l = s.Util.makeHexColor(i[0], i[1], i[2])
                  n.fillStyle = l
                  n.strokeStyle = l
                  a.fillColor = l
                  a.strokeColor = l
                  break
                default:
                  throw new s.FormatError(`Unsupported paint type: ${e}`)
              }
            }
            getPattern(t, e, i, n) {
              let r = i
              if (n !== a.SHADING) {
                r = s.Util.transform(r, e.baseTransform)
                this.matrix && (r = s.Util.transform(r, this.matrix))
              }
              const o = this.createPatternCanvas(e)
              let l = new DOMMatrix(r)
              l = l.translate(o.offsetX, o.offsetY)
              l = l.scale(1 / o.scaleX, 1 / o.scaleY)
              const h = t.createPattern(o.canvas, 'repeat')
              h.setTransform(l)
              return h
            }
          }
          e.TilingPattern = TilingPattern
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA
          e.convertToRGBA = function convertToRGBA(t) {
            switch (t.kind) {
              case s.ImageKind.GRAYSCALE_1BPP:
                return convertBlackAndWhiteToRGBA(t)
              case s.ImageKind.RGB_24BPP:
                return (function convertRGBToRGBA({ src: t, srcPos: e = 0, dest: i, destPos: n = 0, width: a, height: r }) {
                  let o = 0
                  const l = t.length >> 2,
                    h = new Uint32Array(t.buffer, e, l)
                  if (s.FeatureTest.isLittleEndian) {
                    for (; o < l - 2; o += 3, n += 4) {
                      const t = h[o],
                        e = h[o + 1],
                        s = h[o + 2]
                      i[n] = 4278190080 | t
                      i[n + 1] = (t >>> 24) | (e << 8) | 4278190080
                      i[n + 2] = (e >>> 16) | (s << 16) | 4278190080
                      i[n + 3] = (s >>> 8) | 4278190080
                    }
                    for (let e = 4 * o, s = t.length; e < s; e += 3) i[n++] = t[e] | (t[e + 1] << 8) | (t[e + 2] << 16) | 4278190080
                  } else {
                    for (; o < l - 2; o += 3, n += 4) {
                      const t = h[o],
                        e = h[o + 1],
                        s = h[o + 2]
                      i[n] = 255 | t
                      i[n + 1] = (t << 24) | (e >>> 8) | 255
                      i[n + 2] = (e << 16) | (s >>> 16) | 255
                      i[n + 3] = (s << 8) | 255
                    }
                    for (let e = 4 * o, s = t.length; e < s; e += 3) i[n++] = (t[e] << 24) | (t[e + 1] << 16) | (t[e + 2] << 8) | 255
                  }
                  return { srcPos: e, destPos: n }
                })(t)
            }
            return null
          }
          e.grayToRGBA = function grayToRGBA(t, e) {
            if (s.FeatureTest.isLittleEndian) for (let i = 0, s = t.length; i < s; i++) e[i] = (65793 * t[i]) | 4278190080
            else for (let i = 0, s = t.length; i < s; i++) e[i] = (16843008 * t[i]) | 255
          }
          var s = i(1)
          function convertBlackAndWhiteToRGBA({ src: t, srcPos: e = 0, dest: i, width: n, height: a, nonBlackColor: r = 4294967295, inverseDecode: o = !1 }) {
            const l = s.FeatureTest.isLittleEndian ? 4278190080 : 255,
              [h, c] = o ? [r, l] : [l, r],
              d = n >> 3,
              u = 7 & n,
              p = t.length
            i = new Uint32Array(i.buffer)
            let g = 0
            for (let s = 0; s < a; s++) {
              for (const s = e + d; e < s; e++) {
                const s = e < p ? t[e] : 255
                i[g++] = 128 & s ? c : h
                i[g++] = 64 & s ? c : h
                i[g++] = 32 & s ? c : h
                i[g++] = 16 & s ? c : h
                i[g++] = 8 & s ? c : h
                i[g++] = 4 & s ? c : h
                i[g++] = 2 & s ? c : h
                i[g++] = 1 & s ? c : h
              }
              if (0 === u) continue
              const s = e < p ? t[e++] : 255
              for (let t = 0; t < u; t++) i[g++] = s & (1 << (7 - t)) ? c : h
            }
            return { srcPos: e, destPos: g }
          }
        },
        (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.GlobalWorkerOptions = void 0
          const i = Object.create(null)
          e.GlobalWorkerOptions = i
          i.workerPort = null
          i.workerSrc = ''
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.MessageHandler = void 0
          var s = i(1)
          const n = 1,
            a = 2,
            r = 1,
            o = 2,
            l = 3,
            h = 4,
            c = 5,
            d = 6,
            u = 7,
            p = 8
          function wrapReason(t) {
            t instanceof Error || ('object' == typeof t && null !== t) || (0, s.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.')
            switch (t.name) {
              case 'AbortException':
                return new s.AbortException(t.message)
              case 'MissingPDFException':
                return new s.MissingPDFException(t.message)
              case 'PasswordException':
                return new s.PasswordException(t.message, t.code)
              case 'UnexpectedResponseException':
                return new s.UnexpectedResponseException(t.message, t.status)
              case 'UnknownErrorException':
                return new s.UnknownErrorException(t.message, t.details)
              default:
                return new s.UnknownErrorException(t.message, t.toString())
            }
          }
          e.MessageHandler = class MessageHandler {
            constructor(t, e, i) {
              this.sourceName = t
              this.targetName = e
              this.comObj = i
              this.callbackId = 1
              this.streamId = 1
              this.streamSinks = Object.create(null)
              this.streamControllers = Object.create(null)
              this.callbackCapabilities = Object.create(null)
              this.actionHandler = Object.create(null)
              this._onComObjOnMessage = (t) => {
                const e = t.data
                if (e.targetName !== this.sourceName) return
                if (e.stream) {
                  this.#de(e)
                  return
                }
                if (e.callback) {
                  const t = e.callbackId,
                    i = this.callbackCapabilities[t]
                  if (!i) throw new Error(`Cannot resolve callback ${t}`)
                  delete this.callbackCapabilities[t]
                  if (e.callback === n) i.resolve(e.data)
                  else {
                    if (e.callback !== a) throw new Error('Unexpected callback case')
                    i.reject(wrapReason(e.reason))
                  }
                  return
                }
                const s = this.actionHandler[e.action]
                if (!s) throw new Error(`Unknown action from worker: ${e.action}`)
                if (e.callbackId) {
                  const t = this.sourceName,
                    r = e.sourceName
                  new Promise(function (t) {
                    t(s(e.data))
                  }).then(
                    function (s) {
                      i.postMessage({ sourceName: t, targetName: r, callback: n, callbackId: e.callbackId, data: s })
                    },
                    function (s) {
                      i.postMessage({ sourceName: t, targetName: r, callback: a, callbackId: e.callbackId, reason: wrapReason(s) })
                    }
                  )
                } else e.streamId ? this.#ue(e) : s(e.data)
              }
              i.addEventListener('message', this._onComObjOnMessage)
            }
            on(t, e) {
              const i = this.actionHandler
              if (i[t]) throw new Error(`There is already an actionName called "${t}"`)
              i[t] = e
            }
            send(t, e, i) {
              this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t, data: e }, i)
            }
            sendWithPromise(t, e, i) {
              const n = this.callbackId++,
                a = new s.PromiseCapability()
              this.callbackCapabilities[n] = a
              try {
                this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t, callbackId: n, data: e }, i)
              } catch (t) {
                a.reject(t)
              }
              return a.promise
            }
            sendWithStream(t, e, i, n) {
              const a = this.streamId++,
                o = this.sourceName,
                l = this.targetName,
                h = this.comObj
              return new ReadableStream(
                {
                  start: (i) => {
                    const r = new s.PromiseCapability()
                    this.streamControllers[a] = { controller: i, startCall: r, pullCall: null, cancelCall: null, isClosed: !1 }
                    h.postMessage({ sourceName: o, targetName: l, action: t, streamId: a, data: e, desiredSize: i.desiredSize }, n)
                    return r.promise
                  },
                  pull: (t) => {
                    const e = new s.PromiseCapability()
                    this.streamControllers[a].pullCall = e
                    h.postMessage({ sourceName: o, targetName: l, stream: d, streamId: a, desiredSize: t.desiredSize })
                    return e.promise
                  },
                  cancel: (t) => {
                    ;(0, s.assert)(t instanceof Error, 'cancel must have a valid reason')
                    const e = new s.PromiseCapability()
                    this.streamControllers[a].cancelCall = e
                    this.streamControllers[a].isClosed = !0
                    h.postMessage({ sourceName: o, targetName: l, stream: r, streamId: a, reason: wrapReason(t) })
                    return e.promise
                  },
                },
                i
              )
            }
            #ue(t) {
              const e = t.streamId,
                i = this.sourceName,
                n = t.sourceName,
                a = this.comObj,
                r = this,
                o = this.actionHandler[t.action],
                d = {
                  enqueue(t, r = 1, o) {
                    if (this.isCancelled) return
                    const l = this.desiredSize
                    this.desiredSize -= r
                    if (l > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = new s.PromiseCapability()
                      this.ready = this.sinkCapability.promise
                    }
                    a.postMessage({ sourceName: i, targetName: n, stream: h, streamId: e, chunk: t }, o)
                  },
                  close() {
                    if (!this.isCancelled) {
                      this.isCancelled = !0
                      a.postMessage({ sourceName: i, targetName: n, stream: l, streamId: e })
                      delete r.streamSinks[e]
                    }
                  },
                  error(t) {
                    ;(0, s.assert)(t instanceof Error, 'error must have a valid reason')
                    if (!this.isCancelled) {
                      this.isCancelled = !0
                      a.postMessage({ sourceName: i, targetName: n, stream: c, streamId: e, reason: wrapReason(t) })
                    }
                  },
                  sinkCapability: new s.PromiseCapability(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: !1,
                  desiredSize: t.desiredSize,
                  ready: null,
                }
              d.sinkCapability.resolve()
              d.ready = d.sinkCapability.promise
              this.streamSinks[e] = d
              new Promise(function (e) {
                e(o(t.data, d))
              }).then(
                function () {
                  a.postMessage({ sourceName: i, targetName: n, stream: p, streamId: e, success: !0 })
                },
                function (t) {
                  a.postMessage({ sourceName: i, targetName: n, stream: p, streamId: e, reason: wrapReason(t) })
                }
              )
            }
            #de(t) {
              const e = t.streamId,
                i = this.sourceName,
                n = t.sourceName,
                a = this.comObj,
                g = this.streamControllers[e],
                m = this.streamSinks[e]
              switch (t.stream) {
                case p:
                  t.success ? g.startCall.resolve() : g.startCall.reject(wrapReason(t.reason))
                  break
                case u:
                  t.success ? g.pullCall.resolve() : g.pullCall.reject(wrapReason(t.reason))
                  break
                case d:
                  if (!m) {
                    a.postMessage({ sourceName: i, targetName: n, stream: u, streamId: e, success: !0 })
                    break
                  }
                  m.desiredSize <= 0 && t.desiredSize > 0 && m.sinkCapability.resolve()
                  m.desiredSize = t.desiredSize
                  new Promise(function (t) {
                    t(m.onPull?.())
                  }).then(
                    function () {
                      a.postMessage({ sourceName: i, targetName: n, stream: u, streamId: e, success: !0 })
                    },
                    function (t) {
                      a.postMessage({ sourceName: i, targetName: n, stream: u, streamId: e, reason: wrapReason(t) })
                    }
                  )
                  break
                case h:
                  ;(0, s.assert)(g, 'enqueue should have stream controller')
                  if (g.isClosed) break
                  g.controller.enqueue(t.chunk)
                  break
                case l:
                  ;(0, s.assert)(g, 'close should have stream controller')
                  if (g.isClosed) break
                  g.isClosed = !0
                  g.controller.close()
                  this.#pe(g, e)
                  break
                case c:
                  ;(0, s.assert)(g, 'error should have stream controller')
                  g.controller.error(wrapReason(t.reason))
                  this.#pe(g, e)
                  break
                case o:
                  t.success ? g.cancelCall.resolve() : g.cancelCall.reject(wrapReason(t.reason))
                  this.#pe(g, e)
                  break
                case r:
                  if (!m) break
                  new Promise(function (e) {
                    e(m.onCancel?.(wrapReason(t.reason)))
                  }).then(
                    function () {
                      a.postMessage({ sourceName: i, targetName: n, stream: o, streamId: e, success: !0 })
                    },
                    function (t) {
                      a.postMessage({ sourceName: i, targetName: n, stream: o, streamId: e, reason: wrapReason(t) })
                    }
                  )
                  m.sinkCapability.reject(wrapReason(t.reason))
                  m.isCancelled = !0
                  delete this.streamSinks[e]
                  break
                default:
                  throw new Error('Unexpected stream case')
              }
            }
            async #pe(t, e) {
              await Promise.allSettled([t.startCall?.promise, t.pullCall?.promise, t.cancelCall?.promise])
              delete this.streamControllers[e]
            }
            destroy() {
              this.comObj.removeEventListener('message', this._onComObjOnMessage)
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.Metadata = void 0
          var s = i(1)
          e.Metadata = class Metadata {
            #ge
            #me
            constructor({ parsedData: t, rawData: e }) {
              this.#ge = t
              this.#me = e
            }
            getRaw() {
              return this.#me
            }
            get(t) {
              return this.#ge.get(t) ?? null
            }
            getAll() {
              return (0, s.objectFromMap)(this.#ge)
            }
            has(t) {
              return this.#ge.has(t)
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.OptionalContentConfig = void 0
          var s = i(1),
            n = i(8)
          const a = Symbol('INTERNAL')
          class OptionalContentGroup {
            #fe = !0
            constructor(t, e) {
              this.name = t
              this.intent = e
            }
            get visible() {
              return this.#fe
            }
            _setVisible(t, e) {
              t !== a && (0, s.unreachable)('Internal method `_setVisible` called.')
              this.#fe = e
            }
          }
          e.OptionalContentConfig = class OptionalContentConfig {
            #be = null
            #Ae = new Map()
            #_e = null
            #ve = null
            constructor(t) {
              this.name = null
              this.creator = null
              if (null !== t) {
                this.name = t.name
                this.creator = t.creator
                this.#ve = t.order
                for (const e of t.groups) this.#Ae.set(e.id, new OptionalContentGroup(e.name, e.intent))
                if ('OFF' === t.baseState) for (const t of this.#Ae.values()) t._setVisible(a, !1)
                for (const e of t.on) this.#Ae.get(e)._setVisible(a, !0)
                for (const e of t.off) this.#Ae.get(e)._setVisible(a, !1)
                this.#_e = this.getHash()
              }
            }
            #ye(t) {
              const e = t.length
              if (e < 2) return !0
              const i = t[0]
              for (let n = 1; n < e; n++) {
                const e = t[n]
                let a
                if (Array.isArray(e)) a = this.#ye(e)
                else {
                  if (!this.#Ae.has(e)) {
                    ;(0, s.warn)(`Optional content group not found: ${e}`)
                    return !0
                  }
                  a = this.#Ae.get(e).visible
                }
                switch (i) {
                  case 'And':
                    if (!a) return !1
                    break
                  case 'Or':
                    if (a) return !0
                    break
                  case 'Not':
                    return !a
                  default:
                    return !0
                }
              }
              return 'And' === i
            }
            isVisible(t) {
              if (0 === this.#Ae.size) return !0
              if (!t) {
                ;(0, s.warn)('Optional content group not defined.')
                return !0
              }
              if ('OCG' === t.type) {
                if (!this.#Ae.has(t.id)) {
                  ;(0, s.warn)(`Optional content group not found: ${t.id}`)
                  return !0
                }
                return this.#Ae.get(t.id).visible
              }
              if ('OCMD' === t.type) {
                if (t.expression) return this.#ye(t.expression)
                if (!t.policy || 'AnyOn' === t.policy) {
                  for (const e of t.ids) {
                    if (!this.#Ae.has(e)) {
                      ;(0, s.warn)(`Optional content group not found: ${e}`)
                      return !0
                    }
                    if (this.#Ae.get(e).visible) return !0
                  }
                  return !1
                }
                if ('AllOn' === t.policy) {
                  for (const e of t.ids) {
                    if (!this.#Ae.has(e)) {
                      ;(0, s.warn)(`Optional content group not found: ${e}`)
                      return !0
                    }
                    if (!this.#Ae.get(e).visible) return !1
                  }
                  return !0
                }
                if ('AnyOff' === t.policy) {
                  for (const e of t.ids) {
                    if (!this.#Ae.has(e)) {
                      ;(0, s.warn)(`Optional content group not found: ${e}`)
                      return !0
                    }
                    if (!this.#Ae.get(e).visible) return !0
                  }
                  return !1
                }
                if ('AllOff' === t.policy) {
                  for (const e of t.ids) {
                    if (!this.#Ae.has(e)) {
                      ;(0, s.warn)(`Optional content group not found: ${e}`)
                      return !0
                    }
                    if (this.#Ae.get(e).visible) return !1
                  }
                  return !0
                }
                ;(0, s.warn)(`Unknown optional content policy ${t.policy}.`)
                return !0
              }
              ;(0, s.warn)(`Unknown group type ${t.type}.`)
              return !0
            }
            setVisibility(t, e = !0) {
              if (this.#Ae.has(t)) {
                this.#Ae.get(t)._setVisible(a, !!e)
                this.#be = null
              } else (0, s.warn)(`Optional content group not found: ${t}`)
            }
            get hasInitialVisibility() {
              return null === this.#_e || this.getHash() === this.#_e
            }
            getOrder() {
              return this.#Ae.size ? (this.#ve ? this.#ve.slice() : [...this.#Ae.keys()]) : null
            }
            getGroups() {
              return this.#Ae.size > 0 ? (0, s.objectFromMap)(this.#Ae) : null
            }
            getGroup(t) {
              return this.#Ae.get(t) || null
            }
            getHash() {
              if (null !== this.#be) return this.#be
              const t = new n.MurmurHash3_64()
              for (const [e, i] of this.#Ae) t.update(`${e}:${i.visible}`)
              return (this.#be = t.hexdigest())
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.PDFDataTransportStream = void 0
          var s = i(1),
            n = i(6)
          e.PDFDataTransportStream = class PDFDataTransportStream {
            constructor({ length: t, initialData: e, progressiveDone: i = !1, contentDispositionFilename: n = null, disableRange: a = !1, disableStream: r = !1 }, o) {
              ;(0, s.assert)(o, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.')
              this._queuedChunks = []
              this._progressiveDone = i
              this._contentDispositionFilename = n
              if (e?.length > 0) {
                const t = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer
                this._queuedChunks.push(t)
              }
              this._pdfDataRangeTransport = o
              this._isStreamingSupported = !r
              this._isRangeSupported = !a
              this._contentLength = t
              this._fullRequestReader = null
              this._rangeReaders = []
              this._pdfDataRangeTransport.addRangeListener((t, e) => {
                this._onReceiveData({ begin: t, chunk: e })
              })
              this._pdfDataRangeTransport.addProgressListener((t, e) => {
                this._onProgress({ loaded: t, total: e })
              })
              this._pdfDataRangeTransport.addProgressiveReadListener((t) => {
                this._onReceiveData({ chunk: t })
              })
              this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone()
              })
              this._pdfDataRangeTransport.transportReady()
            }
            _onReceiveData({ begin: t, chunk: e }) {
              const i = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer
              if (void 0 === t) this._fullRequestReader ? this._fullRequestReader._enqueue(i) : this._queuedChunks.push(i)
              else {
                const e = this._rangeReaders.some(function (e) {
                  if (e._begin !== t) return !1
                  e._enqueue(i)
                  return !0
                })
                ;(0, s.assert)(e, '_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.')
              }
            }
            get _progressiveDataLength() {
              return this._fullRequestReader?._loaded ?? 0
            }
            _onProgress(t) {
              void 0 === t.total ? this._rangeReaders[0]?.onProgress?.({ loaded: t.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: t.loaded, total: t.total })
            }
            _onProgressiveDone() {
              this._fullRequestReader?.progressiveDone()
              this._progressiveDone = !0
            }
            _removeRangeReader(t) {
              const e = this._rangeReaders.indexOf(t)
              e >= 0 && this._rangeReaders.splice(e, 1)
            }
            getFullReader() {
              ;(0, s.assert)(!this._fullRequestReader, 'PDFDataTransportStream.getFullReader can only be called once.')
              const t = this._queuedChunks
              this._queuedChunks = null
              return new PDFDataTransportStreamReader(this, t, this._progressiveDone, this._contentDispositionFilename)
            }
            getRangeReader(t, e) {
              if (e <= this._progressiveDataLength) return null
              const i = new PDFDataTransportStreamRangeReader(this, t, e)
              this._pdfDataRangeTransport.requestDataRange(t, e)
              this._rangeReaders.push(i)
              return i
            }
            cancelAllRequests(t) {
              this._fullRequestReader?.cancel(t)
              for (const e of this._rangeReaders.slice(0)) e.cancel(t)
              this._pdfDataRangeTransport.abort()
            }
          }
          class PDFDataTransportStreamReader {
            constructor(t, e, i = !1, s = null) {
              this._stream = t
              this._done = i || !1
              this._filename = (0, n.isPdfFile)(s) ? s : null
              this._queuedChunks = e || []
              this._loaded = 0
              for (const t of this._queuedChunks) this._loaded += t.byteLength
              this._requests = []
              this._headersReady = Promise.resolve()
              t._fullRequestReader = this
              this.onProgress = null
            }
            _enqueue(t) {
              if (!this._done) {
                if (this._requests.length > 0) {
                  this._requests.shift().resolve({ value: t, done: !1 })
                } else this._queuedChunks.push(t)
                this._loaded += t.byteLength
              }
            }
            get headersReady() {
              return this._headersReady
            }
            get filename() {
              return this._filename
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported
            }
            get contentLength() {
              return this._stream._contentLength
            }
            async read() {
              if (this._queuedChunks.length > 0) {
                return { value: this._queuedChunks.shift(), done: !1 }
              }
              if (this._done) return { value: void 0, done: !0 }
              const t = new s.PromiseCapability()
              this._requests.push(t)
              return t.promise
            }
            cancel(t) {
              this._done = !0
              for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
            }
            progressiveDone() {
              this._done || (this._done = !0)
            }
          }
          class PDFDataTransportStreamRangeReader {
            constructor(t, e, i) {
              this._stream = t
              this._begin = e
              this._end = i
              this._queuedChunk = null
              this._requests = []
              this._done = !1
              this.onProgress = null
            }
            _enqueue(t) {
              if (!this._done) {
                if (0 === this._requests.length) this._queuedChunk = t
                else {
                  this._requests.shift().resolve({ value: t, done: !1 })
                  for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
                  this._requests.length = 0
                }
                this._done = !0
                this._stream._removeRangeReader(this)
              }
            }
            get isStreamingSupported() {
              return !1
            }
            async read() {
              if (this._queuedChunk) {
                const t = this._queuedChunk
                this._queuedChunk = null
                return { value: t, done: !1 }
              }
              if (this._done) return { value: void 0, done: !0 }
              const t = new s.PromiseCapability()
              this._requests.push(t)
              return t.promise
            }
            cancel(t) {
              this._done = !0
              for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
              this._stream._removeRangeReader(this)
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.PDFFetchStream = void 0
          var s = i(1),
            n = i(20)
          function createFetchOptions(t, e, i) {
            return { method: 'GET', headers: t, signal: i.signal, mode: 'cors', credentials: e ? 'include' : 'same-origin', redirect: 'follow' }
          }
          function createHeaders(t) {
            const e = new Headers()
            for (const i in t) {
              const s = t[i]
              void 0 !== s && e.append(i, s)
            }
            return e
          }
          function getArrayBuffer(t) {
            if (t instanceof Uint8Array) return t.buffer
            if (t instanceof ArrayBuffer) return t
            ;(0, s.warn)(`getArrayBuffer - unexpected data format: ${t}`)
            return new Uint8Array(t).buffer
          }
          e.PDFFetchStream = class PDFFetchStream {
            constructor(t) {
              this.source = t
              this.isHttp = /^https?:/i.test(t.url)
              this.httpHeaders = (this.isHttp && t.httpHeaders) || {}
              this._fullRequestReader = null
              this._rangeRequestReaders = []
            }
            get _progressiveDataLength() {
              return this._fullRequestReader?._loaded ?? 0
            }
            getFullReader() {
              ;(0, s.assert)(!this._fullRequestReader, 'PDFFetchStream.getFullReader can only be called once.')
              this._fullRequestReader = new PDFFetchStreamReader(this)
              return this._fullRequestReader
            }
            getRangeReader(t, e) {
              if (e <= this._progressiveDataLength) return null
              const i = new PDFFetchStreamRangeReader(this, t, e)
              this._rangeRequestReaders.push(i)
              return i
            }
            cancelAllRequests(t) {
              this._fullRequestReader?.cancel(t)
              for (const e of this._rangeRequestReaders.slice(0)) e.cancel(t)
            }
          }
          class PDFFetchStreamReader {
            constructor(t) {
              this._stream = t
              this._reader = null
              this._loaded = 0
              this._filename = null
              const e = t.source
              this._withCredentials = e.withCredentials || !1
              this._contentLength = e.length
              this._headersCapability = new s.PromiseCapability()
              this._disableRange = e.disableRange || !1
              this._rangeChunkSize = e.rangeChunkSize
              this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
              this._abortController = new AbortController()
              this._isStreamingSupported = !e.disableStream
              this._isRangeSupported = !e.disableRange
              this._headers = createHeaders(this._stream.httpHeaders)
              const i = e.url
              fetch(i, createFetchOptions(this._headers, this._withCredentials, this._abortController))
                .then((t) => {
                  if (!(0, n.validateResponseStatus)(t.status)) throw (0, n.createResponseStatusError)(t.status, i)
                  this._reader = t.body.getReader()
                  this._headersCapability.resolve()
                  const getResponseHeader = (e) => t.headers.get(e),
                    { allowRangeRequests: e, suggestedLength: a } = (0, n.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange })
                  this._isRangeSupported = e
                  this._contentLength = a || this._contentLength
                  this._filename = (0, n.extractFilenameFromHeader)(getResponseHeader)
                  !this._isStreamingSupported && this._isRangeSupported && this.cancel(new s.AbortException('Streaming is disabled.'))
                })
                .catch(this._headersCapability.reject)
              this.onProgress = null
            }
            get headersReady() {
              return this._headersCapability.promise
            }
            get filename() {
              return this._filename
            }
            get contentLength() {
              return this._contentLength
            }
            get isRangeSupported() {
              return this._isRangeSupported
            }
            get isStreamingSupported() {
              return this._isStreamingSupported
            }
            async read() {
              await this._headersCapability.promise
              const { value: t, done: e } = await this._reader.read()
              if (e) return { value: t, done: e }
              this._loaded += t.byteLength
              this.onProgress?.({ loaded: this._loaded, total: this._contentLength })
              return { value: getArrayBuffer(t), done: !1 }
            }
            cancel(t) {
              this._reader?.cancel(t)
              this._abortController.abort()
            }
          }
          class PDFFetchStreamRangeReader {
            constructor(t, e, i) {
              this._stream = t
              this._reader = null
              this._loaded = 0
              const a = t.source
              this._withCredentials = a.withCredentials || !1
              this._readCapability = new s.PromiseCapability()
              this._isStreamingSupported = !a.disableStream
              this._abortController = new AbortController()
              this._headers = createHeaders(this._stream.httpHeaders)
              this._headers.append('Range', `bytes=${e}-${i - 1}`)
              const r = a.url
              fetch(r, createFetchOptions(this._headers, this._withCredentials, this._abortController))
                .then((t) => {
                  if (!(0, n.validateResponseStatus)(t.status)) throw (0, n.createResponseStatusError)(t.status, r)
                  this._readCapability.resolve()
                  this._reader = t.body.getReader()
                })
                .catch(this._readCapability.reject)
              this.onProgress = null
            }
            get isStreamingSupported() {
              return this._isStreamingSupported
            }
            async read() {
              await this._readCapability.promise
              const { value: t, done: e } = await this._reader.read()
              if (e) return { value: t, done: e }
              this._loaded += t.byteLength
              this.onProgress?.({ loaded: this._loaded })
              return { value: getArrayBuffer(t), done: !1 }
            }
            cancel(t) {
              this._reader?.cancel(t)
              this._abortController.abort()
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.createResponseStatusError = function createResponseStatusError(t, e) {
            if (404 === t || (0 === t && e.startsWith('file:'))) return new s.MissingPDFException('Missing PDF "' + e + '".')
            return new s.UnexpectedResponseException(`Unexpected server response (${t}) while retrieving PDF "${e}".`, t)
          }
          e.extractFilenameFromHeader = function extractFilenameFromHeader(t) {
            const e = t('Content-Disposition')
            if (e) {
              let t = (0, n.getFilenameFromContentDispositionHeader)(e)
              if (t.includes('%'))
                try {
                  t = decodeURIComponent(t)
                } catch {}
              if ((0, a.isPdfFile)(t)) return t
            }
            return null
          }
          e.validateRangeRequestCapabilities = function validateRangeRequestCapabilities({ getResponseHeader: t, isHttp: e, rangeChunkSize: i, disableRange: s }) {
            const n = { allowRangeRequests: !1, suggestedLength: void 0 },
              a = parseInt(t('Content-Length'), 10)
            if (!Number.isInteger(a)) return n
            n.suggestedLength = a
            if (a <= 2 * i) return n
            if (s || !e) return n
            if ('bytes' !== t('Accept-Ranges')) return n
            if ('identity' !== (t('Content-Encoding') || 'identity')) return n
            n.allowRangeRequests = !0
            return n
          }
          e.validateResponseStatus = function validateResponseStatus(t) {
            return 200 === t || 206 === t
          }
          var s = i(1),
            n = i(21),
            a = i(6)
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.getFilenameFromContentDispositionHeader = function getFilenameFromContentDispositionHeader(t) {
            let e = !0,
              i = toParamRegExp('filename\\*', 'i').exec(t)
            if (i) {
              i = i[1]
              let t = rfc2616unquote(i)
              t = unescape(t)
              t = rfc5987decode(t)
              t = rfc2047decode(t)
              return fixupEncoding(t)
            }
            i = (function rfc2231getparam(t) {
              const e = []
              let i
              const s = toParamRegExp('filename\\*((?!0\\d)\\d+)(\\*?)', 'ig')
              for (; null !== (i = s.exec(t)); ) {
                let [, t, s, n] = i
                t = parseInt(t, 10)
                if (t in e) {
                  if (0 === t) break
                } else e[t] = [s, n]
              }
              const n = []
              for (let t = 0; t < e.length && t in e; ++t) {
                let [i, s] = e[t]
                s = rfc2616unquote(s)
                if (i) {
                  s = unescape(s)
                  0 === t && (s = rfc5987decode(s))
                }
                n.push(s)
              }
              return n.join('')
            })(t)
            if (i) {
              return fixupEncoding(rfc2047decode(i))
            }
            i = toParamRegExp('filename', 'i').exec(t)
            if (i) {
              i = i[1]
              let t = rfc2616unquote(i)
              t = rfc2047decode(t)
              return fixupEncoding(t)
            }
            function toParamRegExp(t, e) {
              return new RegExp('(?:^|;)\\s*' + t + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', e)
            }
            function textdecode(t, i) {
              if (t) {
                if (!/^[\x00-\xFF]+$/.test(i)) return i
                try {
                  const n = new TextDecoder(t, { fatal: !0 }),
                    a = (0, s.stringToBytes)(i)
                  i = n.decode(a)
                  e = !1
                } catch {}
              }
              return i
            }
            function fixupEncoding(t) {
              if (e && /[\x80-\xff]/.test(t)) {
                t = textdecode('utf-8', t)
                e && (t = textdecode('iso-8859-1', t))
              }
              return t
            }
            function rfc2616unquote(t) {
              if (t.startsWith('"')) {
                const e = t.slice(1).split('\\"')
                for (let t = 0; t < e.length; ++t) {
                  const i = e[t].indexOf('"')
                  if (-1 !== i) {
                    e[t] = e[t].slice(0, i)
                    e.length = t + 1
                  }
                  e[t] = e[t].replaceAll(/\\(.)/g, '$1')
                }
                t = e.join('"')
              }
              return t
            }
            function rfc5987decode(t) {
              const e = t.indexOf("'")
              if (-1 === e) return t
              return textdecode(t.slice(0, e), t.slice(e + 1).replace(/^[^']*'/, ''))
            }
            function rfc2047decode(t) {
              return !t.startsWith('=?') || /[\x00-\x19\x80-\xff]/.test(t)
                ? t
                : t.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (t, e, i, s) {
                    if ('q' === i || 'Q' === i)
                      return textdecode(
                        e,
                        (s = (s = s.replaceAll('_', ' ')).replaceAll(/=([0-9a-fA-F]{2})/g, function (t, e) {
                          return String.fromCharCode(parseInt(e, 16))
                        }))
                      )
                    try {
                      s = atob(s)
                    } catch {}
                    return textdecode(e, s)
                  })
            }
            return ''
          }
          var s = i(1)
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.PDFNetworkStream = void 0
          var s = i(1),
            n = i(20)
          class NetworkManager {
            constructor(t, e = {}) {
              this.url = t
              this.isHttp = /^https?:/i.test(t)
              this.httpHeaders = (this.isHttp && e.httpHeaders) || Object.create(null)
              this.withCredentials = e.withCredentials || !1
              this.currXhrId = 0
              this.pendingRequests = Object.create(null)
            }
            requestRange(t, e, i) {
              const s = { begin: t, end: e }
              for (const t in i) s[t] = i[t]
              return this.request(s)
            }
            requestFull(t) {
              return this.request(t)
            }
            request(t) {
              const e = new XMLHttpRequest(),
                i = this.currXhrId++,
                s = (this.pendingRequests[i] = { xhr: e })
              e.open('GET', this.url)
              e.withCredentials = this.withCredentials
              for (const t in this.httpHeaders) {
                const i = this.httpHeaders[t]
                void 0 !== i && e.setRequestHeader(t, i)
              }
              if (this.isHttp && 'begin' in t && 'end' in t) {
                e.setRequestHeader('Range', `bytes=${t.begin}-${t.end - 1}`)
                s.expectedStatus = 206
              } else s.expectedStatus = 200
              e.responseType = 'arraybuffer'
              t.onError &&
                (e.onerror = function (i) {
                  t.onError(e.status)
                })
              e.onreadystatechange = this.onStateChange.bind(this, i)
              e.onprogress = this.onProgress.bind(this, i)
              s.onHeadersReceived = t.onHeadersReceived
              s.onDone = t.onDone
              s.onError = t.onError
              s.onProgress = t.onProgress
              e.send(null)
              return i
            }
            onProgress(t, e) {
              const i = this.pendingRequests[t]
              i && i.onProgress?.(e)
            }
            onStateChange(t, e) {
              const i = this.pendingRequests[t]
              if (!i) return
              const n = i.xhr
              if (n.readyState >= 2 && i.onHeadersReceived) {
                i.onHeadersReceived()
                delete i.onHeadersReceived
              }
              if (4 !== n.readyState) return
              if (!(t in this.pendingRequests)) return
              delete this.pendingRequests[t]
              if (0 === n.status && this.isHttp) {
                i.onError?.(n.status)
                return
              }
              const a = n.status || 200
              if (!(200 === a && 206 === i.expectedStatus) && a !== i.expectedStatus) {
                i.onError?.(n.status)
                return
              }
              const r = (function getArrayBuffer(t) {
                const e = t.response
                return 'string' != typeof e ? e : (0, s.stringToBytes)(e).buffer
              })(n)
              if (206 === a) {
                const t = n.getResponseHeader('Content-Range'),
                  e = /bytes (\d+)-(\d+)\/(\d+)/.exec(t)
                i.onDone({ begin: parseInt(e[1], 10), chunk: r })
              } else r ? i.onDone({ begin: 0, chunk: r }) : i.onError?.(n.status)
            }
            getRequestXhr(t) {
              return this.pendingRequests[t].xhr
            }
            isPendingRequest(t) {
              return t in this.pendingRequests
            }
            abortRequest(t) {
              const e = this.pendingRequests[t].xhr
              delete this.pendingRequests[t]
              e.abort()
            }
          }
          e.PDFNetworkStream = class PDFNetworkStream {
            constructor(t) {
              this._source = t
              this._manager = new NetworkManager(t.url, { httpHeaders: t.httpHeaders, withCredentials: t.withCredentials })
              this._rangeChunkSize = t.rangeChunkSize
              this._fullRequestReader = null
              this._rangeRequestReaders = []
            }
            _onRangeRequestReaderClosed(t) {
              const e = this._rangeRequestReaders.indexOf(t)
              e >= 0 && this._rangeRequestReaders.splice(e, 1)
            }
            getFullReader() {
              ;(0, s.assert)(!this._fullRequestReader, 'PDFNetworkStream.getFullReader can only be called once.')
              this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source)
              return this._fullRequestReader
            }
            getRangeReader(t, e) {
              const i = new PDFNetworkStreamRangeRequestReader(this._manager, t, e)
              i.onClosed = this._onRangeRequestReaderClosed.bind(this)
              this._rangeRequestReaders.push(i)
              return i
            }
            cancelAllRequests(t) {
              this._fullRequestReader?.cancel(t)
              for (const e of this._rangeRequestReaders.slice(0)) e.cancel(t)
            }
          }
          class PDFNetworkStreamFullRequestReader {
            constructor(t, e) {
              this._manager = t
              const i = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }
              this._url = e.url
              this._fullRequestId = t.requestFull(i)
              this._headersReceivedCapability = new s.PromiseCapability()
              this._disableRange = e.disableRange || !1
              this._contentLength = e.length
              this._rangeChunkSize = e.rangeChunkSize
              this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
              this._isStreamingSupported = !1
              this._isRangeSupported = !1
              this._cachedChunks = []
              this._requests = []
              this._done = !1
              this._storedError = void 0
              this._filename = null
              this.onProgress = null
            }
            _onHeadersReceived() {
              const t = this._fullRequestId,
                e = this._manager.getRequestXhr(t),
                getResponseHeader = (t) => e.getResponseHeader(t),
                { allowRangeRequests: i, suggestedLength: s } = (0, n.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange })
              i && (this._isRangeSupported = !0)
              this._contentLength = s || this._contentLength
              this._filename = (0, n.extractFilenameFromHeader)(getResponseHeader)
              this._isRangeSupported && this._manager.abortRequest(t)
              this._headersReceivedCapability.resolve()
            }
            _onDone(t) {
              if (t)
                if (this._requests.length > 0) {
                  this._requests.shift().resolve({ value: t.chunk, done: !1 })
                } else this._cachedChunks.push(t.chunk)
              this._done = !0
              if (!(this._cachedChunks.length > 0)) {
                for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
                this._requests.length = 0
              }
            }
            _onError(t) {
              this._storedError = (0, n.createResponseStatusError)(t, this._url)
              this._headersReceivedCapability.reject(this._storedError)
              for (const t of this._requests) t.reject(this._storedError)
              this._requests.length = 0
              this._cachedChunks.length = 0
            }
            _onProgress(t) {
              this.onProgress?.({ loaded: t.loaded, total: t.lengthComputable ? t.total : this._contentLength })
            }
            get filename() {
              return this._filename
            }
            get isRangeSupported() {
              return this._isRangeSupported
            }
            get isStreamingSupported() {
              return this._isStreamingSupported
            }
            get contentLength() {
              return this._contentLength
            }
            get headersReady() {
              return this._headersReceivedCapability.promise
            }
            async read() {
              if (this._storedError) throw this._storedError
              if (this._cachedChunks.length > 0) {
                return { value: this._cachedChunks.shift(), done: !1 }
              }
              if (this._done) return { value: void 0, done: !0 }
              const t = new s.PromiseCapability()
              this._requests.push(t)
              return t.promise
            }
            cancel(t) {
              this._done = !0
              this._headersReceivedCapability.reject(t)
              for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
              this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId)
              this._fullRequestReader = null
            }
          }
          class PDFNetworkStreamRangeRequestReader {
            constructor(t, e, i) {
              this._manager = t
              const s = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }
              this._url = t.url
              this._requestId = t.requestRange(e, i, s)
              this._requests = []
              this._queuedChunk = null
              this._done = !1
              this._storedError = void 0
              this.onProgress = null
              this.onClosed = null
            }
            _close() {
              this.onClosed?.(this)
            }
            _onDone(t) {
              const e = t.chunk
              if (this._requests.length > 0) {
                this._requests.shift().resolve({ value: e, done: !1 })
              } else this._queuedChunk = e
              this._done = !0
              for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
              this._close()
            }
            _onError(t) {
              this._storedError = (0, n.createResponseStatusError)(t, this._url)
              for (const t of this._requests) t.reject(this._storedError)
              this._requests.length = 0
              this._queuedChunk = null
            }
            _onProgress(t) {
              this.isStreamingSupported || this.onProgress?.({ loaded: t.loaded })
            }
            get isStreamingSupported() {
              return !1
            }
            async read() {
              if (this._storedError) throw this._storedError
              if (null !== this._queuedChunk) {
                const t = this._queuedChunk
                this._queuedChunk = null
                return { value: t, done: !1 }
              }
              if (this._done) return { value: void 0, done: !0 }
              const t = new s.PromiseCapability()
              this._requests.push(t)
              return t.promise
            }
            cancel(t) {
              this._done = !0
              for (const t of this._requests) t.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
              this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId)
              this._close()
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.PDFNodeStream = void 0
          var s = i(1),
            n = i(20)
          const a = /^file:\/\/\/[a-zA-Z]:\//
          e.PDFNodeStream = class PDFNodeStream {
            constructor(t) {
              this.source = t
              this.url = (function parseUrl(t) {
                const e = require('url'),
                  i = e.parse(t)
                if ('file:' === i.protocol || i.host) return i
                if (/^[a-z]:[/\\]/i.test(t)) return e.parse(`file:///${t}`)
                i.host || (i.protocol = 'file:')
                return i
              })(t.url)
              this.isHttp = 'http:' === this.url.protocol || 'https:' === this.url.protocol
              this.isFsUrl = 'file:' === this.url.protocol
              this.httpHeaders = (this.isHttp && t.httpHeaders) || {}
              this._fullRequestReader = null
              this._rangeRequestReaders = []
            }
            get _progressiveDataLength() {
              return this._fullRequestReader?._loaded ?? 0
            }
            getFullReader() {
              ;(0, s.assert)(!this._fullRequestReader, 'PDFNodeStream.getFullReader can only be called once.')
              this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this)
              return this._fullRequestReader
            }
            getRangeReader(t, e) {
              if (e <= this._progressiveDataLength) return null
              const i = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, t, e) : new PDFNodeStreamRangeReader(this, t, e)
              this._rangeRequestReaders.push(i)
              return i
            }
            cancelAllRequests(t) {
              this._fullRequestReader?.cancel(t)
              for (const e of this._rangeRequestReaders.slice(0)) e.cancel(t)
            }
          }
          class BaseFullReader {
            constructor(t) {
              this._url = t.url
              this._done = !1
              this._storedError = null
              this.onProgress = null
              const e = t.source
              this._contentLength = e.length
              this._loaded = 0
              this._filename = null
              this._disableRange = e.disableRange || !1
              this._rangeChunkSize = e.rangeChunkSize
              this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
              this._isStreamingSupported = !e.disableStream
              this._isRangeSupported = !e.disableRange
              this._readableStream = null
              this._readCapability = new s.PromiseCapability()
              this._headersCapability = new s.PromiseCapability()
            }
            get headersReady() {
              return this._headersCapability.promise
            }
            get filename() {
              return this._filename
            }
            get contentLength() {
              return this._contentLength
            }
            get isRangeSupported() {
              return this._isRangeSupported
            }
            get isStreamingSupported() {
              return this._isStreamingSupported
            }
            async read() {
              await this._readCapability.promise
              if (this._done) return { value: void 0, done: !0 }
              if (this._storedError) throw this._storedError
              const t = this._readableStream.read()
              if (null === t) {
                this._readCapability = new s.PromiseCapability()
                return this.read()
              }
              this._loaded += t.length
              this.onProgress?.({ loaded: this._loaded, total: this._contentLength })
              return { value: new Uint8Array(t).buffer, done: !1 }
            }
            cancel(t) {
              this._readableStream ? this._readableStream.destroy(t) : this._error(t)
            }
            _error(t) {
              this._storedError = t
              this._readCapability.resolve()
            }
            _setReadableStream(t) {
              this._readableStream = t
              t.on('readable', () => {
                this._readCapability.resolve()
              })
              t.on('end', () => {
                t.destroy()
                this._done = !0
                this._readCapability.resolve()
              })
              t.on('error', (t) => {
                this._error(t)
              })
              !this._isStreamingSupported && this._isRangeSupported && this._error(new s.AbortException('streaming is disabled'))
              this._storedError && this._readableStream.destroy(this._storedError)
            }
          }
          class BaseRangeReader {
            constructor(t) {
              this._url = t.url
              this._done = !1
              this._storedError = null
              this.onProgress = null
              this._loaded = 0
              this._readableStream = null
              this._readCapability = new s.PromiseCapability()
              const e = t.source
              this._isStreamingSupported = !e.disableStream
            }
            get isStreamingSupported() {
              return this._isStreamingSupported
            }
            async read() {
              await this._readCapability.promise
              if (this._done) return { value: void 0, done: !0 }
              if (this._storedError) throw this._storedError
              const t = this._readableStream.read()
              if (null === t) {
                this._readCapability = new s.PromiseCapability()
                return this.read()
              }
              this._loaded += t.length
              this.onProgress?.({ loaded: this._loaded })
              return { value: new Uint8Array(t).buffer, done: !1 }
            }
            cancel(t) {
              this._readableStream ? this._readableStream.destroy(t) : this._error(t)
            }
            _error(t) {
              this._storedError = t
              this._readCapability.resolve()
            }
            _setReadableStream(t) {
              this._readableStream = t
              t.on('readable', () => {
                this._readCapability.resolve()
              })
              t.on('end', () => {
                t.destroy()
                this._done = !0
                this._readCapability.resolve()
              })
              t.on('error', (t) => {
                this._error(t)
              })
              this._storedError && this._readableStream.destroy(this._storedError)
            }
          }
          function createRequestOptions(t, e) {
            return { protocol: t.protocol, auth: t.auth, host: t.hostname, port: t.port, path: t.path, method: 'GET', headers: e }
          }
          class PDFNodeStreamFullReader extends BaseFullReader {
            constructor(t) {
              super(t)
              const handleResponse = (e) => {
                if (404 === e.statusCode) {
                  const t = new s.MissingPDFException(`Missing PDF "${this._url}".`)
                  this._storedError = t
                  this._headersCapability.reject(t)
                  return
                }
                this._headersCapability.resolve()
                this._setReadableStream(e)
                const getResponseHeader = (t) => this._readableStream.headers[t.toLowerCase()],
                  { allowRangeRequests: i, suggestedLength: a } = (0, n.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: t.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange })
                this._isRangeSupported = i
                this._contentLength = a || this._contentLength
                this._filename = (0, n.extractFilenameFromHeader)(getResponseHeader)
              }
              this._request = null
              if ('http:' === this._url.protocol) {
                const e = require('http')
                this._request = e.request(createRequestOptions(this._url, t.httpHeaders), handleResponse)
              } else {
                const e = require('https')
                this._request = e.request(createRequestOptions(this._url, t.httpHeaders), handleResponse)
              }
              this._request.on('error', (t) => {
                this._storedError = t
                this._headersCapability.reject(t)
              })
              this._request.end()
            }
          }
          class PDFNodeStreamRangeReader extends BaseRangeReader {
            constructor(t, e, i) {
              super(t)
              this._httpHeaders = {}
              for (const e in t.httpHeaders) {
                const i = t.httpHeaders[e]
                void 0 !== i && (this._httpHeaders[e] = i)
              }
              this._httpHeaders.Range = `bytes=${e}-${i - 1}`
              const handleResponse = (t) => {
                if (404 !== t.statusCode) this._setReadableStream(t)
                else {
                  const t = new s.MissingPDFException(`Missing PDF "${this._url}".`)
                  this._storedError = t
                }
              }
              this._request = null
              if ('http:' === this._url.protocol) {
                const t = require('http')
                this._request = t.request(createRequestOptions(this._url, this._httpHeaders), handleResponse)
              } else {
                const t = require('https')
                this._request = t.request(createRequestOptions(this._url, this._httpHeaders), handleResponse)
              }
              this._request.on('error', (t) => {
                this._storedError = t
              })
              this._request.end()
            }
          }
          class PDFNodeStreamFsFullReader extends BaseFullReader {
            constructor(t) {
              super(t)
              let e = decodeURIComponent(this._url.path)
              a.test(this._url.href) && (e = e.replace(/^\//, ''))
              const i = require('fs')
              i.lstat(e, (t, n) => {
                if (t) {
                  'ENOENT' === t.code && (t = new s.MissingPDFException(`Missing PDF "${e}".`))
                  this._storedError = t
                  this._headersCapability.reject(t)
                } else {
                  this._contentLength = n.size
                  this._setReadableStream(i.createReadStream(e))
                  this._headersCapability.resolve()
                }
              })
            }
          }
          class PDFNodeStreamFsRangeReader extends BaseRangeReader {
            constructor(t, e, i) {
              super(t)
              let s = decodeURIComponent(this._url.path)
              a.test(this._url.href) && (s = s.replace(/^\//, ''))
              const n = require('fs')
              this._setReadableStream(n.createReadStream(s, { start: e, end: i - 1 }))
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.SVGGraphics = void 0
          var s = i(6),
            n = i(1)
          const a = 'normal',
            r = 'normal',
            o = '#000000',
            l = ['butt', 'round', 'square'],
            h = ['miter', 'round', 'bevel'],
            createObjectURL = function (t, e = '', i = !1) {
              if (URL.createObjectURL && 'undefined' != typeof Blob && !i) return URL.createObjectURL(new Blob([t], { type: e }))
              const s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
              let n = `data:${e};base64,`
              for (let e = 0, i = t.length; e < i; e += 3) {
                const a = 255 & t[e],
                  r = 255 & t[e + 1],
                  o = 255 & t[e + 2]
                n += s[a >> 2] + s[((3 & a) << 4) | (r >> 4)] + s[e + 1 < i ? ((15 & r) << 2) | (o >> 6) : 64] + s[e + 2 < i ? 63 & o : 64]
              }
              return n
            },
            c = (function () {
              const t = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
                e = new Int32Array(256)
              for (let t = 0; t < 256; t++) {
                let i = t
                for (let t = 0; t < 8; t++) i = 1 & i ? 3988292384 ^ ((i >> 1) & 2147483647) : (i >> 1) & 2147483647
                e[t] = i
              }
              function writePngChunk(t, i, s, n) {
                let a = n
                const r = i.length
                s[a] = (r >> 24) & 255
                s[a + 1] = (r >> 16) & 255
                s[a + 2] = (r >> 8) & 255
                s[a + 3] = 255 & r
                a += 4
                s[a] = 255 & t.charCodeAt(0)
                s[a + 1] = 255 & t.charCodeAt(1)
                s[a + 2] = 255 & t.charCodeAt(2)
                s[a + 3] = 255 & t.charCodeAt(3)
                a += 4
                s.set(i, a)
                a += i.length
                const o = (function crc32(t, i, s) {
                  let n = -1
                  for (let a = i; a < s; a++) {
                    const i = 255 & (n ^ t[a])
                    n = (n >>> 8) ^ e[i]
                  }
                  return -1 ^ n
                })(s, n + 4, a)
                s[a] = (o >> 24) & 255
                s[a + 1] = (o >> 16) & 255
                s[a + 2] = (o >> 8) & 255
                s[a + 3] = 255 & o
              }
              function deflateSyncUncompressed(t) {
                let e = t.length
                const i = 65535,
                  s = Math.ceil(e / i),
                  n = new Uint8Array(2 + e + 5 * s + 4)
                let a = 0
                n[a++] = 120
                n[a++] = 156
                let r = 0
                for (; e > i; ) {
                  n[a++] = 0
                  n[a++] = 255
                  n[a++] = 255
                  n[a++] = 0
                  n[a++] = 0
                  n.set(t.subarray(r, r + i), a)
                  a += i
                  r += i
                  e -= i
                }
                n[a++] = 1
                n[a++] = 255 & e
                n[a++] = (e >> 8) & 255
                n[a++] = 255 & ~e
                n[a++] = ((65535 & ~e) >> 8) & 255
                n.set(t.subarray(r), a)
                a += t.length - r
                const o = (function adler32(t, e, i) {
                  let s = 1,
                    n = 0
                  for (let a = e; a < i; ++a) {
                    s = (s + (255 & t[a])) % 65521
                    n = (n + s) % 65521
                  }
                  return (n << 16) | s
                })(t, 0, t.length)
                n[a++] = (o >> 24) & 255
                n[a++] = (o >> 16) & 255
                n[a++] = (o >> 8) & 255
                n[a++] = 255 & o
                return n
              }
              function encode(e, i, s, a) {
                const r = e.width,
                  o = e.height
                let l, h, c
                const d = e.data
                switch (i) {
                  case n.ImageKind.GRAYSCALE_1BPP:
                    h = 0
                    l = 1
                    c = (r + 7) >> 3
                    break
                  case n.ImageKind.RGB_24BPP:
                    h = 2
                    l = 8
                    c = 3 * r
                    break
                  case n.ImageKind.RGBA_32BPP:
                    h = 6
                    l = 8
                    c = 4 * r
                    break
                  default:
                    throw new Error('invalid format')
                }
                const u = new Uint8Array((1 + c) * o)
                let p = 0,
                  g = 0
                for (let t = 0; t < o; ++t) {
                  u[p++] = 0
                  u.set(d.subarray(g, g + c), p)
                  g += c
                  p += c
                }
                if (i === n.ImageKind.GRAYSCALE_1BPP && a) {
                  p = 0
                  for (let t = 0; t < o; t++) {
                    p++
                    for (let t = 0; t < c; t++) u[p++] ^= 255
                  }
                }
                const m = new Uint8Array([(r >> 24) & 255, (r >> 16) & 255, (r >> 8) & 255, 255 & r, (o >> 24) & 255, (o >> 16) & 255, (o >> 8) & 255, 255 & o, l, h, 0, 0, 0]),
                  f = (function deflateSync(t) {
                    if (!n.isNodeJS) return deflateSyncUncompressed(t)
                    try {
                      const e = parseInt(process.versions.node) >= 8 ? t : Buffer.from(t),
                        i = require('zlib').deflateSync(e, { level: 9 })
                      return i instanceof Uint8Array ? i : new Uint8Array(i)
                    } catch (t) {
                      ;(0, n.warn)('Not compressing PNG because zlib.deflateSync is unavailable: ' + t)
                    }
                    return deflateSyncUncompressed(t)
                  })(u),
                  b = t.length + 36 + m.length + f.length,
                  A = new Uint8Array(b)
                let _ = 0
                A.set(t, _)
                _ += t.length
                writePngChunk('IHDR', m, A, _)
                _ += 12 + m.length
                writePngChunk('IDATA', f, A, _)
                _ += 12 + f.length
                writePngChunk('IEND', new Uint8Array(0), A, _)
                return createObjectURL(A, 'image/png', s)
              }
              return function convertImgDataToPng(t, e, i) {
                return encode(t, void 0 === t.kind ? n.ImageKind.GRAYSCALE_1BPP : t.kind, e, i)
              }
            })()
          class SVGExtraState {
            constructor() {
              this.fontSizeScale = 1
              this.fontWeight = r
              this.fontSize = 0
              this.textMatrix = n.IDENTITY_MATRIX
              this.fontMatrix = n.FONT_IDENTITY_MATRIX
              this.leading = 0
              this.textRenderingMode = n.TextRenderingMode.FILL
              this.textMatrixScale = 1
              this.x = 0
              this.y = 0
              this.lineX = 0
              this.lineY = 0
              this.charSpacing = 0
              this.wordSpacing = 0
              this.textHScale = 1
              this.textRise = 0
              this.fillColor = o
              this.strokeColor = '#000000'
              this.fillAlpha = 1
              this.strokeAlpha = 1
              this.lineWidth = 1
              this.lineJoin = ''
              this.lineCap = ''
              this.miterLimit = 0
              this.dashArray = []
              this.dashPhase = 0
              this.dependencies = []
              this.activeClipUrl = null
              this.clipGroup = null
              this.maskId = ''
            }
            clone() {
              return Object.create(this)
            }
            setCurrentPoint(t, e) {
              this.x = t
              this.y = e
            }
          }
          function pf(t) {
            if (Number.isInteger(t)) return t.toString()
            const e = t.toFixed(10)
            let i = e.length - 1
            if ('0' !== e[i]) return e
            do {
              i--
            } while ('0' === e[i])
            return e.substring(0, '.' === e[i] ? i : i + 1)
          }
          function pm(t) {
            if (0 === t[4] && 0 === t[5]) {
              if (0 === t[1] && 0 === t[2]) return 1 === t[0] && 1 === t[3] ? '' : `scale(${pf(t[0])} ${pf(t[3])})`
              if (t[0] === t[3] && t[1] === -t[2]) {
                return `rotate(${pf((180 * Math.acos(t[0])) / Math.PI)})`
              }
            } else if (1 === t[0] && 0 === t[1] && 0 === t[2] && 1 === t[3]) return `translate(${pf(t[4])} ${pf(t[5])})`
            return `matrix(${pf(t[0])} ${pf(t[1])} ${pf(t[2])} ${pf(t[3])} ${pf(t[4])} ${pf(t[5])})`
          }
          let d = 0,
            u = 0,
            p = 0
          e.SVGGraphics = class SVGGraphics {
            constructor(t, e, i = !1) {
              ;(0, s.deprecated)('The SVG back-end is no longer maintained and *may* be removed in the future.')
              this.svgFactory = new s.DOMSVGFactory()
              this.current = new SVGExtraState()
              this.transformMatrix = n.IDENTITY_MATRIX
              this.transformStack = []
              this.extraStack = []
              this.commonObjs = t
              this.objs = e
              this.pendingClip = null
              this.pendingEOFill = !1
              this.embedFonts = !1
              this.embeddedFonts = Object.create(null)
              this.cssStyle = null
              this.forceDataSchema = !!i
              this._operatorIdMapping = []
              for (const t in n.OPS) this._operatorIdMapping[n.OPS[t]] = t
            }
            getObject(t, e = null) {
              return 'string' == typeof t ? (t.startsWith('g_') ? this.commonObjs.get(t) : this.objs.get(t)) : e
            }
            save() {
              this.transformStack.push(this.transformMatrix)
              const t = this.current
              this.extraStack.push(t)
              this.current = t.clone()
            }
            restore() {
              this.transformMatrix = this.transformStack.pop()
              this.current = this.extraStack.pop()
              this.pendingClip = null
              this.tgrp = null
            }
            group(t) {
              this.save()
              this.executeOpTree(t)
              this.restore()
            }
            loadDependencies(t) {
              const e = t.fnArray,
                i = t.argsArray
              for (let t = 0, s = e.length; t < s; t++)
                if (e[t] === n.OPS.dependency)
                  for (const e of i[t]) {
                    const t = e.startsWith('g_') ? this.commonObjs : this.objs,
                      i = new Promise((i) => {
                        t.get(e, i)
                      })
                    this.current.dependencies.push(i)
                  }
              return Promise.all(this.current.dependencies)
            }
            transform(t, e, i, s, a, r) {
              const o = [t, e, i, s, a, r]
              this.transformMatrix = n.Util.transform(this.transformMatrix, o)
              this.tgrp = null
            }
            getSVG(t, e) {
              this.viewport = e
              const i = this._initialize(e)
              return this.loadDependencies(t).then(() => {
                this.transformMatrix = n.IDENTITY_MATRIX
                this.executeOpTree(this.convertOpList(t))
                return i
              })
            }
            convertOpList(t) {
              const e = this._operatorIdMapping,
                i = t.argsArray,
                s = t.fnArray,
                n = []
              for (let t = 0, a = s.length; t < a; t++) {
                const a = s[t]
                n.push({ fnId: a, fn: e[a], args: i[t] })
              }
              return (function opListToTree(t) {
                let e = []
                const i = []
                for (const s of t)
                  if ('save' !== s.fn) 'restore' === s.fn ? (e = i.pop()) : e.push(s)
                  else {
                    e.push({ fnId: 92, fn: 'group', items: [] })
                    i.push(e)
                    e = e.at(-1).items
                  }
                return e
              })(n)
            }
            executeOpTree(t) {
              for (const e of t) {
                const t = e.fn,
                  i = e.fnId,
                  s = e.args
                switch (0 | i) {
                  case n.OPS.beginText:
                    this.beginText()
                    break
                  case n.OPS.dependency:
                    break
                  case n.OPS.setLeading:
                    this.setLeading(s)
                    break
                  case n.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(s[0], s[1])
                    break
                  case n.OPS.setFont:
                    this.setFont(s)
                    break
                  case n.OPS.showText:
                  case n.OPS.showSpacedText:
                    this.showText(s[0])
                    break
                  case n.OPS.endText:
                    this.endText()
                    break
                  case n.OPS.moveText:
                    this.moveText(s[0], s[1])
                    break
                  case n.OPS.setCharSpacing:
                    this.setCharSpacing(s[0])
                    break
                  case n.OPS.setWordSpacing:
                    this.setWordSpacing(s[0])
                    break
                  case n.OPS.setHScale:
                    this.setHScale(s[0])
                    break
                  case n.OPS.setTextMatrix:
                    this.setTextMatrix(s[0], s[1], s[2], s[3], s[4], s[5])
                    break
                  case n.OPS.setTextRise:
                    this.setTextRise(s[0])
                    break
                  case n.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(s[0])
                    break
                  case n.OPS.setLineWidth:
                    this.setLineWidth(s[0])
                    break
                  case n.OPS.setLineJoin:
                    this.setLineJoin(s[0])
                    break
                  case n.OPS.setLineCap:
                    this.setLineCap(s[0])
                    break
                  case n.OPS.setMiterLimit:
                    this.setMiterLimit(s[0])
                    break
                  case n.OPS.setFillRGBColor:
                    this.setFillRGBColor(s[0], s[1], s[2])
                    break
                  case n.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(s[0], s[1], s[2])
                    break
                  case n.OPS.setStrokeColorN:
                    this.setStrokeColorN(s)
                    break
                  case n.OPS.setFillColorN:
                    this.setFillColorN(s)
                    break
                  case n.OPS.shadingFill:
                    this.shadingFill(s[0])
                    break
                  case n.OPS.setDash:
                    this.setDash(s[0], s[1])
                    break
                  case n.OPS.setRenderingIntent:
                    this.setRenderingIntent(s[0])
                    break
                  case n.OPS.setFlatness:
                    this.setFlatness(s[0])
                    break
                  case n.OPS.setGState:
                    this.setGState(s[0])
                    break
                  case n.OPS.fill:
                    this.fill()
                    break
                  case n.OPS.eoFill:
                    this.eoFill()
                    break
                  case n.OPS.stroke:
                    this.stroke()
                    break
                  case n.OPS.fillStroke:
                    this.fillStroke()
                    break
                  case n.OPS.eoFillStroke:
                    this.eoFillStroke()
                    break
                  case n.OPS.clip:
                    this.clip('nonzero')
                    break
                  case n.OPS.eoClip:
                    this.clip('evenodd')
                    break
                  case n.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask()
                    break
                  case n.OPS.paintImageXObject:
                    this.paintImageXObject(s[0])
                    break
                  case n.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(s[0])
                    break
                  case n.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(s[0])
                    break
                  case n.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(s[0], s[1])
                    break
                  case n.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd()
                    break
                  case n.OPS.closePath:
                    this.closePath()
                    break
                  case n.OPS.closeStroke:
                    this.closeStroke()
                    break
                  case n.OPS.closeFillStroke:
                    this.closeFillStroke()
                    break
                  case n.OPS.closeEOFillStroke:
                    this.closeEOFillStroke()
                    break
                  case n.OPS.nextLine:
                    this.nextLine()
                    break
                  case n.OPS.transform:
                    this.transform(s[0], s[1], s[2], s[3], s[4], s[5])
                    break
                  case n.OPS.constructPath:
                    this.constructPath(s[0], s[1])
                    break
                  case n.OPS.endPath:
                    this.endPath()
                    break
                  case 92:
                    this.group(e.items)
                    break
                  default:
                    ;(0, n.warn)(`Unimplemented operator ${t}`)
                }
              }
            }
            setWordSpacing(t) {
              this.current.wordSpacing = t
            }
            setCharSpacing(t) {
              this.current.charSpacing = t
            }
            nextLine() {
              this.moveText(0, this.current.leading)
            }
            setTextMatrix(t, e, i, s, n, a) {
              const r = this.current
              r.textMatrix = r.lineMatrix = [t, e, i, s, n, a]
              r.textMatrixScale = Math.hypot(t, e)
              r.x = r.lineX = 0
              r.y = r.lineY = 0
              r.xcoords = []
              r.ycoords = []
              r.tspan = this.svgFactory.createElement('svg:tspan')
              r.tspan.setAttributeNS(null, 'font-family', r.fontFamily)
              r.tspan.setAttributeNS(null, 'font-size', `${pf(r.fontSize)}px`)
              r.tspan.setAttributeNS(null, 'y', pf(-r.y))
              r.txtElement = this.svgFactory.createElement('svg:text')
              r.txtElement.append(r.tspan)
            }
            beginText() {
              const t = this.current
              t.x = t.lineX = 0
              t.y = t.lineY = 0
              t.textMatrix = n.IDENTITY_MATRIX
              t.lineMatrix = n.IDENTITY_MATRIX
              t.textMatrixScale = 1
              t.tspan = this.svgFactory.createElement('svg:tspan')
              t.txtElement = this.svgFactory.createElement('svg:text')
              t.txtgrp = this.svgFactory.createElement('svg:g')
              t.xcoords = []
              t.ycoords = []
            }
            moveText(t, e) {
              const i = this.current
              i.x = i.lineX += t
              i.y = i.lineY += e
              i.xcoords = []
              i.ycoords = []
              i.tspan = this.svgFactory.createElement('svg:tspan')
              i.tspan.setAttributeNS(null, 'font-family', i.fontFamily)
              i.tspan.setAttributeNS(null, 'font-size', `${pf(i.fontSize)}px`)
              i.tspan.setAttributeNS(null, 'y', pf(-i.y))
            }
            showText(t) {
              const e = this.current,
                i = e.font,
                s = e.fontSize
              if (0 === s) return
              const l = e.fontSizeScale,
                h = e.charSpacing,
                c = e.wordSpacing,
                d = e.fontDirection,
                u = e.textHScale * d,
                p = i.vertical,
                g = p ? 1 : -1,
                m = i.defaultVMetrics,
                f = s * e.fontMatrix[0]
              let b = 0
              for (const n of t) {
                if (null === n) {
                  b += d * c
                  continue
                }
                if ('number' == typeof n) {
                  b += (g * n * s) / 1e3
                  continue
                }
                const t = (n.isSpace ? c : 0) + h,
                  a = n.fontChar
                let r,
                  o,
                  u = n.width
                if (p) {
                  let t
                  const e = n.vmetric || m
                  t = n.vmetric ? e[1] : 0.5 * u
                  t = -t * f
                  const i = e[2] * f
                  u = e ? -e[0] : u
                  r = t / l
                  o = (b + i) / l
                } else {
                  r = b / l
                  o = 0
                }
                if (n.isInFont || i.missingFile) {
                  e.xcoords.push(e.x + r)
                  p && e.ycoords.push(-e.y + o)
                  e.tspan.textContent += a
                }
                b += p ? u * f - t * d : u * f + t * d
              }
              e.tspan.setAttributeNS(null, 'x', e.xcoords.map(pf).join(' '))
              p ? e.tspan.setAttributeNS(null, 'y', e.ycoords.map(pf).join(' ')) : e.tspan.setAttributeNS(null, 'y', pf(-e.y))
              p ? (e.y -= b) : (e.x += b * u)
              e.tspan.setAttributeNS(null, 'font-family', e.fontFamily)
              e.tspan.setAttributeNS(null, 'font-size', `${pf(e.fontSize)}px`)
              e.fontStyle !== a && e.tspan.setAttributeNS(null, 'font-style', e.fontStyle)
              e.fontWeight !== r && e.tspan.setAttributeNS(null, 'font-weight', e.fontWeight)
              const A = e.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK
              if (A === n.TextRenderingMode.FILL || A === n.TextRenderingMode.FILL_STROKE) {
                e.fillColor !== o && e.tspan.setAttributeNS(null, 'fill', e.fillColor)
                e.fillAlpha < 1 && e.tspan.setAttributeNS(null, 'fill-opacity', e.fillAlpha)
              } else e.textRenderingMode === n.TextRenderingMode.ADD_TO_PATH ? e.tspan.setAttributeNS(null, 'fill', 'transparent') : e.tspan.setAttributeNS(null, 'fill', 'none')
              if (A === n.TextRenderingMode.STROKE || A === n.TextRenderingMode.FILL_STROKE) {
                const t = 1 / (e.textMatrixScale || 1)
                this._setStrokeAttributes(e.tspan, t)
              }
              let _ = e.textMatrix
              if (0 !== e.textRise) {
                _ = _.slice()
                _[5] += e.textRise
              }
              e.txtElement.setAttributeNS(null, 'transform', `${pm(_)} scale(${pf(u)}, -1)`)
              e.txtElement.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve')
              e.txtElement.append(e.tspan)
              e.txtgrp.append(e.txtElement)
              this._ensureTransformGroup().append(e.txtElement)
            }
            setLeadingMoveText(t, e) {
              this.setLeading(-e)
              this.moveText(t, e)
            }
            addFontStyle(t) {
              if (!t.data) throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.')
              if (!this.cssStyle) {
                this.cssStyle = this.svgFactory.createElement('svg:style')
                this.cssStyle.setAttributeNS(null, 'type', 'text/css')
                this.defs.append(this.cssStyle)
              }
              const e = createObjectURL(t.data, t.mimetype, this.forceDataSchema)
              this.cssStyle.textContent += `@font-face { font-family: "${t.loadedName}"; src: url(${e}); }\n`
            }
            setFont(t) {
              const e = this.current,
                i = this.commonObjs.get(t[0])
              let s = t[1]
              e.font = i
              if (this.embedFonts && !i.missingFile && !this.embeddedFonts[i.loadedName]) {
                this.addFontStyle(i)
                this.embeddedFonts[i.loadedName] = i
              }
              e.fontMatrix = i.fontMatrix || n.FONT_IDENTITY_MATRIX
              let a = 'normal'
              i.black ? (a = '900') : i.bold && (a = 'bold')
              const r = i.italic ? 'italic' : 'normal'
              if (s < 0) {
                s = -s
                e.fontDirection = -1
              } else e.fontDirection = 1
              e.fontSize = s
              e.fontFamily = i.loadedName
              e.fontWeight = a
              e.fontStyle = r
              e.tspan = this.svgFactory.createElement('svg:tspan')
              e.tspan.setAttributeNS(null, 'y', pf(-e.y))
              e.xcoords = []
              e.ycoords = []
            }
            endText() {
              const t = this.current
              if (t.textRenderingMode & n.TextRenderingMode.ADD_TO_PATH_FLAG && t.txtElement?.hasChildNodes()) {
                t.element = t.txtElement
                this.clip('nonzero')
                this.endPath()
              }
            }
            setLineWidth(t) {
              t > 0 && (this.current.lineWidth = t)
            }
            setLineCap(t) {
              this.current.lineCap = l[t]
            }
            setLineJoin(t) {
              this.current.lineJoin = h[t]
            }
            setMiterLimit(t) {
              this.current.miterLimit = t
            }
            setStrokeAlpha(t) {
              this.current.strokeAlpha = t
            }
            setStrokeRGBColor(t, e, i) {
              this.current.strokeColor = n.Util.makeHexColor(t, e, i)
            }
            setFillAlpha(t) {
              this.current.fillAlpha = t
            }
            setFillRGBColor(t, e, i) {
              this.current.fillColor = n.Util.makeHexColor(t, e, i)
              this.current.tspan = this.svgFactory.createElement('svg:tspan')
              this.current.xcoords = []
              this.current.ycoords = []
            }
            setStrokeColorN(t) {
              this.current.strokeColor = this._makeColorN_Pattern(t)
            }
            setFillColorN(t) {
              this.current.fillColor = this._makeColorN_Pattern(t)
            }
            shadingFill(t) {
              const { width: e, height: i } = this.viewport,
                s = n.Util.inverseTransform(this.transformMatrix),
                [a, r, o, l] = n.Util.getAxialAlignedBoundingBox([0, 0, e, i], s),
                h = this.svgFactory.createElement('svg:rect')
              h.setAttributeNS(null, 'x', a)
              h.setAttributeNS(null, 'y', r)
              h.setAttributeNS(null, 'width', o - a)
              h.setAttributeNS(null, 'height', l - r)
              h.setAttributeNS(null, 'fill', this._makeShadingPattern(t))
              this.current.fillAlpha < 1 && h.setAttributeNS(null, 'fill-opacity', this.current.fillAlpha)
              this._ensureTransformGroup().append(h)
            }
            _makeColorN_Pattern(t) {
              return 'TilingPattern' === t[0] ? this._makeTilingPattern(t) : this._makeShadingPattern(t)
            }
            _makeTilingPattern(t) {
              const e = t[1],
                i = t[2],
                s = t[3] || n.IDENTITY_MATRIX,
                [a, r, o, l] = t[4],
                h = t[5],
                c = t[6],
                d = t[7],
                u = 'shading' + p++,
                [g, m, f, b] = n.Util.normalizeRect([...n.Util.applyTransform([a, r], s), ...n.Util.applyTransform([o, l], s)]),
                [A, _] = n.Util.singularValueDecompose2dScale(s),
                v = h * A,
                y = c * _,
                S = this.svgFactory.createElement('svg:pattern')
              S.setAttributeNS(null, 'id', u)
              S.setAttributeNS(null, 'patternUnits', 'userSpaceOnUse')
              S.setAttributeNS(null, 'width', v)
              S.setAttributeNS(null, 'height', y)
              S.setAttributeNS(null, 'x', `${g}`)
              S.setAttributeNS(null, 'y', `${m}`)
              const E = this.svg,
                x = this.transformMatrix,
                w = this.current.fillColor,
                C = this.current.strokeColor,
                T = this.svgFactory.create(f - g, b - m)
              this.svg = T
              this.transformMatrix = s
              if (2 === d) {
                const t = n.Util.makeHexColor(...e)
                this.current.fillColor = t
                this.current.strokeColor = t
              }
              this.executeOpTree(this.convertOpList(i))
              this.svg = E
              this.transformMatrix = x
              this.current.fillColor = w
              this.current.strokeColor = C
              S.append(T.childNodes[0])
              this.defs.append(S)
              return `url(#${u})`
            }
            _makeShadingPattern(t) {
              'string' == typeof t && (t = this.objs.get(t))
              switch (t[0]) {
                case 'RadialAxial':
                  const e = 'shading' + p++,
                    i = t[3]
                  let s
                  switch (t[1]) {
                    case 'axial':
                      const i = t[4],
                        n = t[5]
                      s = this.svgFactory.createElement('svg:linearGradient')
                      s.setAttributeNS(null, 'id', e)
                      s.setAttributeNS(null, 'gradientUnits', 'userSpaceOnUse')
                      s.setAttributeNS(null, 'x1', i[0])
                      s.setAttributeNS(null, 'y1', i[1])
                      s.setAttributeNS(null, 'x2', n[0])
                      s.setAttributeNS(null, 'y2', n[1])
                      break
                    case 'radial':
                      const a = t[4],
                        r = t[5],
                        o = t[6],
                        l = t[7]
                      s = this.svgFactory.createElement('svg:radialGradient')
                      s.setAttributeNS(null, 'id', e)
                      s.setAttributeNS(null, 'gradientUnits', 'userSpaceOnUse')
                      s.setAttributeNS(null, 'cx', r[0])
                      s.setAttributeNS(null, 'cy', r[1])
                      s.setAttributeNS(null, 'r', l)
                      s.setAttributeNS(null, 'fx', a[0])
                      s.setAttributeNS(null, 'fy', a[1])
                      s.setAttributeNS(null, 'fr', o)
                      break
                    default:
                      throw new Error(`Unknown RadialAxial type: ${t[1]}`)
                  }
                  for (const t of i) {
                    const e = this.svgFactory.createElement('svg:stop')
                    e.setAttributeNS(null, 'offset', t[0])
                    e.setAttributeNS(null, 'stop-color', t[1])
                    s.append(e)
                  }
                  this.defs.append(s)
                  return `url(#${e})`
                case 'Mesh':
                  ;(0, n.warn)('Unimplemented pattern Mesh')
                  return null
                case 'Dummy':
                  return 'hotpink'
                default:
                  throw new Error(`Unknown IR type: ${t[0]}`)
              }
            }
            setDash(t, e) {
              this.current.dashArray = t
              this.current.dashPhase = e
            }
            constructPath(t, e) {
              const i = this.current
              let s = i.x,
                a = i.y,
                r = [],
                o = 0
              for (const i of t)
                switch (0 | i) {
                  case n.OPS.rectangle:
                    s = e[o++]
                    a = e[o++]
                    const t = s + e[o++],
                      i = a + e[o++]
                    r.push('M', pf(s), pf(a), 'L', pf(t), pf(a), 'L', pf(t), pf(i), 'L', pf(s), pf(i), 'Z')
                    break
                  case n.OPS.moveTo:
                    s = e[o++]
                    a = e[o++]
                    r.push('M', pf(s), pf(a))
                    break
                  case n.OPS.lineTo:
                    s = e[o++]
                    a = e[o++]
                    r.push('L', pf(s), pf(a))
                    break
                  case n.OPS.curveTo:
                    s = e[o + 4]
                    a = e[o + 5]
                    r.push('C', pf(e[o]), pf(e[o + 1]), pf(e[o + 2]), pf(e[o + 3]), pf(s), pf(a))
                    o += 6
                    break
                  case n.OPS.curveTo2:
                    r.push('C', pf(s), pf(a), pf(e[o]), pf(e[o + 1]), pf(e[o + 2]), pf(e[o + 3]))
                    s = e[o + 2]
                    a = e[o + 3]
                    o += 4
                    break
                  case n.OPS.curveTo3:
                    s = e[o + 2]
                    a = e[o + 3]
                    r.push('C', pf(e[o]), pf(e[o + 1]), pf(s), pf(a), pf(s), pf(a))
                    o += 4
                    break
                  case n.OPS.closePath:
                    r.push('Z')
                }
              r = r.join(' ')
              if (i.path && t.length > 0 && t[0] !== n.OPS.rectangle && t[0] !== n.OPS.moveTo) r = i.path.getAttributeNS(null, 'd') + r
              else {
                i.path = this.svgFactory.createElement('svg:path')
                this._ensureTransformGroup().append(i.path)
              }
              i.path.setAttributeNS(null, 'd', r)
              i.path.setAttributeNS(null, 'fill', 'none')
              i.element = i.path
              i.setCurrentPoint(s, a)
            }
            endPath() {
              const t = this.current
              t.path = null
              if (!this.pendingClip) return
              if (!t.element) {
                this.pendingClip = null
                return
              }
              const e = 'clippath' + d++,
                i = this.svgFactory.createElement('svg:clipPath')
              i.setAttributeNS(null, 'id', e)
              i.setAttributeNS(null, 'transform', pm(this.transformMatrix))
              const s = t.element.cloneNode(!0)
              'evenodd' === this.pendingClip ? s.setAttributeNS(null, 'clip-rule', 'evenodd') : s.setAttributeNS(null, 'clip-rule', 'nonzero')
              this.pendingClip = null
              i.append(s)
              this.defs.append(i)
              if (t.activeClipUrl) {
                t.clipGroup = null
                for (const t of this.extraStack) t.clipGroup = null
                i.setAttributeNS(null, 'clip-path', t.activeClipUrl)
              }
              t.activeClipUrl = `url(#${e})`
              this.tgrp = null
            }
            clip(t) {
              this.pendingClip = t
            }
            closePath() {
              const t = this.current
              if (t.path) {
                const e = `${t.path.getAttributeNS(null, 'd')}Z`
                t.path.setAttributeNS(null, 'd', e)
              }
            }
            setLeading(t) {
              this.current.leading = -t
            }
            setTextRise(t) {
              this.current.textRise = t
            }
            setTextRenderingMode(t) {
              this.current.textRenderingMode = t
            }
            setHScale(t) {
              this.current.textHScale = t / 100
            }
            setRenderingIntent(t) {}
            setFlatness(t) {}
            setGState(t) {
              for (const [e, i] of t)
                switch (e) {
                  case 'LW':
                    this.setLineWidth(i)
                    break
                  case 'LC':
                    this.setLineCap(i)
                    break
                  case 'LJ':
                    this.setLineJoin(i)
                    break
                  case 'ML':
                    this.setMiterLimit(i)
                    break
                  case 'D':
                    this.setDash(i[0], i[1])
                    break
                  case 'RI':
                    this.setRenderingIntent(i)
                    break
                  case 'FL':
                    this.setFlatness(i)
                    break
                  case 'Font':
                    this.setFont(i)
                    break
                  case 'CA':
                    this.setStrokeAlpha(i)
                    break
                  case 'ca':
                    this.setFillAlpha(i)
                    break
                  default:
                    ;(0, n.warn)(`Unimplemented graphic state operator ${e}`)
                }
            }
            fill() {
              const t = this.current
              if (t.element) {
                t.element.setAttributeNS(null, 'fill', t.fillColor)
                t.element.setAttributeNS(null, 'fill-opacity', t.fillAlpha)
                this.endPath()
              }
            }
            stroke() {
              const t = this.current
              if (t.element) {
                this._setStrokeAttributes(t.element)
                t.element.setAttributeNS(null, 'fill', 'none')
                this.endPath()
              }
            }
            _setStrokeAttributes(t, e = 1) {
              const i = this.current
              let s = i.dashArray
              1 !== e &&
                s.length > 0 &&
                (s = s.map(function (t) {
                  return e * t
                }))
              t.setAttributeNS(null, 'stroke', i.strokeColor)
              t.setAttributeNS(null, 'stroke-opacity', i.strokeAlpha)
              t.setAttributeNS(null, 'stroke-miterlimit', pf(i.miterLimit))
              t.setAttributeNS(null, 'stroke-linecap', i.lineCap)
              t.setAttributeNS(null, 'stroke-linejoin', i.lineJoin)
              t.setAttributeNS(null, 'stroke-width', pf(e * i.lineWidth) + 'px')
              t.setAttributeNS(null, 'stroke-dasharray', s.map(pf).join(' '))
              t.setAttributeNS(null, 'stroke-dashoffset', pf(e * i.dashPhase) + 'px')
            }
            eoFill() {
              this.current.element?.setAttributeNS(null, 'fill-rule', 'evenodd')
              this.fill()
            }
            fillStroke() {
              this.stroke()
              this.fill()
            }
            eoFillStroke() {
              this.current.element?.setAttributeNS(null, 'fill-rule', 'evenodd')
              this.fillStroke()
            }
            closeStroke() {
              this.closePath()
              this.stroke()
            }
            closeFillStroke() {
              this.closePath()
              this.fillStroke()
            }
            closeEOFillStroke() {
              this.closePath()
              this.eoFillStroke()
            }
            paintSolidColorImageMask() {
              const t = this.svgFactory.createElement('svg:rect')
              t.setAttributeNS(null, 'x', '0')
              t.setAttributeNS(null, 'y', '0')
              t.setAttributeNS(null, 'width', '1px')
              t.setAttributeNS(null, 'height', '1px')
              t.setAttributeNS(null, 'fill', this.current.fillColor)
              this._ensureTransformGroup().append(t)
            }
            paintImageXObject(t) {
              const e = this.getObject(t)
              e ? this.paintInlineImageXObject(e) : (0, n.warn)(`Dependent image with object ID ${t} is not ready yet`)
            }
            paintInlineImageXObject(t, e) {
              const i = t.width,
                s = t.height,
                n = c(t, this.forceDataSchema, !!e),
                a = this.svgFactory.createElement('svg:rect')
              a.setAttributeNS(null, 'x', '0')
              a.setAttributeNS(null, 'y', '0')
              a.setAttributeNS(null, 'width', pf(i))
              a.setAttributeNS(null, 'height', pf(s))
              this.current.element = a
              this.clip('nonzero')
              const r = this.svgFactory.createElement('svg:image')
              r.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', n)
              r.setAttributeNS(null, 'x', '0')
              r.setAttributeNS(null, 'y', pf(-s))
              r.setAttributeNS(null, 'width', pf(i) + 'px')
              r.setAttributeNS(null, 'height', pf(s) + 'px')
              r.setAttributeNS(null, 'transform', `scale(${pf(1 / i)} ${pf(-1 / s)})`)
              e ? e.append(r) : this._ensureTransformGroup().append(r)
            }
            paintImageMaskXObject(t) {
              const e = this.getObject(t.data, t)
              if (e.bitmap) {
                ;(0, n.warn)('paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.')
                return
              }
              const i = this.current,
                s = e.width,
                a = e.height,
                r = i.fillColor
              i.maskId = 'mask' + u++
              const o = this.svgFactory.createElement('svg:mask')
              o.setAttributeNS(null, 'id', i.maskId)
              const l = this.svgFactory.createElement('svg:rect')
              l.setAttributeNS(null, 'x', '0')
              l.setAttributeNS(null, 'y', '0')
              l.setAttributeNS(null, 'width', pf(s))
              l.setAttributeNS(null, 'height', pf(a))
              l.setAttributeNS(null, 'fill', r)
              l.setAttributeNS(null, 'mask', `url(#${i.maskId})`)
              this.defs.append(o)
              this._ensureTransformGroup().append(l)
              this.paintInlineImageXObject(e, o)
            }
            paintFormXObjectBegin(t, e) {
              Array.isArray(t) && 6 === t.length && this.transform(t[0], t[1], t[2], t[3], t[4], t[5])
              if (e) {
                const t = e[2] - e[0],
                  i = e[3] - e[1],
                  s = this.svgFactory.createElement('svg:rect')
                s.setAttributeNS(null, 'x', e[0])
                s.setAttributeNS(null, 'y', e[1])
                s.setAttributeNS(null, 'width', pf(t))
                s.setAttributeNS(null, 'height', pf(i))
                this.current.element = s
                this.clip('nonzero')
                this.endPath()
              }
            }
            paintFormXObjectEnd() {}
            _initialize(t) {
              const e = this.svgFactory.create(t.width, t.height),
                i = this.svgFactory.createElement('svg:defs')
              e.append(i)
              this.defs = i
              const s = this.svgFactory.createElement('svg:g')
              s.setAttributeNS(null, 'transform', pm(t.transform))
              e.append(s)
              this.svg = s
              return e
            }
            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const t = this.svgFactory.createElement('svg:g')
                t.setAttributeNS(null, 'clip-path', this.current.activeClipUrl)
                this.svg.append(t)
                this.current.clipGroup = t
              }
              return this.current.clipGroup
            }
            _ensureTransformGroup() {
              if (!this.tgrp) {
                this.tgrp = this.svgFactory.createElement('svg:g')
                this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix))
                this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)
              }
              return this.tgrp
            }
          }
        },
        (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.XfaText = void 0
          class XfaText {
            static textContent(t) {
              const e = [],
                i = { items: e, styles: Object.create(null) }
              !(function walk(t) {
                if (!t) return
                let i = null
                const s = t.name
                if ('#text' === s) i = t.value
                else {
                  if (!XfaText.shouldBuildText(s)) return
                  t?.attributes?.textContent ? (i = t.attributes.textContent) : t.value && (i = t.value)
                }
                null !== i && e.push({ str: i })
                if (t.children) for (const e of t.children) walk(e)
              })(t)
              return i
            }
            static shouldBuildText(t) {
              return !('textarea' === t || 'input' === t || 'option' === t || 'select' === t)
            }
          }
          e.XfaText = XfaText
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.TextLayerRenderTask = void 0
          e.renderTextLayer = function renderTextLayer(t) {
            if (!t.textContentSource && (t.textContent || t.textContentStream)) {
              ;(0, n.deprecated)('The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.')
              t.textContentSource = t.textContent || t.textContentStream
            }
            const { container: e, viewport: i } = t,
              s = getComputedStyle(e),
              a = s.getPropertyValue('visibility'),
              r = parseFloat(s.getPropertyValue('--scale-factor'))
            'visible' === a && (!r || Math.abs(r - i.scale) > 1e-5) && console.error('The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.')
            const o = new TextLayerRenderTask(t)
            o._render()
            return o
          }
          e.updateTextLayer = function updateTextLayer({ container: t, viewport: e, textDivs: i, textDivProperties: s, isOffscreenCanvasSupported: a, mustRotate: r = !0, mustRescale: o = !0 }) {
            r && (0, n.setLayerDimensions)(t, { rotation: e.rotation })
            if (o) {
              const t = getCtx(0, a),
                n = { prevFontSize: null, prevFontFamily: null, div: null, scale: e.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: t }
              for (const t of i) {
                n.properties = s.get(t)
                n.div = t
                layout(n)
              }
            }
          }
          var s = i(1),
            n = i(6)
          const a = 30,
            r = 0.8,
            o = new Map()
          function getCtx(t, e) {
            let i
            if (e && s.FeatureTest.isOffscreenCanvasSupported) i = new OffscreenCanvas(t, t).getContext('2d', { alpha: !1 })
            else {
              const e = document.createElement('canvas')
              e.width = e.height = t
              i = e.getContext('2d', { alpha: !1 })
            }
            return i
          }
          function appendText(t, e, i) {
            const n = document.createElement('span'),
              l = { angle: 0, canvasWidth: 0, hasText: '' !== e.str, hasEOL: e.hasEOL, fontSize: 0 }
            t._textDivs.push(n)
            const h = s.Util.transform(t._transform, e.transform)
            let c = Math.atan2(h[1], h[0])
            const d = i[e.fontName]
            d.vertical && (c += Math.PI / 2)
            const u = Math.hypot(h[2], h[3]),
              p =
                u *
                (function getAscent(t, e) {
                  const i = o.get(t)
                  if (i) return i
                  const s = getCtx(a, e)
                  s.font = `${a}px ${t}`
                  const n = s.measureText('')
                  let l = n.fontBoundingBoxAscent,
                    h = Math.abs(n.fontBoundingBoxDescent)
                  if (l) {
                    const e = l / (l + h)
                    o.set(t, e)
                    s.canvas.width = s.canvas.height = 0
                    return e
                  }
                  s.strokeStyle = 'red'
                  s.clearRect(0, 0, a, a)
                  s.strokeText('g', 0, 0)
                  let c = s.getImageData(0, 0, a, a).data
                  h = 0
                  for (let t = c.length - 1 - 3; t >= 0; t -= 4)
                    if (c[t] > 0) {
                      h = Math.ceil(t / 4 / a)
                      break
                    }
                  s.clearRect(0, 0, a, a)
                  s.strokeText('A', 0, a)
                  c = s.getImageData(0, 0, a, a).data
                  l = 0
                  for (let t = 0, e = c.length; t < e; t += 4)
                    if (c[t] > 0) {
                      l = a - Math.floor(t / 4 / a)
                      break
                    }
                  s.canvas.width = s.canvas.height = 0
                  if (l) {
                    const e = l / (l + h)
                    o.set(t, e)
                    return e
                  }
                  o.set(t, r)
                  return r
                })(d.fontFamily, t._isOffscreenCanvasSupported)
            let g, m
            if (0 === c) {
              g = h[4]
              m = h[5] - p
            } else {
              g = h[4] + p * Math.sin(c)
              m = h[5] - p * Math.cos(c)
            }
            const f = 'calc(var(--scale-factor)*',
              b = n.style
            if (t._container === t._rootContainer) {
              b.left = `${((100 * g) / t._pageWidth).toFixed(2)}%`
              b.top = `${((100 * m) / t._pageHeight).toFixed(2)}%`
            } else {
              b.left = `${f}${g.toFixed(2)}px)`
              b.top = `${f}${m.toFixed(2)}px)`
            }
            b.fontSize = `${f}${u.toFixed(2)}px)`
            b.fontFamily = d.fontFamily
            l.fontSize = u
            n.setAttribute('role', 'presentation')
            n.textContent = e.str
            n.dir = e.dir
            t._fontInspectorEnabled && (n.dataset.fontName = e.fontName)
            0 !== c && (l.angle = c * (180 / Math.PI))
            let A = !1
            if (e.str.length > 1) A = !0
            else if (' ' !== e.str && e.transform[0] !== e.transform[3]) {
              const t = Math.abs(e.transform[0]),
                i = Math.abs(e.transform[3])
              t !== i && Math.max(t, i) / Math.min(t, i) > 1.5 && (A = !0)
            }
            A && (l.canvasWidth = d.vertical ? e.height : e.width)
            t._textDivProperties.set(n, l)
            t._isReadableStream && t._layoutText(n)
          }
          function layout(t) {
            const { div: e, scale: i, properties: s, ctx: n, prevFontSize: a, prevFontFamily: r } = t,
              { style: o } = e
            let l = ''
            if (0 !== s.canvasWidth && s.hasText) {
              const { fontFamily: h } = o,
                { canvasWidth: c, fontSize: d } = s
              if (a !== d || r !== h) {
                n.font = `${d * i}px ${h}`
                t.prevFontSize = d
                t.prevFontFamily = h
              }
              const { width: u } = n.measureText(e.textContent)
              u > 0 && (l = `scaleX(${(c * i) / u})`)
            }
            0 !== s.angle && (l = `rotate(${s.angle}deg) ${l}`)
            l.length > 0 && (o.transform = l)
          }
          class TextLayerRenderTask {
            constructor({ textContentSource: t, container: e, viewport: i, textDivs: a, textDivProperties: r, textContentItemsStr: o, isOffscreenCanvasSupported: l }) {
              this._textContentSource = t
              this._isReadableStream = t instanceof ReadableStream
              this._container = this._rootContainer = e
              this._textDivs = a || []
              this._textContentItemsStr = o || []
              this._isOffscreenCanvasSupported = l
              this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled
              this._reader = null
              this._textDivProperties = r || new WeakMap()
              this._canceled = !1
              this._capability = new s.PromiseCapability()
              this._layoutTextParams = { prevFontSize: null, prevFontFamily: null, div: null, scale: i.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: getCtx(0, l) }
              const { pageWidth: h, pageHeight: c, pageX: d, pageY: u } = i.rawDims
              this._transform = [1, 0, 0, -1, -d, u + c]
              this._pageWidth = h
              this._pageHeight = c
              ;(0, n.setLayerDimensions)(e, i)
              this._capability.promise
                .finally(() => {
                  this._layoutTextParams = null
                })
                .catch(() => {})
            }
            get promise() {
              return this._capability.promise
            }
            cancel() {
              this._canceled = !0
              if (this._reader) {
                this._reader.cancel(new s.AbortException('TextLayer task cancelled.')).catch(() => {})
                this._reader = null
              }
              this._capability.reject(new s.AbortException('TextLayer task cancelled.'))
            }
            _processItems(t, e) {
              for (const i of t)
                if (void 0 !== i.str) {
                  this._textContentItemsStr.push(i.str)
                  appendText(this, i, e)
                } else if ('beginMarkedContentProps' === i.type || 'beginMarkedContent' === i.type) {
                  const t = this._container
                  this._container = document.createElement('span')
                  this._container.classList.add('markedContent')
                  null !== i.id && this._container.setAttribute('id', `${i.id}`)
                  t.append(this._container)
                } else 'endMarkedContent' === i.type && (this._container = this._container.parentNode)
            }
            _layoutText(t) {
              const e = (this._layoutTextParams.properties = this._textDivProperties.get(t))
              this._layoutTextParams.div = t
              layout(this._layoutTextParams)
              e.hasText && this._container.append(t)
              if (e.hasEOL) {
                const t = document.createElement('br')
                t.setAttribute('role', 'presentation')
                this._container.append(t)
              }
            }
            _render() {
              const t = new s.PromiseCapability()
              let e = Object.create(null)
              if (this._isReadableStream) {
                const pump = () => {
                  this._reader.read().then(({ value: i, done: s }) => {
                    if (s) t.resolve()
                    else {
                      Object.assign(e, i.styles)
                      this._processItems(i.items, e)
                      pump()
                    }
                  }, t.reject)
                }
                this._reader = this._textContentSource.getReader()
                pump()
              } else {
                if (!this._textContentSource) throw new Error('No "textContentSource" parameter specified.')
                {
                  const { items: e, styles: i } = this._textContentSource
                  this._processItems(e, i)
                  t.resolve()
                }
              }
              t.promise.then(() => {
                e = null
                !(function render(t) {
                  if (t._canceled) return
                  const e = t._textDivs,
                    i = t._capability
                  if (e.length > 1e5) i.resolve()
                  else {
                    if (!t._isReadableStream) for (const i of e) t._layoutText(i)
                    i.resolve()
                  }
                })(this)
              }, this._capability.reject)
            }
          }
          e.TextLayerRenderTask = TextLayerRenderTask
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.AnnotationEditorLayer = void 0
          var s = i(1),
            n = i(4),
            a = i(28),
            r = i(33),
            o = i(6),
            l = i(34)
          class AnnotationEditorLayer {
            #Se
            #Ee = !1
            #xe = null
            #we = this.pointerup.bind(this)
            #Ce = this.pointerdown.bind(this)
            #Te = new Map()
            #Pe = !1
            #Me = !1
            #ke = !1
            #Fe
            static _initialized = !1
            constructor({ uiManager: t, pageIndex: e, div: i, accessibilityManager: s, annotationLayer: n, viewport: o, l10n: h }) {
              const c = [a.FreeTextEditor, r.InkEditor, l.StampEditor]
              if (!AnnotationEditorLayer._initialized) {
                AnnotationEditorLayer._initialized = !0
                for (const t of c) t.initialize(h)
              }
              t.registerEditorTypes(c)
              this.#Fe = t
              this.pageIndex = e
              this.div = i
              this.#Se = s
              this.#xe = n
              this.viewport = o
              this.#Fe.addLayer(this)
            }
            get isEmpty() {
              return 0 === this.#Te.size
            }
            updateToolbar(t) {
              this.#Fe.updateToolbar(t)
            }
            updateMode(t = this.#Fe.getMode()) {
              this.#Re()
              if (t === s.AnnotationEditorType.INK) {
                this.addInkEditorIfNeeded(!1)
                this.disableClick()
              } else this.enableClick()
              if (t !== s.AnnotationEditorType.NONE) {
                this.div.classList.toggle('freeTextEditing', t === s.AnnotationEditorType.FREETEXT)
                this.div.classList.toggle('inkEditing', t === s.AnnotationEditorType.INK)
                this.div.classList.toggle('stampEditing', t === s.AnnotationEditorType.STAMP)
                this.div.hidden = !1
              }
            }
            addInkEditorIfNeeded(t) {
              if (!t && this.#Fe.getMode() !== s.AnnotationEditorType.INK) return
              if (!t)
                for (const t of this.#Te.values())
                  if (t.isEmpty()) {
                    t.setInBackground()
                    return
                  }
              this.#De({ offsetX: 0, offsetY: 0 }, !1).setInBackground()
            }
            setEditingState(t) {
              this.#Fe.setEditingState(t)
            }
            addCommands(t) {
              this.#Fe.addCommands(t)
            }
            enable() {
              this.div.style.pointerEvents = 'auto'
              const t = new Set()
              for (const e of this.#Te.values()) {
                e.enableEditing()
                e.annotationElementId && t.add(e.annotationElementId)
              }
              if (!this.#xe) return
              const e = this.#xe.getEditableAnnotations()
              for (const i of e) {
                i.hide()
                if (this.#Fe.isDeletedAnnotationElement(i.data.id)) continue
                if (t.has(i.data.id)) continue
                const e = this.deserialize(i)
                if (e) {
                  this.addOrRebuild(e)
                  e.enableEditing()
                }
              }
            }
            disable() {
              this.#ke = !0
              this.div.style.pointerEvents = 'none'
              const t = new Set()
              for (const e of this.#Te.values()) {
                e.disableEditing()
                if (e.annotationElementId && null === e.serialize()) {
                  this.getEditableAnnotation(e.annotationElementId)?.show()
                  e.remove()
                } else t.add(e.annotationElementId)
              }
              if (this.#xe) {
                const e = this.#xe.getEditableAnnotations()
                for (const i of e) {
                  const { id: e } = i.data
                  t.has(e) || this.#Fe.isDeletedAnnotationElement(e) || i.show()
                }
              }
              this.#Re()
              this.isEmpty && (this.div.hidden = !0)
              this.#ke = !1
            }
            getEditableAnnotation(t) {
              return this.#xe?.getEditableAnnotation(t) || null
            }
            setActiveEditor(t) {
              this.#Fe.getActive() !== t && this.#Fe.setActiveEditor(t)
            }
            enableClick() {
              this.div.addEventListener('pointerdown', this.#Ce)
              this.div.addEventListener('pointerup', this.#we)
            }
            disableClick() {
              this.div.removeEventListener('pointerdown', this.#Ce)
              this.div.removeEventListener('pointerup', this.#we)
            }
            attach(t) {
              this.#Te.set(t.id, t)
              const { annotationElementId: e } = t
              e && this.#Fe.isDeletedAnnotationElement(e) && this.#Fe.removeDeletedAnnotationElement(t)
            }
            detach(t) {
              this.#Te.delete(t.id)
              this.#Se?.removePointerInTextLayer(t.contentDiv)
              !this.#ke && t.annotationElementId && this.#Fe.addDeletedAnnotationElement(t)
            }
            remove(t) {
              this.detach(t)
              this.#Fe.removeEditor(t)
              t.div.contains(document.activeElement) &&
                setTimeout(() => {
                  this.#Fe.focusMainContainer()
                }, 0)
              t.div.remove()
              t.isAttachedToDOM = !1
              this.#Me || this.addInkEditorIfNeeded(!1)
            }
            changeParent(t) {
              if (t.parent !== this) {
                if (t.annotationElementId) {
                  this.#Fe.addDeletedAnnotationElement(t.annotationElementId)
                  n.AnnotationEditor.deleteAnnotationElement(t)
                  t.annotationElementId = null
                }
                this.attach(t)
                t.parent?.detach(t)
                t.setParent(this)
                if (t.div && t.isAttachedToDOM) {
                  t.div.remove()
                  this.div.append(t.div)
                }
              }
            }
            add(t) {
              this.changeParent(t)
              this.#Fe.addEditor(t)
              this.attach(t)
              if (!t.isAttachedToDOM) {
                const e = t.render()
                this.div.append(e)
                t.isAttachedToDOM = !0
              }
              t.fixAndSetPosition()
              t.onceAdded()
              this.#Fe.addToAnnotationStorage(t)
            }
            moveEditorInDOM(t) {
              if (!t.isAttachedToDOM) return
              const { activeElement: e } = document
              if (t.div.contains(e)) {
                t._focusEventsAllowed = !1
                setTimeout(() => {
                  if (t.div.contains(document.activeElement)) t._focusEventsAllowed = !0
                  else {
                    t.div.addEventListener(
                      'focusin',
                      () => {
                        t._focusEventsAllowed = !0
                      },
                      { once: !0 }
                    )
                    e.focus()
                  }
                }, 0)
              }
              t._structTreeParentId = this.#Se?.moveElementInDOM(this.div, t.div, t.contentDiv, !0)
            }
            addOrRebuild(t) {
              t.needsToBeRebuilt() ? t.rebuild() : this.add(t)
            }
            addUndoableEditor(t) {
              this.addCommands({
                cmd: () => t._uiManager.rebuild(t),
                undo: () => {
                  t.remove()
                },
                mustExec: !1,
              })
            }
            getNextId() {
              return this.#Fe.getId()
            }
            #Ie(t) {
              switch (this.#Fe.getMode()) {
                case s.AnnotationEditorType.FREETEXT:
                  return new a.FreeTextEditor(t)
                case s.AnnotationEditorType.INK:
                  return new r.InkEditor(t)
                case s.AnnotationEditorType.STAMP:
                  return new l.StampEditor(t)
              }
              return null
            }
            pasteEditor(t, e) {
              this.#Fe.updateToolbar(t)
              this.#Fe.updateMode(t)
              const { offsetX: i, offsetY: s } = this.#Le(),
                n = this.getNextId(),
                a = this.#Ie({ parent: this, id: n, x: i, y: s, uiManager: this.#Fe, isCentered: !0, ...e })
              a && this.add(a)
            }
            deserialize(t) {
              switch (t.annotationType ?? t.annotationEditorType) {
                case s.AnnotationEditorType.FREETEXT:
                  return a.FreeTextEditor.deserialize(t, this, this.#Fe)
                case s.AnnotationEditorType.INK:
                  return r.InkEditor.deserialize(t, this, this.#Fe)
                case s.AnnotationEditorType.STAMP:
                  return l.StampEditor.deserialize(t, this, this.#Fe)
              }
              return null
            }
            #De(t, e) {
              const i = this.getNextId(),
                s = this.#Ie({ parent: this, id: i, x: t.offsetX, y: t.offsetY, uiManager: this.#Fe, isCentered: e })
              s && this.add(s)
              return s
            }
            #Le() {
              const { x: t, y: e, width: i, height: s } = this.div.getBoundingClientRect(),
                n = Math.max(0, t),
                a = Math.max(0, e),
                r = (n + Math.min(window.innerWidth, t + i)) / 2 - t,
                o = (a + Math.min(window.innerHeight, e + s)) / 2 - e,
                [l, h] = this.viewport.rotation % 180 == 0 ? [r, o] : [o, r]
              return { offsetX: l, offsetY: h }
            }
            addNewEditor() {
              this.#De(this.#Le(), !0)
            }
            setSelected(t) {
              this.#Fe.setSelected(t)
            }
            toggleSelected(t) {
              this.#Fe.toggleSelected(t)
            }
            isSelected(t) {
              return this.#Fe.isSelected(t)
            }
            unselect(t) {
              this.#Fe.unselect(t)
            }
            pointerup(t) {
              const { isMac: e } = s.FeatureTest.platform
              if (!(0 !== t.button || (t.ctrlKey && e)) && t.target === this.div && this.#Pe) {
                this.#Pe = !1
                this.#Ee ? (this.#Fe.getMode() !== s.AnnotationEditorType.STAMP ? this.#De(t, !1) : this.#Fe.unselectAll()) : (this.#Ee = !0)
              }
            }
            pointerdown(t) {
              if (this.#Pe) {
                this.#Pe = !1
                return
              }
              const { isMac: e } = s.FeatureTest.platform
              if (0 !== t.button || (t.ctrlKey && e)) return
              if (t.target !== this.div) return
              this.#Pe = !0
              const i = this.#Fe.getActive()
              this.#Ee = !i || i.isEmpty()
            }
            findNewParent(t, e, i) {
              const s = this.#Fe.findParent(e, i)
              if (null === s || s === this) return !1
              s.changeParent(t)
              return !0
            }
            destroy() {
              if (this.#Fe.getActive()?.parent === this) {
                this.#Fe.commitOrRemove()
                this.#Fe.setActiveEditor(null)
              }
              for (const t of this.#Te.values()) {
                this.#Se?.removePointerInTextLayer(t.contentDiv)
                t.setParent(null)
                t.isAttachedToDOM = !1
                t.div.remove()
              }
              this.div = null
              this.#Te.clear()
              this.#Fe.removeLayer(this)
            }
            #Re() {
              this.#Me = !0
              for (const t of this.#Te.values()) t.isEmpty() && t.remove()
              this.#Me = !1
            }
            render({ viewport: t }) {
              this.viewport = t
              ;(0, o.setLayerDimensions)(this.div, t)
              for (const t of this.#Fe.getEditors(this.pageIndex)) this.add(t)
              this.updateMode()
            }
            update({ viewport: t }) {
              this.#Fe.commitOrRemove()
              this.viewport = t
              ;(0, o.setLayerDimensions)(this.div, { rotation: t.rotation })
              this.updateMode()
            }
            get pageDimensions() {
              const { pageWidth: t, pageHeight: e } = this.viewport.rawDims
              return [t, e]
            }
          }
          e.AnnotationEditorLayer = AnnotationEditorLayer
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.FreeTextEditor = void 0
          var s = i(1),
            n = i(5),
            a = i(4),
            r = i(29)
          class FreeTextEditor extends a.AnnotationEditor {
            #Oe = this.editorDivBlur.bind(this)
            #Ne = this.editorDivFocus.bind(this)
            #Be = this.editorDivInput.bind(this)
            #Ue = this.editorDivKeydown.bind(this)
            #je
            #ze = ''
            #He = `${this.id}-editor`
            #We
            #Ge = null
            static _freeTextDefaultContent = ''
            static _internalPadding = 0
            static _defaultColor = null
            static _defaultFontSize = 10
            static get _keyboardManager() {
              const t = FreeTextEditor.prototype,
                arrowChecker = (t) => t.isEmpty(),
                e = n.AnnotationEditorUIManager.TRANSLATE_SMALL,
                i = n.AnnotationEditorUIManager.TRANSLATE_BIG
              return (0, s.shadow)(
                this,
                '_keyboardManager',
                new n.KeyboardManager([
                  [['ctrl+s', 'mac+meta+s', 'ctrl+p', 'mac+meta+p'], t.commitOrRemove, { bubbles: !0 }],
                  [['ctrl+Enter', 'mac+meta+Enter', 'Escape', 'mac+Escape'], t.commitOrRemove],
                  [['ArrowLeft', 'mac+ArrowLeft'], t._translateEmpty, { args: [-e, 0], checker: arrowChecker }],
                  [['ctrl+ArrowLeft', 'mac+shift+ArrowLeft'], t._translateEmpty, { args: [-i, 0], checker: arrowChecker }],
                  [['ArrowRight', 'mac+ArrowRight'], t._translateEmpty, { args: [e, 0], checker: arrowChecker }],
                  [['ctrl+ArrowRight', 'mac+shift+ArrowRight'], t._translateEmpty, { args: [i, 0], checker: arrowChecker }],
                  [['ArrowUp', 'mac+ArrowUp'], t._translateEmpty, { args: [0, -e], checker: arrowChecker }],
                  [['ctrl+ArrowUp', 'mac+shift+ArrowUp'], t._translateEmpty, { args: [0, -i], checker: arrowChecker }],
                  [['ArrowDown', 'mac+ArrowDown'], t._translateEmpty, { args: [0, e], checker: arrowChecker }],
                  [['ctrl+ArrowDown', 'mac+shift+ArrowDown'], t._translateEmpty, { args: [0, i], checker: arrowChecker }],
                ])
              )
            }
            static _type = 'freetext'
            constructor(t) {
              super({ ...t, name: 'freeTextEditor' })
              this.#je = t.color || FreeTextEditor._defaultColor || a.AnnotationEditor._defaultLineColor
              this.#We = t.fontSize || FreeTextEditor._defaultFontSize
            }
            static initialize(t) {
              a.AnnotationEditor.initialize(t, { strings: ['free_text2_default_content', 'editor_free_text2_aria_label'] })
              const e = getComputedStyle(document.documentElement)
              this._internalPadding = parseFloat(e.getPropertyValue('--freetext-padding'))
            }
            static updateDefaultParams(t, e) {
              switch (t) {
                case s.AnnotationEditorParamsType.FREETEXT_SIZE:
                  FreeTextEditor._defaultFontSize = e
                  break
                case s.AnnotationEditorParamsType.FREETEXT_COLOR:
                  FreeTextEditor._defaultColor = e
              }
            }
            updateParams(t, e) {
              switch (t) {
                case s.AnnotationEditorParamsType.FREETEXT_SIZE:
                  this.#qe(e)
                  break
                case s.AnnotationEditorParamsType.FREETEXT_COLOR:
                  this.#Ve(e)
              }
            }
            static get defaultPropertiesToUpdate() {
              return [
                [s.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize],
                [s.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || a.AnnotationEditor._defaultLineColor],
              ]
            }
            get propertiesToUpdate() {
              return [
                [s.AnnotationEditorParamsType.FREETEXT_SIZE, this.#We],
                [s.AnnotationEditorParamsType.FREETEXT_COLOR, this.#je],
              ]
            }
            #qe(t) {
              const setFontsize = (t) => {
                  this.editorDiv.style.fontSize = `calc(${t}px * var(--scale-factor))`
                  this.translate(0, -(t - this.#We) * this.parentScale)
                  this.#We = t
                  this.#$e()
                },
                e = this.#We
              this.addCommands({
                cmd: () => {
                  setFontsize(t)
                },
                undo: () => {
                  setFontsize(e)
                },
                mustExec: !0,
                type: s.AnnotationEditorParamsType.FREETEXT_SIZE,
                overwriteIfSameType: !0,
                keepUndo: !0,
              })
            }
            #Ve(t) {
              const e = this.#je
              this.addCommands({
                cmd: () => {
                  this.#je = this.editorDiv.style.color = t
                },
                undo: () => {
                  this.#je = this.editorDiv.style.color = e
                },
                mustExec: !0,
                type: s.AnnotationEditorParamsType.FREETEXT_COLOR,
                overwriteIfSameType: !0,
                keepUndo: !0,
              })
            }
            _translateEmpty(t, e) {
              this._uiManager.translateSelectedEditors(t, e, !0)
            }
            getInitialTranslation() {
              const t = this.parentScale
              return [-FreeTextEditor._internalPadding * t, -(FreeTextEditor._internalPadding + this.#We) * t]
            }
            rebuild() {
              if (this.parent) {
                super.rebuild()
                null !== this.div && (this.isAttachedToDOM || this.parent.add(this))
              }
            }
            enableEditMode() {
              if (!this.isInEditMode()) {
                this.parent.setEditingState(!1)
                this.parent.updateToolbar(s.AnnotationEditorType.FREETEXT)
                super.enableEditMode()
                this.overlayDiv.classList.remove('enabled')
                this.editorDiv.contentEditable = !0
                this._isDraggable = !1
                this.div.removeAttribute('aria-activedescendant')
                this.editorDiv.addEventListener('keydown', this.#Ue)
                this.editorDiv.addEventListener('focus', this.#Ne)
                this.editorDiv.addEventListener('blur', this.#Oe)
                this.editorDiv.addEventListener('input', this.#Be)
              }
            }
            disableEditMode() {
              if (this.isInEditMode()) {
                this.parent.setEditingState(!0)
                super.disableEditMode()
                this.overlayDiv.classList.add('enabled')
                this.editorDiv.contentEditable = !1
                this.div.setAttribute('aria-activedescendant', this.#He)
                this._isDraggable = !0
                this.editorDiv.removeEventListener('keydown', this.#Ue)
                this.editorDiv.removeEventListener('focus', this.#Ne)
                this.editorDiv.removeEventListener('blur', this.#Oe)
                this.editorDiv.removeEventListener('input', this.#Be)
                this.div.focus({ preventScroll: !0 })
                this.isEditing = !1
                this.parent.div.classList.add('freeTextEditing')
              }
            }
            focusin(t) {
              if (this._focusEventsAllowed) {
                super.focusin(t)
                t.target !== this.editorDiv && this.editorDiv.focus()
              }
            }
            onceAdded() {
              if (this.width) this.#Xe()
              else {
                this.enableEditMode()
                this.editorDiv.focus()
                this._initialOptions?.isCentered && this.center()
                this._initialOptions = null
              }
            }
            isEmpty() {
              return !this.editorDiv || '' === this.editorDiv.innerText.trim()
            }
            remove() {
              this.isEditing = !1
              if (this.parent) {
                this.parent.setEditingState(!0)
                this.parent.div.classList.add('freeTextEditing')
              }
              super.remove()
            }
            #Ke() {
              const t = this.editorDiv.getElementsByTagName('div')
              if (0 === t.length) return this.editorDiv.innerText
              const e = []
              for (const i of t) e.push(i.innerText.replace(/\r\n?|\n/, ''))
              return e.join('\n')
            }
            #$e() {
              const [t, e] = this.parentDimensions
              let i
              if (this.isAttachedToDOM) i = this.div.getBoundingClientRect()
              else {
                const { currentLayer: t, div: e } = this,
                  s = e.style.display
                e.style.display = 'hidden'
                t.div.append(this.div)
                i = e.getBoundingClientRect()
                e.remove()
                e.style.display = s
              }
              if (this.rotation % 180 == this.parentRotation % 180) {
                this.width = i.width / t
                this.height = i.height / e
              } else {
                this.width = i.height / t
                this.height = i.width / e
              }
              this.fixAndSetPosition()
            }
            commit() {
              if (!this.isInEditMode()) return
              super.commit()
              this.disableEditMode()
              const t = this.#ze,
                e = (this.#ze = this.#Ke().trimEnd())
              if (t === e) return
              const setText = (t) => {
                this.#ze = t
                if (t) {
                  this.#Ye()
                  this._uiManager.rebuild(this)
                  this.#$e()
                } else this.remove()
              }
              this.addCommands({
                cmd: () => {
                  setText(e)
                },
                undo: () => {
                  setText(t)
                },
                mustExec: !1,
              })
              this.#$e()
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode()
            }
            enterInEditMode() {
              this.enableEditMode()
              this.editorDiv.focus()
            }
            dblclick(t) {
              this.enterInEditMode()
            }
            keydown(t) {
              if (t.target === this.div && 'Enter' === t.key) {
                this.enterInEditMode()
                t.preventDefault()
              }
            }
            editorDivKeydown(t) {
              FreeTextEditor._keyboardManager.exec(this, t)
            }
            editorDivFocus(t) {
              this.isEditing = !0
            }
            editorDivBlur(t) {
              this.isEditing = !1
            }
            editorDivInput(t) {
              this.parent.div.classList.toggle('freeTextEditing', this.isEmpty())
            }
            disableEditing() {
              this.editorDiv.setAttribute('role', 'comment')
              this.editorDiv.removeAttribute('aria-multiline')
            }
            enableEditing() {
              this.editorDiv.setAttribute('role', 'textbox')
              this.editorDiv.setAttribute('aria-multiline', !0)
            }
            render() {
              if (this.div) return this.div
              let t, e
              if (this.width) {
                t = this.x
                e = this.y
              }
              super.render()
              this.editorDiv = document.createElement('div')
              this.editorDiv.className = 'internal'
              this.editorDiv.setAttribute('id', this.#He)
              this.enableEditing()
              a.AnnotationEditor._l10nPromise.get('editor_free_text2_aria_label').then((t) => this.editorDiv?.setAttribute('aria-label', t))
              a.AnnotationEditor._l10nPromise.get('free_text2_default_content').then((t) => this.editorDiv?.setAttribute('default-content', t))
              this.editorDiv.contentEditable = !0
              const { style: i } = this.editorDiv
              i.fontSize = `calc(${this.#We}px * var(--scale-factor))`
              i.color = this.#je
              this.div.append(this.editorDiv)
              this.overlayDiv = document.createElement('div')
              this.overlayDiv.classList.add('overlay', 'enabled')
              this.div.append(this.overlayDiv)
              ;(0, n.bindEvents)(this, this.div, ['dblclick', 'keydown'])
              if (this.width) {
                const [i, s] = this.parentDimensions
                if (this.annotationElementId) {
                  const { position: n } = this.#Ge
                  let [a, r] = this.getInitialTranslation()
                  ;[a, r] = this.pageTranslationToScreen(a, r)
                  const [o, l] = this.pageDimensions,
                    [h, c] = this.pageTranslation
                  let d, u
                  switch (this.rotation) {
                    case 0:
                      d = t + (n[0] - h) / o
                      u = e + this.height - (n[1] - c) / l
                      break
                    case 90:
                      d = t + (n[0] - h) / o
                      u = e - (n[1] - c) / l
                      ;[a, r] = [r, -a]
                      break
                    case 180:
                      d = t - this.width + (n[0] - h) / o
                      u = e - (n[1] - c) / l
                      ;[a, r] = [-a, -r]
                      break
                    case 270:
                      d = t + (n[0] - h - this.height * l) / o
                      u = e + (n[1] - c - this.width * o) / l
                      ;[a, r] = [-r, a]
                  }
                  this.setAt(d * i, u * s, a, r)
                } else this.setAt(t * i, e * s, this.width * i, this.height * s)
                this.#Ye()
                this._isDraggable = !0
                this.editorDiv.contentEditable = !1
              } else {
                this._isDraggable = !1
                this.editorDiv.contentEditable = !0
              }
              return this.div
            }
            #Ye() {
              this.editorDiv.replaceChildren()
              if (this.#ze)
                for (const t of this.#ze.split('\n')) {
                  const e = document.createElement('div')
                  e.append(t ? document.createTextNode(t) : document.createElement('br'))
                  this.editorDiv.append(e)
                }
            }
            get contentDiv() {
              return this.editorDiv
            }
            static deserialize(t, e, i) {
              let n = null
              if (t instanceof r.FreeTextAnnotationElement) {
                const {
                  data: {
                    defaultAppearanceData: { fontSize: e, fontColor: i },
                    rect: a,
                    rotation: r,
                    id: o,
                  },
                  textContent: l,
                  textPosition: h,
                  parent: {
                    page: { pageNumber: c },
                  },
                } = t
                if (!l || 0 === l.length) return null
                n = t = { annotationType: s.AnnotationEditorType.FREETEXT, color: Array.from(i), fontSize: e, value: l.join('\n'), position: h, pageIndex: c - 1, rect: a, rotation: r, id: o, deleted: !1 }
              }
              const a = super.deserialize(t, e, i)
              a.#We = t.fontSize
              a.#je = s.Util.makeHexColor(...t.color)
              a.#ze = t.value
              a.annotationElementId = t.id || null
              a.#Ge = n
              return a
            }
            serialize(t = !1) {
              if (this.isEmpty()) return null
              if (this.deleted) return { pageIndex: this.pageIndex, id: this.annotationElementId, deleted: !0 }
              const e = FreeTextEditor._internalPadding * this.parentScale,
                i = this.getRect(e, e),
                n = a.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#je),
                r = { annotationType: s.AnnotationEditorType.FREETEXT, color: n, fontSize: this.#We, value: this.#ze, pageIndex: this.pageIndex, rect: i, rotation: this.rotation, structTreeParentId: this._structTreeParentId }
              if (t) return r
              if (this.annotationElementId && !this.#Je(r)) return null
              r.id = this.annotationElementId
              return r
            }
            #Je(t) {
              const { value: e, fontSize: i, color: s, rect: n, pageIndex: a } = this.#Ge
              return t.value !== e || t.fontSize !== i || t.rect.some((t, e) => Math.abs(t - n[e]) >= 1) || t.color.some((t, e) => t !== s[e]) || t.pageIndex !== a
            }
            #Xe(t = !1) {
              if (!this.annotationElementId) return
              this.#$e()
              if (!t && (0 === this.width || 0 === this.height)) {
                setTimeout(() => this.#Xe(!0), 0)
                return
              }
              const e = FreeTextEditor._internalPadding * this.parentScale
              this.#Ge.rect = this.getRect(e, e)
            }
          }
          e.FreeTextEditor = FreeTextEditor
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.StampAnnotationElement = e.InkAnnotationElement = e.FreeTextAnnotationElement = e.AnnotationLayer = void 0
          var s = i(1),
            n = i(6),
            a = i(3),
            r = i(30),
            o = i(31),
            l = i(32)
          const h = 1e3,
            c = new WeakSet()
          function getRectDims(t) {
            return { width: t[2] - t[0], height: t[3] - t[1] }
          }
          class AnnotationElementFactory {
            static create(t) {
              switch (t.data.annotationType) {
                case s.AnnotationType.LINK:
                  return new LinkAnnotationElement(t)
                case s.AnnotationType.TEXT:
                  return new TextAnnotationElement(t)
                case s.AnnotationType.WIDGET:
                  switch (t.data.fieldType) {
                    case 'Tx':
                      return new TextWidgetAnnotationElement(t)
                    case 'Btn':
                      return t.data.radioButton ? new RadioButtonWidgetAnnotationElement(t) : t.data.checkBox ? new CheckboxWidgetAnnotationElement(t) : new PushButtonWidgetAnnotationElement(t)
                    case 'Ch':
                      return new ChoiceWidgetAnnotationElement(t)
                    case 'Sig':
                      return new SignatureWidgetAnnotationElement(t)
                  }
                  return new WidgetAnnotationElement(t)
                case s.AnnotationType.POPUP:
                  return new PopupAnnotationElement(t)
                case s.AnnotationType.FREETEXT:
                  return new FreeTextAnnotationElement(t)
                case s.AnnotationType.LINE:
                  return new LineAnnotationElement(t)
                case s.AnnotationType.SQUARE:
                  return new SquareAnnotationElement(t)
                case s.AnnotationType.CIRCLE:
                  return new CircleAnnotationElement(t)
                case s.AnnotationType.POLYLINE:
                  return new PolylineAnnotationElement(t)
                case s.AnnotationType.CARET:
                  return new CaretAnnotationElement(t)
                case s.AnnotationType.INK:
                  return new InkAnnotationElement(t)
                case s.AnnotationType.POLYGON:
                  return new PolygonAnnotationElement(t)
                case s.AnnotationType.HIGHLIGHT:
                  return new HighlightAnnotationElement(t)
                case s.AnnotationType.UNDERLINE:
                  return new UnderlineAnnotationElement(t)
                case s.AnnotationType.SQUIGGLY:
                  return new SquigglyAnnotationElement(t)
                case s.AnnotationType.STRIKEOUT:
                  return new StrikeOutAnnotationElement(t)
                case s.AnnotationType.STAMP:
                  return new StampAnnotationElement(t)
                case s.AnnotationType.FILEATTACHMENT:
                  return new FileAttachmentAnnotationElement(t)
                default:
                  return new AnnotationElement(t)
              }
            }
          }
          class AnnotationElement {
            #Qe = !1
            constructor(t, { isRenderable: e = !1, ignoreBorder: i = !1, createQuadrilaterals: s = !1 } = {}) {
              this.isRenderable = e
              this.data = t.data
              this.layer = t.layer
              this.linkService = t.linkService
              this.downloadManager = t.downloadManager
              this.imageResourcesPath = t.imageResourcesPath
              this.renderForms = t.renderForms
              this.svgFactory = t.svgFactory
              this.annotationStorage = t.annotationStorage
              this.enableScripting = t.enableScripting
              this.hasJSActions = t.hasJSActions
              this._fieldObjects = t.fieldObjects
              this.parent = t.parent
              e && (this.container = this._createContainer(i))
              s && this._createQuadrilaterals()
            }
            static _hasPopupData({ titleObj: t, contentsObj: e, richText: i }) {
              return !!(t?.str || e?.str || i?.str)
            }
            get hasPopupData() {
              return AnnotationElement._hasPopupData(this.data)
            }
            _createContainer(t) {
              const {
                  data: e,
                  parent: { page: i, viewport: n },
                } = this,
                a = document.createElement('section')
              a.setAttribute('data-annotation-id', e.id)
              this instanceof WidgetAnnotationElement || (a.tabIndex = h)
              a.style.zIndex = this.parent.zIndex++
              this.data.popupRef && a.setAttribute('aria-haspopup', 'dialog')
              e.noRotate && a.classList.add('norotate')
              const { pageWidth: r, pageHeight: o, pageX: l, pageY: c } = n.rawDims
              if (!e.rect || this instanceof PopupAnnotationElement) {
                const { rotation: t } = e
                e.hasOwnCanvas || 0 === t || this.setRotation(t, a)
                return a
              }
              const { width: d, height: u } = getRectDims(e.rect),
                p = s.Util.normalizeRect([e.rect[0], i.view[3] - e.rect[1] + i.view[1], e.rect[2], i.view[3] - e.rect[3] + i.view[1]])
              if (!t && e.borderStyle.width > 0) {
                a.style.borderWidth = `${e.borderStyle.width}px`
                const t = e.borderStyle.horizontalCornerRadius,
                  i = e.borderStyle.verticalCornerRadius
                if (t > 0 || i > 0) {
                  const e = `calc(${t}px * var(--scale-factor)) / calc(${i}px * var(--scale-factor))`
                  a.style.borderRadius = e
                } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                  const t = `calc(${d}px * var(--scale-factor)) / calc(${u}px * var(--scale-factor))`
                  a.style.borderRadius = t
                }
                switch (e.borderStyle.style) {
                  case s.AnnotationBorderStyleType.SOLID:
                    a.style.borderStyle = 'solid'
                    break
                  case s.AnnotationBorderStyleType.DASHED:
                    a.style.borderStyle = 'dashed'
                    break
                  case s.AnnotationBorderStyleType.BEVELED:
                    ;(0, s.warn)('Unimplemented border style: beveled')
                    break
                  case s.AnnotationBorderStyleType.INSET:
                    ;(0, s.warn)('Unimplemented border style: inset')
                    break
                  case s.AnnotationBorderStyleType.UNDERLINE:
                    a.style.borderBottomStyle = 'solid'
                }
                const n = e.borderColor || null
                if (n) {
                  this.#Qe = !0
                  a.style.borderColor = s.Util.makeHexColor(0 | n[0], 0 | n[1], 0 | n[2])
                } else a.style.borderWidth = 0
              }
              a.style.left = (100 * (p[0] - l)) / r + '%'
              a.style.top = (100 * (p[1] - c)) / o + '%'
              const { rotation: g } = e
              if (e.hasOwnCanvas || 0 === g) {
                a.style.width = (100 * d) / r + '%'
                a.style.height = (100 * u) / o + '%'
              } else this.setRotation(g, a)
              return a
            }
            setRotation(t, e = this.container) {
              if (!this.data.rect) return
              const { pageWidth: i, pageHeight: s } = this.parent.viewport.rawDims,
                { width: n, height: a } = getRectDims(this.data.rect)
              let r, o
              if (t % 180 == 0) {
                r = (100 * n) / i
                o = (100 * a) / s
              } else {
                r = (100 * a) / i
                o = (100 * n) / s
              }
              e.style.width = `${r}%`
              e.style.height = `${o}%`
              e.setAttribute('data-main-rotation', (360 - t) % 360)
            }
            get _commonActions() {
              const setColor = (t, e, i) => {
                const s = i.detail[t],
                  n = s[0],
                  a = s.slice(1)
                i.target.style[e] = r.ColorConverters[`${n}_HTML`](a)
                this.annotationStorage.setValue(this.data.id, { [e]: r.ColorConverters[`${n}_rgb`](a) })
              }
              return (0, s.shadow)(this, '_commonActions', {
                display: (t) => {
                  const { display: e } = t.detail,
                    i = e % 2 == 1
                  this.container.style.visibility = i ? 'hidden' : 'visible'
                  this.annotationStorage.setValue(this.data.id, { noView: i, noPrint: 1 === e || 2 === e })
                },
                print: (t) => {
                  this.annotationStorage.setValue(this.data.id, { noPrint: !t.detail.print })
                },
                hidden: (t) => {
                  const { hidden: e } = t.detail
                  this.container.style.visibility = e ? 'hidden' : 'visible'
                  this.annotationStorage.setValue(this.data.id, { noPrint: e, noView: e })
                },
                focus: (t) => {
                  setTimeout(() => t.target.focus({ preventScroll: !1 }), 0)
                },
                userName: (t) => {
                  t.target.title = t.detail.userName
                },
                readonly: (t) => {
                  t.target.disabled = t.detail.readonly
                },
                required: (t) => {
                  this._setRequired(t.target, t.detail.required)
                },
                bgColor: (t) => {
                  setColor('bgColor', 'backgroundColor', t)
                },
                fillColor: (t) => {
                  setColor('fillColor', 'backgroundColor', t)
                },
                fgColor: (t) => {
                  setColor('fgColor', 'color', t)
                },
                textColor: (t) => {
                  setColor('textColor', 'color', t)
                },
                borderColor: (t) => {
                  setColor('borderColor', 'borderColor', t)
                },
                strokeColor: (t) => {
                  setColor('strokeColor', 'borderColor', t)
                },
                rotation: (t) => {
                  const e = t.detail.rotation
                  this.setRotation(e)
                  this.annotationStorage.setValue(this.data.id, { rotation: e })
                },
              })
            }
            _dispatchEventFromSandbox(t, e) {
              const i = this._commonActions
              for (const s of Object.keys(e.detail)) {
                const n = t[s] || i[s]
                n?.(e)
              }
            }
            _setDefaultPropertiesFromJS(t) {
              if (!this.enableScripting) return
              const e = this.annotationStorage.getRawValue(this.data.id)
              if (!e) return
              const i = this._commonActions
              for (const [s, n] of Object.entries(e)) {
                const a = i[s]
                if (a) {
                  a({ detail: { [s]: n }, target: t })
                  delete e[s]
                }
              }
            }
            _createQuadrilaterals() {
              if (!this.container) return
              const { quadPoints: t } = this.data
              if (!t) return
              const [e, i, s, n] = this.data.rect
              if (1 === t.length) {
                const [, { x: a, y: r }, { x: o, y: l }] = t[0]
                if (s === a && n === r && e === o && i === l) return
              }
              const { style: a } = this.container
              let r
              if (this.#Qe) {
                const { borderColor: t, borderWidth: e } = a
                a.borderWidth = 0
                r = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${t}" stroke-width="${e}">`]
                this.container.classList.add('hasBorder')
              }
              const o = s - e,
                l = n - i,
                { svgFactory: h } = this,
                c = h.createElement('svg')
              c.classList.add('quadrilateralsContainer')
              c.setAttribute('width', 0)
              c.setAttribute('height', 0)
              const d = h.createElement('defs')
              c.append(d)
              const u = h.createElement('clipPath'),
                p = `clippath_${this.data.id}`
              u.setAttribute('id', p)
              u.setAttribute('clipPathUnits', 'objectBoundingBox')
              d.append(u)
              for (const [, { x: i, y: s }, { x: a, y: c }] of t) {
                const t = h.createElement('rect'),
                  d = (a - e) / o,
                  p = (n - s) / l,
                  g = (i - a) / o,
                  m = (s - c) / l
                t.setAttribute('x', d)
                t.setAttribute('y', p)
                t.setAttribute('width', g)
                t.setAttribute('height', m)
                u.append(t)
                r?.push(`<rect vector-effect="non-scaling-stroke" x="${d}" y="${p}" width="${g}" height="${m}"/>`)
              }
              if (this.#Qe) {
                r.push("</g></svg>')")
                a.backgroundImage = r.join('')
              }
              this.container.append(c)
              this.container.style.clipPath = `url(#${p})`
            }
            _createPopup() {
              const { container: t, data: e } = this
              t.setAttribute('aria-haspopup', 'dialog')
              const i = new PopupAnnotationElement({
                data: { color: e.color, titleObj: e.titleObj, modificationDate: e.modificationDate, contentsObj: e.contentsObj, richText: e.richText, parentRect: e.rect, borderStyle: 0, id: `popup_${e.id}`, rotation: e.rotation },
                parent: this.parent,
                elements: [this],
              })
              this.parent.div.append(i.render())
            }
            render() {
              ;(0, s.unreachable)('Abstract method `AnnotationElement.render` called')
            }
            _getElementsByName(t, e = null) {
              const i = []
              if (this._fieldObjects) {
                const n = this._fieldObjects[t]
                if (n)
                  for (const { page: t, id: a, exportValues: r } of n) {
                    if (-1 === t) continue
                    if (a === e) continue
                    const n = 'string' == typeof r ? r : null,
                      o = document.querySelector(`[data-element-id="${a}"]`)
                    !o || c.has(o) ? i.push({ id: a, exportValue: n, domElement: o }) : (0, s.warn)(`_getElementsByName - element not allowed: ${a}`)
                  }
                return i
              }
              for (const s of document.getElementsByName(t)) {
                const { exportValue: t } = s,
                  n = s.getAttribute('data-element-id')
                n !== e && c.has(s) && i.push({ id: n, exportValue: t, domElement: s })
              }
              return i
            }
            show() {
              this.container && (this.container.hidden = !1)
              this.popup?.maybeShow()
            }
            hide() {
              this.container && (this.container.hidden = !0)
              this.popup?.forceHide()
            }
            getElementsToTriggerPopup() {
              return this.container
            }
            addHighlightArea() {
              const t = this.getElementsToTriggerPopup()
              if (Array.isArray(t)) for (const e of t) e.classList.add('highlightArea')
              else t.classList.add('highlightArea')
            }
            _editOnDoubleClick() {
              const {
                annotationEditorType: t,
                data: { id: e },
              } = this
              this.container.addEventListener('dblclick', () => {
                this.linkService.eventBus?.dispatch('switchannotationeditormode', { source: this, mode: t, editId: e })
              })
            }
          }
          class LinkAnnotationElement extends AnnotationElement {
            constructor(t, e = null) {
              super(t, { isRenderable: !0, ignoreBorder: !!e?.ignoreBorder, createQuadrilaterals: !0 })
              this.isTooltipOnly = t.data.isTooltipOnly
            }
            render() {
              const { data: t, linkService: e } = this,
                i = document.createElement('a')
              i.setAttribute('data-element-id', t.id)
              let s = !1
              if (t.url) {
                e.addLinkAttributes(i, t.url, t.newWindow)
                s = !0
              } else if (t.action) {
                this._bindNamedAction(i, t.action)
                s = !0
              } else if (t.attachment) {
                this._bindAttachment(i, t.attachment)
                s = !0
              } else if (t.setOCGState) {
                this.#Ze(i, t.setOCGState)
                s = !0
              } else if (t.dest) {
                this._bindLink(i, t.dest)
                s = !0
              } else {
                if (t.actions && (t.actions.Action || t.actions['Mouse Up'] || t.actions['Mouse Down']) && this.enableScripting && this.hasJSActions) {
                  this._bindJSAction(i, t)
                  s = !0
                }
                if (t.resetForm) {
                  this._bindResetFormAction(i, t.resetForm)
                  s = !0
                } else if (this.isTooltipOnly && !s) {
                  this._bindLink(i, '')
                  s = !0
                }
              }
              this.container.classList.add('linkAnnotation')
              s && this.container.append(i)
              return this.container
            }
            #ti() {
              this.container.setAttribute('data-internal-link', '')
            }
            _bindLink(t, e) {
              t.href = this.linkService.getDestinationHash(e)
              t.onclick = () => {
                e && this.linkService.goToDestination(e)
                return !1
              }
              ;(e || '' === e) && this.#ti()
            }
            _bindNamedAction(t, e) {
              t.href = this.linkService.getAnchorUrl('')
              t.onclick = () => {
                this.linkService.executeNamedAction(e)
                return !1
              }
              this.#ti()
            }
            _bindAttachment(t, e) {
              t.href = this.linkService.getAnchorUrl('')
              t.onclick = () => {
                this.downloadManager?.openOrDownloadData(this.container, e.content, e.filename)
                return !1
              }
              this.#ti()
            }
            #Ze(t, e) {
              t.href = this.linkService.getAnchorUrl('')
              t.onclick = () => {
                this.linkService.executeSetOCGState(e)
                return !1
              }
              this.#ti()
            }
            _bindJSAction(t, e) {
              t.href = this.linkService.getAnchorUrl('')
              const i = new Map([
                ['Action', 'onclick'],
                ['Mouse Up', 'onmouseup'],
                ['Mouse Down', 'onmousedown'],
              ])
              for (const s of Object.keys(e.actions)) {
                const n = i.get(s)
                n &&
                  (t[n] = () => {
                    this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e.id, name: s } })
                    return !1
                  })
              }
              t.onclick || (t.onclick = () => !1)
              this.#ti()
            }
            _bindResetFormAction(t, e) {
              const i = t.onclick
              i || (t.href = this.linkService.getAnchorUrl(''))
              this.#ti()
              if (this._fieldObjects)
                t.onclick = () => {
                  i?.()
                  const { fields: t, refs: n, include: a } = e,
                    r = []
                  if (0 !== t.length || 0 !== n.length) {
                    const e = new Set(n)
                    for (const i of t) {
                      const t = this._fieldObjects[i] || []
                      for (const { id: i } of t) e.add(i)
                    }
                    for (const t of Object.values(this._fieldObjects)) for (const i of t) e.has(i.id) === a && r.push(i)
                  } else for (const t of Object.values(this._fieldObjects)) r.push(...t)
                  const o = this.annotationStorage,
                    l = []
                  for (const t of r) {
                    const { id: e } = t
                    l.push(e)
                    switch (t.type) {
                      case 'text': {
                        const i = t.defaultValue || ''
                        o.setValue(e, { value: i })
                        break
                      }
                      case 'checkbox':
                      case 'radiobutton': {
                        const i = t.defaultValue === t.exportValues
                        o.setValue(e, { value: i })
                        break
                      }
                      case 'combobox':
                      case 'listbox': {
                        const i = t.defaultValue || ''
                        o.setValue(e, { value: i })
                        break
                      }
                      default:
                        continue
                    }
                    const i = document.querySelector(`[data-element-id="${e}"]`)
                    i && (c.has(i) ? i.dispatchEvent(new Event('resetform')) : (0, s.warn)(`_bindResetFormAction - element not allowed: ${e}`))
                  }
                  this.enableScripting && this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: 'app', ids: l, name: 'ResetForm' } })
                  return !1
                }
              else {
                ;(0, s.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.')
                i || (t.onclick = () => !1)
              }
            }
          }
          class TextAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0 })
            }
            render() {
              this.container.classList.add('textAnnotation')
              const t = document.createElement('img')
              t.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg'
              t.alt = '[{{type}} Annotation]'
              t.dataset.l10nId = 'text_annotation_type'
              t.dataset.l10nArgs = JSON.stringify({ type: this.data.name })
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this.container.append(t)
              return this.container
            }
          }
          class WidgetAnnotationElement extends AnnotationElement {
            render() {
              this.data.alternativeText && (this.container.title = this.data.alternativeText)
              return this.container
            }
            showElementAndHideCanvas(t) {
              if (this.data.hasOwnCanvas) {
                'CANVAS' === t.previousSibling?.nodeName && (t.previousSibling.hidden = !0)
                t.hidden = !1
              }
            }
            _getKeyModifier(t) {
              const { isWin: e, isMac: i } = s.FeatureTest.platform
              return (e && t.ctrlKey) || (i && t.metaKey)
            }
            _setEventListener(t, e, i, s, n) {
              i.includes('mouse')
                ? t.addEventListener(i, (t) => {
                    this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: this.data.id, name: s, value: n(t), shift: t.shiftKey, modifier: this._getKeyModifier(t) } })
                  })
                : t.addEventListener(i, (t) => {
                    if ('blur' === i) {
                      if (!e.focused || !t.relatedTarget) return
                      e.focused = !1
                    } else if ('focus' === i) {
                      if (e.focused) return
                      e.focused = !0
                    }
                    n && this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: this.data.id, name: s, value: n(t) } })
                  })
            }
            _setEventListeners(t, e, i, s) {
              for (const [n, a] of i)
                if ('Action' === a || this.data.actions?.[a]) {
                  ;('Focus' !== a && 'Blur' !== a) || (e ||= { focused: !1 })
                  this._setEventListener(t, e, n, a, s)
                  'Focus' !== a || this.data.actions?.Blur ? 'Blur' !== a || this.data.actions?.Focus || this._setEventListener(t, e, 'focus', 'Focus', null) : this._setEventListener(t, e, 'blur', 'Blur', null)
                }
            }
            _setBackgroundColor(t) {
              const e = this.data.backgroundColor || null
              t.style.backgroundColor = null === e ? 'transparent' : s.Util.makeHexColor(e[0], e[1], e[2])
            }
            _setTextStyle(t) {
              const e = ['left', 'center', 'right'],
                { fontColor: i } = this.data.defaultAppearanceData,
                n = this.data.defaultAppearanceData.fontSize || 9,
                a = t.style
              let r
              const roundToOneDecimal = (t) => Math.round(10 * t) / 10
              if (this.data.multiLine) {
                const t = Math.abs(this.data.rect[3] - this.data.rect[1] - 2),
                  e = t / (Math.round(t / (s.LINE_FACTOR * n)) || 1)
                r = Math.min(n, roundToOneDecimal(e / s.LINE_FACTOR))
              } else {
                const t = Math.abs(this.data.rect[3] - this.data.rect[1] - 2)
                r = Math.min(n, roundToOneDecimal(t / s.LINE_FACTOR))
              }
              a.fontSize = `calc(${r}px * var(--scale-factor))`
              a.color = s.Util.makeHexColor(i[0], i[1], i[2])
              null !== this.data.textAlignment && (a.textAlign = e[this.data.textAlignment])
            }
            _setRequired(t, e) {
              e ? t.setAttribute('required', !0) : t.removeAttribute('required')
              t.setAttribute('aria-required', e)
            }
          }
          class TextWidgetAnnotationElement extends WidgetAnnotationElement {
            constructor(t) {
              super(t, { isRenderable: t.renderForms || (!t.data.hasAppearance && !!t.data.fieldValue) })
            }
            setPropertyOnSiblings(t, e, i, s) {
              const n = this.annotationStorage
              for (const a of this._getElementsByName(t.name, t.id)) {
                a.domElement && (a.domElement[e] = i)
                n.setValue(a.id, { [s]: i })
              }
            }
            render() {
              const t = this.annotationStorage,
                e = this.data.id
              this.container.classList.add('textWidgetAnnotation')
              let i = null
              if (this.renderForms) {
                const s = t.getValue(e, { value: this.data.fieldValue })
                let n = s.value || ''
                const a = t.getValue(e, { charLimit: this.data.maxLen }).charLimit
                a && n.length > a && (n = n.slice(0, a))
                let r = s.formattedValue || this.data.textContent?.join('\n') || null
                r && this.data.comb && (r = r.replaceAll(/\s+/g, ''))
                const o = { userValue: n, formattedValue: r, lastCommittedValue: null, commitKey: 1, focused: !1 }
                if (this.data.multiLine) {
                  i = document.createElement('textarea')
                  i.textContent = r ?? n
                  this.data.doNotScroll && (i.style.overflowY = 'hidden')
                } else {
                  i = document.createElement('input')
                  i.type = 'text'
                  i.setAttribute('value', r ?? n)
                  this.data.doNotScroll && (i.style.overflowX = 'hidden')
                }
                this.data.hasOwnCanvas && (i.hidden = !0)
                c.add(i)
                i.setAttribute('data-element-id', e)
                i.disabled = this.data.readOnly
                i.name = this.data.fieldName
                i.tabIndex = h
                this._setRequired(i, this.data.required)
                a && (i.maxLength = a)
                i.addEventListener('input', (s) => {
                  t.setValue(e, { value: s.target.value })
                  this.setPropertyOnSiblings(i, 'value', s.target.value, 'value')
                  o.formattedValue = null
                })
                i.addEventListener('resetform', (t) => {
                  const e = this.data.defaultFieldValue ?? ''
                  i.value = o.userValue = e
                  o.formattedValue = null
                })
                let blurListener = (t) => {
                  const { formattedValue: e } = o
                  null != e && (t.target.value = e)
                  t.target.scrollLeft = 0
                }
                if (this.enableScripting && this.hasJSActions) {
                  i.addEventListener('focus', (t) => {
                    if (o.focused) return
                    const { target: e } = t
                    o.userValue && (e.value = o.userValue)
                    o.lastCommittedValue = e.value
                    o.commitKey = 1
                    o.focused = !0
                  })
                  i.addEventListener('updatefromsandbox', (i) => {
                    this.showElementAndHideCanvas(i.target)
                    const s = {
                      value(i) {
                        o.userValue = i.detail.value ?? ''
                        t.setValue(e, { value: o.userValue.toString() })
                        i.target.value = o.userValue
                      },
                      formattedValue(i) {
                        const { formattedValue: s } = i.detail
                        o.formattedValue = s
                        null != s && i.target !== document.activeElement && (i.target.value = s)
                        t.setValue(e, { formattedValue: s })
                      },
                      selRange(t) {
                        t.target.setSelectionRange(...t.detail.selRange)
                      },
                      charLimit: (i) => {
                        const { charLimit: s } = i.detail,
                          { target: n } = i
                        if (0 === s) {
                          n.removeAttribute('maxLength')
                          return
                        }
                        n.setAttribute('maxLength', s)
                        let a = o.userValue
                        if (a && !(a.length <= s)) {
                          a = a.slice(0, s)
                          n.value = o.userValue = a
                          t.setValue(e, { value: a })
                          this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e, name: 'Keystroke', value: a, willCommit: !0, commitKey: 1, selStart: n.selectionStart, selEnd: n.selectionEnd } })
                        }
                      },
                    }
                    this._dispatchEventFromSandbox(s, i)
                  })
                  i.addEventListener('keydown', (t) => {
                    o.commitKey = 1
                    let i = -1
                    'Escape' === t.key ? (i = 0) : 'Enter' !== t.key || this.data.multiLine ? 'Tab' === t.key && (o.commitKey = 3) : (i = 2)
                    if (-1 === i) return
                    const { value: s } = t.target
                    if (o.lastCommittedValue !== s) {
                      o.lastCommittedValue = s
                      o.userValue = s
                      this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e, name: 'Keystroke', value: s, willCommit: !0, commitKey: i, selStart: t.target.selectionStart, selEnd: t.target.selectionEnd } })
                    }
                  })
                  const s = blurListener
                  blurListener = null
                  i.addEventListener('blur', (t) => {
                    if (!o.focused || !t.relatedTarget) return
                    o.focused = !1
                    const { value: i } = t.target
                    o.userValue = i
                    o.lastCommittedValue !== i && this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e, name: 'Keystroke', value: i, willCommit: !0, commitKey: o.commitKey, selStart: t.target.selectionStart, selEnd: t.target.selectionEnd } })
                    s(t)
                  })
                  this.data.actions?.Keystroke &&
                    i.addEventListener('beforeinput', (t) => {
                      o.lastCommittedValue = null
                      const { data: i, target: s } = t,
                        { value: n, selectionStart: a, selectionEnd: r } = s
                      let l = a,
                        h = r
                      switch (t.inputType) {
                        case 'deleteWordBackward': {
                          const t = n.substring(0, a).match(/\w*[^\w]*$/)
                          t && (l -= t[0].length)
                          break
                        }
                        case 'deleteWordForward': {
                          const t = n.substring(a).match(/^[^\w]*\w*/)
                          t && (h += t[0].length)
                          break
                        }
                        case 'deleteContentBackward':
                          a === r && (l -= 1)
                          break
                        case 'deleteContentForward':
                          a === r && (h += 1)
                      }
                      t.preventDefault()
                      this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e, name: 'Keystroke', value: n, change: i || '', willCommit: !1, selStart: l, selEnd: h } })
                    })
                  this._setEventListeners(
                    i,
                    o,
                    [
                      ['focus', 'Focus'],
                      ['blur', 'Blur'],
                      ['mousedown', 'Mouse Down'],
                      ['mouseenter', 'Mouse Enter'],
                      ['mouseleave', 'Mouse Exit'],
                      ['mouseup', 'Mouse Up'],
                    ],
                    (t) => t.target.value
                  )
                }
                blurListener && i.addEventListener('blur', blurListener)
                if (this.data.comb) {
                  const t = (this.data.rect[2] - this.data.rect[0]) / a
                  i.classList.add('comb')
                  i.style.letterSpacing = `calc(${t}px * var(--scale-factor) - 1ch)`
                }
              } else {
                i = document.createElement('div')
                i.textContent = this.data.fieldValue
                i.style.verticalAlign = 'middle'
                i.style.display = 'table-cell'
              }
              this._setTextStyle(i)
              this._setBackgroundColor(i)
              this._setDefaultPropertiesFromJS(i)
              this.container.append(i)
              return this.container
            }
          }
          class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !!t.data.hasOwnCanvas })
            }
          }
          class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
            constructor(t) {
              super(t, { isRenderable: t.renderForms })
            }
            render() {
              const t = this.annotationStorage,
                e = this.data,
                i = e.id
              let s = t.getValue(i, { value: e.exportValue === e.fieldValue }).value
              if ('string' == typeof s) {
                s = 'Off' !== s
                t.setValue(i, { value: s })
              }
              this.container.classList.add('buttonWidgetAnnotation', 'checkBox')
              const n = document.createElement('input')
              c.add(n)
              n.setAttribute('data-element-id', i)
              n.disabled = e.readOnly
              this._setRequired(n, this.data.required)
              n.type = 'checkbox'
              n.name = e.fieldName
              s && n.setAttribute('checked', !0)
              n.setAttribute('exportValue', e.exportValue)
              n.tabIndex = h
              n.addEventListener('change', (s) => {
                const { name: n, checked: a } = s.target
                for (const s of this._getElementsByName(n, i)) {
                  const i = a && s.exportValue === e.exportValue
                  s.domElement && (s.domElement.checked = i)
                  t.setValue(s.id, { value: i })
                }
                t.setValue(i, { value: a })
              })
              n.addEventListener('resetform', (t) => {
                const i = e.defaultFieldValue || 'Off'
                t.target.checked = i === e.exportValue
              })
              if (this.enableScripting && this.hasJSActions) {
                n.addEventListener('updatefromsandbox', (e) => {
                  const s = {
                    value(e) {
                      e.target.checked = 'Off' !== e.detail.value
                      t.setValue(i, { value: e.target.checked })
                    },
                  }
                  this._dispatchEventFromSandbox(s, e)
                })
                this._setEventListeners(
                  n,
                  null,
                  [
                    ['change', 'Validate'],
                    ['change', 'Action'],
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up'],
                  ],
                  (t) => t.target.checked
                )
              }
              this._setBackgroundColor(n)
              this._setDefaultPropertiesFromJS(n)
              this.container.append(n)
              return this.container
            }
          }
          class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
            constructor(t) {
              super(t, { isRenderable: t.renderForms })
            }
            render() {
              this.container.classList.add('buttonWidgetAnnotation', 'radioButton')
              const t = this.annotationStorage,
                e = this.data,
                i = e.id
              let s = t.getValue(i, { value: e.fieldValue === e.buttonValue }).value
              if ('string' == typeof s) {
                s = s !== e.buttonValue
                t.setValue(i, { value: s })
              }
              const n = document.createElement('input')
              c.add(n)
              n.setAttribute('data-element-id', i)
              n.disabled = e.readOnly
              this._setRequired(n, this.data.required)
              n.type = 'radio'
              n.name = e.fieldName
              s && n.setAttribute('checked', !0)
              n.tabIndex = h
              n.addEventListener('change', (e) => {
                const { name: s, checked: n } = e.target
                for (const e of this._getElementsByName(s, i)) t.setValue(e.id, { value: !1 })
                t.setValue(i, { value: n })
              })
              n.addEventListener('resetform', (t) => {
                const i = e.defaultFieldValue
                t.target.checked = null != i && i === e.buttonValue
              })
              if (this.enableScripting && this.hasJSActions) {
                const s = e.buttonValue
                n.addEventListener('updatefromsandbox', (e) => {
                  const n = {
                    value: (e) => {
                      const n = s === e.detail.value
                      for (const s of this._getElementsByName(e.target.name)) {
                        const e = n && s.id === i
                        s.domElement && (s.domElement.checked = e)
                        t.setValue(s.id, { value: e })
                      }
                    },
                  }
                  this._dispatchEventFromSandbox(n, e)
                })
                this._setEventListeners(
                  n,
                  null,
                  [
                    ['change', 'Validate'],
                    ['change', 'Action'],
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up'],
                  ],
                  (t) => t.target.checked
                )
              }
              this._setBackgroundColor(n)
              this._setDefaultPropertiesFromJS(n)
              this.container.append(n)
              return this.container
            }
          }
          class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
            constructor(t) {
              super(t, { ignoreBorder: t.data.hasAppearance })
            }
            render() {
              const t = super.render()
              t.classList.add('buttonWidgetAnnotation', 'pushButton')
              this.data.alternativeText && (t.title = this.data.alternativeText)
              const e = t.lastChild
              if (this.enableScripting && this.hasJSActions && e) {
                this._setDefaultPropertiesFromJS(e)
                e.addEventListener('updatefromsandbox', (t) => {
                  this._dispatchEventFromSandbox({}, t)
                })
              }
              return t
            }
          }
          class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
            constructor(t) {
              super(t, { isRenderable: t.renderForms })
            }
            render() {
              this.container.classList.add('choiceWidgetAnnotation')
              const t = this.annotationStorage,
                e = this.data.id,
                i = t.getValue(e, { value: this.data.fieldValue }),
                s = document.createElement('select')
              c.add(s)
              s.setAttribute('data-element-id', e)
              s.disabled = this.data.readOnly
              this._setRequired(s, this.data.required)
              s.name = this.data.fieldName
              s.tabIndex = h
              let n = this.data.combo && this.data.options.length > 0
              if (!this.data.combo) {
                s.size = this.data.options.length
                this.data.multiSelect && (s.multiple = !0)
              }
              s.addEventListener('resetform', (t) => {
                const e = this.data.defaultFieldValue
                for (const t of s.options) t.selected = t.value === e
              })
              for (const t of this.data.options) {
                const e = document.createElement('option')
                e.textContent = t.displayValue
                e.value = t.exportValue
                if (i.value.includes(t.exportValue)) {
                  e.setAttribute('selected', !0)
                  n = !1
                }
                s.append(e)
              }
              let a = null
              if (n) {
                const t = document.createElement('option')
                t.value = ' '
                t.setAttribute('hidden', !0)
                t.setAttribute('selected', !0)
                s.prepend(t)
                a = () => {
                  t.remove()
                  s.removeEventListener('input', a)
                  a = null
                }
                s.addEventListener('input', a)
              }
              const getValue = (t) => {
                const e = t ? 'value' : 'textContent',
                  { options: i, multiple: n } = s
                return n ? Array.prototype.filter.call(i, (t) => t.selected).map((t) => t[e]) : -1 === i.selectedIndex ? null : i[i.selectedIndex][e]
              }
              let r = getValue(!1)
              const getItems = (t) => {
                const e = t.target.options
                return Array.prototype.map.call(e, (t) => ({ displayValue: t.textContent, exportValue: t.value }))
              }
              if (this.enableScripting && this.hasJSActions) {
                s.addEventListener('updatefromsandbox', (i) => {
                  const n = {
                    value(i) {
                      a?.()
                      const n = i.detail.value,
                        o = new Set(Array.isArray(n) ? n : [n])
                      for (const t of s.options) t.selected = o.has(t.value)
                      t.setValue(e, { value: getValue(!0) })
                      r = getValue(!1)
                    },
                    multipleSelection(t) {
                      s.multiple = !0
                    },
                    remove(i) {
                      const n = s.options,
                        a = i.detail.remove
                      n[a].selected = !1
                      s.remove(a)
                      if (n.length > 0) {
                        ;-1 === Array.prototype.findIndex.call(n, (t) => t.selected) && (n[0].selected = !0)
                      }
                      t.setValue(e, { value: getValue(!0), items: getItems(i) })
                      r = getValue(!1)
                    },
                    clear(i) {
                      for (; 0 !== s.length; ) s.remove(0)
                      t.setValue(e, { value: null, items: [] })
                      r = getValue(!1)
                    },
                    insert(i) {
                      const { index: n, displayValue: a, exportValue: o } = i.detail.insert,
                        l = s.children[n],
                        h = document.createElement('option')
                      h.textContent = a
                      h.value = o
                      l ? l.before(h) : s.append(h)
                      t.setValue(e, { value: getValue(!0), items: getItems(i) })
                      r = getValue(!1)
                    },
                    items(i) {
                      const { items: n } = i.detail
                      for (; 0 !== s.length; ) s.remove(0)
                      for (const t of n) {
                        const { displayValue: e, exportValue: i } = t,
                          n = document.createElement('option')
                        n.textContent = e
                        n.value = i
                        s.append(n)
                      }
                      s.options.length > 0 && (s.options[0].selected = !0)
                      t.setValue(e, { value: getValue(!0), items: getItems(i) })
                      r = getValue(!1)
                    },
                    indices(i) {
                      const s = new Set(i.detail.indices)
                      for (const t of i.target.options) t.selected = s.has(t.index)
                      t.setValue(e, { value: getValue(!0) })
                      r = getValue(!1)
                    },
                    editable(t) {
                      t.target.disabled = !t.detail.editable
                    },
                  }
                  this._dispatchEventFromSandbox(n, i)
                })
                s.addEventListener('input', (i) => {
                  const s = getValue(!0)
                  t.setValue(e, { value: s })
                  i.preventDefault()
                  this.linkService.eventBus?.dispatch('dispatcheventinsandbox', { source: this, detail: { id: e, name: 'Keystroke', value: r, changeEx: s, willCommit: !1, commitKey: 1, keyDown: !1 } })
                })
                this._setEventListeners(
                  s,
                  null,
                  [
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up'],
                    ['input', 'Action'],
                    ['input', 'Validate'],
                  ],
                  (t) => t.target.value
                )
              } else
                s.addEventListener('input', function (i) {
                  t.setValue(e, { value: getValue(!0) })
                })
              this.data.combo && this._setTextStyle(s)
              this._setBackgroundColor(s)
              this._setDefaultPropertiesFromJS(s)
              this.container.append(s)
              return this.container
            }
          }
          class PopupAnnotationElement extends AnnotationElement {
            constructor(t) {
              const { data: e, elements: i } = t
              super(t, { isRenderable: AnnotationElement._hasPopupData(e) })
              this.elements = i
            }
            render() {
              this.container.classList.add('popupAnnotation')
              const t = new PopupElement({
                  container: this.container,
                  color: this.data.color,
                  titleObj: this.data.titleObj,
                  modificationDate: this.data.modificationDate,
                  contentsObj: this.data.contentsObj,
                  richText: this.data.richText,
                  rect: this.data.rect,
                  parentRect: this.data.parentRect || null,
                  parent: this.parent,
                  elements: this.elements,
                  open: this.data.open,
                }),
                e = []
              for (const i of this.elements) {
                i.popup = t
                e.push(i.data.id)
                i.addHighlightArea()
              }
              this.container.setAttribute('aria-controls', e.map((t) => `${s.AnnotationPrefix}${t}`).join(','))
              return this.container
            }
          }
          class PopupElement {
            #ei = null
            #ii = this.#si.bind(this)
            #ni = this.#ai.bind(this)
            #ri = this.#oi.bind(this)
            #li = this.#hi.bind(this)
            #je = null
            #Rt = null
            #ci = null
            #di = null
            #ui = null
            #pi = null
            #gi = !1
            #mi = null
            #fi = null
            #bi = null
            #Ai = null
            #_i = !1
            constructor({ container: t, color: e, elements: i, titleObj: s, modificationDate: a, contentsObj: r, richText: o, parent: l, rect: h, parentRect: c, open: d }) {
              this.#Rt = t
              this.#Ai = s
              this.#ci = r
              this.#bi = o
              this.#ui = l
              this.#je = e
              this.#fi = h
              this.#pi = c
              this.#di = i
              const u = n.PDFDateString.toDateObject(a)
              u && (this.#ei = l.l10n.get('annotation_date_string', { date: u.toLocaleDateString(), time: u.toLocaleTimeString() }))
              this.trigger = i.flatMap((t) => t.getElementsToTriggerPopup())
              for (const t of this.trigger) {
                t.addEventListener('click', this.#li)
                t.addEventListener('mouseenter', this.#ri)
                t.addEventListener('mouseleave', this.#ni)
                t.classList.add('popupTriggerArea')
              }
              for (const t of i) t.container?.addEventListener('keydown', this.#ii)
              this.#Rt.hidden = !0
              d && this.#hi()
            }
            render() {
              if (this.#mi) return
              const {
                  page: { view: t },
                  viewport: {
                    rawDims: { pageWidth: e, pageHeight: i, pageX: n, pageY: a },
                  },
                } = this.#ui,
                r = (this.#mi = document.createElement('div'))
              r.className = 'popup'
              if (this.#je) {
                const t = (r.style.outlineColor = s.Util.makeHexColor(...this.#je))
                if (CSS.supports('background-color', 'color-mix(in srgb, red 30%, white)')) r.style.backgroundColor = `color-mix(in srgb, ${t} 30%, white)`
                else {
                  const t = 0.7
                  r.style.backgroundColor = s.Util.makeHexColor(...this.#je.map((e) => Math.floor(t * (255 - e) + e)))
                }
              }
              const o = document.createElement('span')
              o.className = 'header'
              const h = document.createElement('h1')
              o.append(h)
              ;({ dir: h.dir, str: h.textContent } = this.#Ai)
              r.append(o)
              if (this.#ei) {
                const t = document.createElement('span')
                t.classList.add('popupDate')
                this.#ei.then((e) => {
                  t.textContent = e
                })
                o.append(t)
              }
              const c = this.#ci,
                d = this.#bi
              if (!d?.str || (c?.str && c.str !== d.str)) {
                const t = this._formatContents(c)
                r.append(t)
              } else {
                l.XfaLayer.render({ xfaHtml: d.html, intent: 'richText', div: r })
                r.lastChild.classList.add('richText', 'popupContent')
              }
              let u = !!this.#pi,
                p = u ? this.#pi : this.#fi
              for (const t of this.#di)
                if (!p || null !== s.Util.intersect(t.data.rect, p)) {
                  p = t.data.rect
                  u = !0
                  break
                }
              const g = s.Util.normalizeRect([p[0], t[3] - p[1] + t[1], p[2], t[3] - p[3] + t[1]]),
                m = u ? p[2] - p[0] + 5 : 0,
                f = g[0] + m,
                b = g[1],
                { style: A } = this.#Rt
              A.left = (100 * (f - n)) / e + '%'
              A.top = (100 * (b - a)) / i + '%'
              this.#Rt.append(r)
            }
            _formatContents({ str: t, dir: e }) {
              const i = document.createElement('p')
              i.classList.add('popupContent')
              i.dir = e
              const s = t.split(/(?:\r\n?|\n)/)
              for (let t = 0, e = s.length; t < e; ++t) {
                const n = s[t]
                i.append(document.createTextNode(n))
                t < e - 1 && i.append(document.createElement('br'))
              }
              return i
            }
            #si(t) {
              t.altKey || t.shiftKey || t.ctrlKey || t.metaKey || (('Enter' === t.key || ('Escape' === t.key && this.#gi)) && this.#hi())
            }
            #hi() {
              this.#gi = !this.#gi
              if (this.#gi) {
                this.#oi()
                this.#Rt.addEventListener('click', this.#li)
                this.#Rt.addEventListener('keydown', this.#ii)
              } else {
                this.#ai()
                this.#Rt.removeEventListener('click', this.#li)
                this.#Rt.removeEventListener('keydown', this.#ii)
              }
            }
            #oi() {
              this.#mi || this.render()
              if (this.isVisible) this.#gi && this.#Rt.classList.add('focused')
              else {
                this.#Rt.hidden = !1
                this.#Rt.style.zIndex = parseInt(this.#Rt.style.zIndex) + 1e3
              }
            }
            #ai() {
              this.#Rt.classList.remove('focused')
              if (!this.#gi && this.isVisible) {
                this.#Rt.hidden = !0
                this.#Rt.style.zIndex = parseInt(this.#Rt.style.zIndex) - 1e3
              }
            }
            forceHide() {
              this.#_i = this.isVisible
              this.#_i && (this.#Rt.hidden = !0)
            }
            maybeShow() {
              if (this.#_i) {
                this.#_i = !1
                this.#Rt.hidden = !1
              }
            }
            get isVisible() {
              return !1 === this.#Rt.hidden
            }
          }
          class FreeTextAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
              this.textContent = t.data.textContent
              this.textPosition = t.data.textPosition
              this.annotationEditorType = s.AnnotationEditorType.FREETEXT
            }
            render() {
              this.container.classList.add('freeTextAnnotation')
              if (this.textContent) {
                const t = document.createElement('div')
                t.classList.add('annotationTextContent')
                t.setAttribute('role', 'comment')
                for (const e of this.textContent) {
                  const i = document.createElement('span')
                  i.textContent = e
                  t.append(i)
                }
                this.container.append(t)
              }
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this._editOnDoubleClick()
              return this.container
            }
          }
          e.FreeTextAnnotationElement = FreeTextAnnotationElement
          class LineAnnotationElement extends AnnotationElement {
            #vi = null
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
            }
            render() {
              this.container.classList.add('lineAnnotation')
              const t = this.data,
                { width: e, height: i } = getRectDims(t.rect),
                s = this.svgFactory.create(e, i, !0),
                n = (this.#vi = this.svgFactory.createElement('svg:line'))
              n.setAttribute('x1', t.rect[2] - t.lineCoordinates[0])
              n.setAttribute('y1', t.rect[3] - t.lineCoordinates[1])
              n.setAttribute('x2', t.rect[2] - t.lineCoordinates[2])
              n.setAttribute('y2', t.rect[3] - t.lineCoordinates[3])
              n.setAttribute('stroke-width', t.borderStyle.width || 1)
              n.setAttribute('stroke', 'transparent')
              n.setAttribute('fill', 'transparent')
              s.append(n)
              this.container.append(s)
              !t.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
            getElementsToTriggerPopup() {
              return this.#vi
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
          }
          class SquareAnnotationElement extends AnnotationElement {
            #yi = null
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
            }
            render() {
              this.container.classList.add('squareAnnotation')
              const t = this.data,
                { width: e, height: i } = getRectDims(t.rect),
                s = this.svgFactory.create(e, i, !0),
                n = t.borderStyle.width,
                a = (this.#yi = this.svgFactory.createElement('svg:rect'))
              a.setAttribute('x', n / 2)
              a.setAttribute('y', n / 2)
              a.setAttribute('width', e - n)
              a.setAttribute('height', i - n)
              a.setAttribute('stroke-width', n || 1)
              a.setAttribute('stroke', 'transparent')
              a.setAttribute('fill', 'transparent')
              s.append(a)
              this.container.append(s)
              !t.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
            getElementsToTriggerPopup() {
              return this.#yi
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
          }
          class CircleAnnotationElement extends AnnotationElement {
            #Si = null
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
            }
            render() {
              this.container.classList.add('circleAnnotation')
              const t = this.data,
                { width: e, height: i } = getRectDims(t.rect),
                s = this.svgFactory.create(e, i, !0),
                n = t.borderStyle.width,
                a = (this.#Si = this.svgFactory.createElement('svg:ellipse'))
              a.setAttribute('cx', e / 2)
              a.setAttribute('cy', i / 2)
              a.setAttribute('rx', e / 2 - n / 2)
              a.setAttribute('ry', i / 2 - n / 2)
              a.setAttribute('stroke-width', n || 1)
              a.setAttribute('stroke', 'transparent')
              a.setAttribute('fill', 'transparent')
              s.append(a)
              this.container.append(s)
              !t.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
            getElementsToTriggerPopup() {
              return this.#Si
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
          }
          class PolylineAnnotationElement extends AnnotationElement {
            #Ei = null
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
              this.containerClassName = 'polylineAnnotation'
              this.svgElementName = 'svg:polyline'
            }
            render() {
              this.container.classList.add(this.containerClassName)
              const t = this.data,
                { width: e, height: i } = getRectDims(t.rect),
                s = this.svgFactory.create(e, i, !0)
              let n = []
              for (const e of t.vertices) {
                const i = e.x - t.rect[0],
                  s = t.rect[3] - e.y
                n.push(i + ',' + s)
              }
              n = n.join(' ')
              const a = (this.#Ei = this.svgFactory.createElement(this.svgElementName))
              a.setAttribute('points', n)
              a.setAttribute('stroke-width', t.borderStyle.width || 1)
              a.setAttribute('stroke', 'transparent')
              a.setAttribute('fill', 'transparent')
              s.append(a)
              this.container.append(s)
              !t.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
            getElementsToTriggerPopup() {
              return this.#Ei
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
          }
          class PolygonAnnotationElement extends PolylineAnnotationElement {
            constructor(t) {
              super(t)
              this.containerClassName = 'polygonAnnotation'
              this.svgElementName = 'svg:polygon'
            }
          }
          class CaretAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
            }
            render() {
              this.container.classList.add('caretAnnotation')
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
          }
          class InkAnnotationElement extends AnnotationElement {
            #xi = []
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
              this.containerClassName = 'inkAnnotation'
              this.svgElementName = 'svg:polyline'
              this.annotationEditorType = s.AnnotationEditorType.INK
            }
            render() {
              this.container.classList.add(this.containerClassName)
              const t = this.data,
                { width: e, height: i } = getRectDims(t.rect),
                s = this.svgFactory.create(e, i, !0)
              for (const e of t.inkLists) {
                let i = []
                for (const s of e) {
                  const e = s.x - t.rect[0],
                    n = t.rect[3] - s.y
                  i.push(`${e},${n}`)
                }
                i = i.join(' ')
                const n = this.svgFactory.createElement(this.svgElementName)
                this.#xi.push(n)
                n.setAttribute('points', i)
                n.setAttribute('stroke-width', t.borderStyle.width || 1)
                n.setAttribute('stroke', 'transparent')
                n.setAttribute('fill', 'transparent')
                !t.popupRef && this.hasPopupData && this._createPopup()
                s.append(n)
              }
              this.container.append(s)
              return this.container
            }
            getElementsToTriggerPopup() {
              return this.#xi
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
          }
          e.InkAnnotationElement = InkAnnotationElement
          class HighlightAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 })
            }
            render() {
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this.container.classList.add('highlightAnnotation')
              return this.container
            }
          }
          class UnderlineAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 })
            }
            render() {
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this.container.classList.add('underlineAnnotation')
              return this.container
            }
          }
          class SquigglyAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 })
            }
            render() {
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this.container.classList.add('squigglyAnnotation')
              return this.container
            }
          }
          class StrikeOutAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 })
            }
            render() {
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              this.container.classList.add('strikeoutAnnotation')
              return this.container
            }
          }
          class StampAnnotationElement extends AnnotationElement {
            constructor(t) {
              super(t, { isRenderable: !0, ignoreBorder: !0 })
            }
            render() {
              this.container.classList.add('stampAnnotation')
              !this.data.popupRef && this.hasPopupData && this._createPopup()
              return this.container
            }
          }
          e.StampAnnotationElement = StampAnnotationElement
          class FileAttachmentAnnotationElement extends AnnotationElement {
            #wi = null
            constructor(t) {
              super(t, { isRenderable: !0 })
              const { filename: e, content: i } = this.data.file
              this.filename = (0, n.getFilenameFromUrl)(e, !0)
              this.content = i
              this.linkService.eventBus?.dispatch('fileattachmentannotation', { source: this, filename: e, content: i })
            }
            render() {
              this.container.classList.add('fileAttachmentAnnotation')
              const { container: t, data: e } = this
              let i
              if (e.hasAppearance || 0 === e.fillAlpha) i = document.createElement('div')
              else {
                i = document.createElement('img')
                i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(e.name) ? 'paperclip' : 'pushpin'}.svg`
                e.fillAlpha && e.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(100 * e.fillAlpha)}%);`)
              }
              i.addEventListener('dblclick', this.#Ci.bind(this))
              this.#wi = i
              const { isMac: n } = s.FeatureTest.platform
              t.addEventListener('keydown', (t) => {
                'Enter' === t.key && (n ? t.metaKey : t.ctrlKey) && this.#Ci()
              })
              !e.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add('popupTriggerArea')
              t.append(i)
              return t
            }
            getElementsToTriggerPopup() {
              return this.#wi
            }
            addHighlightArea() {
              this.container.classList.add('highlightArea')
            }
            #Ci() {
              this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename)
            }
          }
          e.AnnotationLayer = class AnnotationLayer {
            #Se = null
            #Ti = null
            #Pi = new Map()
            constructor({ div: t, accessibilityManager: e, annotationCanvasMap: i, l10n: s, page: n, viewport: a }) {
              this.div = t
              this.#Se = e
              this.#Ti = i
              this.l10n = s
              this.page = n
              this.viewport = a
              this.zIndex = 0
              this.l10n ||= o.NullL10n
            }
            #Mi(t, e) {
              const i = t.firstChild || t
              i.id = `${s.AnnotationPrefix}${e}`
              this.div.append(t)
              this.#Se?.moveElementInDOM(this.div, t, i, !1)
            }
            async render(t) {
              const { annotations: e } = t,
                i = this.div
              ;(0, n.setLayerDimensions)(i, this.viewport)
              const r = new Map(),
                o = {
                  data: null,
                  layer: i,
                  linkService: t.linkService,
                  downloadManager: t.downloadManager,
                  imageResourcesPath: t.imageResourcesPath || '',
                  renderForms: !1 !== t.renderForms,
                  svgFactory: new n.DOMSVGFactory(),
                  annotationStorage: t.annotationStorage || new a.AnnotationStorage(),
                  enableScripting: !0 === t.enableScripting,
                  hasJSActions: t.hasJSActions,
                  fieldObjects: t.fieldObjects,
                  parent: this,
                  elements: null,
                }
              for (const t of e) {
                if (t.noHTML) continue
                const e = t.annotationType === s.AnnotationType.POPUP
                if (e) {
                  const e = r.get(t.id)
                  if (!e) continue
                  o.elements = e
                } else {
                  const { width: e, height: i } = getRectDims(t.rect)
                  if (e <= 0 || i <= 0) continue
                }
                o.data = t
                const i = AnnotationElementFactory.create(o)
                if (!i.isRenderable) continue
                if (!e && t.popupRef) {
                  const e = r.get(t.popupRef)
                  e ? e.push(i) : r.set(t.popupRef, [i])
                }
                i.annotationEditorType > 0 && this.#Pi.set(i.data.id, i)
                const n = i.render()
                t.hidden && (n.style.visibility = 'hidden')
                this.#Mi(n, t.id)
              }
              this.#ki()
              await this.l10n.translate(i)
            }
            update({ viewport: t }) {
              const e = this.div
              this.viewport = t
              ;(0, n.setLayerDimensions)(e, { rotation: t.rotation })
              this.#ki()
              e.hidden = !1
            }
            #ki() {
              if (!this.#Ti) return
              const t = this.div
              for (const [e, i] of this.#Ti) {
                const s = t.querySelector(`[data-annotation-id="${e}"]`)
                if (!s) continue
                const { firstChild: n } = s
                n ? ('CANVAS' === n.nodeName ? n.replaceWith(i) : n.before(i)) : s.append(i)
              }
              this.#Ti.clear()
            }
            getEditableAnnotations() {
              return Array.from(this.#Pi.values())
            }
            getEditableAnnotation(t) {
              return this.#Pi.get(t)
            }
          }
        },
        (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.ColorConverters = void 0
          function makeColorComp(t) {
            return Math.floor(255 * Math.max(0, Math.min(1, t)))
              .toString(16)
              .padStart(2, '0')
          }
          function scaleAndClamp(t) {
            return Math.max(0, Math.min(255, 255 * t))
          }
          e.ColorConverters = class ColorConverters {
            static CMYK_G([t, e, i, s]) {
              return ['G', 1 - Math.min(1, 0.3 * t + 0.59 * i + 0.11 * e + s)]
            }
            static G_CMYK([t]) {
              return ['CMYK', 0, 0, 0, 1 - t]
            }
            static G_RGB([t]) {
              return ['RGB', t, t, t]
            }
            static G_rgb([t]) {
              return [(t = scaleAndClamp(t)), t, t]
            }
            static G_HTML([t]) {
              const e = makeColorComp(t)
              return `#${e}${e}${e}`
            }
            static RGB_G([t, e, i]) {
              return ['G', 0.3 * t + 0.59 * e + 0.11 * i]
            }
            static RGB_rgb(t) {
              return t.map(scaleAndClamp)
            }
            static RGB_HTML(t) {
              return `#${t.map(makeColorComp).join('')}`
            }
            static T_HTML() {
              return '#00000000'
            }
            static T_rgb() {
              return [null]
            }
            static CMYK_RGB([t, e, i, s]) {
              return ['RGB', 1 - Math.min(1, t + s), 1 - Math.min(1, i + s), 1 - Math.min(1, e + s)]
            }
            static CMYK_rgb([t, e, i, s]) {
              return [scaleAndClamp(1 - Math.min(1, t + s)), scaleAndClamp(1 - Math.min(1, i + s)), scaleAndClamp(1 - Math.min(1, e + s))]
            }
            static CMYK_HTML(t) {
              const e = this.CMYK_RGB(t).slice(1)
              return this.RGB_HTML(e)
            }
            static RGB_CMYK([t, e, i]) {
              const s = 1 - t,
                n = 1 - e,
                a = 1 - i
              return ['CMYK', s, n, a, Math.min(s, n, a)]
            }
          }
        },
        (t, e) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.NullL10n = void 0
          e.getL10nFallback = getL10nFallback
          const i = {
            of_pages: 'of {{pagesCount}}',
            page_of_pages: '({{pageNumber}} of {{pagesCount}})',
            document_properties_kb: '{{size_kb}} KB ({{size_b}} bytes)',
            document_properties_mb: '{{size_mb}} MB ({{size_b}} bytes)',
            document_properties_date_string: '{{date}}, {{time}}',
            document_properties_page_size_unit_inches: 'in',
            document_properties_page_size_unit_millimeters: 'mm',
            document_properties_page_size_orientation_portrait: 'portrait',
            document_properties_page_size_orientation_landscape: 'landscape',
            document_properties_page_size_name_a3: 'A3',
            document_properties_page_size_name_a4: 'A4',
            document_properties_page_size_name_letter: 'Letter',
            document_properties_page_size_name_legal: 'Legal',
            document_properties_page_size_dimension_string: '{{width}} × {{height}} {{unit}} ({{orientation}})',
            document_properties_page_size_dimension_name_string: '{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})',
            document_properties_linearized_yes: 'Yes',
            document_properties_linearized_no: 'No',
            additional_layers: 'Additional Layers',
            page_landmark: 'Page {{page}}',
            thumb_page_title: 'Page {{page}}',
            thumb_page_canvas: 'Thumbnail of Page {{page}}',
            find_reached_top: 'Reached top of document, continued from bottom',
            find_reached_bottom: 'Reached end of document, continued from top',
            'find_match_count[one]': '{{current}} of {{total}} match',
            'find_match_count[other]': '{{current}} of {{total}} matches',
            'find_match_count_limit[one]': 'More than {{limit}} match',
            'find_match_count_limit[other]': 'More than {{limit}} matches',
            find_not_found: 'Phrase not found',
            page_scale_width: 'Page Width',
            page_scale_fit: 'Page Fit',
            page_scale_auto: 'Automatic Zoom',
            page_scale_actual: 'Actual Size',
            page_scale_percent: '{{scale}}%',
            loading_error: 'An error occurred while loading the PDF.',
            invalid_file_error: 'Invalid or corrupted PDF file.',
            missing_file_error: 'Missing PDF file.',
            unexpected_response_error: 'Unexpected server response.',
            rendering_error: 'An error occurred while rendering the page.',
            annotation_date_string: '{{date}}, {{time}}',
            printing_not_supported: 'Warning: Printing is not fully supported by this browser.',
            printing_not_ready: 'Warning: The PDF is not fully loaded for printing.',
            web_fonts_disabled: 'Web fonts are disabled: unable to use embedded PDF fonts.',
            free_text2_default_content: 'Start typing…',
            editor_free_text2_aria_label: 'Text Editor',
            editor_ink2_aria_label: 'Draw Editor',
            editor_ink_canvas_aria_label: 'User-created image',
            editor_alt_text_button_label: 'Alt text',
            editor_alt_text_edit_button_label: 'Edit alt text',
            editor_alt_text_decorative_tooltip: 'Marked as decorative',
            print_progress_percent: '{{progress}}%',
          }
          function getL10nFallback(t, e) {
            switch (t) {
              case 'find_match_count':
                t = `find_match_count[${1 === e.total ? 'one' : 'other'}]`
                break
              case 'find_match_count_limit':
                t = `find_match_count_limit[${1 === e.limit ? 'one' : 'other'}]`
            }
            return i[t] || ''
          }
          const s = {
            getLanguage: async () => 'en-us',
            getDirection: async () => 'ltr',
            get: async (t, e = null, i = getL10nFallback(t, e)) =>
              (function formatL10nValue(t, e) {
                return e ? t.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (t, i) => (i in e ? e[i] : '{{' + i + '}}')) : t
              })(i, e),
            async translate(t) {},
          }
          e.NullL10n = s
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.XfaLayer = void 0
          var s = i(25)
          e.XfaLayer = class XfaLayer {
            static setupStorage(t, e, i, s, n) {
              const a = s.getValue(e, { value: null })
              switch (i.name) {
                case 'textarea':
                  null !== a.value && (t.textContent = a.value)
                  if ('print' === n) break
                  t.addEventListener('input', (t) => {
                    s.setValue(e, { value: t.target.value })
                  })
                  break
                case 'input':
                  if ('radio' === i.attributes.type || 'checkbox' === i.attributes.type) {
                    a.value === i.attributes.xfaOn ? t.setAttribute('checked', !0) : a.value === i.attributes.xfaOff && t.removeAttribute('checked')
                    if ('print' === n) break
                    t.addEventListener('change', (t) => {
                      s.setValue(e, { value: t.target.checked ? t.target.getAttribute('xfaOn') : t.target.getAttribute('xfaOff') })
                    })
                  } else {
                    null !== a.value && t.setAttribute('value', a.value)
                    if ('print' === n) break
                    t.addEventListener('input', (t) => {
                      s.setValue(e, { value: t.target.value })
                    })
                  }
                  break
                case 'select':
                  if (null !== a.value) {
                    t.setAttribute('value', a.value)
                    for (const t of i.children) t.attributes.value === a.value ? (t.attributes.selected = !0) : t.attributes.hasOwnProperty('selected') && delete t.attributes.selected
                  }
                  t.addEventListener('input', (t) => {
                    const i = t.target.options,
                      n = -1 === i.selectedIndex ? '' : i[i.selectedIndex].value
                    s.setValue(e, { value: n })
                  })
              }
            }
            static setAttributes({ html: t, element: e, storage: i = null, intent: s, linkService: n }) {
              const { attributes: a } = e,
                r = t instanceof HTMLAnchorElement
              'radio' === a.type && (a.name = `${a.name}-${s}`)
              for (const [e, i] of Object.entries(a))
                if (null != i)
                  switch (e) {
                    case 'class':
                      i.length && t.setAttribute(e, i.join(' '))
                      break
                    case 'dataId':
                      break
                    case 'id':
                      t.setAttribute('data-element-id', i)
                      break
                    case 'style':
                      Object.assign(t.style, i)
                      break
                    case 'textContent':
                      t.textContent = i
                      break
                    default:
                      ;(!r || ('href' !== e && 'newWindow' !== e)) && t.setAttribute(e, i)
                  }
              r && n.addLinkAttributes(t, a.href, a.newWindow)
              i && a.dataId && this.setupStorage(t, a.dataId, e, i)
            }
            static render(t) {
              const e = t.annotationStorage,
                i = t.linkService,
                n = t.xfaHtml,
                a = t.intent || 'display',
                r = document.createElement(n.name)
              n.attributes && this.setAttributes({ html: r, element: n, intent: a, linkService: i })
              const o = [[n, -1, r]],
                l = t.div
              l.append(r)
              if (t.viewport) {
                const e = `matrix(${t.viewport.transform.join(',')})`
                l.style.transform = e
              }
              'richText' !== a && l.setAttribute('class', 'xfaLayer xfaFont')
              const h = []
              for (; o.length > 0; ) {
                const [t, n, r] = o.at(-1)
                if (n + 1 === t.children.length) {
                  o.pop()
                  continue
                }
                const l = t.children[++o.at(-1)[1]]
                if (null === l) continue
                const { name: c } = l
                if ('#text' === c) {
                  const t = document.createTextNode(l.value)
                  h.push(t)
                  r.append(t)
                  continue
                }
                const d = l?.attributes?.xmlns ? document.createElementNS(l.attributes.xmlns, c) : document.createElement(c)
                r.append(d)
                l.attributes && this.setAttributes({ html: d, element: l, storage: e, intent: a, linkService: i })
                if (l.children && l.children.length > 0) o.push([l, -1, d])
                else if (l.value) {
                  const t = document.createTextNode(l.value)
                  s.XfaText.shouldBuildText(c) && h.push(t)
                  d.append(t)
                }
              }
              for (const t of l.querySelectorAll('.xfaNonInteractive input, .xfaNonInteractive textarea')) t.setAttribute('readOnly', !0)
              return { textDivs: h }
            }
            static update(t) {
              const e = `matrix(${t.viewport.transform.join(',')})`
              t.div.style.transform = e
              t.div.hidden = !1
            }
          }
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.InkEditor = void 0
          var s = i(1),
            n = i(4),
            a = i(29),
            r = i(6),
            o = i(5)
          class InkEditor extends n.AnnotationEditor {
            #Fi = 0
            #Ri = 0
            #Di = this.canvasPointermove.bind(this)
            #Ii = this.canvasPointerleave.bind(this)
            #Li = this.canvasPointerup.bind(this)
            #Oi = this.canvasPointerdown.bind(this)
            #Ni = new Path2D()
            #Bi = !1
            #Ui = !1
            #ji = !1
            #zi = null
            #Hi = 0
            #Wi = 0
            #Gi = null
            static _defaultColor = null
            static _defaultOpacity = 1
            static _defaultThickness = 1
            static _type = 'ink'
            constructor(t) {
              super({ ...t, name: 'inkEditor' })
              this.color = t.color || null
              this.thickness = t.thickness || null
              this.opacity = t.opacity || null
              this.paths = []
              this.bezierPath2D = []
              this.allRawPaths = []
              this.currentPath = []
              this.scaleFactor = 1
              this.translationX = this.translationY = 0
              this.x = 0
              this.y = 0
              this._willKeepAspectRatio = !0
            }
            static initialize(t) {
              n.AnnotationEditor.initialize(t, { strings: ['editor_ink_canvas_aria_label', 'editor_ink2_aria_label'] })
            }
            static updateDefaultParams(t, e) {
              switch (t) {
                case s.AnnotationEditorParamsType.INK_THICKNESS:
                  InkEditor._defaultThickness = e
                  break
                case s.AnnotationEditorParamsType.INK_COLOR:
                  InkEditor._defaultColor = e
                  break
                case s.AnnotationEditorParamsType.INK_OPACITY:
                  InkEditor._defaultOpacity = e / 100
              }
            }
            updateParams(t, e) {
              switch (t) {
                case s.AnnotationEditorParamsType.INK_THICKNESS:
                  this.#qi(e)
                  break
                case s.AnnotationEditorParamsType.INK_COLOR:
                  this.#Ve(e)
                  break
                case s.AnnotationEditorParamsType.INK_OPACITY:
                  this.#Vi(e)
              }
            }
            static get defaultPropertiesToUpdate() {
              return [
                [s.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness],
                [s.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || n.AnnotationEditor._defaultLineColor],
                [s.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * InkEditor._defaultOpacity)],
              ]
            }
            get propertiesToUpdate() {
              return [
                [s.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness],
                [s.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || n.AnnotationEditor._defaultLineColor],
                [s.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))],
              ]
            }
            #qi(t) {
              const e = this.thickness
              this.addCommands({
                cmd: () => {
                  this.thickness = t
                  this.#$i()
                },
                undo: () => {
                  this.thickness = e
                  this.#$i()
                },
                mustExec: !0,
                type: s.AnnotationEditorParamsType.INK_THICKNESS,
                overwriteIfSameType: !0,
                keepUndo: !0,
              })
            }
            #Ve(t) {
              const e = this.color
              this.addCommands({
                cmd: () => {
                  this.color = t
                  this.#Xi()
                },
                undo: () => {
                  this.color = e
                  this.#Xi()
                },
                mustExec: !0,
                type: s.AnnotationEditorParamsType.INK_COLOR,
                overwriteIfSameType: !0,
                keepUndo: !0,
              })
            }
            #Vi(t) {
              t /= 100
              const e = this.opacity
              this.addCommands({
                cmd: () => {
                  this.opacity = t
                  this.#Xi()
                },
                undo: () => {
                  this.opacity = e
                  this.#Xi()
                },
                mustExec: !0,
                type: s.AnnotationEditorParamsType.INK_OPACITY,
                overwriteIfSameType: !0,
                keepUndo: !0,
              })
            }
            rebuild() {
              if (this.parent) {
                super.rebuild()
                if (null !== this.div) {
                  if (!this.canvas) {
                    this.#Ki()
                    this.#Yi()
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this)
                    this.#Ji()
                  }
                  this.#$i()
                }
              }
            }
            remove() {
              if (null !== this.canvas) {
                this.isEmpty() || this.commit()
                this.canvas.width = this.canvas.height = 0
                this.canvas.remove()
                this.canvas = null
                this.#zi.disconnect()
                this.#zi = null
                super.remove()
              }
            }
            setParent(t) {
              !this.parent && t ? this._uiManager.removeShouldRescale(this) : this.parent && null === t && this._uiManager.addShouldRescale(this)
              super.setParent(t)
            }
            onScaleChanging() {
              const [t, e] = this.parentDimensions,
                i = this.width * t,
                s = this.height * e
              this.setDimensions(i, s)
            }
            enableEditMode() {
              if (!this.#Bi && null !== this.canvas) {
                super.enableEditMode()
                this._isDraggable = !1
                this.canvas.addEventListener('pointerdown', this.#Oi)
              }
            }
            disableEditMode() {
              if (this.isInEditMode() && null !== this.canvas) {
                super.disableEditMode()
                this._isDraggable = !this.isEmpty()
                this.div.classList.remove('editing')
                this.canvas.removeEventListener('pointerdown', this.#Oi)
              }
            }
            onceAdded() {
              this._isDraggable = !this.isEmpty()
            }
            isEmpty() {
              return 0 === this.paths.length || (1 === this.paths.length && 0 === this.paths[0].length)
            }
            #Qi() {
              const {
                parentRotation: t,
                parentDimensions: [e, i],
              } = this
              switch (t) {
                case 90:
                  return [0, i, i, e]
                case 180:
                  return [e, i, e, i]
                case 270:
                  return [e, 0, i, e]
                default:
                  return [0, 0, e, i]
              }
            }
            #Zi() {
              const { ctx: t, color: e, opacity: i, thickness: s, parentScale: n, scaleFactor: a } = this
              t.lineWidth = (s * n) / a
              t.lineCap = 'round'
              t.lineJoin = 'round'
              t.miterLimit = 10
              t.strokeStyle = `${e}${(0, o.opacityToHex)(i)}`
            }
            #ts(t, e) {
              this.canvas.addEventListener('contextmenu', r.noContextMenu)
              this.canvas.addEventListener('pointerleave', this.#Ii)
              this.canvas.addEventListener('pointermove', this.#Di)
              this.canvas.addEventListener('pointerup', this.#Li)
              this.canvas.removeEventListener('pointerdown', this.#Oi)
              this.isEditing = !0
              if (!this.#ji) {
                this.#ji = !0
                this.#Ji()
                this.thickness ||= InkEditor._defaultThickness
                this.color ||= InkEditor._defaultColor || n.AnnotationEditor._defaultLineColor
                this.opacity ??= InkEditor._defaultOpacity
              }
              this.currentPath.push([t, e])
              this.#Ui = !1
              this.#Zi()
              this.#Gi = () => {
                this.#es()
                this.#Gi && window.requestAnimationFrame(this.#Gi)
              }
              window.requestAnimationFrame(this.#Gi)
            }
            #is(t, e) {
              const [i, s] = this.currentPath.at(-1)
              if (this.currentPath.length > 1 && t === i && e === s) return
              const n = this.currentPath
              let a = this.#Ni
              n.push([t, e])
              this.#Ui = !0
              if (n.length <= 2) {
                a.moveTo(...n[0])
                a.lineTo(t, e)
              } else {
                if (3 === n.length) {
                  this.#Ni = a = new Path2D()
                  a.moveTo(...n[0])
                }
                this.#ss(a, ...n.at(-3), ...n.at(-2), t, e)
              }
            }
            #ns() {
              if (0 === this.currentPath.length) return
              const t = this.currentPath.at(-1)
              this.#Ni.lineTo(...t)
            }
            #as(t, e) {
              this.#Gi = null
              t = Math.min(Math.max(t, 0), this.canvas.width)
              e = Math.min(Math.max(e, 0), this.canvas.height)
              this.#is(t, e)
              this.#ns()
              let i
              if (1 !== this.currentPath.length) i = this.#rs()
              else {
                const s = [t, e]
                i = [[s, s.slice(), s.slice(), s]]
              }
              const s = this.#Ni,
                n = this.currentPath
              this.currentPath = []
              this.#Ni = new Path2D()
              this.addCommands({
                cmd: () => {
                  this.allRawPaths.push(n)
                  this.paths.push(i)
                  this.bezierPath2D.push(s)
                  this.rebuild()
                },
                undo: () => {
                  this.allRawPaths.pop()
                  this.paths.pop()
                  this.bezierPath2D.pop()
                  if (0 === this.paths.length) this.remove()
                  else {
                    if (!this.canvas) {
                      this.#Ki()
                      this.#Yi()
                    }
                    this.#$i()
                  }
                },
                mustExec: !0,
              })
            }
            #es() {
              if (!this.#Ui) return
              this.#Ui = !1
              const t = Math.ceil(this.thickness * this.parentScale),
                e = this.currentPath.slice(-3),
                i = e.map((t) => t[0]),
                s = e.map((t) => t[1]),
                { ctx: n } = (Math.min(...i), Math.max(...i), Math.min(...s), Math.max(...s), this)
              n.save()
              n.clearRect(0, 0, this.canvas.width, this.canvas.height)
              for (const t of this.bezierPath2D) n.stroke(t)
              n.stroke(this.#Ni)
              n.restore()
            }
            #ss(t, e, i, s, n, a, r) {
              const o = (e + s) / 2,
                l = (i + n) / 2,
                h = (s + a) / 2,
                c = (n + r) / 2
              t.bezierCurveTo(o + (2 * (s - o)) / 3, l + (2 * (n - l)) / 3, h + (2 * (s - h)) / 3, c + (2 * (n - c)) / 3, h, c)
            }
            #rs() {
              const t = this.currentPath
              if (t.length <= 2) return [[t[0], t[0], t.at(-1), t.at(-1)]]
              const e = []
              let i,
                [s, n] = t[0]
              for (i = 1; i < t.length - 2; i++) {
                const [a, r] = t[i],
                  [o, l] = t[i + 1],
                  h = (a + o) / 2,
                  c = (r + l) / 2,
                  d = [s + (2 * (a - s)) / 3, n + (2 * (r - n)) / 3],
                  u = [h + (2 * (a - h)) / 3, c + (2 * (r - c)) / 3]
                e.push([[s, n], d, u, [h, c]])
                ;[s, n] = [h, c]
              }
              const [a, r] = t[i],
                [o, l] = t[i + 1],
                h = [s + (2 * (a - s)) / 3, n + (2 * (r - n)) / 3],
                c = [o + (2 * (a - o)) / 3, l + (2 * (r - l)) / 3]
              e.push([[s, n], h, c, [o, l]])
              return e
            }
            #Xi() {
              if (this.isEmpty()) {
                this.#os()
                return
              }
              this.#Zi()
              const { canvas: t, ctx: e } = this
              e.setTransform(1, 0, 0, 1, 0, 0)
              e.clearRect(0, 0, t.width, t.height)
              this.#os()
              for (const t of this.bezierPath2D) e.stroke(t)
            }
            commit() {
              if (!this.#Bi) {
                super.commit()
                this.isEditing = !1
                this.disableEditMode()
                this.setInForeground()
                this.#Bi = !0
                this.div.classList.add('disabled')
                this.#$i(!0)
                this.makeResizable()
                this.parent.addInkEditorIfNeeded(!0)
                this.moveInDOM()
                this.div.focus({ preventScroll: !0 })
              }
            }
            focusin(t) {
              if (this._focusEventsAllowed) {
                super.focusin(t)
                this.enableEditMode()
              }
            }
            canvasPointerdown(t) {
              if (0 === t.button && this.isInEditMode() && !this.#Bi) {
                this.setInForeground()
                t.preventDefault()
                'mouse' !== t.type && this.div.focus()
                this.#ts(t.offsetX, t.offsetY)
              }
            }
            canvasPointermove(t) {
              t.preventDefault()
              this.#is(t.offsetX, t.offsetY)
            }
            canvasPointerup(t) {
              t.preventDefault()
              this.#ls(t)
            }
            canvasPointerleave(t) {
              this.#ls(t)
            }
            #ls(t) {
              this.canvas.removeEventListener('pointerleave', this.#Ii)
              this.canvas.removeEventListener('pointermove', this.#Di)
              this.canvas.removeEventListener('pointerup', this.#Li)
              this.canvas.addEventListener('pointerdown', this.#Oi)
              setTimeout(() => {
                this.canvas.removeEventListener('contextmenu', r.noContextMenu)
              }, 10)
              this.#as(t.offsetX, t.offsetY)
              this.addToAnnotationStorage()
              this.setInBackground()
            }
            #Ki() {
              this.canvas = document.createElement('canvas')
              this.canvas.width = this.canvas.height = 0
              this.canvas.className = 'inkEditorCanvas'
              n.AnnotationEditor._l10nPromise.get('editor_ink_canvas_aria_label').then((t) => this.canvas?.setAttribute('aria-label', t))
              this.div.append(this.canvas)
              this.ctx = this.canvas.getContext('2d')
            }
            #Yi() {
              this.#zi = new ResizeObserver((t) => {
                const e = t[0].contentRect
                e.width && e.height && this.setDimensions(e.width, e.height)
              })
              this.#zi.observe(this.div)
            }
            get isResizable() {
              return !this.isEmpty() && this.#Bi
            }
            render() {
              if (this.div) return this.div
              let t, e
              if (this.width) {
                t = this.x
                e = this.y
              }
              super.render()
              n.AnnotationEditor._l10nPromise.get('editor_ink2_aria_label').then((t) => this.div?.setAttribute('aria-label', t))
              const [i, s, a, r] = this.#Qi()
              this.setAt(i, s, 0, 0)
              this.setDims(a, r)
              this.#Ki()
              if (this.width) {
                const [i, s] = this.parentDimensions
                this.setAspectRatio(this.width * i, this.height * s)
                this.setAt(t * i, e * s, this.width * i, this.height * s)
                this.#ji = !0
                this.#Ji()
                this.setDims(this.width * i, this.height * s)
                this.#Xi()
                this.div.classList.add('disabled')
              } else {
                this.div.classList.add('editing')
                this.enableEditMode()
              }
              this.#Yi()
              return this.div
            }
            #Ji() {
              if (!this.#ji) return
              const [t, e] = this.parentDimensions
              this.canvas.width = Math.ceil(this.width * t)
              this.canvas.height = Math.ceil(this.height * e)
              this.#os()
            }
            setDimensions(t, e) {
              const i = Math.round(t),
                s = Math.round(e)
              if (this.#Hi === i && this.#Wi === s) return
              this.#Hi = i
              this.#Wi = s
              this.canvas.style.visibility = 'hidden'
              const [n, a] = this.parentDimensions
              this.width = t / n
              this.height = e / a
              this.fixAndSetPosition()
              this.#Bi && this.#hs(t, e)
              this.#Ji()
              this.#Xi()
              this.canvas.style.visibility = 'visible'
              this.fixDims()
            }
            #hs(t, e) {
              const i = this.#cs(),
                s = (t - i) / this.#Ri,
                n = (e - i) / this.#Fi
              this.scaleFactor = Math.min(s, n)
            }
            #os() {
              const t = this.#cs() / 2
              this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + t, this.translationY * this.scaleFactor + t)
            }
            static #ds(t) {
              const e = new Path2D()
              for (let i = 0, s = t.length; i < s; i++) {
                const [s, n, a, r] = t[i]
                0 === i && e.moveTo(...s)
                e.bezierCurveTo(n[0], n[1], a[0], a[1], r[0], r[1])
              }
              return e
            }
            static #us(t, e, i) {
              const [s, n, a, r] = e
              switch (i) {
                case 0:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    t[e] += s
                    t[e + 1] = r - t[e + 1]
                  }
                  break
                case 90:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    const i = t[e]
                    t[e] = t[e + 1] + s
                    t[e + 1] = i + n
                  }
                  break
                case 180:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    t[e] = a - t[e]
                    t[e + 1] += n
                  }
                  break
                case 270:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    const i = t[e]
                    t[e] = a - t[e + 1]
                    t[e + 1] = r - i
                  }
                  break
                default:
                  throw new Error('Invalid rotation')
              }
              return t
            }
            static #ps(t, e, i) {
              const [s, n, a, r] = e
              switch (i) {
                case 0:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    t[e] -= s
                    t[e + 1] = r - t[e + 1]
                  }
                  break
                case 90:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    const i = t[e]
                    t[e] = t[e + 1] - n
                    t[e + 1] = i - s
                  }
                  break
                case 180:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    t[e] = a - t[e]
                    t[e + 1] -= n
                  }
                  break
                case 270:
                  for (let e = 0, i = t.length; e < i; e += 2) {
                    const i = t[e]
                    t[e] = r - t[e + 1]
                    t[e + 1] = a - i
                  }
                  break
                default:
                  throw new Error('Invalid rotation')
              }
              return t
            }
            #gs(t, e, i, s) {
              const n = [],
                a = this.thickness / 2,
                r = t * e + a,
                o = t * i + a
              for (const e of this.paths) {
                const i = [],
                  a = []
                for (let s = 0, n = e.length; s < n; s++) {
                  const [l, h, c, d] = e[s],
                    u = t * l[0] + r,
                    p = t * l[1] + o,
                    g = t * h[0] + r,
                    m = t * h[1] + o,
                    f = t * c[0] + r,
                    b = t * c[1] + o,
                    A = t * d[0] + r,
                    _ = t * d[1] + o
                  if (0 === s) {
                    i.push(u, p)
                    a.push(u, p)
                  }
                  i.push(g, m, f, b, A, _)
                  a.push(g, m)
                  s === n - 1 && a.push(A, _)
                }
                n.push({ bezier: InkEditor.#us(i, s, this.rotation), points: InkEditor.#us(a, s, this.rotation) })
              }
              return n
            }
            #ms() {
              let t = 1 / 0,
                e = -1 / 0,
                i = 1 / 0,
                n = -1 / 0
              for (const a of this.paths)
                for (const [r, o, l, h] of a) {
                  const a = s.Util.bezierBoundingBox(...r, ...o, ...l, ...h)
                  t = Math.min(t, a[0])
                  i = Math.min(i, a[1])
                  e = Math.max(e, a[2])
                  n = Math.max(n, a[3])
                }
              return [t, i, e, n]
            }
            #cs() {
              return this.#Bi ? Math.ceil(this.thickness * this.parentScale) : 0
            }
            #$i(t = !1) {
              if (this.isEmpty()) return
              if (!this.#Bi) {
                this.#Xi()
                return
              }
              const e = this.#ms(),
                i = this.#cs()
              this.#Ri = Math.max(n.AnnotationEditor.MIN_SIZE, e[2] - e[0])
              this.#Fi = Math.max(n.AnnotationEditor.MIN_SIZE, e[3] - e[1])
              const s = Math.ceil(i + this.#Ri * this.scaleFactor),
                a = Math.ceil(i + this.#Fi * this.scaleFactor),
                [r, o] = this.parentDimensions
              this.width = s / r
              this.height = a / o
              this.setAspectRatio(s, a)
              const l = this.translationX,
                h = this.translationY
              this.translationX = -e[0]
              this.translationY = -e[1]
              this.#Ji()
              this.#Xi()
              this.#Hi = s
              this.#Wi = a
              this.setDims(s, a)
              const c = t ? i / this.scaleFactor / 2 : 0
              this.translate(l - this.translationX - c, h - this.translationY - c)
            }
            static deserialize(t, e, i) {
              if (t instanceof a.InkAnnotationElement) return null
              const r = super.deserialize(t, e, i)
              r.thickness = t.thickness
              r.color = s.Util.makeHexColor(...t.color)
              r.opacity = t.opacity
              const [o, l] = r.pageDimensions,
                h = r.width * o,
                c = r.height * l,
                d = r.parentScale,
                u = t.thickness / 2
              r.#Bi = !0
              r.#Hi = Math.round(h)
              r.#Wi = Math.round(c)
              const { paths: p, rect: g, rotation: m } = t
              for (let { bezier: t } of p) {
                t = InkEditor.#ps(t, g, m)
                const e = []
                r.paths.push(e)
                let i = d * (t[0] - u),
                  s = d * (t[1] - u)
                for (let n = 2, a = t.length; n < a; n += 6) {
                  const a = d * (t[n] - u),
                    r = d * (t[n + 1] - u),
                    o = d * (t[n + 2] - u),
                    l = d * (t[n + 3] - u),
                    h = d * (t[n + 4] - u),
                    c = d * (t[n + 5] - u)
                  e.push([
                    [i, s],
                    [a, r],
                    [o, l],
                    [h, c],
                  ])
                  i = h
                  s = c
                }
                const n = this.#ds(e)
                r.bezierPath2D.push(n)
              }
              const f = r.#ms()
              r.#Ri = Math.max(n.AnnotationEditor.MIN_SIZE, f[2] - f[0])
              r.#Fi = Math.max(n.AnnotationEditor.MIN_SIZE, f[3] - f[1])
              r.#hs(h, c)
              return r
            }
            serialize() {
              if (this.isEmpty()) return null
              const t = this.getRect(0, 0),
                e = n.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle)
              return {
                annotationType: s.AnnotationEditorType.INK,
                color: e,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: this.#gs(this.scaleFactor / this.parentScale, this.translationX, this.translationY, t),
                pageIndex: this.pageIndex,
                rect: t,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId,
              }
            }
          }
          e.InkEditor = InkEditor
        },
        (t, e, i) => {
          Object.defineProperty(e, '__esModule', { value: !0 })
          e.StampEditor = void 0
          var s = i(1),
            n = i(4),
            a = i(6),
            r = i(29)
          class StampEditor extends n.AnnotationEditor {
            #fs = null
            #bs = null
            #As = null
            #_s = null
            #vs = null
            #ys = null
            #zi = null
            #Ss = null
            #Es = !1
            #xs = !1
            static _type = 'stamp'
            constructor(t) {
              super({ ...t, name: 'stampEditor' })
              this.#_s = t.bitmapUrl
              this.#vs = t.bitmapFile
            }
            static initialize(t) {
              n.AnnotationEditor.initialize(t)
            }
            static get supportedTypes() {
              return (0, s.shadow)(
                this,
                'supportedTypes',
                ['apng', 'avif', 'bmp', 'gif', 'jpeg', 'png', 'svg+xml', 'webp', 'x-icon'].map((t) => `image/${t}`)
              )
            }
            static get supportedTypesStr() {
              return (0, s.shadow)(this, 'supportedTypesStr', this.supportedTypes.join(','))
            }
            static isHandlingMimeForPasting(t) {
              return this.supportedTypes.includes(t)
            }
            static paste(t, e) {
              e.pasteEditor(s.AnnotationEditorType.STAMP, { bitmapFile: t.getAsFile() })
            }
            #ws(t, e = !1) {
              if (t) {
                this.#fs = t.bitmap
                if (!e) {
                  this.#bs = t.id
                  this.#Es = t.isSvg
                }
                this.#Ki()
              } else this.remove()
            }
            #Cs() {
              this.#As = null
              this._uiManager.enableWaiting(!1)
              this.#ys && this.div.focus()
            }
            #Ts() {
              if (this.#bs) {
                this._uiManager.enableWaiting(!0)
                this._uiManager.imageManager
                  .getFromId(this.#bs)
                  .then((t) => this.#ws(t, !0))
                  .finally(() => this.#Cs())
                return
              }
              if (this.#_s) {
                const t = this.#_s
                this.#_s = null
                this._uiManager.enableWaiting(!0)
                this.#As = this._uiManager.imageManager
                  .getFromUrl(t)
                  .then((t) => this.#ws(t))
                  .finally(() => this.#Cs())
                return
              }
              if (this.#vs) {
                const t = this.#vs
                this.#vs = null
                this._uiManager.enableWaiting(!0)
                this.#As = this._uiManager.imageManager
                  .getFromFile(t)
                  .then((t) => this.#ws(t))
                  .finally(() => this.#Cs())
                return
              }
              const t = document.createElement('input')
              t.type = 'file'
              t.accept = StampEditor.supportedTypesStr
              this.#As = new Promise((e) => {
                t.addEventListener('change', async () => {
                  if (t.files && 0 !== t.files.length) {
                    this._uiManager.enableWaiting(!0)
                    const e = await this._uiManager.imageManager.getFromFile(t.files[0])
                    this.#ws(e)
                  } else this.remove()
                  e()
                })
                t.addEventListener('cancel', () => {
                  this.remove()
                  e()
                })
              }).finally(() => this.#Cs())
              t.click()
            }
            remove() {
              if (this.#bs) {
                this.#fs = null
                this._uiManager.imageManager.deleteId(this.#bs)
                this.#ys?.remove()
                this.#ys = null
                this.#zi?.disconnect()
                this.#zi = null
              }
              super.remove()
            }
            rebuild() {
              if (this.parent) {
                super.rebuild()
                if (null !== this.div) {
                  this.#bs && this.#Ts()
                  this.isAttachedToDOM || this.parent.add(this)
                }
              } else this.#bs && this.#Ts()
            }
            onceAdded() {
              this._isDraggable = !0
              this.div.focus()
            }
            isEmpty() {
              return !(this.#As || this.#fs || this.#_s || this.#vs)
            }
            get isResizable() {
              return !0
            }
            render() {
              if (this.div) return this.div
              let t, e
              if (this.width) {
                t = this.x
                e = this.y
              }
              super.render()
              this.div.hidden = !0
              this.#fs ? this.#Ki() : this.#Ts()
              if (this.width) {
                const [i, s] = this.parentDimensions
                this.setAt(t * i, e * s, this.width * i, this.height * s)
              }
              return this.div
            }
            #Ki() {
              const { div: t } = this
              let { width: e, height: i } = this.#fs
              const [s, n] = this.pageDimensions,
                a = 0.75
              if (this.width) {
                e = this.width * s
                i = this.height * n
              } else if (e > a * s || i > a * n) {
                const t = Math.min((a * s) / e, (a * n) / i)
                e *= t
                i *= t
              }
              const [r, o] = this.parentDimensions
              this.setDims((e * r) / s, (i * o) / n)
              this._uiManager.enableWaiting(!1)
              const l = (this.#ys = document.createElement('canvas'))
              t.append(l)
              t.hidden = !1
              this.#Ps(e, i)
              this.#Yi()
              if (!this.#xs) {
                this.parent.addUndoableEditor(this)
                this.#xs = !0
              }
              this._uiManager._eventBus.dispatch('reporttelemetry', { source: this, details: { type: 'editing', subtype: this.editorType, data: { action: 'inserted_image' } } })
              this.addAltTextButton()
            }
            #Ms(t, e) {
              const [i, s] = this.parentDimensions
              this.width = t / i
              this.height = e / s
              this.setDims(t, e)
              this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition()
              this._initialOptions = null
              null !== this.#Ss && clearTimeout(this.#Ss)
              this.#Ss = setTimeout(() => {
                this.#Ss = null
                this.#Ps(t, e)
              }, 200)
            }
            #ks(t, e) {
              const { width: i, height: s } = this.#fs
              let n = i,
                a = s,
                r = this.#fs
              for (; n > 2 * t || a > 2 * e; ) {
                const i = n,
                  s = a
                n > 2 * t && (n = n >= 16384 ? Math.floor(n / 2) - 1 : Math.ceil(n / 2))
                a > 2 * e && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2))
                const o = new OffscreenCanvas(n, a)
                o.getContext('2d').drawImage(r, 0, 0, i, s, 0, 0, n, a)
                r = o.transferToImageBitmap()
              }
              return r
            }
            #Ps(t, e) {
              t = Math.ceil(t)
              e = Math.ceil(e)
              const i = this.#ys
              if (!i || (i.width === t && i.height === e)) return
              i.width = t
              i.height = e
              const s = this.#Es ? this.#fs : this.#ks(t, e),
                n = i.getContext('2d')
              n.filter = this._uiManager.hcmFilter
              n.drawImage(s, 0, 0, s.width, s.height, 0, 0, t, e)
            }
            #Fs(t) {
              if (t) {
                if (this.#Es) {
                  const t = this._uiManager.imageManager.getSvgUrl(this.#bs)
                  if (t) return t
                }
                const t = document.createElement('canvas')
                ;({ width: t.width, height: t.height } = this.#fs)
                t.getContext('2d').drawImage(this.#fs, 0, 0)
                return t.toDataURL()
              }
              if (this.#Es) {
                const [t, e] = this.pageDimensions,
                  i = Math.round(this.width * t * a.PixelsPerInch.PDF_TO_CSS_UNITS),
                  s = Math.round(this.height * e * a.PixelsPerInch.PDF_TO_CSS_UNITS),
                  n = new OffscreenCanvas(i, s)
                n.getContext('2d').drawImage(this.#fs, 0, 0, this.#fs.width, this.#fs.height, 0, 0, i, s)
                return n.transferToImageBitmap()
              }
              return structuredClone(this.#fs)
            }
            #Yi() {
              this.#zi = new ResizeObserver((t) => {
                const e = t[0].contentRect
                e.width && e.height && this.#Ms(e.width, e.height)
              })
              this.#zi.observe(this.div)
            }
            static deserialize(t, e, i) {
              if (t instanceof r.StampAnnotationElement) return null
              const s = super.deserialize(t, e, i),
                { rect: n, bitmapUrl: a, bitmapId: o, isSvg: l, accessibilityData: h } = t
              o && i.imageManager.isValidId(o) ? (s.#bs = o) : (s.#_s = a)
              s.#Es = l
              const [c, d] = s.pageDimensions
              s.width = (n[2] - n[0]) / c
              s.height = (n[3] - n[1]) / d
              h && (s.altTextData = h)
              return s
            }
            serialize(t = !1, e = null) {
              if (this.isEmpty()) return null
              const i = { annotationType: s.AnnotationEditorType.STAMP, bitmapId: this.#bs, pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: this.#Es, structTreeParentId: this._structTreeParentId }
              if (t) {
                i.bitmapUrl = this.#Fs(!0)
                i.accessibilityData = this.altTextData
                return i
              }
              const { decorative: n, altText: a } = this.altTextData
              !n && a && (i.accessibilityData = { type: 'Figure', alt: a })
              if (null === e) return i
              e.stamps ||= new Map()
              const r = this.#Es ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null
              if (e.stamps.has(this.#bs)) {
                if (this.#Es) {
                  const t = e.stamps.get(this.#bs)
                  if (r > t.area) {
                    t.area = r
                    t.serialized.bitmap.close()
                    t.serialized.bitmap = this.#Fs(!1)
                  }
                }
              } else {
                e.stamps.set(this.#bs, { area: r, serialized: i })
                i.bitmap = this.#Fs(!1)
              }
              return i
            }
          }
          e.StampEditor = StampEditor
        },
      ],
      __webpack_module_cache__ = {}
    function __w_pdfjs_require__(t) {
      var e = __webpack_module_cache__[t]
      if (void 0 !== e) return e.exports
      var i = (__webpack_module_cache__[t] = { exports: {} })
      __webpack_modules__[t](i, i.exports, __w_pdfjs_require__)
      return i.exports
    }
    var __webpack_exports__ = {}
    ;(() => {
      var t = __webpack_exports__
      Object.defineProperty(t, '__esModule', { value: !0 })
      Object.defineProperty(t, 'AbortException', {
        enumerable: !0,
        get: function () {
          return e.AbortException
        },
      })
      Object.defineProperty(t, 'AnnotationEditorLayer', {
        enumerable: !0,
        get: function () {
          return a.AnnotationEditorLayer
        },
      })
      Object.defineProperty(t, 'AnnotationEditorParamsType', {
        enumerable: !0,
        get: function () {
          return e.AnnotationEditorParamsType
        },
      })
      Object.defineProperty(t, 'AnnotationEditorType', {
        enumerable: !0,
        get: function () {
          return e.AnnotationEditorType
        },
      })
      Object.defineProperty(t, 'AnnotationEditorUIManager', {
        enumerable: !0,
        get: function () {
          return r.AnnotationEditorUIManager
        },
      })
      Object.defineProperty(t, 'AnnotationLayer', {
        enumerable: !0,
        get: function () {
          return o.AnnotationLayer
        },
      })
      Object.defineProperty(t, 'AnnotationMode', {
        enumerable: !0,
        get: function () {
          return e.AnnotationMode
        },
      })
      Object.defineProperty(t, 'CMapCompressionType', {
        enumerable: !0,
        get: function () {
          return e.CMapCompressionType
        },
      })
      Object.defineProperty(t, 'DOMSVGFactory', {
        enumerable: !0,
        get: function () {
          return s.DOMSVGFactory
        },
      })
      Object.defineProperty(t, 'FeatureTest', {
        enumerable: !0,
        get: function () {
          return e.FeatureTest
        },
      })
      Object.defineProperty(t, 'GlobalWorkerOptions', {
        enumerable: !0,
        get: function () {
          return l.GlobalWorkerOptions
        },
      })
      Object.defineProperty(t, 'ImageKind', {
        enumerable: !0,
        get: function () {
          return e.ImageKind
        },
      })
      Object.defineProperty(t, 'InvalidPDFException', {
        enumerable: !0,
        get: function () {
          return e.InvalidPDFException
        },
      })
      Object.defineProperty(t, 'MissingPDFException', {
        enumerable: !0,
        get: function () {
          return e.MissingPDFException
        },
      })
      Object.defineProperty(t, 'OPS', {
        enumerable: !0,
        get: function () {
          return e.OPS
        },
      })
      Object.defineProperty(t, 'PDFDataRangeTransport', {
        enumerable: !0,
        get: function () {
          return i.PDFDataRangeTransport
        },
      })
      Object.defineProperty(t, 'PDFDateString', {
        enumerable: !0,
        get: function () {
          return s.PDFDateString
        },
      })
      Object.defineProperty(t, 'PDFWorker', {
        enumerable: !0,
        get: function () {
          return i.PDFWorker
        },
      })
      Object.defineProperty(t, 'PasswordResponses', {
        enumerable: !0,
        get: function () {
          return e.PasswordResponses
        },
      })
      Object.defineProperty(t, 'PermissionFlag', {
        enumerable: !0,
        get: function () {
          return e.PermissionFlag
        },
      })
      Object.defineProperty(t, 'PixelsPerInch', {
        enumerable: !0,
        get: function () {
          return s.PixelsPerInch
        },
      })
      Object.defineProperty(t, 'PromiseCapability', {
        enumerable: !0,
        get: function () {
          return e.PromiseCapability
        },
      })
      Object.defineProperty(t, 'RenderingCancelledException', {
        enumerable: !0,
        get: function () {
          return s.RenderingCancelledException
        },
      })
      Object.defineProperty(t, 'SVGGraphics', {
        enumerable: !0,
        get: function () {
          return i.SVGGraphics
        },
      })
      Object.defineProperty(t, 'UnexpectedResponseException', {
        enumerable: !0,
        get: function () {
          return e.UnexpectedResponseException
        },
      })
      Object.defineProperty(t, 'Util', {
        enumerable: !0,
        get: function () {
          return e.Util
        },
      })
      Object.defineProperty(t, 'VerbosityLevel', {
        enumerable: !0,
        get: function () {
          return e.VerbosityLevel
        },
      })
      Object.defineProperty(t, 'XfaLayer', {
        enumerable: !0,
        get: function () {
          return h.XfaLayer
        },
      })
      Object.defineProperty(t, 'build', {
        enumerable: !0,
        get: function () {
          return i.build
        },
      })
      Object.defineProperty(t, 'createValidAbsoluteUrl', {
        enumerable: !0,
        get: function () {
          return e.createValidAbsoluteUrl
        },
      })
      Object.defineProperty(t, 'getDocument', {
        enumerable: !0,
        get: function () {
          return i.getDocument
        },
      })
      Object.defineProperty(t, 'getFilenameFromUrl', {
        enumerable: !0,
        get: function () {
          return s.getFilenameFromUrl
        },
      })
      Object.defineProperty(t, 'getPdfFilenameFromUrl', {
        enumerable: !0,
        get: function () {
          return s.getPdfFilenameFromUrl
        },
      })
      Object.defineProperty(t, 'getXfaPageViewport', {
        enumerable: !0,
        get: function () {
          return s.getXfaPageViewport
        },
      })
      Object.defineProperty(t, 'isDataScheme', {
        enumerable: !0,
        get: function () {
          return s.isDataScheme
        },
      })
      Object.defineProperty(t, 'isPdfFile', {
        enumerable: !0,
        get: function () {
          return s.isPdfFile
        },
      })
      Object.defineProperty(t, 'loadScript', {
        enumerable: !0,
        get: function () {
          return s.loadScript
        },
      })
      Object.defineProperty(t, 'noContextMenu', {
        enumerable: !0,
        get: function () {
          return s.noContextMenu
        },
      })
      Object.defineProperty(t, 'normalizeUnicode', {
        enumerable: !0,
        get: function () {
          return e.normalizeUnicode
        },
      })
      Object.defineProperty(t, 'renderTextLayer', {
        enumerable: !0,
        get: function () {
          return n.renderTextLayer
        },
      })
      Object.defineProperty(t, 'setLayerDimensions', {
        enumerable: !0,
        get: function () {
          return s.setLayerDimensions
        },
      })
      Object.defineProperty(t, 'shadow', {
        enumerable: !0,
        get: function () {
          return e.shadow
        },
      })
      Object.defineProperty(t, 'updateTextLayer', {
        enumerable: !0,
        get: function () {
          return n.updateTextLayer
        },
      })
      Object.defineProperty(t, 'version', {
        enumerable: !0,
        get: function () {
          return i.version
        },
      })
      var e = __w_pdfjs_require__(1),
        i = __w_pdfjs_require__(2),
        s = __w_pdfjs_require__(6),
        n = __w_pdfjs_require__(26),
        a = __w_pdfjs_require__(27),
        r = __w_pdfjs_require__(5),
        o = __w_pdfjs_require__(29),
        l = __w_pdfjs_require__(14),
        h = __w_pdfjs_require__(32)
    })()
    return __webpack_exports__
  })()
)
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tsukimiya.github.io/custom/pages/js/pdf.3.11.174.worker.min.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = root.pdfjsWorker = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.worker", [], () => { return (root.pdfjsWorker = factory()); });
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
	else
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerTask = exports.WorkerMessageHandler = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _primitives = __w_pdfjs_require__(4);
var _pdf_manager = __w_pdfjs_require__(6);
var _annotation = __w_pdfjs_require__(10);
var _cleanup_helper = __w_pdfjs_require__(68);
var _writer = __w_pdfjs_require__(73);
var _message_handler = __w_pdfjs_require__(104);
var _worker_stream = __w_pdfjs_require__(105);
var _struct_tree = __w_pdfjs_require__(72);
class WorkerTask {
  constructor(name) {
    this.name = name;
    this.terminated = false;
    this._capability = new _util.PromiseCapability();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = true;
  }
  ensureNotTerminated() {
    if (this.terminated) {
      throw new Error("Worker task was terminated");
    }
  }
}
exports.WorkerTask = WorkerTask;
class WorkerMessageHandler {
  static setup(handler, port) {
    let testMessageProcessed = false;
    handler.on("test", function (data) {
      if (testMessageProcessed) {
        return;
      }
      testMessageProcessed = true;
      handler.send("test", data instanceof Uint8Array);
    });
    handler.on("configure", function (data) {
      (0, _util.setVerbosityLevel)(data.verbosity);
    });
    handler.on("GetDocRequest", function (data) {
      return WorkerMessageHandler.createDocumentHandler(data, port);
    });
  }
  static createDocumentHandler(docParams, port) {
    let pdfManager;
    let terminated = false;
    let cancelXHRs = null;
    const WorkerTasks = new Set();
    const verbosity = (0, _util.getVerbosityLevel)();
    const {
      docId,
      apiVersion
    } = docParams;
    const workerVersion = '3.11.174';
    if (apiVersion !== workerVersion) {
      throw new Error(`The API version "${apiVersion}" does not match ` + `the Worker version "${workerVersion}".`);
    }
    const enumerableProperties = [];
    for (const property in []) {
      enumerableProperties.push(property);
    }
    if (enumerableProperties.length) {
      throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    }
    const workerHandlerName = docId + "_worker";
    let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
    function ensureNotTerminated() {
      if (terminated) {
        throw new Error("Worker was terminated");
      }
    }
    function startWorkerTask(task) {
      WorkerTasks.add(task);
    }
    function finishWorkerTask(task) {
      task.finish();
      WorkerTasks.delete(task);
    }
    async function loadDocument(recoveryMode) {
      await pdfManager.ensureDoc("checkHeader");
      await pdfManager.ensureDoc("parseStartXRef");
      await pdfManager.ensureDoc("parse", [recoveryMode]);
      await pdfManager.ensureDoc("checkFirstPage", [recoveryMode]);
      await pdfManager.ensureDoc("checkLastPage", [recoveryMode]);
      const isPureXfa = await pdfManager.ensureDoc("isPureXfa");
      if (isPureXfa) {
        const task = new WorkerTask("loadXfaFonts");
        startWorkerTask(task);
        await Promise.all([pdfManager.loadXfaFonts(handler, task).catch(reason => {}).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);
      }
      const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprints")]);
      const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc("htmlForXfa") : null;
      return {
        numPages,
        fingerprints,
        htmlForXfa
      };
    }
    function getPdfManager({
      data,
      password,
      disableAutoFetch,
      rangeChunkSize,
      length,
      docBaseUrl,
      enableXfa,
      evaluatorOptions
    }) {
      const pdfManagerArgs = {
        source: null,
        disableAutoFetch,
        docBaseUrl,
        docId,
        enableXfa,
        evaluatorOptions,
        handler,
        length,
        password,
        rangeChunkSize
      };
      const pdfManagerCapability = new _util.PromiseCapability();
      let newPdfManager;
      if (data) {
        try {
          pdfManagerArgs.source = data;
          newPdfManager = new _pdf_manager.LocalPdfManager(pdfManagerArgs);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        return pdfManagerCapability.promise;
      }
      let pdfStream,
        cachedChunks = [];
      try {
        pdfStream = new _worker_stream.PDFWorkerStream(handler);
      } catch (ex) {
        pdfManagerCapability.reject(ex);
        return pdfManagerCapability.promise;
      }
      const fullRequest = pdfStream.getFullReader();
      fullRequest.headersReady.then(function () {
        if (!fullRequest.isRangeSupported) {
          return;
        }
        pdfManagerArgs.source = pdfStream;
        pdfManagerArgs.length = fullRequest.contentLength;
        pdfManagerArgs.disableAutoFetch ||= fullRequest.isStreamingSupported;
        newPdfManager = new _pdf_manager.NetworkPdfManager(pdfManagerArgs);
        for (const chunk of cachedChunks) {
          newPdfManager.sendProgressiveData(chunk);
        }
        cachedChunks = [];
        pdfManagerCapability.resolve(newPdfManager);
        cancelXHRs = null;
      }).catch(function (reason) {
        pdfManagerCapability.reject(reason);
        cancelXHRs = null;
      });
      let loaded = 0;
      const flushChunks = function () {
        const pdfFile = (0, _core_utils.arrayBuffersToBytes)(cachedChunks);
        if (length && pdfFile.length !== length) {
          (0, _util.warn)("reported HTTP length is different from actual");
        }
        try {
          pdfManagerArgs.source = pdfFile;
          newPdfManager = new _pdf_manager.LocalPdfManager(pdfManagerArgs);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        cachedChunks = [];
      };
      new Promise(function (resolve, reject) {
        const readChunk = function ({
          value,
          done
        }) {
          try {
            ensureNotTerminated();
            if (done) {
              if (!newPdfManager) {
                flushChunks();
              }
              cancelXHRs = null;
              return;
            }
            loaded += value.byteLength;
            if (!fullRequest.isStreamingSupported) {
              handler.send("DocProgress", {
                loaded,
                total: Math.max(loaded, fullRequest.contentLength || 0)
              });
            }
            if (newPdfManager) {
              newPdfManager.sendProgressiveData(value);
            } else {
              cachedChunks.push(value);
            }
            fullRequest.read().then(readChunk, reject);
          } catch (e) {
            reject(e);
          }
        };
        fullRequest.read().then(readChunk, reject);
      }).catch(function (e) {
        pdfManagerCapability.reject(e);
        cancelXHRs = null;
      });
      cancelXHRs = function (reason) {
        pdfStream.cancelAllRequests(reason);
      };
      return pdfManagerCapability.promise;
    }
    function setupDoc(data) {
      function onSuccess(doc) {
        ensureNotTerminated();
        handler.send("GetDoc", {
          pdfInfo: doc
        });
      }
      function onFailure(ex) {
        ensureNotTerminated();
        if (ex instanceof _util.PasswordException) {
          const task = new WorkerTask(`PasswordException: response ${ex.code}`);
          startWorkerTask(task);
          handler.sendWithPromise("PasswordRequest", ex).then(function ({
            password
          }) {
            finishWorkerTask(task);
            pdfManager.updatePassword(password);
            pdfManagerReady();
          }).catch(function () {
            finishWorkerTask(task);
            handler.send("DocException", ex);
          });
        } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
          handler.send("DocException", ex);
        } else {
          handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
        }
      }
      function pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, function (reason) {
          ensureNotTerminated();
          if (!(reason instanceof _core_utils.XRefParseException)) {
            onFailure(reason);
            return;
          }
          pdfManager.requestLoadedStream().then(function () {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          });
        });
      }
      ensureNotTerminated();
      getPdfManager(data).then(function (newPdfManager) {
        if (terminated) {
          newPdfManager.terminate(new _util.AbortException("Worker was terminated."));
          throw new Error("Worker was terminated");
        }
        pdfManager = newPdfManager;
        pdfManager.requestLoadedStream(true).then(stream => {
          handler.send("DataLoaded", {
            length: stream.bytes.byteLength
          });
        });
      }).then(pdfManagerReady, onFailure);
    }
    handler.on("GetPage", function (data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function ([rotate, ref, userUnit, view]) {
          return {
            rotate,
            ref,
            userUnit,
            view
          };
        });
      });
    });
    handler.on("GetPageIndex", function (data) {
      const pageRef = _primitives.Ref.get(data.num, data.gen);
      return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
    });
    handler.on("GetDestinations", function (data) {
      return pdfManager.ensureCatalog("destinations");
    });
    handler.on("GetDestination", function (data) {
      return pdfManager.ensureCatalog("getDestination", [data.id]);
    });
    handler.on("GetPageLabels", function (data) {
      return pdfManager.ensureCatalog("pageLabels");
    });
    handler.on("GetPageLayout", function (data) {
      return pdfManager.ensureCatalog("pageLayout");
    });
    handler.on("GetPageMode", function (data) {
      return pdfManager.ensureCatalog("pageMode");
    });
    handler.on("GetViewerPreferences", function (data) {
      return pdfManager.ensureCatalog("viewerPreferences");
    });
    handler.on("GetOpenAction", function (data) {
      return pdfManager.ensureCatalog("openAction");
    });
    handler.on("GetAttachments", function (data) {
      return pdfManager.ensureCatalog("attachments");
    });
    handler.on("GetDocJSActions", function (data) {
      return pdfManager.ensureCatalog("jsActions");
    });
    handler.on("GetPageJSActions", function ({
      pageIndex
    }) {
      return pdfManager.getPage(pageIndex).then(function (page) {
        return pdfManager.ensure(page, "jsActions");
      });
    });
    handler.on("GetOutline", function (data) {
      return pdfManager.ensureCatalog("documentOutline");
    });
    handler.on("GetOptionalContentConfig", function (data) {
      return pdfManager.ensureCatalog("optionalContentConfig");
    });
    handler.on("GetPermissions", function (data) {
      return pdfManager.ensureCatalog("permissions");
    });
    handler.on("GetMetadata", function (data) {
      return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
    });
    handler.on("GetMarkInfo", function (data) {
      return pdfManager.ensureCatalog("markInfo");
    });
    handler.on("GetData", function (data) {
      return pdfManager.requestLoadedStream().then(function (stream) {
        return stream.bytes;
      });
    });
    handler.on("GetAnnotations", function ({
      pageIndex,
      intent
    }) {
      return pdfManager.getPage(pageIndex).then(function (page) {
        const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`);
        startWorkerTask(task);
        return page.getAnnotationsData(handler, task, intent).then(data => {
          finishWorkerTask(task);
          return data;
        }, reason => {
          finishWorkerTask(task);
          throw reason;
        });
      });
    });
    handler.on("GetFieldObjects", function (data) {
      return pdfManager.ensureDoc("fieldObjects");
    });
    handler.on("HasJSActions", function (data) {
      return pdfManager.ensureDoc("hasJSActions");
    });
    handler.on("GetCalculationOrderIds", function (data) {
      return pdfManager.ensureDoc("calculationOrderIds");
    });
    handler.on("SaveDocument", async function ({
      isPureXfa,
      numPages,
      annotationStorage,
      filename
    }) {
      const globalPromises = [pdfManager.requestLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureCatalog("acroFormRef"), pdfManager.ensureDoc("startXRef"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("structTreeRoot")];
      const promises = [];
      const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
      const [stream, acroForm, acroFormRef, startXRef, xref, linearization, _structTreeRoot] = await Promise.all(globalPromises);
      const catalogRef = xref.trailer.getRaw("Root") || null;
      let structTreeRoot;
      if (newAnnotationsByPage) {
        if (!_structTreeRoot) {
          if (await _struct_tree.StructTreeRoot.canCreateStructureTree({
            catalogRef,
            pdfManager,
            newAnnotationsByPage
          })) {
            structTreeRoot = null;
          }
        } else if (await _structTreeRoot.canUpdateStructTree({
          pdfManager,
          newAnnotationsByPage
        })) {
          structTreeRoot = _structTreeRoot;
        }
        const imagePromises = _annotation.AnnotationFactory.generateImages(annotationStorage.values(), xref, pdfManager.evaluatorOptions.isOffscreenCanvasSupported);
        const newAnnotationPromises = structTreeRoot === undefined ? promises : [];
        for (const [pageIndex, annotations] of newAnnotationsByPage) {
          newAnnotationPromises.push(pdfManager.getPage(pageIndex).then(page => {
            const task = new WorkerTask(`Save (editor): page ${pageIndex}`);
            return page.saveNewAnnotations(handler, task, annotations, imagePromises).finally(function () {
              finishWorkerTask(task);
            });
          }));
        }
        if (structTreeRoot === null) {
          promises.push(Promise.all(newAnnotationPromises).then(async newRefs => {
            await _struct_tree.StructTreeRoot.createStructureTree({
              newAnnotationsByPage,
              xref,
              catalogRef,
              pdfManager,
              newRefs
            });
            return newRefs;
          }));
        } else if (structTreeRoot) {
          promises.push(Promise.all(newAnnotationPromises).then(async newRefs => {
            await structTreeRoot.updateStructureTree({
              newAnnotationsByPage,
              pdfManager,
              newRefs
            });
            return newRefs;
          }));
        }
      }
      if (isPureXfa) {
        promises.push(pdfManager.serializeXfaData(annotationStorage));
      } else {
        for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
          promises.push(pdfManager.getPage(pageIndex).then(function (page) {
            const task = new WorkerTask(`Save: page ${pageIndex}`);
            return page.save(handler, task, annotationStorage).finally(function () {
              finishWorkerTask(task);
            });
          }));
        }
      }
      const refs = await Promise.all(promises);
      let newRefs = [];
      let xfaData = null;
      if (isPureXfa) {
        xfaData = refs[0];
        if (!xfaData) {
          return stream.bytes;
        }
      } else {
        newRefs = refs.flat(2);
        if (newRefs.length === 0) {
          return stream.bytes;
        }
      }
      const needAppearances = acroFormRef && acroForm instanceof _primitives.Dict && newRefs.some(ref => ref.needAppearances);
      const xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || null;
      let xfaDatasetsRef = null;
      let hasXfaDatasetsEntry = false;
      if (Array.isArray(xfa)) {
        for (let i = 0, ii = xfa.length; i < ii; i += 2) {
          if (xfa[i] === "datasets") {
            xfaDatasetsRef = xfa[i + 1];
            hasXfaDatasetsEntry = true;
          }
        }
        if (xfaDatasetsRef === null) {
          xfaDatasetsRef = xref.getNewTemporaryRef();
        }
      } else if (xfa) {
        (0, _util.warn)("Unsupported XFA type.");
      }
      let newXrefInfo = Object.create(null);
      if (xref.trailer) {
        const infoObj = Object.create(null);
        const xrefInfo = xref.trailer.get("Info") || null;
        if (xrefInfo instanceof _primitives.Dict) {
          xrefInfo.forEach((key, value) => {
            if (typeof value === "string") {
              infoObj[key] = (0, _util.stringToPDFString)(value);
            }
          });
        }
        newXrefInfo = {
          rootRef: catalogRef,
          encryptRef: xref.trailer.getRaw("Encrypt") || null,
          newRef: xref.getNewTemporaryRef(),
          infoRef: xref.trailer.getRaw("Info") || null,
          info: infoObj,
          fileIds: xref.trailer.get("ID") || null,
          startXRef: linearization ? startXRef : xref.lastXRefStreamPos ?? startXRef,
          filename
        };
      }
      return (0, _writer.incrementalUpdate)({
        originalData: stream.bytes,
        xrefInfo: newXrefInfo,
        newRefs,
        xref,
        hasXfa: !!xfa,
        xfaDatasetsRef,
        hasXfaDatasetsEntry,
        needAppearances,
        acroFormRef,
        acroForm,
        xfaData
      }).finally(() => {
        xref.resetNewTemporaryRef();
      });
    });
    handler.on("GetOperatorList", function (data, sink) {
      const pageIndex = data.pageIndex;
      pdfManager.getPage(pageIndex).then(function (page) {
        const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
        startWorkerTask(task);
        const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        page.getOperatorList({
          handler,
          sink,
          task,
          intent: data.intent,
          cacheKey: data.cacheKey,
          annotationStorage: data.annotationStorage
        }).then(function (operatorListInfo) {
          finishWorkerTask(task);
          if (start) {
            (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`);
          }
          sink.close();
        }, function (reason) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          sink.error(reason);
        });
      });
    });
    handler.on("GetTextContent", function (data, sink) {
      const {
        pageIndex,
        includeMarkedContent,
        disableNormalization
      } = data;
      pdfManager.getPage(pageIndex).then(function (page) {
        const task = new WorkerTask("GetTextContent: page " + pageIndex);
        startWorkerTask(task);
        const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        page.extractTextContent({
          handler,
          task,
          sink,
          includeMarkedContent,
          disableNormalization
        }).then(function () {
          finishWorkerTask(task);
          if (start) {
            (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`);
          }
          sink.close();
        }, function (reason) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          sink.error(reason);
        });
      });
    });
    handler.on("GetStructTree", function (data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        return pdfManager.ensure(page, "getStructTree");
      });
    });
    handler.on("FontFallback", function (data) {
      return pdfManager.fontFallback(data.id, handler);
    });
    handler.on("Cleanup", function (data) {
      return pdfManager.cleanup(true);
    });
    handler.on("Terminate", function (data) {
      terminated = true;
      const waitOn = [];
      if (pdfManager) {
        pdfManager.terminate(new _util.AbortException("Worker was terminated."));
        const cleanupPromise = pdfManager.cleanup();
        waitOn.push(cleanupPromise);
        pdfManager = null;
      } else {
        (0, _cleanup_helper.clearGlobalCaches)();
      }
      if (cancelXHRs) {
        cancelXHRs(new _util.AbortException("Worker was terminated."));
      }
      for (const task of WorkerTasks) {
        waitOn.push(task.finished);
        task.terminate();
      }
      return Promise.all(waitOn).then(function () {
        handler.destroy();
        handler = null;
      });
    });
    handler.on("Ready", function (data) {
      setupDoc(docParams);
      docParams = null;
    });
    return workerHandlerName;
  }
  static initializeFromPort(port) {
    const handler = new _message_handler.MessageHandler("worker", "main", port);
    WorkerMessageHandler.setup(handler, port);
    handler.send("ready", null);
  }
}
exports.WorkerMessageHandler = WorkerMessageHandler;
function isMessagePort(maybePort) {
  return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
}
if (typeof window === "undefined" && !_util.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
  WorkerMessageHandler.initializeFromPort(self);
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.getModificationDate = getModificationDate;
exports.getUuid = getUuid;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isNodeJS = void 0;
exports.normalizeUnicode = normalizeUnicode;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const MAX_IMAGE_SIZE_TO_CACHE = 10e6;
exports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
const LINE_FACTOR = 1.35;
exports.LINE_FACTOR = LINE_FACTOR;
const LINE_DESCENT_FACTOR = 0.35;
exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
exports.BASELINE_FACTOR = BASELINE_FACTOR;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  SAVE: 0x08,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
exports.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
exports.AnnotationEditorPrefix = AnnotationEditorPrefix;
const AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  STAMP: 13,
  INK: 15
};
exports.AnnotationEditorType = AnnotationEditorType;
const AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23
};
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);
        if (dots?.length >= 2) {
          url = `http://${url}`;
        }
      }
      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch {}
      }
    }
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch {}
  return null;
}
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }
    this.message = message;
    this.name = name;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();
exports.BaseException = BaseException;
class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
}
exports.PasswordException = PasswordException;
class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
}
exports.UnknownErrorException = UnknownErrorException;
class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
}
exports.InvalidPDFException = InvalidPDFException;
class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }
}
exports.MissingPDFException = MissingPDFException;
class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }
}
exports.UnexpectedResponseException = UnexpectedResponseException;
class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
}
exports.FormatError = FormatError;
class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
}
exports.AbortException = AbortException;
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === undefined) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function objectSize(obj) {
  return Object.keys(obj).length;
}
function objectFromMap(map) {
  const obj = Object.create(null);
  for (const [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
class FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get platform() {
    if (typeof navigator === "undefined") {
      return shadow(this, "platform", {
        isWin: false,
        isMac: false
      });
    }
    return shadow(this, "platform", {
      isWin: navigator.platform.includes("Win"),
      isMac: navigator.platform.includes("Mac")
    });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
exports.FeatureTest = FeatureTest;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));
class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }
      minMax[0] *= transform[0];
      minMax[1] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }
      minMax[2] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[2];
      minMax[2] = temp;
      temp = minMax[1];
      minMax[1] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }
      minMax[2] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }
      minMax[0] *= transform[2];
      minMax[1] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[4];
    minMax[2] += transform[5];
    minMax[3] += transform[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }
  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }
  static getAxialAlignedBoundingBox(r, m) {
    const p1 = this.applyTransform(r, m);
    const p2 = this.applyTransform(r.slice(2, 4), m);
    const p3 = this.applyTransform([r[0], r[3]], m);
    const p4 = this.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }
  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }
  static normalizeRect(rect) {
    const r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    const tvalues = [],
      bounds = [[], []];
    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
    for (let i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    let j = tvalues.length,
      mt;
    const jlen = j;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
  }
}
exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];
function stringToPDFString(str) {
  if (str[0] >= "\xEF") {
    let encoding;
    if (str[0] === "\xFE" && str[1] === "\xFF") {
      encoding = "utf-16be";
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      encoding = "utf-16le";
    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      encoding = "utf-8";
    }
    if (encoding) {
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(str);
        return decoder.decode(buffer);
      } catch (ex) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }
  const strBuf = [];
  for (let i = 0, ii = str.length; i < ii; i++) {
    const code = PDFStringTranslateTable[str.charCodeAt(i)];
    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
  }
  return strBuf.join("");
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function isArrayBuffer(v) {
  return typeof v === "object" && v?.byteLength !== undefined;
}
function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}
class PromiseCapability {
  #settled = false;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = data => {
        this.#settled = true;
        resolve(data);
      };
      this.reject = reason => {
        this.#settled = true;
        reject(reason);
      };
    });
  }
  get settled() {
    return this.#settled;
  }
}
exports.PromiseCapability = PromiseCapability;
let NormalizeRegex = null;
let NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = new Map([["ﬅ", "ſt"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p2) => {
    return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
  });
}
function getUuid() {
  if (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  if (typeof crypto !== "undefined" && typeof crypto?.getRandomValues === "function") {
    crypto.getRandomValues(buf);
  } else {
    for (let i = 0; i < 32; i++) {
      buf[i] = Math.floor(Math.random() * 255);
    }
  }
  return bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
exports.AnnotationPrefix = AnnotationPrefix;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRefParseException = exports.XRefEntryException = exports.ParserEOFException = exports.PDF_VERSION_REGEXP = exports.MissingDataException = void 0;
exports.arrayBuffersToBytes = arrayBuffersToBytes;
exports.collectActions = collectActions;
exports.encodeToXmlString = encodeToXmlString;
exports.escapePDFName = escapePDFName;
exports.escapeString = escapeString;
exports.getInheritableProperty = getInheritableProperty;
exports.getLookupTableFactory = getLookupTableFactory;
exports.getNewAnnotationsMap = getNewAnnotationsMap;
exports.getRotationMatrix = getRotationMatrix;
exports.isAscii = isAscii;
exports.isWhiteSpace = isWhiteSpace;
exports.log2 = log2;
exports.numberToString = numberToString;
exports.parseXFAPath = parseXFAPath;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.recoverJsURL = recoverJsURL;
exports.stringToUTF16HexString = stringToUTF16HexString;
exports.stringToUTF16String = stringToUTF16String;
exports.toRomanNumerals = toRomanNumerals;
exports.validateCSSFont = validateCSSFont;
exports.validateFontName = validateFontName;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
exports.PDF_VERSION_REGEXP = PDF_VERSION_REGEXP;
function getLookupTableFactory(initializer) {
  let lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }
    return lookup;
  };
}
class MissingDataException extends _util.BaseException {
  constructor(begin, end) {
    super(`Missing data [${begin}, ${end})`, "MissingDataException");
    this.begin = begin;
    this.end = end;
  }
}
exports.MissingDataException = MissingDataException;
class ParserEOFException extends _util.BaseException {
  constructor(msg) {
    super(msg, "ParserEOFException");
  }
}
exports.ParserEOFException = ParserEOFException;
class XRefEntryException extends _util.BaseException {
  constructor(msg) {
    super(msg, "XRefEntryException");
  }
}
exports.XRefEntryException = XRefEntryException;
class XRefParseException extends _util.BaseException {
  constructor(msg) {
    super(msg, "XRefParseException");
  }
}
exports.XRefParseException = XRefParseException;
function arrayBuffersToBytes(arr) {
  const length = arr.length;
  if (length === 0) {
    return new Uint8Array(0);
  }
  if (length === 1) {
    return new Uint8Array(arr[0]);
  }
  let dataLength = 0;
  for (let i = 0; i < length; i++) {
    dataLength += arr[i].byteLength;
  }
  const data = new Uint8Array(dataLength);
  let pos = 0;
  for (let i = 0; i < length; i++) {
    const item = new Uint8Array(arr[i]);
    data.set(item, pos);
    pos += item.byteLength;
  }
  return data;
}
function getInheritableProperty({
  dict,
  key,
  getArray = false,
  stopWhenFound = true
}) {
  let values;
  const visited = new _primitives.RefSet();
  while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) {
    if (dict.objId) {
      visited.put(dict.objId);
    }
    const value = getArray ? dict.getArray(key) : dict.get(key);
    if (value !== undefined) {
      if (stopWhenFound) {
        return value;
      }
      (values ||= []).push(value);
    }
    dict = dict.get("Parent");
  }
  return values;
}
const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function toRomanNumerals(number, lowerCase = false) {
  (0, _util.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
  const romanBuf = [];
  let pos;
  while (number >= 1000) {
    number -= 1000;
    romanBuf.push("M");
  }
  pos = number / 100 | 0;
  number %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = number / 10 | 0;
  number %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
  const romanStr = romanBuf.join("");
  return lowerCase ? romanStr.toLowerCase() : romanStr;
}
function log2(x) {
  if (x <= 0) {
    return 0;
  }
  return Math.ceil(Math.log2(x));
}
function readInt8(data, offset) {
  return data[offset] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}
function parseXFAPath(path) {
  const positionPattern = /(.+)\[(\d+)\]$/;
  return path.split(".").map(component => {
    const m = component.match(positionPattern);
    if (m) {
      return {
        name: m[1],
        pos: parseInt(m[2], 10)
      };
    }
    return {
      name: component,
      pos: 0
    };
  });
}
function escapePDFName(str) {
  const buffer = [];
  let start = 0;
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    if (char < 0x21 || char > 0x7e || char === 0x23 || char === 0x28 || char === 0x29 || char === 0x3c || char === 0x3e || char === 0x5b || char === 0x5d || char === 0x7b || char === 0x7d || char === 0x2f || char === 0x25) {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }
      buffer.push(`#${char.toString(16)}`);
      start = i + 1;
    }
  }
  if (buffer.length === 0) {
    return str;
  }
  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }
  return buffer.join("");
}
function escapeString(str) {
  return str.replaceAll(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }
    return `\\${match}`;
  });
}
function _collectJS(entry, xref, list, parents) {
  if (!entry) {
    return;
  }
  let parent = null;
  if (entry instanceof _primitives.Ref) {
    if (parents.has(entry)) {
      return;
    }
    parent = entry;
    parents.put(parent);
    entry = xref.fetch(entry);
  }
  if (Array.isArray(entry)) {
    for (const element of entry) {
      _collectJS(element, xref, list, parents);
    }
  } else if (entry instanceof _primitives.Dict) {
    if ((0, _primitives.isName)(entry.get("S"), "JavaScript")) {
      const js = entry.get("JS");
      let code;
      if (js instanceof _base_stream.BaseStream) {
        code = js.getString();
      } else if (typeof js === "string") {
        code = js;
      }
      code &&= (0, _util.stringToPDFString)(code).replaceAll("\x00", "");
      if (code) {
        list.push(code);
      }
    }
    _collectJS(entry.getRaw("Next"), xref, list, parents);
  }
  if (parent) {
    parents.remove(parent);
  }
}
function collectActions(xref, dict, eventType) {
  const actions = Object.create(null);
  const additionalActionsDicts = getInheritableProperty({
    dict,
    key: "AA",
    stopWhenFound: false
  });
  if (additionalActionsDicts) {
    for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
      const additionalActions = additionalActionsDicts[i];
      if (!(additionalActions instanceof _primitives.Dict)) {
        continue;
      }
      for (const key of additionalActions.getKeys()) {
        const action = eventType[key];
        if (!action) {
          continue;
        }
        const actionDict = additionalActions.getRaw(key);
        const parents = new _primitives.RefSet();
        const list = [];
        _collectJS(actionDict, xref, list, parents);
        if (list.length > 0) {
          actions[action] = list;
        }
      }
    }
  }
  if (dict.has("A")) {
    const actionDict = dict.get("A");
    const parents = new _primitives.RefSet();
    const list = [];
    _collectJS(actionDict, xref, list, parents);
    if (list.length > 0) {
      actions.Action = list;
    }
  }
  return (0, _util.objectSize)(actions) > 0 ? actions : null;
}
const XMLEntities = {
  0x3c: "&lt;",
  0x3e: "&gt;",
  0x26: "&amp;",
  0x22: "&quot;",
  0x27: "&apos;"
};
function encodeToXmlString(str) {
  const buffer = [];
  let start = 0;
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.codePointAt(i);
    if (0x20 <= char && char <= 0x7e) {
      const entity = XMLEntities[char];
      if (entity) {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }
        buffer.push(entity);
        start = i + 1;
      }
    } else {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }
      buffer.push(`&#x${char.toString(16).toUpperCase()};`);
      if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
        i++;
      }
      start = i + 1;
    }
  }
  if (buffer.length === 0) {
    return str;
  }
  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }
  return buffer.join("");
}
function validateFontName(fontFamily, mustWarn = false) {
  const m = /^("|').*("|')$/.exec(fontFamily);
  if (m && m[1] === m[2]) {
    const re = new RegExp(`[^\\\\]${m[1]}`);
    if (re.test(fontFamily.slice(1, -1))) {
      if (mustWarn) {
        (0, _util.warn)(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);
      }
      return false;
    }
  } else {
    for (const ident of fontFamily.split(/[ \t]+/)) {
      if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
        if (mustWarn) {
          (0, _util.warn)(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);
        }
        return false;
      }
    }
  }
  return true;
}
function validateCSSFont(cssFontInfo) {
  const DEFAULT_CSS_FONT_OBLIQUE = "14";
  const DEFAULT_CSS_FONT_WEIGHT = "400";
  const CSS_FONT_WEIGHT_VALUES = new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
  const {
    fontFamily,
    fontWeight,
    italicAngle
  } = cssFontInfo;
  if (!validateFontName(fontFamily, true)) {
    return false;
  }
  const weight = fontWeight ? fontWeight.toString() : "";
  cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;
  const angle = parseFloat(italicAngle);
  cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
  return true;
}
function recoverJsURL(str) {
  const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
  const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i");
  const jsUrl = regex.exec(str);
  if (jsUrl?.[2]) {
    const url = jsUrl[2];
    let newWindow = false;
    if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
      newWindow = true;
    }
    return {
      url,
      newWindow
    };
  }
  return null;
}
function numberToString(value) {
  if (Number.isInteger(value)) {
    return value.toString();
  }
  const roundedValue = Math.round(value * 100);
  if (roundedValue % 100 === 0) {
    return (roundedValue / 100).toString();
  }
  if (roundedValue % 10 === 0) {
    return value.toFixed(1);
  }
  return value.toFixed(2);
}
function getNewAnnotationsMap(annotationStorage) {
  if (!annotationStorage) {
    return null;
  }
  const newAnnotationsByPage = new Map();
  for (const [key, value] of annotationStorage) {
    if (!key.startsWith(_util.AnnotationEditorPrefix)) {
      continue;
    }
    let annotations = newAnnotationsByPage.get(value.pageIndex);
    if (!annotations) {
      annotations = [];
      newAnnotationsByPage.set(value.pageIndex, annotations);
    }
    annotations.push(value);
  }
  return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
}
function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}
function stringToUTF16HexString(str) {
  const buf = [];
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push((char >> 8 & 0xff).toString(16).padStart(2, "0"), (char & 0xff).toString(16).padStart(2, "0"));
  }
  return buf.join("");
}
function stringToUTF16String(str, bigEndian = false) {
  const buf = [];
  if (bigEndian) {
    buf.push("\xFE\xFF");
  }
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
  }
  return buf.join("");
}
function getRotationMatrix(rotation, width, height) {
  switch (rotation) {
    case 90:
      return [0, 1, -1, 0, width, 0];
    case 180:
      return [-1, 0, 0, -1, width, height];
    case 270:
      return [0, -1, 1, 0, 0, height];
    default:
      throw new Error("Invalid rotation");
  }
}

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = exports.CIRCULAR_REF = void 0;
exports.clearPrimitiveCaches = clearPrimitiveCaches;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isName = isName;
exports.isRefsEqual = isRefsEqual;
var _util = __w_pdfjs_require__(2);
const CIRCULAR_REF = Symbol("CIRCULAR_REF");
exports.CIRCULAR_REF = CIRCULAR_REF;
const EOF = Symbol("EOF");
exports.EOF = EOF;
let CmdCache = Object.create(null);
let NameCache = Object.create(null);
let RefCache = Object.create(null);
function clearPrimitiveCaches() {
  CmdCache = Object.create(null);
  NameCache = Object.create(null);
  RefCache = Object.create(null);
}
class Name {
  constructor(name) {
    this.name = name;
  }
  static get(name) {
    return NameCache[name] ||= new Name(name);
  }
}
exports.Name = Name;
class Cmd {
  constructor(cmd) {
    this.cmd = cmd;
  }
  static get(cmd) {
    return CmdCache[cmd] ||= new Cmd(cmd);
  }
}
exports.Cmd = Cmd;
const nonSerializable = function nonSerializableClosure() {
  return nonSerializable;
};
class Dict {
  constructor(xref = null) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }
  assignXref(newXref) {
    this.xref = newXref;
  }
  get size() {
    return Object.keys(this._map).length;
  }
  get(key1, key2, key3) {
    let value = this._map[key1];
    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];
      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      return this.xref.fetch(value, this.suppressEncryption);
    }
    return value;
  }
  async getAsync(key1, key2, key3) {
    let value = this._map[key1];
    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];
      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      return this.xref.fetchAsync(value, this.suppressEncryption);
    }
    return value;
  }
  getArray(key1, key2, key3) {
    let value = this._map[key1];
    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];
      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      value = this.xref.fetch(value, this.suppressEncryption);
    }
    if (Array.isArray(value)) {
      value = value.slice();
      for (let i = 0, ii = value.length; i < ii; i++) {
        if (value[i] instanceof Ref && this.xref) {
          value[i] = this.xref.fetch(value[i], this.suppressEncryption);
        }
      }
    }
    return value;
  }
  getRaw(key) {
    return this._map[key];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  getRawValues() {
    return Object.values(this._map);
  }
  set(key, value) {
    this._map[key] = value;
  }
  has(key) {
    return this._map[key] !== undefined;
  }
  forEach(callback) {
    for (const key in this._map) {
      callback(key, this.get(key));
    }
  }
  static get empty() {
    const emptyDict = new Dict(null);
    emptyDict.set = (key, value) => {
      (0, _util.unreachable)("Should not call `set` on the empty dictionary.");
    };
    return (0, _util.shadow)(this, "empty", emptyDict);
  }
  static merge({
    xref,
    dictArray,
    mergeSubDicts = false
  }) {
    const mergedDict = new Dict(xref),
      properties = new Map();
    for (const dict of dictArray) {
      if (!(dict instanceof Dict)) {
        continue;
      }
      for (const [key, value] of Object.entries(dict._map)) {
        let property = properties.get(key);
        if (property === undefined) {
          property = [];
          properties.set(key, property);
        } else if (!mergeSubDicts || !(value instanceof Dict)) {
          continue;
        }
        property.push(value);
      }
    }
    for (const [name, values] of properties) {
      if (values.length === 1 || !(values[0] instanceof Dict)) {
        mergedDict._map[name] = values[0];
        continue;
      }
      const subDict = new Dict(xref);
      for (const dict of values) {
        for (const [key, value] of Object.entries(dict._map)) {
          if (subDict._map[key] === undefined) {
            subDict._map[key] = value;
          }
        }
      }
      if (subDict.size > 0) {
        mergedDict._map[name] = subDict;
      }
    }
    properties.clear();
    return mergedDict.size > 0 ? mergedDict : Dict.empty;
  }
  clone() {
    const dict = new Dict(this.xref);
    for (const key of this.getKeys()) {
      dict.set(key, this.getRaw(key));
    }
    return dict;
  }
}
exports.Dict = Dict;
class Ref {
  constructor(num, gen) {
    this.num = num;
    this.gen = gen;
  }
  toString() {
    if (this.gen === 0) {
      return `${this.num}R`;
    }
    return `${this.num}R${this.gen}`;
  }
  static fromString(str) {
    const ref = RefCache[str];
    if (ref) {
      return ref;
    }
    const m = /^(\d+)R(\d*)$/.exec(str);
    if (!m || m[1] === "0") {
      return null;
    }
    return RefCache[str] = new Ref(parseInt(m[1]), !m[2] ? 0 : parseInt(m[2]));
  }
  static get(num, gen) {
    const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
    return RefCache[key] ||= new Ref(num, gen);
  }
}
exports.Ref = Ref;
class RefSet {
  constructor(parent = null) {
    this._set = new Set(parent?._set);
  }
  has(ref) {
    return this._set.has(ref.toString());
  }
  put(ref) {
    this._set.add(ref.toString());
  }
  remove(ref) {
    this._set.delete(ref.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
exports.RefSet = RefSet;
class RefSetCache {
  constructor() {
    this._map = new Map();
  }
  get size() {
    return this._map.size;
  }
  get(ref) {
    return this._map.get(ref.toString());
  }
  has(ref) {
    return this._map.has(ref.toString());
  }
  put(ref, obj) {
    this._map.set(ref.toString(), obj);
  }
  putAlias(ref, aliasRef) {
    this._map.set(ref.toString(), this.get(aliasRef));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
}
exports.RefSetCache = RefSetCache;
function isName(v, name) {
  return v instanceof Name && (name === undefined || v.name === name);
}
function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}
function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get("Type"), type));
}
function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStream = void 0;
var _util = __w_pdfjs_require__(2);
class BaseStream {
  constructor() {
    if (this.constructor === BaseStream) {
      (0, _util.unreachable)("Cannot initialize BaseStream.");
    }
  }
  get length() {
    (0, _util.unreachable)("Abstract getter `length` accessed");
  }
  get isEmpty() {
    (0, _util.unreachable)("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return (0, _util.shadow)(this, "isDataLoaded", true);
  }
  getByte() {
    (0, _util.unreachable)("Abstract method `getByte` called");
  }
  getBytes(length) {
    (0, _util.unreachable)("Abstract method `getBytes` called");
  }
  peekByte() {
    const peekedByte = this.getByte();
    if (peekedByte !== -1) {
      this.pos--;
    }
    return peekedByte;
  }
  peekBytes(length) {
    const bytes = this.getBytes(length);
    this.pos -= bytes.length;
    return bytes;
  }
  getUint16() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    if (b0 === -1 || b1 === -1) {
      return -1;
    }
    return (b0 << 8) + b1;
  }
  getInt32() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    const b2 = this.getByte();
    const b3 = this.getByte();
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }
  getByteRange(begin, end) {
    (0, _util.unreachable)("Abstract method `getByteRange` called");
  }
  getString(length) {
    return (0, _util.bytesToString)(this.getBytes(length));
  }
  skip(n) {
    this.pos += n || 1;
  }
  reset() {
    (0, _util.unreachable)("Abstract method `reset` called");
  }
  moveStart() {
    (0, _util.unreachable)("Abstract method `moveStart` called");
  }
  makeSubStream(start, length, dict = null) {
    (0, _util.unreachable)("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
exports.BaseStream = BaseStream;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NetworkPdfManager = exports.LocalPdfManager = void 0;
var _util = __w_pdfjs_require__(2);
var _chunked_stream = __w_pdfjs_require__(7);
var _core_utils = __w_pdfjs_require__(3);
var _document = __w_pdfjs_require__(9);
var _stream = __w_pdfjs_require__(8);
function parseDocBaseUrl(url) {
  if (url) {
    const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url);
    if (absoluteUrl) {
      return absoluteUrl.href;
    }
    (0, _util.warn)(`Invalid absolute docBaseUrl: "${url}".`);
  }
  return null;
}
class BasePdfManager {
  constructor(args) {
    if (this.constructor === BasePdfManager) {
      (0, _util.unreachable)("Cannot initialize BasePdfManager.");
    }
    this._docBaseUrl = parseDocBaseUrl(args.docBaseUrl);
    this._docId = args.docId;
    this._password = args.password;
    this.enableXfa = args.enableXfa;
    args.evaluatorOptions.isOffscreenCanvasSupported &&= _util.FeatureTest.isOffscreenCanvasSupported;
    this.evaluatorOptions = args.evaluatorOptions;
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  get catalog() {
    return this.pdfDocument.catalog;
  }
  ensureDoc(prop, args) {
    return this.ensure(this.pdfDocument, prop, args);
  }
  ensureXRef(prop, args) {
    return this.ensure(this.pdfDocument.xref, prop, args);
  }
  ensureCatalog(prop, args) {
    return this.ensure(this.pdfDocument.catalog, prop, args);
  }
  getPage(pageIndex) {
    return this.pdfDocument.getPage(pageIndex);
  }
  fontFallback(id, handler) {
    return this.pdfDocument.fontFallback(id, handler);
  }
  loadXfaFonts(handler, task) {
    return this.pdfDocument.loadXfaFonts(handler, task);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(annotationStorage) {
    return this.pdfDocument.serializeXfaData(annotationStorage);
  }
  cleanup(manuallyTriggered = false) {
    return this.pdfDocument.cleanup(manuallyTriggered);
  }
  async ensure(obj, prop, args) {
    (0, _util.unreachable)("Abstract method `ensure` called");
  }
  requestRange(begin, end) {
    (0, _util.unreachable)("Abstract method `requestRange` called");
  }
  requestLoadedStream(noFetch = false) {
    (0, _util.unreachable)("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(chunk) {
    (0, _util.unreachable)("Abstract method `sendProgressiveData` called");
  }
  updatePassword(password) {
    this._password = password;
  }
  terminate(reason) {
    (0, _util.unreachable)("Abstract method `terminate` called");
  }
}
class LocalPdfManager extends BasePdfManager {
  constructor(args) {
    super(args);
    const stream = new _stream.Stream(args.source);
    this.pdfDocument = new _document.PDFDocument(this, stream);
    this._loadedStreamPromise = Promise.resolve(stream);
  }
  async ensure(obj, prop, args) {
    const value = obj[prop];
    if (typeof value === "function") {
      return value.apply(obj, args);
    }
    return value;
  }
  requestRange(begin, end) {
    return Promise.resolve();
  }
  requestLoadedStream(noFetch = false) {
    return this._loadedStreamPromise;
  }
  terminate(reason) {}
}
exports.LocalPdfManager = LocalPdfManager;
class NetworkPdfManager extends BasePdfManager {
  constructor(args) {
    super(args);
    this.streamManager = new _chunked_stream.ChunkedStreamManager(args.source, {
      msgHandler: args.handler,
      length: args.length,
      disableAutoFetch: args.disableAutoFetch,
      rangeChunkSize: args.rangeChunkSize
    });
    this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(obj, prop, args) {
    try {
      const value = obj[prop];
      if (typeof value === "function") {
        return value.apply(obj, args);
      }
      return value;
    } catch (ex) {
      if (!(ex instanceof _core_utils.MissingDataException)) {
        throw ex;
      }
      await this.requestRange(ex.begin, ex.end);
      return this.ensure(obj, prop, args);
    }
  }
  requestRange(begin, end) {
    return this.streamManager.requestRange(begin, end);
  }
  requestLoadedStream(noFetch = false) {
    return this.streamManager.requestAllChunks(noFetch);
  }
  sendProgressiveData(chunk) {
    this.streamManager.onReceiveData({
      chunk
    });
  }
  terminate(reason) {
    this.streamManager.abort(reason);
  }
}
exports.NetworkPdfManager = NetworkPdfManager;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChunkedStreamManager = exports.ChunkedStream = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _stream = __w_pdfjs_require__(8);
class ChunkedStream extends _stream.Stream {
  constructor(length, chunkSize, manager) {
    super(new Uint8Array(length), 0, length, null);
    this.chunkSize = chunkSize;
    this._loadedChunks = new Set();
    this.numChunks = Math.ceil(length / chunkSize);
    this.manager = manager;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const chunks = [];
    for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        chunks.push(chunk);
      }
    }
    return chunks;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(begin, chunk) {
    const chunkSize = this.chunkSize;
    if (begin % chunkSize !== 0) {
      throw new Error(`Bad begin offset: ${begin}`);
    }
    const end = begin + chunk.byteLength;
    if (end % chunkSize !== 0 && end !== this.bytes.length) {
      throw new Error(`Bad end offset: ${end}`);
    }
    this.bytes.set(new Uint8Array(chunk), begin);
    const beginChunk = Math.floor(begin / chunkSize);
    const endChunk = Math.floor((end - 1) / chunkSize) + 1;
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  onReceiveProgressiveData(data) {
    let position = this.progressiveDataLength;
    const beginChunk = Math.floor(position / this.chunkSize);
    this.bytes.set(new Uint8Array(data), position);
    position += data.byteLength;
    this.progressiveDataLength = position;
    const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  ensureByte(pos) {
    if (pos < this.progressiveDataLength) {
      return;
    }
    const chunk = Math.floor(pos / this.chunkSize);
    if (chunk > this.numChunks) {
      return;
    }
    if (chunk === this.lastSuccessfulEnsureByteChunk) {
      return;
    }
    if (!this._loadedChunks.has(chunk)) {
      throw new _core_utils.MissingDataException(pos, pos + 1);
    }
    this.lastSuccessfulEnsureByteChunk = chunk;
  }
  ensureRange(begin, end) {
    if (begin >= end) {
      return;
    }
    if (end <= this.progressiveDataLength) {
      return;
    }
    const beginChunk = Math.floor(begin / this.chunkSize);
    if (beginChunk > this.numChunks) {
      return;
    }
    const endChunk = Math.min(Math.floor((end - 1) / this.chunkSize) + 1, this.numChunks);
    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        throw new _core_utils.MissingDataException(begin, end);
      }
    }
  }
  nextEmptyChunk(beginChunk) {
    const numChunks = this.numChunks;
    for (let i = 0; i < numChunks; ++i) {
      const chunk = (beginChunk + i) % numChunks;
      if (!this._loadedChunks.has(chunk)) {
        return chunk;
      }
    }
    return null;
  }
  hasChunk(chunk) {
    return this._loadedChunks.has(chunk);
  }
  getByte() {
    const pos = this.pos;
    if (pos >= this.end) {
      return -1;
    }
    if (pos >= this.progressiveDataLength) {
      this.ensureByte(pos);
    }
    return this.bytes[this.pos++];
  }
  getBytes(length) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;
    if (!length) {
      if (strEnd > this.progressiveDataLength) {
        this.ensureRange(pos, strEnd);
      }
      return bytes.subarray(pos, strEnd);
    }
    let end = pos + length;
    if (end > strEnd) {
      end = strEnd;
    }
    if (end > this.progressiveDataLength) {
      this.ensureRange(pos, end);
    }
    this.pos = end;
    return bytes.subarray(pos, end);
  }
  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.end) {
      end = this.end;
    }
    if (end > this.progressiveDataLength) {
      this.ensureRange(begin, end);
    }
    return this.bytes.subarray(begin, end);
  }
  makeSubStream(start, length, dict = null) {
    if (length) {
      if (start + length > this.progressiveDataLength) {
        this.ensureRange(start, start + length);
      }
    } else if (start >= this.progressiveDataLength) {
      this.ensureByte(start);
    }
    function ChunkedStreamSubstream() {}
    ChunkedStreamSubstream.prototype = Object.create(this);
    ChunkedStreamSubstream.prototype.getMissingChunks = function () {
      const chunkSize = this.chunkSize;
      const beginChunk = Math.floor(this.start / chunkSize);
      const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
      const missingChunks = [];
      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!this._loadedChunks.has(chunk)) {
          missingChunks.push(chunk);
        }
      }
      return missingChunks;
    };
    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
      get() {
        if (this.numChunksLoaded === this.numChunks) {
          return true;
        }
        return this.getMissingChunks().length === 0;
      },
      configurable: true
    });
    const subStream = new ChunkedStreamSubstream();
    subStream.pos = subStream.start = start;
    subStream.end = start + length || this.end;
    subStream.dict = dict;
    return subStream;
  }
  getBaseStreams() {
    return [this];
  }
}
exports.ChunkedStream = ChunkedStream;
class ChunkedStreamManager {
  constructor(pdfNetworkStream, args) {
    this.length = args.length;
    this.chunkSize = args.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = pdfNetworkStream;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = new Map();
    this._requestsByChunk = new Map();
    this._promisesByRequest = new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = new _util.PromiseCapability();
  }
  sendRequest(begin, end) {
    const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
    if (!rangeReader.isStreamingSupported) {
      rangeReader.onProgress = this.onProgress.bind(this);
    }
    let chunks = [],
      loaded = 0;
    return new Promise((resolve, reject) => {
      const readChunk = ({
        value,
        done
      }) => {
        try {
          if (done) {
            const chunkData = (0, _core_utils.arrayBuffersToBytes)(chunks);
            chunks = null;
            resolve(chunkData);
            return;
          }
          loaded += value.byteLength;
          if (rangeReader.isStreamingSupported) {
            this.onProgress({
              loaded
            });
          }
          chunks.push(value);
          rangeReader.read().then(readChunk, reject);
        } catch (e) {
          reject(e);
        }
      };
      rangeReader.read().then(readChunk, reject);
    }).then(data => {
      if (this.aborted) {
        return;
      }
      this.onReceiveData({
        chunk: data,
        begin
      });
    });
  }
  requestAllChunks(noFetch = false) {
    if (!noFetch) {
      const missingChunks = this.stream.getMissingChunks();
      this._requestChunks(missingChunks);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(chunks) {
    const requestId = this.currRequestId++;
    const chunksNeeded = new Set();
    this._chunksNeededByRequest.set(requestId, chunksNeeded);
    for (const chunk of chunks) {
      if (!this.stream.hasChunk(chunk)) {
        chunksNeeded.add(chunk);
      }
    }
    if (chunksNeeded.size === 0) {
      return Promise.resolve();
    }
    const capability = new _util.PromiseCapability();
    this._promisesByRequest.set(requestId, capability);
    const chunksToRequest = [];
    for (const chunk of chunksNeeded) {
      let requestIds = this._requestsByChunk.get(chunk);
      if (!requestIds) {
        requestIds = [];
        this._requestsByChunk.set(chunk, requestIds);
        chunksToRequest.push(chunk);
      }
      requestIds.push(requestId);
    }
    if (chunksToRequest.length > 0) {
      const groupedChunksToRequest = this.groupChunks(chunksToRequest);
      for (const groupedChunk of groupedChunksToRequest) {
        const begin = groupedChunk.beginChunk * this.chunkSize;
        const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
        this.sendRequest(begin, end).catch(capability.reject);
      }
    }
    return capability.promise.catch(reason => {
      if (this.aborted) {
        return;
      }
      throw reason;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(begin, end) {
    end = Math.min(end, this.length);
    const beginChunk = this.getBeginChunk(begin);
    const endChunk = this.getEndChunk(end);
    const chunks = [];
    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      chunks.push(chunk);
    }
    return this._requestChunks(chunks);
  }
  requestRanges(ranges = []) {
    const chunksToRequest = [];
    for (const range of ranges) {
      const beginChunk = this.getBeginChunk(range.begin);
      const endChunk = this.getEndChunk(range.end);
      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!chunksToRequest.includes(chunk)) {
          chunksToRequest.push(chunk);
        }
      }
    }
    chunksToRequest.sort(function (a, b) {
      return a - b;
    });
    return this._requestChunks(chunksToRequest);
  }
  groupChunks(chunks) {
    const groupedChunks = [];
    let beginChunk = -1;
    let prevChunk = -1;
    for (let i = 0, ii = chunks.length; i < ii; ++i) {
      const chunk = chunks[i];
      if (beginChunk < 0) {
        beginChunk = chunk;
      }
      if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
        groupedChunks.push({
          beginChunk,
          endChunk: prevChunk + 1
        });
        beginChunk = chunk;
      }
      if (i + 1 === chunks.length) {
        groupedChunks.push({
          beginChunk,
          endChunk: chunk + 1
        });
      }
      prevChunk = chunk;
    }
    return groupedChunks;
  }
  onProgress(args) {
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
      total: this.length
    });
  }
  onReceiveData(args) {
    const chunk = args.chunk;
    const isProgressive = args.begin === undefined;
    const begin = isProgressive ? this.progressiveDataLength : args.begin;
    const end = begin + chunk.byteLength;
    const beginChunk = Math.floor(begin / this.chunkSize);
    const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
    if (isProgressive) {
      this.stream.onReceiveProgressiveData(chunk);
      this.progressiveDataLength = end;
    } else {
      this.stream.onReceiveData(begin, chunk);
    }
    if (this.stream.isDataLoaded) {
      this._loadedStreamCapability.resolve(this.stream);
    }
    const loadedRequests = [];
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      const requestIds = this._requestsByChunk.get(curChunk);
      if (!requestIds) {
        continue;
      }
      this._requestsByChunk.delete(curChunk);
      for (const requestId of requestIds) {
        const chunksNeeded = this._chunksNeededByRequest.get(requestId);
        if (chunksNeeded.has(curChunk)) {
          chunksNeeded.delete(curChunk);
        }
        if (chunksNeeded.size > 0) {
          continue;
        }
        loadedRequests.push(requestId);
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let nextEmptyChunk;
      if (this.stream.numChunksLoaded === 1) {
        const lastChunk = this.stream.numChunks - 1;
        if (!this.stream.hasChunk(lastChunk)) {
          nextEmptyChunk = lastChunk;
        }
      } else {
        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
      }
      if (Number.isInteger(nextEmptyChunk)) {
        this._requestChunks([nextEmptyChunk]);
      }
    }
    for (const requestId of loadedRequests) {
      const capability = this._promisesByRequest.get(requestId);
      this._promisesByRequest.delete(requestId);
      capability.resolve();
    }
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize,
      total: this.length
    });
  }
  onError(err) {
    this._loadedStreamCapability.reject(err);
  }
  getBeginChunk(begin) {
    return Math.floor(begin / this.chunkSize);
  }
  getEndChunk(end) {
    return Math.floor((end - 1) / this.chunkSize) + 1;
  }
  abort(reason) {
    this.aborted = true;
    this.pdfNetworkStream?.cancelAllRequests(reason);
    for (const capability of this._promisesByRequest.values()) {
      capability.reject(reason);
    }
  }
}
exports.ChunkedStreamManager = ChunkedStreamManager;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StringStream = exports.Stream = exports.NullStream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _util = __w_pdfjs_require__(2);
class Stream extends _base_stream.BaseStream {
  constructor(arrayBuffer, start, length, dict) {
    super();
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.bytes[this.pos++];
  }
  getBytes(length) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;
    if (!length) {
      return bytes.subarray(pos, strEnd);
    }
    let end = pos + length;
    if (end > strEnd) {
      end = strEnd;
    }
    this.pos = end;
    return bytes.subarray(pos, end);
  }
  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.end) {
      end = this.end;
    }
    return this.bytes.subarray(begin, end);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(start, length, dict = null) {
    return new Stream(this.bytes.buffer, start, length, dict);
  }
}
exports.Stream = Stream;
class StringStream extends Stream {
  constructor(str) {
    super((0, _util.stringToBytes)(str));
  }
}
exports.StringStream = StringStream;
class NullStream extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }
}
exports.NullStream = NullStream;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Page = exports.PDFDocument = void 0;
var _util = __w_pdfjs_require__(2);
var _annotation = __w_pdfjs_require__(10);
var _core_utils = __w_pdfjs_require__(3);
var _primitives = __w_pdfjs_require__(4);
var _xfa_fonts = __w_pdfjs_require__(51);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
var _catalog = __w_pdfjs_require__(66);
var _cleanup_helper = __w_pdfjs_require__(68);
var _dataset_reader = __w_pdfjs_require__(102);
var _parser = __w_pdfjs_require__(16);
var _stream = __w_pdfjs_require__(8);
var _object_loader = __w_pdfjs_require__(76);
var _operator_list = __w_pdfjs_require__(64);
var _evaluator = __w_pdfjs_require__(13);
var _decode_stream = __w_pdfjs_require__(18);
var _struct_tree = __w_pdfjs_require__(72);
var _writer = __w_pdfjs_require__(73);
var _factory = __w_pdfjs_require__(77);
var _xref = __w_pdfjs_require__(103);
const DEFAULT_USER_UNIT = 1.0;
const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
class Page {
  constructor({
    pdfManager,
    xref,
    pageIndex,
    pageDict,
    ref,
    globalIdFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    systemFontCache,
    nonBlendModesSet,
    xfaFactory
  }) {
    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.systemFontCache = systemFontCache;
    this.nonBlendModesSet = nonBlendModesSet;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    this.xfaFactory = xfaFactory;
    const idCounters = {
      obj: 0
    };
    this._localIdFactory = class extends globalIdFactory {
      static createObjId() {
        return `p${pageIndex}_${++idCounters.obj}`;
      }
      static getPageObjId() {
        return `p${ref.toString()}`;
      }
    };
  }
  _getInheritableProperty(key, getArray = false) {
    const value = (0, _core_utils.getInheritableProperty)({
      dict: this.pageDict,
      key,
      getArray,
      stopWhenFound: false
    });
    if (!Array.isArray(value)) {
      return value;
    }
    if (value.length === 1 || !(value[0] instanceof _primitives.Dict)) {
      return value[0];
    }
    return _primitives.Dict.merge({
      xref: this.xref,
      dictArray: value
    });
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const resources = this._getInheritableProperty("Resources");
    return (0, _util.shadow)(this, "resources", resources instanceof _primitives.Dict ? resources : _primitives.Dict.empty);
  }
  _getBoundingBox(name) {
    if (this.xfaData) {
      return this.xfaData.bbox;
    }
    let box = this._getInheritableProperty(name, true);
    if (Array.isArray(box) && box.length === 4) {
      box = _util.Util.normalizeRect(box);
      if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {
        return box;
      }
      (0, _util.warn)(`Empty, or invalid, /${name} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
  }
  get cropBox() {
    return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    let obj = this.pageDict.get("UserUnit");
    if (typeof obj !== "number" || obj <= 0) {
      obj = DEFAULT_USER_UNIT;
    }
    return (0, _util.shadow)(this, "userUnit", obj);
  }
  get view() {
    const {
      cropBox,
      mediaBox
    } = this;
    if (cropBox !== mediaBox && !(0, _util.isArrayEqual)(cropBox, mediaBox)) {
      const box = _util.Util.intersect(cropBox, mediaBox);
      if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
        return (0, _util.shadow)(this, "view", box);
      }
      (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
    }
    return (0, _util.shadow)(this, "view", mediaBox);
  }
  get rotate() {
    let rotate = this._getInheritableProperty("Rotate") || 0;
    if (rotate % 90 !== 0) {
      rotate = 0;
    } else if (rotate >= 360) {
      rotate %= 360;
    } else if (rotate < 0) {
      rotate = (rotate % 360 + 360) % 360;
    }
    return (0, _util.shadow)(this, "rotate", rotate);
  }
  _onSubStreamError(reason, objId) {
    if (this.evaluatorOptions.ignoreErrors) {
      (0, _util.warn)(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
      return;
    }
    throw reason;
  }
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then(content => {
      if (content instanceof _base_stream.BaseStream) {
        return content;
      }
      if (Array.isArray(content)) {
        return new _decode_stream.StreamsSequenceStream(content, this._onSubStreamError.bind(this));
      }
      return new _stream.NullStream();
    });
  }
  get xfaData() {
    return (0, _util.shadow)(this, "xfaData", this.xfaFactory ? {
      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
    } : null);
  }
  #replaceIdByRef(annotations, deletedAnnotations, existingAnnotations) {
    for (const annotation of annotations) {
      if (annotation.id) {
        const ref = _primitives.Ref.fromString(annotation.id);
        if (!ref) {
          (0, _util.warn)(`A non-linked annotation cannot be modified: ${annotation.id}`);
          continue;
        }
        if (annotation.deleted) {
          deletedAnnotations.put(ref);
          continue;
        }
        existingAnnotations?.put(ref);
        annotation.ref = ref;
        delete annotation.id;
      }
    }
  }
  async saveNewAnnotations(handler, task, annotations, imagePromises) {
    if (this.xfaFactory) {
      throw new Error("XFA: Cannot save new annotations.");
    }
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    });
    const deletedAnnotations = new _primitives.RefSet();
    const existingAnnotations = new _primitives.RefSet();
    this.#replaceIdByRef(annotations, deletedAnnotations, existingAnnotations);
    const pageDict = this.pageDict;
    const annotationsArray = this.annotations.filter(a => !(a instanceof _primitives.Ref && deletedAnnotations.has(a)));
    const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations, imagePromises);
    for (const {
      ref
    } of newData.annotations) {
      if (ref instanceof _primitives.Ref && !existingAnnotations.has(ref)) {
        annotationsArray.push(ref);
      }
    }
    const savedDict = pageDict.get("Annots");
    pageDict.set("Annots", annotationsArray);
    const buffer = [];
    await (0, _writer.writeObject)(this.ref, pageDict, buffer, this.xref);
    if (savedDict) {
      pageDict.set("Annots", savedDict);
    }
    const objects = newData.dependencies;
    objects.push({
      ref: this.ref,
      data: buffer.join("")
    }, ...newData.annotations);
    return objects;
  }
  save(handler, task, annotationStorage) {
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    });
    return this._parsedAnnotations.then(function (annotations) {
      const newRefsPromises = [];
      for (const annotation of annotations) {
        if (!annotation.mustBePrinted(annotationStorage)) {
          continue;
        }
        newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) {
          (0, _util.warn)("save - ignoring annotation data during " + `"${task.name}" task: "${reason}".`);
          return null;
        }));
      }
      return Promise.all(newRefsPromises).then(function (newRefs) {
        return newRefs.filter(newRef => !!newRef);
      });
    });
  }
  loadResources(keys) {
    if (!this.resourcesPromise) {
      this.resourcesPromise = this.pdfManager.ensure(this, "resources");
    }
    return this.resourcesPromise.then(() => {
      const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref);
      return objectLoader.load();
    });
  }
  getOperatorList({
    handler,
    sink,
    task,
    intent,
    cacheKey,
    annotationStorage = null
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    });
    const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null;
    let deletedAnnotations = null;
    let newAnnotationsPromise = Promise.resolve(null);
    if (newAnnotationsByPage) {
      const newAnnotations = newAnnotationsByPage.get(this.pageIndex);
      if (newAnnotations) {
        const annotationGlobalsPromise = this.pdfManager.ensureDoc("annotationGlobals");
        let imagePromises;
        const missingBitmaps = new Set();
        for (const {
          bitmapId,
          bitmap
        } of newAnnotations) {
          if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
            missingBitmaps.add(bitmapId);
          }
        }
        const {
          isOffscreenCanvasSupported
        } = this.evaluatorOptions;
        if (missingBitmaps.size > 0) {
          const annotationWithBitmaps = newAnnotations.slice();
          for (const [key, annotation] of annotationStorage) {
            if (!key.startsWith(_util.AnnotationEditorPrefix)) {
              continue;
            }
            if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {
              annotationWithBitmaps.push(annotation);
            }
          }
          imagePromises = _annotation.AnnotationFactory.generateImages(annotationWithBitmaps, this.xref, isOffscreenCanvasSupported);
        } else {
          imagePromises = _annotation.AnnotationFactory.generateImages(newAnnotations, this.xref, isOffscreenCanvasSupported);
        }
        deletedAnnotations = new _primitives.RefSet();
        this.#replaceIdByRef(newAnnotations, deletedAnnotations, null);
        newAnnotationsPromise = annotationGlobalsPromise.then(annotationGlobals => {
          if (!annotationGlobals) {
            return null;
          }
          return _annotation.AnnotationFactory.printNewAnnotations(annotationGlobals, partialEvaluator, task, newAnnotations, imagePromises);
        });
      }
    }
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    const pageListPromise = dataPromises.then(([contentStream]) => {
      const opList = new _operator_list.OperatorList(intent, sink);
      handler.send("StartRenderPage", {
        transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        cacheKey
      });
      return partialEvaluator.getOperatorList({
        stream: contentStream,
        task,
        resources: this.resources,
        operatorList: opList
      }).then(function () {
        return opList;
      });
    });
    return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function ([pageOpList, annotations, newAnnotations]) {
      if (newAnnotations) {
        annotations = annotations.filter(a => !(a.ref && deletedAnnotations.has(a.ref)));
        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
          const newAnnotation = newAnnotations[i];
          if (newAnnotation.refToReplace) {
            const j = annotations.findIndex(a => a.ref && (0, _primitives.isRefsEqual)(a.ref, newAnnotation.refToReplace));
            if (j >= 0) {
              annotations.splice(j, 1, newAnnotation);
              newAnnotations.splice(i--, 1);
              ii--;
            }
          }
        }
        annotations = annotations.concat(newAnnotations);
      }
      if (annotations.length === 0 || intent & _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
        pageOpList.flush(true);
        return {
          length: pageOpList.totalLength
        };
      }
      const renderForms = !!(intent & _util.RenderingIntentFlag.ANNOTATIONS_FORMS),
        intentAny = !!(intent & _util.RenderingIntentFlag.ANY),
        intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY),
        intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
      const opListPromises = [];
      for (const annotation of annotations) {
        if (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage, renderForms) || intentPrint && annotation.mustBePrinted(annotationStorage)) {
          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function (reason) {
            (0, _util.warn)("getOperatorList - ignoring annotation data during " + `"${task.name}" task: "${reason}".`);
            return {
              opList: null,
              separateForm: false,
              separateCanvas: false
            };
          }));
        }
      }
      return Promise.all(opListPromises).then(function (opLists) {
        let form = false,
          canvas = false;
        for (const {
          opList,
          separateForm,
          separateCanvas
        } of opLists) {
          pageOpList.addOpList(opList);
          form ||= separateForm;
          canvas ||= separateCanvas;
        }
        pageOpList.flush(true, {
          form,
          canvas
        });
        return {
          length: pageOpList.totalLength
        };
      });
    });
  }
  extractTextContent({
    handler,
    task,
    includeMarkedContent,
    disableNormalization,
    sink
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    return dataPromises.then(([contentStream]) => {
      const partialEvaluator = new _evaluator.PartialEvaluator({
        xref: this.xref,
        handler,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      });
      return partialEvaluator.getTextContent({
        stream: contentStream,
        task,
        resources: this.resources,
        includeMarkedContent,
        disableNormalization,
        sink,
        viewBox: this.view
      });
    });
  }
  async getStructTree() {
    const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!structTreeRoot) {
      return null;
    }
    await this._parsedAnnotations;
    const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
    return structTree.serializable;
  }
  _parseStructTree(structTreeRoot) {
    const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict);
    tree.parse(this.ref);
    return tree;
  }
  async getAnnotationsData(handler, task, intent) {
    const annotations = await this._parsedAnnotations;
    if (annotations.length === 0) {
      return annotations;
    }
    const annotationsData = [],
      textContentPromises = [];
    let partialEvaluator;
    const intentAny = !!(intent & _util.RenderingIntentFlag.ANY),
      intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY),
      intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT);
    for (const annotation of annotations) {
      const isVisible = intentAny || intentDisplay && annotation.viewable;
      if (isVisible || intentPrint && annotation.printable) {
        annotationsData.push(annotation.data);
      }
      if (annotation.hasTextContent && isVisible) {
        partialEvaluator ||= new _evaluator.PartialEvaluator({
          xref: this.xref,
          handler,
          pageIndex: this.pageIndex,
          idFactory: this._localIdFactory,
          fontCache: this.fontCache,
          builtInCMapCache: this.builtInCMapCache,
          standardFontDataCache: this.standardFontDataCache,
          globalImageCache: this.globalImageCache,
          systemFontCache: this.systemFontCache,
          options: this.evaluatorOptions
        });
        textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, [-Infinity, -Infinity, Infinity, Infinity]).catch(function (reason) {
          (0, _util.warn)(`getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`);
        }));
      }
    }
    await Promise.all(textContentPromises);
    return annotationsData;
  }
  get annotations() {
    const annots = this._getInheritableProperty("Annots");
    return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
  }
  get _parsedAnnotations() {
    const promise = this.pdfManager.ensure(this, "annotations").then(async annots => {
      if (annots.length === 0) {
        return annots;
      }
      const annotationGlobals = await this.pdfManager.ensureDoc("annotationGlobals");
      if (!annotationGlobals) {
        return [];
      }
      const annotationPromises = [];
      for (const annotationRef of annots) {
        annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, annotationGlobals, this._localIdFactory, false, this.ref).catch(function (reason) {
          (0, _util.warn)(`_parsedAnnotations: "${reason}".`);
          return null;
        }));
      }
      const sortedAnnotations = [];
      let popupAnnotations;
      for (const annotation of await Promise.all(annotationPromises)) {
        if (!annotation) {
          continue;
        }
        if (annotation instanceof _annotation.PopupAnnotation) {
          (popupAnnotations ||= []).push(annotation);
          continue;
        }
        sortedAnnotations.push(annotation);
      }
      if (popupAnnotations) {
        sortedAnnotations.push(...popupAnnotations);
      }
      return sortedAnnotations;
    });
    return (0, _util.shadow)(this, "_parsedAnnotations", promise);
  }
  get jsActions() {
    const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
    return (0, _util.shadow)(this, "jsActions", actions);
  }
}
exports.Page = Page;
const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
const STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
const FINGERPRINT_FIRST_BYTES = 1024;
const EMPTY_FINGERPRINT = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
function find(stream, signature, limit = 1024, backwards = false) {
  const signatureLength = signature.length;
  const scanBytes = stream.peekBytes(limit);
  const scanLength = scanBytes.length - signatureLength;
  if (scanLength <= 0) {
    return false;
  }
  if (backwards) {
    const signatureEnd = signatureLength - 1;
    let pos = scanBytes.length - 1;
    while (pos >= signatureEnd) {
      let j = 0;
      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
        j++;
      }
      if (j >= signatureLength) {
        stream.pos += pos - signatureEnd;
        return true;
      }
      pos--;
    }
  } else {
    let pos = 0;
    while (pos <= scanLength) {
      let j = 0;
      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
        j++;
      }
      if (j >= signatureLength) {
        stream.pos += pos;
        return true;
      }
      pos++;
    }
  }
  return false;
}
class PDFDocument {
  constructor(pdfManager, stream) {
    if (stream.length <= 0) {
      throw new _util.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    }
    this.pdfManager = pdfManager;
    this.stream = stream;
    this.xref = new _xref.XRef(stream, pdfManager);
    this._pagePromises = new Map();
    this._version = null;
    const idCounters = {
      font: 0
    };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${pdfManager.docId}`;
      }
      static createFontId() {
        return `f${++idCounters.font}`;
      }
      static createObjId() {
        (0, _util.unreachable)("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        (0, _util.unreachable)("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(recoveryMode) {
    this.xref.parse(recoveryMode);
    this.catalog = new _catalog.Catalog(this.pdfManager, this.xref);
  }
  get linearization() {
    let linearization = null;
    try {
      linearization = _parser.Linearization.create(this.stream);
    } catch (err) {
      if (err instanceof _core_utils.MissingDataException) {
        throw err;
      }
      (0, _util.info)(err);
    }
    return (0, _util.shadow)(this, "linearization", linearization);
  }
  get startXRef() {
    const stream = this.stream;
    let startXRef = 0;
    if (this.linearization) {
      stream.reset();
      if (find(stream, ENDOBJ_SIGNATURE)) {
        startXRef = stream.pos + 6 - stream.start;
      }
    } else {
      const step = 1024;
      const startXRefLength = STARTXREF_SIGNATURE.length;
      let found = false,
        pos = stream.end;
      while (!found && pos > 0) {
        pos -= step - startXRefLength;
        if (pos < 0) {
          pos = 0;
        }
        stream.pos = pos;
        found = find(stream, STARTXREF_SIGNATURE, step, true);
      }
      if (found) {
        stream.skip(9);
        let ch;
        do {
          ch = stream.getByte();
        } while ((0, _core_utils.isWhiteSpace)(ch));
        let str = "";
        while (ch >= 0x20 && ch <= 0x39) {
          str += String.fromCharCode(ch);
          ch = stream.getByte();
        }
        startXRef = parseInt(str, 10);
        if (isNaN(startXRef)) {
          startXRef = 0;
        }
      }
    }
    return (0, _util.shadow)(this, "startXRef", startXRef);
  }
  checkHeader() {
    const stream = this.stream;
    stream.reset();
    if (!find(stream, PDF_HEADER_SIGNATURE)) {
      return;
    }
    stream.moveStart();
    stream.skip(PDF_HEADER_SIGNATURE.length);
    let version = "",
      ch;
    while ((ch = stream.getByte()) > 0x20 && version.length < 7) {
      version += String.fromCharCode(ch);
    }
    if (_core_utils.PDF_VERSION_REGEXP.test(version)) {
      this._version = version;
    } else {
      (0, _util.warn)(`Invalid PDF header version: ${version}`);
    }
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let num = 0;
    if (this.catalog.hasActualNumPages) {
      num = this.catalog.numPages;
    } else if (this.xfaFactory) {
      num = this.xfaFactory.getNumPages();
    } else if (this.linearization) {
      num = this.linearization.numPages;
    } else {
      num = this.catalog.numPages;
    }
    return (0, _util.shadow)(this, "numPages", num);
  }
  _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
    const RECURSION_LIMIT = 10;
    if (!Array.isArray(fields)) {
      return false;
    }
    return fields.every(field => {
      field = this.xref.fetchIfRef(field);
      if (!(field instanceof _primitives.Dict)) {
        return false;
      }
      if (field.has("Kids")) {
        if (++recursionDepth > RECURSION_LIMIT) {
          (0, _util.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
          return false;
        }
        return this._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
      }
      const isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
      const rectangle = field.get("Rect");
      const isInvisible = Array.isArray(rectangle) && rectangle.every(value => value === 0);
      return isSignature && isInvisible;
    });
  }
  get _xfaStreams() {
    const acroForm = this.catalog.acroForm;
    if (!acroForm) {
      return null;
    }
    const xfa = acroForm.get("XFA");
    const entries = {
      "xdp:xdp": "",
      template: "",
      datasets: "",
      config: "",
      connectionSet: "",
      localeSet: "",
      stylesheet: "",
      "/xdp:xdp": ""
    };
    if (xfa instanceof _base_stream.BaseStream && !xfa.isEmpty) {
      entries["xdp:xdp"] = xfa;
      return entries;
    }
    if (!Array.isArray(xfa) || xfa.length === 0) {
      return null;
    }
    for (let i = 0, ii = xfa.length; i < ii; i += 2) {
      let name;
      if (i === 0) {
        name = "xdp:xdp";
      } else if (i === ii - 2) {
        name = "/xdp:xdp";
      } else {
        name = xfa[i];
      }
      if (!entries.hasOwnProperty(name)) {
        continue;
      }
      const data = this.xref.fetchIfRef(xfa[i + 1]);
      if (!(data instanceof _base_stream.BaseStream) || data.isEmpty) {
        continue;
      }
      entries[name] = data;
    }
    return entries;
  }
  get xfaDatasets() {
    const streams = this._xfaStreams;
    if (!streams) {
      return (0, _util.shadow)(this, "xfaDatasets", null);
    }
    for (const key of ["datasets", "xdp:xdp"]) {
      const stream = streams[key];
      if (!stream) {
        continue;
      }
      try {
        const str = (0, _util.stringToUTF8String)(stream.getString());
        const data = {
          [key]: str
        };
        return (0, _util.shadow)(this, "xfaDatasets", new _dataset_reader.DatasetReader(data));
      } catch {
        (0, _util.warn)("XFA - Invalid utf-8 string.");
        break;
      }
    }
    return (0, _util.shadow)(this, "xfaDatasets", null);
  }
  get xfaData() {
    const streams = this._xfaStreams;
    if (!streams) {
      return null;
    }
    const data = Object.create(null);
    for (const [key, stream] of Object.entries(streams)) {
      if (!stream) {
        continue;
      }
      try {
        data[key] = (0, _util.stringToUTF8String)(stream.getString());
      } catch {
        (0, _util.warn)("XFA - Invalid utf-8 string.");
        return null;
      }
    }
    return data;
  }
  get xfaFactory() {
    let data;
    if (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
      data = this.xfaData;
    }
    return (0, _util.shadow)(this, "xfaFactory", data ? new _factory.XFAFactory(data) : null);
  }
  get isPureXfa() {
    return this.xfaFactory ? this.xfaFactory.isValid() : false;
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async loadXfaImages() {
    const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
    if (!xfaImagesDict) {
      return;
    }
    const keys = xfaImagesDict.getKeys();
    const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref);
    await objectLoader.load();
    const xfaImages = new Map();
    for (const key of keys) {
      const stream = xfaImagesDict.get(key);
      if (stream instanceof _base_stream.BaseStream) {
        xfaImages.set(key, stream.getBytes());
      }
    }
    this.xfaFactory.setImages(xfaImages);
  }
  async loadXfaFonts(handler, task) {
    const acroForm = await this.pdfManager.ensureCatalog("acroForm");
    if (!acroForm) {
      return;
    }
    const resources = await acroForm.getAsync("DR");
    if (!(resources instanceof _primitives.Dict)) {
      return;
    }
    const objectLoader = new _object_loader.ObjectLoader(resources, ["Font"], this.xref);
    await objectLoader.load();
    const fontRes = resources.get("Font");
    if (!(fontRes instanceof _primitives.Dict)) {
      return;
    }
    const options = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions);
    options.useSystemFonts = false;
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: -1,
      idFactory: this._globalIdFactory,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache,
      standardFontDataCache: this.catalog.standardFontDataCache,
      options
    });
    const operatorList = new _operator_list.OperatorList();
    const pdfFonts = [];
    const initialState = {
      get font() {
        return pdfFonts.at(-1);
      },
      set font(font) {
        pdfFonts.push(font);
      },
      clone() {
        return this;
      }
    };
    const fonts = new Map();
    fontRes.forEach((fontName, font) => {
      fonts.set(fontName, font);
    });
    const promises = [];
    for (const [fontName, font] of fonts) {
      const descriptor = font.get("FontDescriptor");
      if (!(descriptor instanceof _primitives.Dict)) {
        continue;
      }
      let fontFamily = descriptor.get("FontFamily");
      fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
      const fontWeight = descriptor.get("FontWeight");
      const italicAngle = -descriptor.get("ItalicAngle");
      const cssFontInfo = {
        fontFamily,
        fontWeight,
        italicAngle
      };
      if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) {
        continue;
      }
      promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) {
        (0, _util.warn)(`loadXfaFonts: "${reason}".`);
        return null;
      }));
    }
    await Promise.all(promises);
    const missingFonts = this.xfaFactory.setFonts(pdfFonts);
    if (!missingFonts) {
      return;
    }
    options.ignoreErrors = true;
    promises.length = 0;
    pdfFonts.length = 0;
    const reallyMissingFonts = new Set();
    for (const missing of missingFonts) {
      if (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) {
        reallyMissingFonts.add(missing);
      }
    }
    if (reallyMissingFonts.size) {
      missingFonts.push("PdfJS-Fallback");
    }
    for (const missing of missingFonts) {
      if (reallyMissingFonts.has(missing)) {
        continue;
      }
      for (const fontInfo of [{
        name: "Regular",
        fontWeight: 400,
        italicAngle: 0
      }, {
        name: "Bold",
        fontWeight: 700,
        italicAngle: 0
      }, {
        name: "Italic",
        fontWeight: 400,
        italicAngle: 12
      }, {
        name: "BoldItalic",
        fontWeight: 700,
        italicAngle: 12
      }]) {
        const name = `${missing}-${fontInfo.name}`;
        const dict = (0, _xfa_fonts.getXfaFontDict)(name);
        promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, {
          fontFamily: missing,
          fontWeight: fontInfo.fontWeight,
          italicAngle: fontInfo.italicAngle
        }).catch(function (reason) {
          (0, _util.warn)(`loadXfaFonts: "${reason}".`);
          return null;
        }));
      }
    }
    await Promise.all(promises);
    this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
  }
  async serializeXfaData(annotationStorage) {
    return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null;
  }
  get version() {
    return this.catalog.version || this._version;
  }
  get formInfo() {
    const formInfo = {
      hasFields: false,
      hasAcroForm: false,
      hasXfa: false,
      hasSignatures: false
    };
    const acroForm = this.catalog.acroForm;
    if (!acroForm) {
      return (0, _util.shadow)(this, "formInfo", formInfo);
    }
    try {
      const fields = acroForm.get("Fields");
      const hasFields = Array.isArray(fields) && fields.length > 0;
      formInfo.hasFields = hasFields;
      const xfa = acroForm.get("XFA");
      formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa instanceof _base_stream.BaseStream && !xfa.isEmpty;
      const sigFlags = acroForm.get("SigFlags");
      const hasSignatures = !!(sigFlags & 0x1);
      const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);
      formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
      formInfo.hasSignatures = hasSignatures;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`Cannot fetch form information: "${ex}".`);
    }
    return (0, _util.shadow)(this, "formInfo", formInfo);
  }
  get documentInfo() {
    const docInfo = {
      PDFFormatVersion: this.version,
      Language: this.catalog.lang,
      EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: this.formInfo.hasAcroForm,
      IsXFAPresent: this.formInfo.hasXfa,
      IsCollectionPresent: !!this.catalog.collection,
      IsSignaturesPresent: this.formInfo.hasSignatures
    };
    let infoDict;
    try {
      infoDict = this.xref.trailer.get("Info");
    } catch (err) {
      if (err instanceof _core_utils.MissingDataException) {
        throw err;
      }
      (0, _util.info)("The document information dictionary is invalid.");
    }
    if (!(infoDict instanceof _primitives.Dict)) {
      return (0, _util.shadow)(this, "documentInfo", docInfo);
    }
    for (const key of infoDict.getKeys()) {
      const value = infoDict.get(key);
      switch (key) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if (typeof value === "string") {
            docInfo[key] = (0, _util.stringToPDFString)(value);
            continue;
          }
          break;
        case "Trapped":
          if (value instanceof _primitives.Name) {
            docInfo[key] = value;
            continue;
          }
          break;
        default:
          let customValue;
          switch (typeof value) {
            case "string":
              customValue = (0, _util.stringToPDFString)(value);
              break;
            case "number":
            case "boolean":
              customValue = value;
              break;
            default:
              if (value instanceof _primitives.Name) {
                customValue = value;
              }
              break;
          }
          if (customValue === undefined) {
            (0, _util.warn)(`Bad value, for custom key "${key}", in Info: ${value}.`);
            continue;
          }
          if (!docInfo.Custom) {
            docInfo.Custom = Object.create(null);
          }
          docInfo.Custom[key] = customValue;
          continue;
      }
      (0, _util.warn)(`Bad value, for key "${key}", in Info: ${value}.`);
    }
    return (0, _util.shadow)(this, "documentInfo", docInfo);
  }
  get fingerprints() {
    function validate(data) {
      return typeof data === "string" && data.length > 0 && data !== EMPTY_FINGERPRINT;
    }
    function hexString(hash) {
      const buf = [];
      for (const num of hash) {
        const hex = num.toString(16);
        buf.push(hex.padStart(2, "0"));
      }
      return buf.join("");
    }
    const idArray = this.xref.trailer.get("ID");
    let hashOriginal, hashModified;
    if (Array.isArray(idArray) && validate(idArray[0])) {
      hashOriginal = (0, _util.stringToBytes)(idArray[0]);
      if (idArray[1] !== idArray[0] && validate(idArray[1])) {
        hashModified = (0, _util.stringToBytes)(idArray[1]);
      }
    } else {
      hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
    }
    return (0, _util.shadow)(this, "fingerprints", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);
  }
  async _getLinearizationPage(pageIndex) {
    const {
      catalog,
      linearization,
      xref
    } = this;
    const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
    try {
      const obj = await xref.fetchAsync(ref);
      if (obj instanceof _primitives.Dict) {
        let type = obj.getRaw("Type");
        if (type instanceof _primitives.Ref) {
          type = await xref.fetchAsync(type);
        }
        if ((0, _primitives.isName)(type, "Page") || !obj.has("Type") && !obj.has("Kids")) {
          if (!catalog.pageKidsCountCache.has(ref)) {
            catalog.pageKidsCountCache.put(ref, 1);
          }
          if (!catalog.pageIndexCache.has(ref)) {
            catalog.pageIndexCache.put(ref, 0);
          }
          return [obj, ref];
        }
      }
      throw new _util.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (reason) {
      (0, _util.warn)(`_getLinearizationPage: "${reason.message}".`);
      return catalog.getPageDict(pageIndex);
    }
  }
  getPage(pageIndex) {
    const cachedPromise = this._pagePromises.get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const {
      catalog,
      linearization,
      xfaFactory
    } = this;
    let promise;
    if (xfaFactory) {
      promise = Promise.resolve([_primitives.Dict.empty, null]);
    } else if (linearization?.pageFirst === pageIndex) {
      promise = this._getLinearizationPage(pageIndex);
    } else {
      promise = catalog.getPageDict(pageIndex);
    }
    promise = promise.then(([pageDict, ref]) => {
      return new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex,
        pageDict,
        ref,
        globalIdFactory: this._globalIdFactory,
        fontCache: catalog.fontCache,
        builtInCMapCache: catalog.builtInCMapCache,
        standardFontDataCache: catalog.standardFontDataCache,
        globalImageCache: catalog.globalImageCache,
        systemFontCache: catalog.systemFontCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory
      });
    });
    this._pagePromises.set(pageIndex, promise);
    return promise;
  }
  async checkFirstPage(recoveryMode = false) {
    if (recoveryMode) {
      return;
    }
    try {
      await this.getPage(0);
    } catch (reason) {
      if (reason instanceof _core_utils.XRefEntryException) {
        this._pagePromises.delete(0);
        await this.cleanup();
        throw new _core_utils.XRefParseException();
      }
    }
  }
  async checkLastPage(recoveryMode = false) {
    const {
      catalog,
      pdfManager
    } = this;
    catalog.setActualNumPages();
    let numPages;
    try {
      await Promise.all([pdfManager.ensureDoc("xfaFactory"), pdfManager.ensureDoc("linearization"), pdfManager.ensureCatalog("numPages")]);
      if (this.xfaFactory) {
        return;
      } else if (this.linearization) {
        numPages = this.linearization.numPages;
      } else {
        numPages = catalog.numPages;
      }
      if (!Number.isInteger(numPages)) {
        throw new _util.FormatError("Page count is not an integer.");
      } else if (numPages <= 1) {
        return;
      }
      await this.getPage(numPages - 1);
    } catch (reason) {
      this._pagePromises.delete(numPages - 1);
      await this.cleanup();
      if (reason instanceof _core_utils.XRefEntryException && !recoveryMode) {
        throw new _core_utils.XRefParseException();
      }
      (0, _util.warn)(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
      let pagesTree;
      try {
        pagesTree = await catalog.getAllPageDicts(recoveryMode);
      } catch (reasonAll) {
        if (reasonAll instanceof _core_utils.XRefEntryException && !recoveryMode) {
          throw new _core_utils.XRefParseException();
        }
        catalog.setActualNumPages(1);
        return;
      }
      for (const [pageIndex, [pageDict, ref]] of pagesTree) {
        let promise;
        if (pageDict instanceof Error) {
          promise = Promise.reject(pageDict);
          promise.catch(() => {});
        } else {
          promise = Promise.resolve(new Page({
            pdfManager,
            xref: this.xref,
            pageIndex,
            pageDict,
            ref,
            globalIdFactory: this._globalIdFactory,
            fontCache: catalog.fontCache,
            builtInCMapCache: catalog.builtInCMapCache,
            standardFontDataCache: catalog.standardFontDataCache,
            globalImageCache: catalog.globalImageCache,
            systemFontCache: catalog.systemFontCache,
            nonBlendModesSet: catalog.nonBlendModesSet,
            xfaFactory: null
          }));
        }
        this._pagePromises.set(pageIndex, promise);
      }
      catalog.setActualNumPages(pagesTree.size);
    }
  }
  fontFallback(id, handler) {
    return this.catalog.fontFallback(id, handler);
  }
  async cleanup(manuallyTriggered = false) {
    return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)();
  }
  #collectFieldObjects(name, fieldRef, promises, annotationGlobals) {
    const field = this.xref.fetchIfRef(fieldRef);
    if (field.has("T")) {
      const partName = (0, _util.stringToPDFString)(field.get("T"));
      name = name === "" ? partName : `${name}.${partName}`;
    }
    if (!promises.has(name)) {
      promises.set(name, []);
    }
    promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, annotationGlobals, this._localIdFactory, true, null).then(annotation => annotation?.getFieldObject()).catch(function (reason) {
      (0, _util.warn)(`#collectFieldObjects: "${reason}".`);
      return null;
    }));
    if (field.has("Kids")) {
      for (const kid of field.get("Kids")) {
        this.#collectFieldObjects(name, kid, promises, annotationGlobals);
      }
    }
  }
  get fieldObjects() {
    if (!this.formInfo.hasFields) {
      return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
    }
    const promise = this.pdfManager.ensureDoc("annotationGlobals").then(async annotationGlobals => {
      if (!annotationGlobals) {
        return null;
      }
      const allFields = Object.create(null);
      const fieldPromises = new Map();
      for (const fieldRef of this.catalog.acroForm.get("Fields")) {
        this.#collectFieldObjects("", fieldRef, fieldPromises, annotationGlobals);
      }
      const allPromises = [];
      for (const [name, promises] of fieldPromises) {
        allPromises.push(Promise.all(promises).then(fields => {
          fields = fields.filter(field => !!field);
          if (fields.length > 0) {
            allFields[name] = fields;
          }
        }));
      }
      await Promise.all(allPromises);
      return allFields;
    });
    return (0, _util.shadow)(this, "fieldObjects", promise);
  }
  get hasJSActions() {
    const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
    return (0, _util.shadow)(this, "hasJSActions", promise);
  }
  async _parseHasJSActions() {
    const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    if (catalogJsActions) {
      return true;
    }
    if (fieldObjects) {
      return Object.values(fieldObjects).some(fieldObject => fieldObject.some(object => object.actions !== null));
    }
    return false;
  }
  get calculationOrderIds() {
    const acroForm = this.catalog.acroForm;
    if (!acroForm?.has("CO")) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    const calculationOrder = acroForm.get("CO");
    if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    const ids = [];
    for (const id of calculationOrder) {
      if (id instanceof _primitives.Ref) {
        ids.push(id.toString());
      }
    }
    if (ids.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }
    return (0, _util.shadow)(this, "calculationOrderIds", ids);
  }
  get annotationGlobals() {
    return (0, _util.shadow)(this, "annotationGlobals", _annotation.AnnotationFactory.createGlobals(this.pdfManager));
  }
}
exports.PDFDocument = PDFDocument;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PopupAnnotation = exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0;
exports.getQuadPoints = getQuadPoints;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _default_appearance = __w_pdfjs_require__(11);
var _primitives = __w_pdfjs_require__(4);
var _stream = __w_pdfjs_require__(8);
var _base_stream = __w_pdfjs_require__(5);
var _bidi = __w_pdfjs_require__(60);
var _catalog = __w_pdfjs_require__(66);
var _colorspace = __w_pdfjs_require__(12);
var _file_spec = __w_pdfjs_require__(69);
var _jpeg_stream = __w_pdfjs_require__(26);
var _object_loader = __w_pdfjs_require__(76);
var _operator_list = __w_pdfjs_require__(64);
var _writer = __w_pdfjs_require__(73);
var _factory = __w_pdfjs_require__(77);
class AnnotationFactory {
  static createGlobals(pdfManager) {
    return Promise.all([pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xfaDatasets"), pdfManager.ensureCatalog("structTreeRoot"), pdfManager.ensureCatalog("baseUrl"), pdfManager.ensureCatalog("attachments")]).then(([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
      return {
        pdfManager,
        acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty,
        xfaDatasets,
        structTreeRoot,
        baseUrl,
        attachments
      };
    }, reason => {
      (0, _util.warn)(`createGlobals: "${reason}".`);
      return null;
    });
  }
  static async create(xref, ref, annotationGlobals, idFactory, collectFields, pageRef) {
    const pageIndex = collectFields ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager) : null;
    return annotationGlobals.pdfManager.ensure(this, "_create", [xref, ref, annotationGlobals, idFactory, collectFields, pageIndex, pageRef]);
  }
  static _create(xref, ref, annotationGlobals, idFactory, collectFields = false, pageIndex = null, pageRef = null) {
    const dict = xref.fetchIfRef(ref);
    if (!(dict instanceof _primitives.Dict)) {
      return undefined;
    }
    const {
      acroForm,
      pdfManager
    } = annotationGlobals;
    const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
    let subtype = dict.get("Subtype");
    subtype = subtype instanceof _primitives.Name ? subtype.name : null;
    const parameters = {
      xref,
      ref,
      dict,
      subtype,
      id,
      annotationGlobals,
      collectFields,
      needAppearances: !collectFields && acroForm.get("NeedAppearances") === true,
      pageIndex,
      evaluatorOptions: pdfManager.evaluatorOptions,
      pageRef
    };
    switch (subtype) {
      case "Link":
        return new LinkAnnotation(parameters);
      case "Text":
        return new TextAnnotation(parameters);
      case "Widget":
        let fieldType = (0, _core_utils.getInheritableProperty)({
          dict,
          key: "FT"
        });
        fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotation(parameters);
          case "Btn":
            return new ButtonWidgetAnnotation(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotation(parameters);
          case "Sig":
            return new SignatureWidgetAnnotation(parameters);
        }
        (0, _util.warn)(`Unimplemented widget field type "${fieldType}", ` + "falling back to base field type.");
        return new WidgetAnnotation(parameters);
      case "Popup":
        return new PopupAnnotation(parameters);
      case "FreeText":
        return new FreeTextAnnotation(parameters);
      case "Line":
        return new LineAnnotation(parameters);
      case "Square":
        return new SquareAnnotation(parameters);
      case "Circle":
        return new CircleAnnotation(parameters);
      case "PolyLine":
        return new PolylineAnnotation(parameters);
      case "Polygon":
        return new PolygonAnnotation(parameters);
      case "Caret":
        return new CaretAnnotation(parameters);
      case "Ink":
        return new InkAnnotation(parameters);
      case "Highlight":
        return new HighlightAnnotation(parameters);
      case "Underline":
        return new UnderlineAnnotation(parameters);
      case "Squiggly":
        return new SquigglyAnnotation(parameters);
      case "StrikeOut":
        return new StrikeOutAnnotation(parameters);
      case "Stamp":
        return new StampAnnotation(parameters);
      case "FileAttachment":
        return new FileAttachmentAnnotation(parameters);
      default:
        if (!collectFields) {
          if (!subtype) {
            (0, _util.warn)("Annotation is missing the required /Subtype.");
          } else {
            (0, _util.warn)(`Unimplemented annotation type "${subtype}", ` + "falling back to base annotation.");
          }
        }
        return new Annotation(parameters);
    }
  }
  static async _getPageIndex(xref, ref, pdfManager) {
    try {
      const annotDict = await xref.fetchIfRefAsync(ref);
      if (!(annotDict instanceof _primitives.Dict)) {
        return -1;
      }
      const pageRef = annotDict.getRaw("P");
      if (pageRef instanceof _primitives.Ref) {
        try {
          const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
          return pageIndex;
        } catch (ex) {
          (0, _util.info)(`_getPageIndex -- not a valid page reference: "${ex}".`);
        }
      }
      if (annotDict.has("Kids")) {
        return -1;
      }
      const numPages = await pdfManager.ensureDoc("numPages");
      for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
        const page = await pdfManager.getPage(pageIndex);
        const annotations = await pdfManager.ensure(page, "annotations");
        for (const annotRef of annotations) {
          if (annotRef instanceof _primitives.Ref && (0, _primitives.isRefsEqual)(annotRef, ref)) {
            return pageIndex;
          }
        }
      }
    } catch (ex) {
      (0, _util.warn)(`_getPageIndex: "${ex}".`);
    }
    return -1;
  }
  static generateImages(annotations, xref, isOffscreenCanvasSupported) {
    if (!isOffscreenCanvasSupported) {
      (0, _util.warn)("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
      return null;
    }
    let imagePromises;
    for (const {
      bitmapId,
      bitmap
    } of annotations) {
      if (!bitmap) {
        continue;
      }
      imagePromises ||= new Map();
      imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
    }
    return imagePromises;
  }
  static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
    const xref = evaluator.xref;
    let baseFontRef;
    const dependencies = [];
    const promises = [];
    const {
      isOffscreenCanvasSupported
    } = evaluator.options;
    for (const annotation of annotations) {
      if (annotation.deleted) {
        continue;
      }
      switch (annotation.annotationType) {
        case _util.AnnotationEditorType.FREETEXT:
          if (!baseFontRef) {
            const baseFont = new _primitives.Dict(xref);
            baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
            baseFont.set("Type", _primitives.Name.get("Font"));
            baseFont.set("Subtype", _primitives.Name.get("Type1"));
            baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
            const buffer = [];
            baseFontRef = xref.getNewTemporaryRef();
            await (0, _writer.writeObject)(baseFontRef, baseFont, buffer, xref);
            dependencies.push({
              ref: baseFontRef,
              data: buffer.join("")
            });
          }
          promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, {
            evaluator,
            task,
            baseFontRef
          }));
          break;
        case _util.AnnotationEditorType.INK:
          promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies));
          break;
        case _util.AnnotationEditorType.STAMP:
          if (!isOffscreenCanvasSupported) {
            break;
          }
          const image = await imagePromises.get(annotation.bitmapId);
          if (image.imageStream) {
            const {
              imageStream,
              smaskStream
            } = image;
            const buffer = [];
            if (smaskStream) {
              const smaskRef = xref.getNewTemporaryRef();
              await (0, _writer.writeObject)(smaskRef, smaskStream, buffer, xref);
              dependencies.push({
                ref: smaskRef,
                data: buffer.join("")
              });
              imageStream.dict.set("SMask", smaskRef);
              buffer.length = 0;
            }
            const imageRef = image.imageRef = xref.getNewTemporaryRef();
            await (0, _writer.writeObject)(imageRef, imageStream, buffer, xref);
            dependencies.push({
              ref: imageRef,
              data: buffer.join("")
            });
            image.imageStream = image.smaskStream = null;
          }
          promises.push(StampAnnotation.createNewAnnotation(xref, annotation, dependencies, {
            image
          }));
          break;
      }
    }
    return {
      annotations: await Promise.all(promises),
      dependencies
    };
  }
  static async printNewAnnotations(annotationGlobals, evaluator, task, annotations, imagePromises) {
    if (!annotations) {
      return null;
    }
    const {
      options,
      xref
    } = evaluator;
    const promises = [];
    for (const annotation of annotations) {
      if (annotation.deleted) {
        continue;
      }
      switch (annotation.annotationType) {
        case _util.AnnotationEditorType.FREETEXT:
          promises.push(FreeTextAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
            evaluator,
            task,
            evaluatorOptions: options
          }));
          break;
        case _util.AnnotationEditorType.INK:
          promises.push(InkAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
            evaluatorOptions: options
          }));
          break;
        case _util.AnnotationEditorType.STAMP:
          if (!options.isOffscreenCanvasSupported) {
            break;
          }
          const image = await imagePromises.get(annotation.bitmapId);
          if (image.imageStream) {
            const {
              imageStream,
              smaskStream
            } = image;
            if (smaskStream) {
              imageStream.dict.set("SMask", smaskStream);
            }
            image.imageRef = new _jpeg_stream.JpegStream(imageStream, imageStream.length);
            image.imageStream = image.smaskStream = null;
          }
          promises.push(StampAnnotation.createNewPrintAnnotation(annotationGlobals, xref, annotation, {
            image,
            evaluatorOptions: options
          }));
          break;
      }
    }
    return Promise.all(promises);
  }
}
exports.AnnotationFactory = AnnotationFactory;
function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
  if (!Array.isArray(color)) {
    return defaultColor;
  }
  const rgbColor = defaultColor || new Uint8ClampedArray(3);
  switch (color.length) {
    case 0:
      return null;
    case 1:
      _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    case 3:
      _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    case 4:
      _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    default:
      return defaultColor;
  }
}
function getPdfColorArray(color) {
  return Array.from(color, c => c / 255);
}
function getQuadPoints(dict, rect) {
  const quadPoints = dict.getArray("QuadPoints");
  if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
    return null;
  }
  const quadPointsLists = [];
  for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
    let minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity;
    for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
      const x = quadPoints[j];
      const y = quadPoints[j + 1];
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
    if (rect !== null && (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])) {
      return null;
    }
    quadPointsLists.push([{
      x: minX,
      y: maxY
    }, {
      x: maxX,
      y: maxY
    }, {
      x: minX,
      y: minY
    }, {
      x: maxX,
      y: minY
    }]);
  }
  return quadPointsLists;
}
function getTransformMatrix(rect, bbox, matrix) {
  const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix);
  if (minX === maxX || minY === maxY) {
    return [1, 0, 0, 1, rect[0], rect[1]];
  }
  const xRatio = (rect[2] - rect[0]) / (maxX - minX);
  const yRatio = (rect[3] - rect[1]) / (maxY - minY);
  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
}
class Annotation {
  constructor(params) {
    const {
      dict,
      xref,
      annotationGlobals
    } = params;
    this.setTitle(dict.get("T"));
    this.setContents(dict.get("Contents"));
    this.setModificationDate(dict.get("M"));
    this.setFlags(dict.get("F"));
    this.setRectangle(dict.getArray("Rect"));
    this.setColor(dict.getArray("C"));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this.setOptionalContent(dict);
    const MK = dict.get("MK");
    this.setBorderAndBackgroundColors(MK);
    this.setRotation(MK, dict);
    this.ref = params.ref instanceof _primitives.Ref ? params.ref : null;
    this._streams = [];
    if (this.appearance) {
      this._streams.push(this.appearance);
    }
    const isLocked = !!(this.flags & _util.AnnotationFlag.LOCKED);
    const isContentLocked = !!(this.flags & _util.AnnotationFlag.LOCKEDCONTENTS);
    if (annotationGlobals.structTreeRoot) {
      let structParent = dict.get("StructParent");
      structParent = Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
      annotationGlobals.structTreeRoot.addAnnotationIdToPage(params.pageRef, structParent);
    }
    this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      backgroundColor: this.backgroundColor,
      borderColor: this.borderColor,
      rotation: this.rotation,
      contentsObj: this._contents,
      hasAppearance: !!this.appearance,
      id: params.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: params.subtype,
      hasOwnCanvas: false,
      noRotate: !!(this.flags & _util.AnnotationFlag.NOROTATE),
      noHTML: isLocked && isContentLocked
    };
    if (params.collectFields) {
      const kids = dict.get("Kids");
      if (Array.isArray(kids)) {
        const kidIds = [];
        for (const kid of kids) {
          if (kid instanceof _primitives.Ref) {
            kidIds.push(kid.toString());
          }
        }
        if (kidIds.length !== 0) {
          this.data.kidIds = kidIds;
        }
      }
      this.data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
      this.data.fieldName = this._constructFieldName(dict);
      this.data.pageIndex = params.pageIndex;
    }
    this._isOffscreenCanvasSupported = params.evaluatorOptions.isOffscreenCanvasSupported;
    this._fallbackFontDict = null;
    this._needAppearances = false;
  }
  _hasFlag(flags, flag) {
    return !!(flags & flag);
  }
  _isViewable(flags) {
    return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
  }
  _isPrintable(flags) {
    return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
  }
  mustBeViewed(annotationStorage, _renderForms) {
    const noView = annotationStorage?.get(this.data.id)?.noView;
    if (noView !== undefined) {
      return !noView;
    }
    return this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
  }
  mustBePrinted(annotationStorage) {
    const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
    if (noPrint !== undefined) {
      return !noPrint;
    }
    return this.printable;
  }
  get viewable() {
    if (this.data.quadPoints === null) {
      return false;
    }
    if (this.flags === 0) {
      return true;
    }
    return this._isViewable(this.flags);
  }
  get printable() {
    if (this.data.quadPoints === null) {
      return false;
    }
    if (this.flags === 0) {
      return false;
    }
    return this._isPrintable(this.flags);
  }
  _parseStringHelper(data) {
    const str = typeof data === "string" ? (0, _util.stringToPDFString)(data) : "";
    const dir = str && (0, _bidi.bidi)(str).dir === "rtl" ? "rtl" : "ltr";
    return {
      str,
      dir
    };
  }
  setDefaultAppearance(params) {
    const {
      dict,
      annotationGlobals
    } = params;
    const defaultAppearance = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DA"
    }) || annotationGlobals.acroForm.get("DA");
    this._defaultAppearance = typeof defaultAppearance === "string" ? defaultAppearance : "";
    this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance);
  }
  setTitle(title) {
    this._title = this._parseStringHelper(title);
  }
  setContents(contents) {
    this._contents = this._parseStringHelper(contents);
  }
  setModificationDate(modificationDate) {
    this.modificationDate = typeof modificationDate === "string" ? modificationDate : null;
  }
  setFlags(flags) {
    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
  }
  hasFlag(flag) {
    return this._hasFlag(this.flags, flag);
  }
  setRectangle(rectangle) {
    this.rectangle = Array.isArray(rectangle) && rectangle.length === 4 ? _util.Util.normalizeRect(rectangle) : [0, 0, 0, 0];
  }
  setColor(color) {
    this.color = getRgbColor(color);
  }
  setLineEndings(lineEndings) {
    this.lineEndings = ["None", "None"];
    if (Array.isArray(lineEndings) && lineEndings.length === 2) {
      for (let i = 0; i < 2; i++) {
        const obj = lineEndings[i];
        if (obj instanceof _primitives.Name) {
          switch (obj.name) {
            case "None":
              continue;
            case "Square":
            case "Circle":
            case "Diamond":
            case "OpenArrow":
            case "ClosedArrow":
            case "Butt":
            case "ROpenArrow":
            case "RClosedArrow":
            case "Slash":
              this.lineEndings[i] = obj.name;
              continue;
          }
        }
        (0, _util.warn)(`Ignoring invalid lineEnding: ${obj}`);
      }
    }
  }
  setRotation(mk, dict) {
    this.rotation = 0;
    let angle = mk instanceof _primitives.Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
    if (Number.isInteger(angle) && angle !== 0) {
      angle %= 360;
      if (angle < 0) {
        angle += 360;
      }
      if (angle % 90 === 0) {
        this.rotation = angle;
      }
    }
  }
  setBorderAndBackgroundColors(mk) {
    if (mk instanceof _primitives.Dict) {
      this.borderColor = getRgbColor(mk.getArray("BC"), null);
      this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
    } else {
      this.borderColor = this.backgroundColor = null;
    }
  }
  setBorderStyle(borderStyle) {
    this.borderStyle = new AnnotationBorderStyle();
    if (!(borderStyle instanceof _primitives.Dict)) {
      return;
    }
    if (borderStyle.has("BS")) {
      const dict = borderStyle.get("BS");
      const dictType = dict.get("Type");
      if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
        this.borderStyle.setWidth(dict.get("W"), this.rectangle);
        this.borderStyle.setStyle(dict.get("S"));
        this.borderStyle.setDashArray(dict.getArray("D"));
      }
    } else if (borderStyle.has("Border")) {
      const array = borderStyle.getArray("Border");
      if (Array.isArray(array) && array.length >= 3) {
        this.borderStyle.setHorizontalCornerRadius(array[0]);
        this.borderStyle.setVerticalCornerRadius(array[1]);
        this.borderStyle.setWidth(array[2], this.rectangle);
        if (array.length === 4) {
          this.borderStyle.setDashArray(array[3], true);
        }
      }
    } else {
      this.borderStyle.setWidth(0);
    }
  }
  setAppearance(dict) {
    this.appearance = null;
    const appearanceStates = dict.get("AP");
    if (!(appearanceStates instanceof _primitives.Dict)) {
      return;
    }
    const normalAppearanceState = appearanceStates.get("N");
    if (normalAppearanceState instanceof _base_stream.BaseStream) {
      this.appearance = normalAppearanceState;
      return;
    }
    if (!(normalAppearanceState instanceof _primitives.Dict)) {
      return;
    }
    const as = dict.get("AS");
    if (!(as instanceof _primitives.Name) || !normalAppearanceState.has(as.name)) {
      return;
    }
    const appearance = normalAppearanceState.get(as.name);
    if (appearance instanceof _base_stream.BaseStream) {
      this.appearance = appearance;
    }
  }
  setOptionalContent(dict) {
    this.oc = null;
    const oc = dict.get("OC");
    if (oc instanceof _primitives.Name) {
      (0, _util.warn)("setOptionalContent: Support for /Name-entry is not implemented.");
    } else if (oc instanceof _primitives.Dict) {
      this.oc = oc;
    }
  }
  loadResources(keys, appearance) {
    return appearance.dict.getAsync("Resources").then(resources => {
      if (!resources) {
        return undefined;
      }
      const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref);
      return objectLoader.load().then(function () {
        return resources;
      });
    });
  }
  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
    const data = this.data;
    let appearance = this.appearance;
    const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
    if (!appearance) {
      if (!isUsingOwnCanvas) {
        return {
          opList: new _operator_list.OperatorList(),
          separateForm: false,
          separateCanvas: false
        };
      }
      appearance = new _stream.StringStream("");
      appearance.dict = new _primitives.Dict();
    }
    const appearanceDict = appearance.dict;
    const resources = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], appearance);
    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
    const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
    const transform = getTransformMatrix(data.rect, bbox, matrix);
    const opList = new _operator_list.OperatorList();
    let optionalContent;
    if (this.oc) {
      optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
    }
    if (optionalContent !== undefined) {
      opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]);
    await evaluator.getOperatorList({
      stream: appearance,
      task,
      resources,
      operatorList: opList,
      fallbackFontDict: this._fallbackFontDict
    });
    opList.addOp(_util.OPS.endAnnotation, []);
    if (optionalContent !== undefined) {
      opList.addOp(_util.OPS.endMarkedContent, []);
    }
    this.reset();
    return {
      opList,
      separateForm: false,
      separateCanvas: isUsingOwnCanvas
    };
  }
  async save(evaluator, task, annotationStorage) {
    return null;
  }
  get hasTextContent() {
    return false;
  }
  async extractTextContent(evaluator, task, viewBox) {
    if (!this.appearance) {
      return;
    }
    const resources = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance);
    const text = [];
    const buffer = [];
    let firstPosition = null;
    const sink = {
      desiredSize: Math.Infinity,
      ready: true,
      enqueue(chunk, size) {
        for (const item of chunk.items) {
          if (item.str === undefined) {
            continue;
          }
          firstPosition ||= item.transform.slice(-2);
          buffer.push(item.str);
          if (item.hasEOL) {
            text.push(buffer.join(""));
            buffer.length = 0;
          }
        }
      }
    };
    await evaluator.getTextContent({
      stream: this.appearance,
      task,
      resources,
      includeMarkedContent: true,
      sink,
      viewBox
    });
    this.reset();
    if (buffer.length) {
      text.push(buffer.join(""));
    }
    if (text.length > 1 || text[0]) {
      const appearanceDict = this.appearance.dict;
      const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
      const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
      const rect = this.data.rect;
      const transform = getTransformMatrix(rect, bbox, matrix);
      transform[4] -= rect[0];
      transform[5] -= rect[1];
      firstPosition = _util.Util.applyTransform(firstPosition, transform);
      firstPosition = _util.Util.applyTransform(firstPosition, matrix);
      this.data.textPosition = firstPosition;
      this.data.textContent = text;
    }
  }
  getFieldObject() {
    if (this.data.kidIds) {
      return {
        id: this.data.id,
        actions: this.data.actions,
        name: this.data.fieldName,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        type: "",
        kidIds: this.data.kidIds,
        page: this.data.pageIndex,
        rotation: this.rotation
      };
    }
    return null;
  }
  reset() {
    for (const stream of this._streams) {
      stream.reset();
    }
  }
  _constructFieldName(dict) {
    if (!dict.has("T") && !dict.has("Parent")) {
      (0, _util.warn)("Unknown field name, falling back to empty field name.");
      return "";
    }
    if (!dict.has("Parent")) {
      return (0, _util.stringToPDFString)(dict.get("T"));
    }
    const fieldName = [];
    if (dict.has("T")) {
      fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
    }
    let loopDict = dict;
    const visited = new _primitives.RefSet();
    if (dict.objId) {
      visited.put(dict.objId);
    }
    while (loopDict.has("Parent")) {
      loopDict = loopDict.get("Parent");
      if (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) {
        break;
      }
      if (loopDict.objId) {
        visited.put(loopDict.objId);
      }
      if (loopDict.has("T")) {
        fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
      }
    }
    return fieldName.join(".");
  }
}
exports.Annotation = Annotation;
class AnnotationBorderStyle {
  constructor() {
    this.width = 1;
    this.style = _util.AnnotationBorderStyleType.SOLID;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }
  setWidth(width, rect = [0, 0, 0, 0]) {
    if (width instanceof _primitives.Name) {
      this.width = 0;
      return;
    }
    if (typeof width === "number") {
      if (width > 0) {
        const maxWidth = (rect[2] - rect[0]) / 2;
        const maxHeight = (rect[3] - rect[1]) / 2;
        if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
          (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
          width = 1;
        }
      }
      this.width = width;
    }
  }
  setStyle(style) {
    if (!(style instanceof _primitives.Name)) {
      return;
    }
    switch (style.name) {
      case "S":
        this.style = _util.AnnotationBorderStyleType.SOLID;
        break;
      case "D":
        this.style = _util.AnnotationBorderStyleType.DASHED;
        break;
      case "B":
        this.style = _util.AnnotationBorderStyleType.BEVELED;
        break;
      case "I":
        this.style = _util.AnnotationBorderStyleType.INSET;
        break;
      case "U":
        this.style = _util.AnnotationBorderStyleType.UNDERLINE;
        break;
      default:
        break;
    }
  }
  setDashArray(dashArray, forceStyle = false) {
    if (Array.isArray(dashArray) && dashArray.length > 0) {
      let isValid = true;
      let allZeros = true;
      for (const element of dashArray) {
        const validNumber = +element >= 0;
        if (!validNumber) {
          isValid = false;
          break;
        } else if (element > 0) {
          allZeros = false;
        }
      }
      if (isValid && !allZeros) {
        this.dashArray = dashArray;
        if (forceStyle) {
          this.setStyle(_primitives.Name.get("D"));
        }
      } else {
        this.width = 0;
      }
    } else if (dashArray) {
      this.width = 0;
    }
  }
  setHorizontalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.horizontalCornerRadius = radius;
    }
  }
  setVerticalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.verticalCornerRadius = radius;
    }
  }
}
exports.AnnotationBorderStyle = AnnotationBorderStyle;
class MarkupAnnotation extends Annotation {
  constructor(params) {
    super(params);
    const {
      dict
    } = params;
    if (dict.has("IRT")) {
      const rawIRT = dict.getRaw("IRT");
      this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null;
      const rt = dict.get("RT");
      this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY;
    }
    let popupRef = null;
    if (this.data.replyType === _util.AnnotationReplyType.GROUP) {
      const parent = dict.get("IRT");
      this.setTitle(parent.get("T"));
      this.data.titleObj = this._title;
      this.setContents(parent.get("Contents"));
      this.data.contentsObj = this._contents;
      if (!parent.has("CreationDate")) {
        this.data.creationDate = null;
      } else {
        this.setCreationDate(parent.get("CreationDate"));
        this.data.creationDate = this.creationDate;
      }
      if (!parent.has("M")) {
        this.data.modificationDate = null;
      } else {
        this.setModificationDate(parent.get("M"));
        this.data.modificationDate = this.modificationDate;
      }
      popupRef = parent.getRaw("Popup");
      if (!parent.has("C")) {
        this.data.color = null;
      } else {
        this.setColor(parent.getArray("C"));
        this.data.color = this.color;
      }
    } else {
      this.data.titleObj = this._title;
      this.setCreationDate(dict.get("CreationDate"));
      this.data.creationDate = this.creationDate;
      popupRef = dict.getRaw("Popup");
      if (!dict.has("C")) {
        this.data.color = null;
      }
    }
    this.data.popupRef = popupRef instanceof _primitives.Ref ? popupRef.toString() : null;
    if (dict.has("RC")) {
      this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get("RC"));
    }
  }
  setCreationDate(creationDate) {
    this.creationDate = typeof creationDate === "string" ? creationDate : null;
  }
  _setDefaultAppearance({
    xref,
    extra,
    strokeColor,
    fillColor,
    blendMode,
    strokeAlpha,
    fillAlpha,
    pointsCallback
  }) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = Number.MIN_VALUE;
    let maxY = Number.MIN_VALUE;
    const buffer = ["q"];
    if (extra) {
      buffer.push(extra);
    }
    if (strokeColor) {
      buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
    }
    if (fillColor) {
      buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
    }
    let pointsArray = this.data.quadPoints;
    if (!pointsArray) {
      pointsArray = [[{
        x: this.rectangle[0],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[0],
        y: this.rectangle[1]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[1]
      }]];
    }
    for (const points of pointsArray) {
      const [mX, MX, mY, MY] = pointsCallback(buffer, points);
      minX = Math.min(minX, mX);
      maxX = Math.max(maxX, MX);
      minY = Math.min(minY, mY);
      maxY = Math.max(maxY, MY);
    }
    buffer.push("Q");
    const formDict = new _primitives.Dict(xref);
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    const appearanceStream = new _stream.StringStream(buffer.join(" "));
    appearanceStream.dict = appearanceStreamDict;
    formDict.set("Fm0", appearanceStream);
    const gsDict = new _primitives.Dict(xref);
    if (blendMode) {
      gsDict.set("BM", _primitives.Name.get(blendMode));
    }
    if (typeof strokeAlpha === "number") {
      gsDict.set("CA", strokeAlpha);
    }
    if (typeof fillAlpha === "number") {
      gsDict.set("ca", fillAlpha);
    }
    const stateDict = new _primitives.Dict(xref);
    stateDict.set("GS0", gsDict);
    const resources = new _primitives.Dict(xref);
    resources.set("ExtGState", stateDict);
    resources.set("XObject", formDict);
    const appearanceDict = new _primitives.Dict(xref);
    appearanceDict.set("Resources", resources);
    const bbox = this.data.rect = [minX, minY, maxX, maxY];
    appearanceDict.set("BBox", bbox);
    this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
    this.appearance.dict = appearanceDict;
    this._streams.push(this.appearance, appearanceStream);
  }
  static async createNewAnnotation(xref, annotation, dependencies, params) {
    const annotationRef = annotation.ref ||= xref.getNewTemporaryRef();
    const ap = await this.createNewAppearanceStream(annotation, xref, params);
    const buffer = [];
    let annotationDict;
    if (ap) {
      const apRef = xref.getNewTemporaryRef();
      annotationDict = this.createNewDict(annotation, xref, {
        apRef
      });
      await (0, _writer.writeObject)(apRef, ap, buffer, xref);
      dependencies.push({
        ref: apRef,
        data: buffer.join("")
      });
    } else {
      annotationDict = this.createNewDict(annotation, xref, {});
    }
    if (Number.isInteger(annotation.parentTreeId)) {
      annotationDict.set("StructParent", annotation.parentTreeId);
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(annotationRef, annotationDict, buffer, xref);
    return {
      ref: annotationRef,
      data: buffer.join("")
    };
  }
  static async createNewPrintAnnotation(annotationGlobals, xref, annotation, params) {
    const ap = await this.createNewAppearanceStream(annotation, xref, params);
    const annotationDict = this.createNewDict(annotation, xref, {
      ap
    });
    const newAnnotation = new this.prototype.constructor({
      dict: annotationDict,
      xref,
      annotationGlobals,
      evaluatorOptions: params.evaluatorOptions
    });
    if (annotation.ref) {
      newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
    }
    return newAnnotation;
  }
}
exports.MarkupAnnotation = MarkupAnnotation;
class WidgetAnnotation extends Annotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref,
      annotationGlobals
    } = params;
    const data = this.data;
    this._needAppearances = params.needAppearances;
    data.annotationType = _util.AnnotationType.WIDGET;
    if (data.fieldName === undefined) {
      data.fieldName = this._constructFieldName(dict);
    }
    if (data.actions === undefined) {
      data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType);
    }
    let fieldValue = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "V",
      getArray: true
    });
    data.fieldValue = this._decodeFormValue(fieldValue);
    const defaultFieldValue = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DV",
      getArray: true
    });
    data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
    if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
      const path = this._title.str;
      if (path) {
        this._hasValueFromXFA = true;
        data.fieldValue = fieldValue = annotationGlobals.xfaDatasets.getValue(path);
      }
    }
    if (fieldValue === undefined && data.defaultFieldValue !== null) {
      data.fieldValue = data.defaultFieldValue;
    }
    data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
    this.setDefaultAppearance(params);
    data.hasAppearance ||= this._needAppearances && data.fieldValue !== undefined && data.fieldValue !== null;
    const fieldType = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "FT"
    });
    data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null;
    const localResources = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DR"
    });
    const acroFormResources = annotationGlobals.acroForm.get("DR");
    const appearanceResources = this.appearance?.dict.get("Resources");
    this._fieldResources = {
      localResources,
      acroFormResources,
      appearanceResources,
      mergedResources: _primitives.Dict.merge({
        xref,
        dictArray: [localResources, appearanceResources, acroFormResources],
        mergeSubDicts: true
      })
    };
    data.fieldFlags = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "Ff"
    });
    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
      data.fieldFlags = 0;
    }
    data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
    data.required = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED);
    data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN) || this._hasFlag(data.annotationFlags, _util.AnnotationFlag.NOVIEW);
  }
  _decodeFormValue(formValue) {
    if (Array.isArray(formValue)) {
      return formValue.filter(item => typeof item === "string").map(item => (0, _util.stringToPDFString)(item));
    } else if (formValue instanceof _primitives.Name) {
      return (0, _util.stringToPDFString)(formValue.name);
    } else if (typeof formValue === "string") {
      return (0, _util.stringToPDFString)(formValue);
    }
    return null;
  }
  hasFieldFlag(flag) {
    return !!(this.data.fieldFlags & flag);
  }
  _isViewable(flags) {
    return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
  }
  mustBeViewed(annotationStorage, renderForms) {
    if (renderForms) {
      return this.viewable;
    }
    return super.mustBeViewed(annotationStorage, renderForms) && !this._hasFlag(this.flags, _util.AnnotationFlag.NOVIEW);
  }
  getRotationMatrix(annotationStorage) {
    let rotation = annotationStorage?.get(this.data.id)?.rotation;
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    if (rotation === 0) {
      return _util.IDENTITY_MATRIX;
    }
    const width = this.data.rect[2] - this.data.rect[0];
    const height = this.data.rect[3] - this.data.rect[1];
    return (0, _core_utils.getRotationMatrix)(rotation, width, height);
  }
  getBorderAndBackgroundAppearances(annotationStorage) {
    let rotation = annotationStorage?.get(this.data.id)?.rotation;
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    if (!this.backgroundColor && !this.borderColor) {
      return "";
    }
    const width = this.data.rect[2] - this.data.rect[0];
    const height = this.data.rect[3] - this.data.rect[1];
    const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`;
    let str = "";
    if (this.backgroundColor) {
      str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `;
    }
    if (this.borderColor) {
      const borderWidth = this.borderStyle.width || 1;
      str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `;
    }
    return str;
  }
  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
    if (renderForms && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) {
      return {
        opList: new _operator_list.OperatorList(),
        separateForm: true,
        separateCanvas: false
      };
    }
    if (!this._hasText) {
      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
    }
    const content = await this._getAppearance(evaluator, task, intent, annotationStorage);
    if (this.appearance && content === null) {
      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
    }
    const opList = new _operator_list.OperatorList();
    if (!this._defaultAppearance || content === null) {
      return {
        opList,
        separateForm: false,
        separateCanvas: false
      };
    }
    const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY);
    const matrix = [1, 0, 0, 1, 0, 0];
    const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
    const transform = getTransformMatrix(this.data.rect, bbox, matrix);
    let optionalContent;
    if (this.oc) {
      optionalContent = await evaluator.parseMarkedContentProps(this.oc, null);
    }
    if (optionalContent !== undefined) {
      opList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), isUsingOwnCanvas]);
    const stream = new _stream.StringStream(content);
    await evaluator.getOperatorList({
      stream,
      task,
      resources: this._fieldResources.mergedResources,
      operatorList: opList
    });
    opList.addOp(_util.OPS.endAnnotation, []);
    if (optionalContent !== undefined) {
      opList.addOp(_util.OPS.endMarkedContent, []);
    }
    return {
      opList,
      separateForm: false,
      separateCanvas: isUsingOwnCanvas
    };
  }
  _getMKDict(rotation) {
    const mk = new _primitives.Dict(null);
    if (rotation) {
      mk.set("R", rotation);
    }
    if (this.borderColor) {
      mk.set("BC", getPdfColorArray(this.borderColor));
    }
    if (this.backgroundColor) {
      mk.set("BG", getPdfColorArray(this.backgroundColor));
    }
    return mk.size > 0 ? mk : null;
  }
  amendSavedDict(annotationStorage, dict) {}
  async save(evaluator, task, annotationStorage) {
    const storageEntry = annotationStorage?.get(this.data.id);
    let value = storageEntry?.value,
      rotation = storageEntry?.rotation;
    if (value === this.data.fieldValue || value === undefined) {
      if (!this._hasValueFromXFA && rotation === undefined) {
        return null;
      }
      value ||= this.data.fieldValue;
    }
    if (rotation === undefined && !this._hasValueFromXFA && Array.isArray(value) && Array.isArray(this.data.fieldValue) && value.length === this.data.fieldValue.length && value.every((x, i) => x === this.data.fieldValue[i])) {
      return null;
    }
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    let appearance = null;
    if (!this._needAppearances) {
      appearance = await this._getAppearance(evaluator, task, _util.RenderingIntentFlag.SAVE, annotationStorage);
      if (appearance === null) {
        return null;
      }
    } else {}
    let needAppearances = false;
    if (appearance?.needAppearances) {
      needAppearances = true;
      appearance = null;
    }
    const {
      xref
    } = evaluator;
    const originalDict = xref.fetchIfRef(this.ref);
    if (!(originalDict instanceof _primitives.Dict)) {
      return null;
    }
    const dict = new _primitives.Dict(xref);
    for (const key of originalDict.getKeys()) {
      if (key !== "AP") {
        dict.set(key, originalDict.getRaw(key));
      }
    }
    const xfa = {
      path: this.data.fieldName,
      value
    };
    const encoder = val => {
      return (0, _core_utils.isAscii)(val) ? val : (0, _core_utils.stringToUTF16String)(val, true);
    };
    dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
    this.amendSavedDict(annotationStorage, dict);
    const maybeMK = this._getMKDict(rotation);
    if (maybeMK) {
      dict.set("MK", maybeMK);
    }
    const buffer = [];
    const changes = [{
      ref: this.ref,
      data: "",
      xfa,
      needAppearances
    }];
    if (appearance !== null) {
      const newRef = xref.getNewTemporaryRef();
      const AP = new _primitives.Dict(xref);
      dict.set("AP", AP);
      AP.set("N", newRef);
      const resources = this._getSaveFieldResources(xref);
      const appearanceStream = new _stream.StringStream(appearance);
      const appearanceDict = appearanceStream.dict = new _primitives.Dict(xref);
      appearanceDict.set("Subtype", _primitives.Name.get("Form"));
      appearanceDict.set("Resources", resources);
      appearanceDict.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const rotationMatrix = this.getRotationMatrix(annotationStorage);
      if (rotationMatrix !== _util.IDENTITY_MATRIX) {
        appearanceDict.set("Matrix", rotationMatrix);
      }
      await (0, _writer.writeObject)(newRef, appearanceStream, buffer, xref);
      changes.push({
        ref: newRef,
        data: buffer.join(""),
        xfa: null,
        needAppearances: false
      });
      buffer.length = 0;
    }
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    await (0, _writer.writeObject)(this.ref, dict, buffer, xref);
    changes[0].data = buffer.join("");
    return changes;
  }
  async _getAppearance(evaluator, task, intent, annotationStorage) {
    const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);
    if (isPassword) {
      return null;
    }
    const storageEntry = annotationStorage?.get(this.data.id);
    let value, rotation;
    if (storageEntry) {
      value = storageEntry.formattedValue || storageEntry.value;
      rotation = storageEntry.rotation;
    }
    if (rotation === undefined && value === undefined && !this._needAppearances) {
      if (!this._hasValueFromXFA || this.appearance) {
        return null;
      }
    }
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    if (value === undefined) {
      value = this.data.fieldValue;
      if (!value) {
        return `/Tx BMC q ${colors}Q EMC`;
      }
    }
    if (Array.isArray(value) && value.length === 1) {
      value = value[0];
    }
    (0, _util.assert)(typeof value === "string", "Expected `value` to be a string.");
    value = value.trim();
    if (this.data.combo) {
      const option = this.data.options.find(({
        exportValue
      }) => value === exportValue);
      value = option?.displayValue || value;
    }
    if (value === "") {
      return `/Tx BMC q ${colors}Q EMC`;
    }
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    let lineCount = -1;
    let lines;
    if (this.data.multiLine) {
      lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
      lineCount = lines.length;
    } else {
      lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
    }
    const defaultPadding = 1;
    const defaultHPadding = 2;
    let totalHeight = this.data.rect[3] - this.data.rect[1];
    let totalWidth = this.data.rect[2] - this.data.rect[0];
    if (rotation === 90 || rotation === 270) {
      [totalWidth, totalHeight] = [totalHeight, totalWidth];
    }
    if (!this._defaultAppearance) {
      this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }
    let font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let defaultAppearance, fontSize, lineHeight;
    const encodedLines = [];
    let encodingError = false;
    for (const line of lines) {
      const encodedString = font.encodeString(line);
      if (encodedString.length > 1) {
        encodingError = true;
      }
      encodedLines.push(encodedString.join(""));
    }
    if (encodingError && intent & _util.RenderingIntentFlag.SAVE) {
      return {
        needAppearances: true
      };
    }
    if (encodingError && this._isOffscreenCanvasSupported) {
      const fontFamily = this.data.comb ? "monospace" : "sans-serif";
      const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(evaluator.xref, fontFamily);
      const resources = fakeUnicodeFont.createFontResources(lines.join(""));
      const newFont = resources.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const oldFont = this._fieldResources.mergedResources.get("Font");
        for (const key of newFont.getKeys()) {
          oldFont.set(key, newFont.getRaw(key));
        }
      } else {
        this._fieldResources.mergedResources.set("Font", newFont);
      }
      const fontName = fakeUnicodeFont.fontName.name;
      font = await WidgetAnnotation._getFontData(evaluator, task, {
        fontName,
        fontSize: 0
      }, resources);
      for (let i = 0, ii = encodedLines.length; i < ii; i++) {
        encodedLines[i] = (0, _core_utils.stringToUTF16String)(lines[i]);
      }
      const savedDefaultAppearance = Object.assign(Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0;
      this.data.defaultAppearanceData.fontName = fontName;
      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
      this.data.defaultAppearanceData = savedDefaultAppearance;
    } else {
      if (!this._isOffscreenCanvasSupported) {
        (0, _util.warn)("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
      }
      [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount);
    }
    let descent = font.descent;
    if (isNaN(descent)) {
      descent = _util.BASELINE_FACTOR * lineHeight;
    } else {
      descent = Math.max(_util.BASELINE_FACTOR * lineHeight, Math.abs(descent) * fontSize);
    }
    const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding);
    const alignment = this.data.textAlignment;
    if (this.data.multiLine) {
      return this._getMultilineAppearance(defaultAppearance, encodedLines, font, fontSize, totalWidth, totalHeight, alignment, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
    }
    if (this.data.comb) {
      return this._getCombAppearance(defaultAppearance, font, encodedLines[0], fontSize, totalWidth, totalHeight, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage);
    }
    const bottomPadding = defaultVPadding + descent;
    if (alignment === 0 || alignment > 2) {
      return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(defaultHPadding)} ${(0, _core_utils.numberToString)(bottomPadding)} Tm (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj` + " ET Q EMC";
    }
    const prevInfo = {
      shift: 0
    };
    const renderedText = this._renderText(encodedLines[0], font, fontSize, totalWidth, alignment, prevInfo, defaultHPadding, bottomPadding);
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + " ET Q EMC";
  }
  static async _getFontData(evaluator, task, appearanceData, resources) {
    const operatorList = new _operator_list.OperatorList();
    const initialState = {
      font: null,
      clone() {
        return this;
      }
    };
    const {
      fontName,
      fontSize
    } = appearanceData;
    await evaluator.handleSetFont(resources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null);
    return initialState.font;
  }
  _getTextWidth(text, font) {
    return font.charsToGlyphs(text).reduce((width, glyph) => width + glyph.width, 0) / 1000;
  }
  _computeFontSize(height, width, text, font, lineCount) {
    let {
      fontSize
    } = this.data.defaultAppearanceData;
    let lineHeight = (fontSize || 12) * _util.LINE_FACTOR,
      numberOfLines = Math.round(height / lineHeight);
    if (!fontSize) {
      const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
      if (lineCount === -1) {
        const textWidth = this._getTextWidth(text, font);
        fontSize = roundWithTwoDigits(Math.min(height / _util.LINE_FACTOR, textWidth > width ? width / textWidth : Infinity));
        numberOfLines = 1;
      } else {
        const lines = text.split(/\r\n?|\n/);
        const cachedLines = [];
        for (const line of lines) {
          const encoded = font.encodeString(line).join("");
          const glyphs = font.charsToGlyphs(encoded);
          const positions = font.getCharPositions(encoded);
          cachedLines.push({
            line: encoded,
            glyphs,
            positions
          });
        }
        const isTooBig = fsize => {
          let totalHeight = 0;
          for (const cache of cachedLines) {
            const chunks = this._splitLine(null, font, fsize, width, cache);
            totalHeight += chunks.length * fsize;
            if (totalHeight > height) {
              return true;
            }
          }
          return false;
        };
        numberOfLines = Math.max(numberOfLines, lineCount);
        while (true) {
          lineHeight = height / numberOfLines;
          fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR);
          if (isTooBig(fontSize)) {
            numberOfLines++;
            continue;
          }
          break;
        }
      }
      const {
        fontName,
        fontColor
      } = this.data.defaultAppearanceData;
      this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
        fontSize,
        fontName,
        fontColor
      });
    }
    return [this._defaultAppearance, fontSize, height / numberOfLines];
  }
  _renderText(text, font, fontSize, totalWidth, alignment, prevInfo, hPadding, vPadding) {
    let shift;
    if (alignment === 1) {
      const width = this._getTextWidth(text, font) * fontSize;
      shift = (totalWidth - width) / 2;
    } else if (alignment === 2) {
      const width = this._getTextWidth(text, font) * fontSize;
      shift = totalWidth - width - hPadding;
    } else {
      shift = hPadding;
    }
    const shiftStr = (0, _core_utils.numberToString)(shift - prevInfo.shift);
    prevInfo.shift = shift;
    vPadding = (0, _core_utils.numberToString)(vPadding);
    return `${shiftStr} ${vPadding} Td (${(0, _core_utils.escapeString)(text)}) Tj`;
  }
  _getSaveFieldResources(xref) {
    const {
      localResources,
      appearanceResources,
      acroFormResources
    } = this._fieldResources;
    const fontName = this.data.defaultAppearanceData?.fontName;
    if (!fontName) {
      return localResources || _primitives.Dict.empty;
    }
    for (const resources of [localResources, appearanceResources]) {
      if (resources instanceof _primitives.Dict) {
        const localFont = resources.get("Font");
        if (localFont instanceof _primitives.Dict && localFont.has(fontName)) {
          return resources;
        }
      }
    }
    if (acroFormResources instanceof _primitives.Dict) {
      const acroFormFont = acroFormResources.get("Font");
      if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) {
        const subFontDict = new _primitives.Dict(xref);
        subFontDict.set(fontName, acroFormFont.getRaw(fontName));
        const subResourcesDict = new _primitives.Dict(xref);
        subResourcesDict.set("Font", subFontDict);
        return _primitives.Dict.merge({
          xref,
          dictArray: [subResourcesDict, localResources],
          mergeSubDicts: true
        });
      }
    }
    return localResources || _primitives.Dict.empty;
  }
  getFieldObject() {
    return null;
  }
}
class TextWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
    this._hasText = true;
    const dict = params.dict;
    if (typeof this.data.fieldValue !== "string") {
      this.data.fieldValue = "";
    }
    let alignment = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "Q"
    });
    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
      alignment = null;
    }
    this.data.textAlignment = alignment;
    let maximumLength = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "MaxLen"
    });
    if (!Number.isInteger(maximumLength) || maximumLength < 0) {
      maximumLength = 0;
    }
    this.data.maxLen = maximumLength;
    this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
    this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0;
    this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL);
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(defaultAppearance, font, text, fontSize, width, height, hPadding, vPadding, descent, lineHeight, annotationStorage) {
    const combWidth = width / this.data.maxLen;
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    const buf = [];
    const positions = font.getCharPositions(text);
    for (const [start, end] of positions) {
      buf.push(`(${(0, _core_utils.escapeString)(text.substring(start, end))}) Tj`);
    }
    const renderedComb = buf.join(` ${(0, _core_utils.numberToString)(combWidth)} 0 Td `);
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(hPadding)} ${(0, _core_utils.numberToString)(vPadding + descent)} Tm ${renderedComb}` + " ET Q EMC";
  }
  _getMultilineAppearance(defaultAppearance, lines, font, fontSize, width, height, alignment, hPadding, vPadding, descent, lineHeight, annotationStorage) {
    const buf = [];
    const totalWidth = width - 2 * hPadding;
    const prevInfo = {
      shift: 0
    };
    for (let i = 0, ii = lines.length; i < ii; i++) {
      const line = lines[i];
      const chunks = this._splitLine(line, font, fontSize, totalWidth);
      for (let j = 0, jj = chunks.length; j < jj; j++) {
        const chunk = chunks[j];
        const vShift = i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
        buf.push(this._renderText(chunk, font, fontSize, width, alignment, prevInfo, hPadding, vShift));
      }
    }
    const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
    const renderedText = buf.join("\n");
    return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${(0, _core_utils.numberToString)(height)} Tm ${renderedText}` + " ET Q EMC";
  }
  _splitLine(line, font, fontSize, width, cache = {}) {
    line = cache.line || line;
    const glyphs = cache.glyphs || font.charsToGlyphs(line);
    if (glyphs.length <= 1) {
      return [line];
    }
    const positions = cache.positions || font.getCharPositions(line);
    const scale = fontSize / 1000;
    const chunks = [];
    let lastSpacePosInStringStart = -1,
      lastSpacePosInStringEnd = -1,
      lastSpacePos = -1,
      startChunk = 0,
      currentWidth = 0;
    for (let i = 0, ii = glyphs.length; i < ii; i++) {
      const [start, end] = positions[i];
      const glyph = glyphs[i];
      const glyphWidth = glyph.width * scale;
      if (glyph.unicode === " ") {
        if (currentWidth + glyphWidth > width) {
          chunks.push(line.substring(startChunk, start));
          startChunk = start;
          currentWidth = glyphWidth;
          lastSpacePosInStringStart = -1;
          lastSpacePos = -1;
        } else {
          currentWidth += glyphWidth;
          lastSpacePosInStringStart = start;
          lastSpacePosInStringEnd = end;
          lastSpacePos = i;
        }
      } else if (currentWidth + glyphWidth > width) {
        if (lastSpacePosInStringStart !== -1) {
          chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
          startChunk = lastSpacePosInStringEnd;
          i = lastSpacePos + 1;
          lastSpacePosInStringStart = -1;
          currentWidth = 0;
        } else {
          chunks.push(line.substring(startChunk, start));
          startChunk = start;
          currentWidth = glyphWidth;
        }
      } else {
        currentWidth += glyphWidth;
      }
    }
    if (startChunk < line.length) {
      chunks.push(line.substring(startChunk, line.length));
    }
    return chunks;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: this.data.fieldValue,
      defaultValue: this.data.defaultFieldValue || "",
      multiline: this.data.multiLine,
      password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
      charLimit: this.data.maxLen,
      comb: this.data.comb,
      editable: !this.data.readOnly,
      hidden: this.data.hidden,
      name: this.data.fieldName,
      rect: this.data.rect,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: "text"
    };
  }
}
class ButtonWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.isTooltipOnly = false;
    if (this.data.checkBox) {
      this._processCheckBox(params);
    } else if (this.data.radioButton) {
      this._processRadioButton(params);
    } else if (this.data.pushButton) {
      this.data.hasOwnCanvas = true;
      this._processPushButton(params);
    } else {
      (0, _util.warn)("Invalid field flags for button widget annotation");
    }
  }
  async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
    if (this.data.pushButton) {
      return super.getOperatorList(evaluator, task, intent, false, annotationStorage);
    }
    let value = null;
    let rotation = null;
    if (annotationStorage) {
      const storageEntry = annotationStorage.get(this.data.id);
      value = storageEntry ? storageEntry.value : null;
      rotation = storageEntry ? storageEntry.rotation : null;
    }
    if (value === null && this.appearance) {
      return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
    }
    if (value === null || value === undefined) {
      value = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue;
    }
    const appearance = value ? this.checkedAppearance : this.uncheckedAppearance;
    if (appearance) {
      const savedAppearance = this.appearance;
      const savedMatrix = appearance.dict.getArray("Matrix") || _util.IDENTITY_MATRIX;
      if (rotation) {
        appearance.dict.set("Matrix", this.getRotationMatrix(annotationStorage));
      }
      this.appearance = appearance;
      const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage);
      this.appearance = savedAppearance;
      appearance.dict.set("Matrix", savedMatrix);
      return operatorList;
    }
    return {
      opList: new _operator_list.OperatorList(),
      separateForm: false,
      separateCanvas: false
    };
  }
  async save(evaluator, task, annotationStorage) {
    if (this.data.checkBox) {
      return this._saveCheckbox(evaluator, task, annotationStorage);
    }
    if (this.data.radioButton) {
      return this._saveRadioButton(evaluator, task, annotationStorage);
    }
    return null;
  }
  async _saveCheckbox(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    let rotation = storageEntry?.rotation,
      value = storageEntry?.value;
    if (rotation === undefined) {
      if (value === undefined) {
        return null;
      }
      const defaultValue = this.data.fieldValue === this.data.exportValue;
      if (defaultValue === value) {
        return null;
      }
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    if (!(dict instanceof _primitives.Dict)) {
      return null;
    }
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    if (value === undefined) {
      value = this.data.fieldValue === this.data.exportValue;
    }
    const xfa = {
      path: this.data.fieldName,
      value: value ? this.data.exportValue : ""
    };
    const name = _primitives.Name.get(value ? this.data.exportValue : "Off");
    dict.set("V", name);
    dict.set("AS", name);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const maybeMK = this._getMKDict(rotation);
    if (maybeMK) {
      dict.set("MK", maybeMK);
    }
    const buffer = [];
    await (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
    return [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];
  }
  async _saveRadioButton(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    let rotation = storageEntry?.rotation,
      value = storageEntry?.value;
    if (rotation === undefined) {
      if (value === undefined) {
        return null;
      }
      const defaultValue = this.data.fieldValue === this.data.buttonValue;
      if (defaultValue === value) {
        return null;
      }
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    if (!(dict instanceof _primitives.Dict)) {
      return null;
    }
    if (value === undefined) {
      value = this.data.fieldValue === this.data.buttonValue;
    }
    if (rotation === undefined) {
      rotation = this.rotation;
    }
    const xfa = {
      path: this.data.fieldName,
      value: value ? this.data.buttonValue : ""
    };
    const name = _primitives.Name.get(value ? this.data.buttonValue : "Off");
    const buffer = [];
    let parentData = null;
    if (value) {
      if (this.parent instanceof _primitives.Ref) {
        const parent = evaluator.xref.fetch(this.parent);
        parent.set("V", name);
        await (0, _writer.writeObject)(this.parent, parent, buffer, evaluator.xref);
        parentData = buffer.join("");
        buffer.length = 0;
      } else if (this.parent instanceof _primitives.Dict) {
        this.parent.set("V", name);
      }
    }
    dict.set("AS", name);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const maybeMK = this._getMKDict(rotation);
    if (maybeMK) {
      dict.set("MK", maybeMK);
    }
    await (0, _writer.writeObject)(this.ref, dict, buffer, evaluator.xref);
    const newRefs = [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];
    if (parentData) {
      newRefs.push({
        ref: this.parent,
        data: parentData,
        xfa: null
      });
    }
    return newRefs;
  }
  _getDefaultCheckedAppearance(params, type) {
    const width = this.data.rect[2] - this.data.rect[0];
    const height = this.data.rect[3] - this.data.rect[1];
    const bbox = [0, 0, width, height];
    const FONT_RATIO = 0.8;
    const fontSize = Math.min(width, height) * FONT_RATIO;
    let metrics, char;
    if (type === "check") {
      metrics = {
        width: 0.755 * fontSize,
        height: 0.705 * fontSize
      };
      char = "\x33";
    } else if (type === "disc") {
      metrics = {
        width: 0.791 * fontSize,
        height: 0.705 * fontSize
      };
      char = "\x6C";
    } else {
      (0, _util.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
    }
    const xShift = (0, _core_utils.numberToString)((width - metrics.width) / 2);
    const yShift = (0, _core_utils.numberToString)((height - metrics.height) / 2);
    const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
    const appearanceStreamDict = new _primitives.Dict(params.xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", bbox);
    appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
    appearanceStreamDict.set("Length", appearance.length);
    const resources = new _primitives.Dict(params.xref);
    const font = new _primitives.Dict(params.xref);
    font.set("PdfJsZaDb", this.fallbackFontDict);
    resources.set("Font", font);
    appearanceStreamDict.set("Resources", resources);
    this.checkedAppearance = new _stream.StringStream(appearance);
    this.checkedAppearance.dict = appearanceStreamDict;
    this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(params) {
    const customAppearance = params.dict.get("AP");
    if (!(customAppearance instanceof _primitives.Dict)) {
      return;
    }
    const normalAppearance = customAppearance.get("N");
    if (!(normalAppearance instanceof _primitives.Dict)) {
      return;
    }
    const asValue = this._decodeFormValue(params.dict.get("AS"));
    if (typeof asValue === "string") {
      this.data.fieldValue = asValue;
    }
    const yes = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes";
    const exportValues = normalAppearance.getKeys();
    if (exportValues.length === 0) {
      exportValues.push("Off", yes);
    } else if (exportValues.length === 1) {
      if (exportValues[0] === "Off") {
        exportValues.push(yes);
      } else {
        exportValues.unshift("Off");
      }
    } else if (exportValues.includes(yes)) {
      exportValues.length = 0;
      exportValues.push("Off", yes);
    } else {
      const otherYes = exportValues.find(v => v !== "Off");
      exportValues.length = 0;
      exportValues.push("Off", otherYes);
    }
    if (!exportValues.includes(this.data.fieldValue)) {
      this.data.fieldValue = "Off";
    }
    this.data.exportValue = exportValues[1];
    const checkedAppearance = normalAppearance.get(this.data.exportValue);
    this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
    const uncheckedAppearance = normalAppearance.get("Off");
    this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
    if (this.checkedAppearance) {
      this._streams.push(this.checkedAppearance);
    } else {
      this._getDefaultCheckedAppearance(params, "check");
    }
    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    this._fallbackFontDict = this.fallbackFontDict;
    if (this.data.defaultFieldValue === null) {
      this.data.defaultFieldValue = "Off";
    }
  }
  _processRadioButton(params) {
    this.data.fieldValue = this.data.buttonValue = null;
    const fieldParent = params.dict.get("Parent");
    if (fieldParent instanceof _primitives.Dict) {
      this.parent = params.dict.getRaw("Parent");
      const fieldParentValue = fieldParent.get("V");
      if (fieldParentValue instanceof _primitives.Name) {
        this.data.fieldValue = this._decodeFormValue(fieldParentValue);
      }
    }
    const appearanceStates = params.dict.get("AP");
    if (!(appearanceStates instanceof _primitives.Dict)) {
      return;
    }
    const normalAppearance = appearanceStates.get("N");
    if (!(normalAppearance instanceof _primitives.Dict)) {
      return;
    }
    for (const key of normalAppearance.getKeys()) {
      if (key !== "Off") {
        this.data.buttonValue = this._decodeFormValue(key);
        break;
      }
    }
    const checkedAppearance = normalAppearance.get(this.data.buttonValue);
    this.checkedAppearance = checkedAppearance instanceof _base_stream.BaseStream ? checkedAppearance : null;
    const uncheckedAppearance = normalAppearance.get("Off");
    this.uncheckedAppearance = uncheckedAppearance instanceof _base_stream.BaseStream ? uncheckedAppearance : null;
    if (this.checkedAppearance) {
      this._streams.push(this.checkedAppearance);
    } else {
      this._getDefaultCheckedAppearance(params, "disc");
    }
    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    this._fallbackFontDict = this.fallbackFontDict;
    if (this.data.defaultFieldValue === null) {
      this.data.defaultFieldValue = "Off";
    }
  }
  _processPushButton(params) {
    const {
      dict,
      annotationGlobals
    } = params;
    if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
      (0, _util.warn)("Push buttons without action dictionaries are not supported");
      return;
    }
    this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
    _catalog.Catalog.parseDestDictionary({
      destDict: dict,
      resultObj: this.data,
      docBaseUrl: annotationGlobals.baseUrl,
      docAttachments: annotationGlobals.attachments
    });
  }
  getFieldObject() {
    let type = "button";
    let exportValues;
    if (this.data.checkBox) {
      type = "checkbox";
      exportValues = this.data.exportValue;
    } else if (this.data.radioButton) {
      type = "radiobutton";
      exportValues = this.data.buttonValue;
    }
    return {
      id: this.data.id,
      value: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      exportValues,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type
    };
  }
  get fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
    dict.set("Type", _primitives.Name.get("FallbackType"));
    dict.set("Subtype", _primitives.Name.get("FallbackType"));
    dict.set("Encoding", _primitives.Name.get("ZapfDingbatsEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }
}
class ChoiceWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.indices = dict.getArray("I");
    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
    this.data.options = [];
    const options = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "Opt"
    });
    if (Array.isArray(options)) {
      for (let i = 0, ii = options.length; i < ii; i++) {
        const option = xref.fetchIfRef(options[i]);
        const isOptionArray = Array.isArray(option);
        this.data.options[i] = {
          exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
          displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
        };
      }
    }
    if (!this.hasIndices) {
      if (typeof this.data.fieldValue === "string") {
        this.data.fieldValue = [this.data.fieldValue];
      } else if (!this.data.fieldValue) {
        this.data.fieldValue = [];
      }
    } else {
      this.data.fieldValue = [];
      const ii = this.data.options.length;
      for (const i of this.indices) {
        if (Number.isInteger(i) && i >= 0 && i < ii) {
          this.data.fieldValue.push(this.data.options[i].exportValue);
        }
      }
    }
    this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
    this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
    this._hasText = true;
  }
  getFieldObject() {
    const type = this.data.combo ? "combobox" : "listbox";
    const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return {
      id: this.data.id,
      value,
      defaultValue: this.data.defaultFieldValue,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      numItems: this.data.fieldValue.length,
      multipleSelection: this.data.multiSelect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      items: this.data.options,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type
    };
  }
  amendSavedDict(annotationStorage, dict) {
    if (!this.hasIndices) {
      return;
    }
    let values = annotationStorage?.get(this.data.id)?.value;
    if (!Array.isArray(values)) {
      values = [values];
    }
    const indices = [];
    const {
      options
    } = this.data;
    for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
      if (options[i].exportValue === values[j]) {
        indices.push(i);
        j += 1;
      }
    }
    dict.set("I", indices);
  }
  async _getAppearance(evaluator, task, intent, annotationStorage) {
    if (this.data.combo) {
      return super._getAppearance(evaluator, task, intent, annotationStorage);
    }
    let exportedValue, rotation;
    const storageEntry = annotationStorage?.get(this.data.id);
    if (storageEntry) {
      rotation = storageEntry.rotation;
      exportedValue = storageEntry.value;
    }
    if (rotation === undefined && exportedValue === undefined && !this._needAppearances) {
      return null;
    }
    if (exportedValue === undefined) {
      exportedValue = this.data.fieldValue;
    } else if (!Array.isArray(exportedValue)) {
      exportedValue = [exportedValue];
    }
    const defaultPadding = 1;
    const defaultHPadding = 2;
    let totalHeight = this.data.rect[3] - this.data.rect[1];
    let totalWidth = this.data.rect[2] - this.data.rect[0];
    if (rotation === 90 || rotation === 270) {
      [totalWidth, totalHeight] = [totalHeight, totalWidth];
    }
    const lineCount = this.data.options.length;
    const valueIndices = [];
    for (let i = 0; i < lineCount; i++) {
      const {
        exportValue
      } = this.data.options[i];
      if (exportedValue.includes(exportValue)) {
        valueIndices.push(i);
      }
    }
    if (!this._defaultAppearance) {
      this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }
    const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let defaultAppearance;
    let {
      fontSize
    } = this.data.defaultAppearanceData;
    if (!fontSize) {
      const lineHeight = (totalHeight - defaultPadding) / lineCount;
      let lineWidth = -1;
      let value;
      for (const {
        displayValue
      } of this.data.options) {
        const width = this._getTextWidth(displayValue, font);
        if (width > lineWidth) {
          lineWidth = width;
          value = displayValue;
        }
      }
      [defaultAppearance, fontSize] = this._computeFontSize(lineHeight, totalWidth - 2 * defaultHPadding, value, font, -1);
    } else {
      defaultAppearance = this._defaultAppearance;
    }
    const lineHeight = fontSize * _util.LINE_FACTOR;
    const vPadding = (lineHeight - fontSize) / 2;
    const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
    let firstIndex = 0;
    if (valueIndices.length > 0) {
      const minIndex = Math.min(...valueIndices);
      const maxIndex = Math.max(...valueIndices);
      firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
      if (firstIndex > minIndex) {
        firstIndex = minIndex;
      }
    }
    const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
    const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
    if (valueIndices.length) {
      buf.push("0.600006 0.756866 0.854904 rg");
      for (const index of valueIndices) {
        if (firstIndex <= index && index < end) {
          buf.push(`1 ${totalHeight - (index - firstIndex + 1) * lineHeight} ${totalWidth} ${lineHeight} re f`);
        }
      }
    }
    buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
    const prevInfo = {
      shift: 0
    };
    for (let i = firstIndex; i < end; i++) {
      const {
        displayValue
      } = this.data.options[i];
      const vpadding = i === firstIndex ? vPadding : 0;
      buf.push(this._renderText(displayValue, font, fontSize, totalWidth, 0, prevInfo, defaultHPadding, -lineHeight + vpadding));
    }
    buf.push("ET Q EMC");
    return buf.join("\n");
  }
}
class SignatureWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.fieldValue = null;
    this.data.hasOwnCanvas = this.data.noRotate;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: null,
      page: this.data.pageIndex,
      type: "signature"
    };
  }
}
class TextAnnotation extends MarkupAnnotation {
  constructor(params) {
    const DEFAULT_ICON_SIZE = 22;
    super(params);
    this.data.noRotate = true;
    this.data.hasOwnCanvas = this.data.noRotate;
    const {
      dict
    } = params;
    this.data.annotationType = _util.AnnotationType.TEXT;
    if (this.data.hasAppearance) {
      this.data.name = "NoIcon";
    } else {
      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
      this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
    }
    if (dict.has("State")) {
      this.data.state = dict.get("State") || null;
      this.data.stateModel = dict.get("StateModel") || null;
    } else {
      this.data.state = null;
      this.data.stateModel = null;
    }
  }
}
class LinkAnnotation extends Annotation {
  constructor(params) {
    super(params);
    const {
      dict,
      annotationGlobals
    } = params;
    this.data.annotationType = _util.AnnotationType.LINK;
    const quadPoints = getQuadPoints(dict, this.rectangle);
    if (quadPoints) {
      this.data.quadPoints = quadPoints;
    }
    this.data.borderColor ||= this.data.color;
    _catalog.Catalog.parseDestDictionary({
      destDict: dict,
      resultObj: this.data,
      docBaseUrl: annotationGlobals.baseUrl,
      docAttachments: annotationGlobals.attachments
    });
  }
}
class PopupAnnotation extends Annotation {
  constructor(params) {
    super(params);
    const {
      dict
    } = params;
    this.data.annotationType = _util.AnnotationType.POPUP;
    if (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) {
      this.data.rect = null;
    }
    let parentItem = dict.get("Parent");
    if (!parentItem) {
      (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    const parentRect = parentItem.getArray("Rect");
    this.data.parentRect = Array.isArray(parentRect) && parentRect.length === 4 ? _util.Util.normalizeRect(parentRect) : null;
    const rt = parentItem.get("RT");
    if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
      parentItem = parentItem.get("IRT");
    }
    if (!parentItem.has("M")) {
      this.data.modificationDate = null;
    } else {
      this.setModificationDate(parentItem.get("M"));
      this.data.modificationDate = this.modificationDate;
    }
    if (!parentItem.has("C")) {
      this.data.color = null;
    } else {
      this.setColor(parentItem.getArray("C"));
      this.data.color = this.color;
    }
    if (!this.viewable) {
      const parentFlags = parentItem.get("F");
      if (this._isViewable(parentFlags)) {
        this.setFlags(parentFlags);
      }
    }
    this.setTitle(parentItem.get("T"));
    this.data.titleObj = this._title;
    this.setContents(parentItem.get("Contents"));
    this.data.contentsObj = this._contents;
    if (parentItem.has("RC")) {
      this.data.richText = _factory.XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
    }
    this.data.open = !!dict.get("Open");
  }
}
exports.PopupAnnotation = PopupAnnotation;
class FreeTextAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    this.data.hasOwnCanvas = true;
    const {
      evaluatorOptions,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.FREETEXT;
    this.setDefaultAppearance(params);
    if (this.appearance) {
      const {
        fontColor,
        fontSize
      } = (0, _default_appearance.parseAppearanceStream)(this.appearance, evaluatorOptions, xref);
      this.data.defaultAppearanceData.fontColor = fontColor;
      this.data.defaultAppearanceData.fontSize = fontSize || 10;
    } else if (this._isOffscreenCanvasSupported) {
      const strokeAlpha = params.dict.get("CA");
      const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(xref, "sans-serif");
      this.data.defaultAppearanceData.fontSize ||= 10;
      const {
        fontColor,
        fontSize
      } = this.data.defaultAppearanceData;
      this.appearance = fakeUnicodeFont.createAppearance(this._contents.str, this.rectangle, this.rotation, fontSize, fontColor, strokeAlpha);
      this._streams.push(this.appearance, _default_appearance.FakeUnicodeFont.toUnicodeStream);
    } else {
      (0, _util.warn)("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return !!this.appearance;
  }
  static createNewDict(annotation, xref, {
    apRef,
    ap
  }) {
    const {
      color,
      fontSize,
      rect,
      rotation,
      user,
      value
    } = annotation;
    const freetext = new _primitives.Dict(xref);
    freetext.set("Type", _primitives.Name.get("Annot"));
    freetext.set("Subtype", _primitives.Name.get("FreeText"));
    freetext.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
    freetext.set("Rect", rect);
    const da = `/Helv ${fontSize} Tf ${(0, _default_appearance.getPdfColor)(color, true)}`;
    freetext.set("DA", da);
    freetext.set("Contents", (0, _core_utils.isAscii)(value) ? value : (0, _core_utils.stringToUTF16String)(value, true));
    freetext.set("F", 4);
    freetext.set("Border", [0, 0, 0]);
    freetext.set("Rotate", rotation);
    if (user) {
      freetext.set("T", (0, _core_utils.isAscii)(user) ? user : (0, _core_utils.stringToUTF16String)(user, true));
    }
    if (apRef || ap) {
      const n = new _primitives.Dict(xref);
      freetext.set("AP", n);
      if (apRef) {
        n.set("N", apRef);
      } else {
        n.set("N", ap);
      }
    }
    return freetext;
  }
  static async createNewAppearanceStream(annotation, xref, params) {
    const {
      baseFontRef,
      evaluator,
      task
    } = params;
    const {
      color,
      fontSize,
      rect,
      rotation,
      value
    } = annotation;
    const resources = new _primitives.Dict(xref);
    const font = new _primitives.Dict(xref);
    if (baseFontRef) {
      font.set("Helv", baseFontRef);
    } else {
      const baseFont = new _primitives.Dict(xref);
      baseFont.set("BaseFont", _primitives.Name.get("Helvetica"));
      baseFont.set("Type", _primitives.Name.get("Font"));
      baseFont.set("Subtype", _primitives.Name.get("Type1"));
      baseFont.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
      font.set("Helv", baseFont);
    }
    resources.set("Font", font);
    const helv = await WidgetAnnotation._getFontData(evaluator, task, {
      fontName: "Helv",
      fontSize
    }, resources);
    const [x1, y1, x2, y2] = rect;
    let w = x2 - x1;
    let h = y2 - y1;
    if (rotation % 180 !== 0) {
      [w, h] = [h, w];
    }
    const lines = value.split("\n");
    const scale = fontSize / 1000;
    let totalWidth = -Infinity;
    const encodedLines = [];
    for (let line of lines) {
      const encoded = helv.encodeString(line);
      if (encoded.length > 1) {
        return null;
      }
      line = encoded.join("");
      encodedLines.push(line);
      let lineWidth = 0;
      const glyphs = helv.charsToGlyphs(line);
      for (const glyph of glyphs) {
        lineWidth += glyph.width * scale;
      }
      totalWidth = Math.max(totalWidth, lineWidth);
    }
    let hscale = 1;
    if (totalWidth > w) {
      hscale = w / totalWidth;
    }
    let vscale = 1;
    const lineHeight = _util.LINE_FACTOR * fontSize;
    const lineAscent = (_util.LINE_FACTOR - _util.LINE_DESCENT_FACTOR) * fontSize;
    const totalHeight = lineHeight * lines.length;
    if (totalHeight > h) {
      vscale = h / totalHeight;
    }
    const fscale = Math.min(hscale, vscale);
    const newFontSize = fontSize * fscale;
    let firstPoint, clipBox, matrix;
    switch (rotation) {
      case 0:
        matrix = [1, 0, 0, 1];
        clipBox = [rect[0], rect[1], w, h];
        firstPoint = [rect[0], rect[3] - lineAscent];
        break;
      case 90:
        matrix = [0, 1, -1, 0];
        clipBox = [rect[1], -rect[2], w, h];
        firstPoint = [rect[1], -rect[0] - lineAscent];
        break;
      case 180:
        matrix = [-1, 0, 0, -1];
        clipBox = [-rect[2], -rect[3], w, h];
        firstPoint = [-rect[2], -rect[1] - lineAscent];
        break;
      case 270:
        matrix = [0, -1, 1, 0];
        clipBox = [-rect[3], rect[0], w, h];
        firstPoint = [-rect[3], rect[2] - lineAscent];
        break;
    }
    const buffer = ["q", `${matrix.join(" ")} 0 0 cm`, `${clipBox.join(" ")} re W n`, `BT`, `${(0, _default_appearance.getPdfColor)(color, true)}`, `0 Tc /Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
    buffer.push(`${firstPoint.join(" ")} Td (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj`);
    const vShift = (0, _core_utils.numberToString)(lineHeight);
    for (let i = 1, ii = encodedLines.length; i < ii; i++) {
      const line = encodedLines[i];
      buffer.push(`0 -${vShift} Td (${(0, _core_utils.escapeString)(line)}) Tj`);
    }
    buffer.push("ET", "Q");
    const appearance = buffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", rect);
    appearanceStreamDict.set("Resources", resources);
    appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
    const ap = new _stream.StringStream(appearance);
    ap.dict = appearanceStreamDict;
    return ap;
  }
}
class LineAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.LINE;
    this.data.hasOwnCanvas = this.data.noRotate;
    const lineCoordinates = dict.getArray("L");
    this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates);
    this.setLineEndings(dict.getArray("LE"));
    this.data.lineEndings = this.lineEndings;
    if (!this.appearance) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * borderWidth;
      const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];
      if (!_util.Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref,
        extra: `${borderWidth} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, "S");
          return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];
        }
      });
    }
  }
}
class SquareAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.SQUARE;
    this.data.hasOwnCanvas = this.data.noRotate;
    if (!this.appearance) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      if (this.borderStyle.width === 0 && !fillColor) {
        return;
      }
      this._setDefaultAppearance({
        xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          const x = points[2].x + this.borderStyle.width / 2;
          const y = points[2].y + this.borderStyle.width / 2;
          const width = points[3].x - points[2].x - this.borderStyle.width;
          const height = points[1].y - points[3].y - this.borderStyle.width;
          buffer.push(`${x} ${y} ${width} ${height} re`);
          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
}
class CircleAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.CIRCLE;
    if (!this.appearance) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const interiorColor = getRgbColor(dict.getArray("IC"), null);
      const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
      const fillAlpha = fillColor ? strokeAlpha : null;
      if (this.borderStyle.width === 0 && !fillColor) {
        return;
      }
      const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));
      this._setDefaultAppearance({
        xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          const x0 = points[0].x + this.borderStyle.width / 2;
          const y0 = points[0].y - this.borderStyle.width / 2;
          const x1 = points[3].x - this.borderStyle.width / 2;
          const y1 = points[3].y + this.borderStyle.width / 2;
          const xMid = x0 + (x1 - x0) / 2;
          const yMid = y0 + (y1 - y0) / 2;
          const xOffset = (x1 - x0) / 2 * controlPointsDistance;
          const yOffset = (y1 - y0) / 2 * controlPointsDistance;
          buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, "h");
          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
}
class PolylineAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.POLYLINE;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.vertices = [];
    if (!(this instanceof PolygonAnnotation)) {
      this.setLineEndings(dict.getArray("LE"));
      this.data.lineEndings = this.lineEndings;
    }
    const rawVertices = dict.getArray("Vertices");
    if (!Array.isArray(rawVertices)) {
      return;
    }
    for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
      this.data.vertices.push({
        x: rawVertices[i],
        y: rawVertices[i + 1]
      });
    }
    if (!this.appearance) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * borderWidth;
      const bbox = [Infinity, Infinity, -Infinity, -Infinity];
      for (const vertex of this.data.vertices) {
        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
      }
      if (!_util.Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref,
        extra: `${borderWidth} w`,
        strokeColor,
        strokeAlpha,
        pointsCallback: (buffer, points) => {
          const vertices = this.data.vertices;
          for (let i = 0, ii = vertices.length; i < ii; i++) {
            buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`);
          }
          buffer.push("S");
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
}
class PolygonAnnotation extends PolylineAnnotation {
  constructor(params) {
    super(params);
    this.data.annotationType = _util.AnnotationType.POLYGON;
  }
}
class CaretAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    this.data.annotationType = _util.AnnotationType.CARET;
  }
}
class InkAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    this.data.hasOwnCanvas = this.data.noRotate;
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.INK;
    this.data.inkLists = [];
    const rawInkLists = dict.getArray("InkList");
    if (!Array.isArray(rawInkLists)) {
      return;
    }
    for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
      this.data.inkLists.push([]);
      for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
        this.data.inkLists[i].push({
          x: xref.fetchIfRef(rawInkLists[i][j]),
          y: xref.fetchIfRef(rawInkLists[i][j + 1])
        });
      }
    }
    if (!this.appearance) {
      const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
      const strokeAlpha = dict.get("CA");
      const borderWidth = this.borderStyle.width || 1,
        borderAdjust = 2 * borderWidth;
      const bbox = [Infinity, Infinity, -Infinity, -Infinity];
      for (const inkLists of this.data.inkLists) {
        for (const vertex of inkLists) {
          bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
          bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
          bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
          bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
        }
      }
      if (!_util.Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref,
        extra: `${borderWidth} w`,
        strokeColor,
        strokeAlpha,
        pointsCallback: (buffer, points) => {
          for (const inkList of this.data.inkLists) {
            for (let i = 0, ii = inkList.length; i < ii; i++) {
              buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
            }
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
  static createNewDict(annotation, xref, {
    apRef,
    ap
  }) {
    const {
      color,
      opacity,
      paths,
      rect,
      rotation,
      thickness
    } = annotation;
    const ink = new _primitives.Dict(xref);
    ink.set("Type", _primitives.Name.get("Annot"));
    ink.set("Subtype", _primitives.Name.get("Ink"));
    ink.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
    ink.set("Rect", rect);
    ink.set("InkList", paths.map(p => p.points));
    ink.set("F", 4);
    ink.set("Rotate", rotation);
    const bs = new _primitives.Dict(xref);
    ink.set("BS", bs);
    bs.set("W", thickness);
    ink.set("C", Array.from(color, c => c / 255));
    ink.set("CA", opacity);
    const n = new _primitives.Dict(xref);
    ink.set("AP", n);
    if (apRef) {
      n.set("N", apRef);
    } else {
      n.set("N", ap);
    }
    return ink;
  }
  static async createNewAppearanceStream(annotation, xref, params) {
    const {
      color,
      rect,
      paths,
      thickness,
      opacity
    } = annotation;
    const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(color, false)}`];
    if (opacity !== 1) {
      appearanceBuffer.push("/R0 gs");
    }
    const buffer = [];
    for (const {
      bezier
    } of paths) {
      buffer.length = 0;
      buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`);
      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
        const curve = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(" ");
        buffer.push(`${curve} c`);
      }
      buffer.push("S");
      appearanceBuffer.push(buffer.join("\n"));
    }
    const appearance = appearanceBuffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", rect);
    appearanceStreamDict.set("Length", appearance.length);
    if (opacity !== 1) {
      const resources = new _primitives.Dict(xref);
      const extGState = new _primitives.Dict(xref);
      const r0 = new _primitives.Dict(xref);
      r0.set("CA", opacity);
      r0.set("Type", _primitives.Name.get("ExtGState"));
      extGState.set("R0", r0);
      resources.set("ExtGState", extGState);
      appearanceStreamDict.set("Resources", resources);
    }
    const ap = new _stream.StringStream(appearance);
    ap.dict = appearanceStreamDict;
    return ap;
  }
}
class HighlightAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.HIGHLIGHT;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    if (quadPoints) {
      const resources = this.appearance?.dict.get("Resources");
      if (!this.appearance || !resources?.has("ExtGState")) {
        if (this.appearance) {
          (0, _util.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
        }
        const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
        const fillAlpha = dict.get("CA");
        this._setDefaultAppearance({
          xref,
          fillColor,
          blendMode: "Multiply",
          fillAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, "f");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.popupRef = null;
    }
  }
}
class UnderlineAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.UNDERLINE;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        this._setDefaultAppearance({
          xref,
          extra: "[] 0 d 0.571 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[2].x} ${points[2].y + 1.3} m`, `${points[3].x} ${points[3].y + 1.3} l`, "S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.popupRef = null;
    }
  }
}
class SquigglyAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.SQUIGGLY;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        this._setDefaultAppearance({
          xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            const dy = (points[0].y - points[2].y) / 6;
            let shift = dy;
            let x = points[2].x;
            const y = points[2].y;
            const xEnd = points[3].x;
            buffer.push(`${x} ${y + shift} m`);
            do {
              x += 2;
              shift = shift === 0 ? dy : 0;
              buffer.push(`${x} ${y + shift} l`);
            } while (x < xEnd);
            buffer.push("S");
            return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
          }
        });
      }
    } else {
      this.data.popupRef = null;
    }
  }
}
class StrikeOutAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    this.data.annotationType = _util.AnnotationType.STRIKEOUT;
    const quadPoints = this.data.quadPoints = getQuadPoints(dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
        const strokeAlpha = dict.get("CA");
        this._setDefaultAppearance({
          xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${(points[0].x + points[2].x) / 2} ` + `${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ` + `${(points[1].y + points[3].y) / 2} l`, "S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.popupRef = null;
    }
  }
}
class StampAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    this.data.annotationType = _util.AnnotationType.STAMP;
    this.data.hasOwnCanvas = this.data.noRotate;
  }
  static async createImage(bitmap, xref) {
    const {
      width,
      height
    } = bitmap;
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d", {
      alpha: true
    });
    ctx.drawImage(bitmap, 0, 0);
    const data = ctx.getImageData(0, 0, width, height).data;
    const buf32 = new Uint32Array(data.buffer);
    const hasAlpha = buf32.some(_util.FeatureTest.isLittleEndian ? x => x >>> 24 !== 0xff : x => (x & 0xff) !== 0xff);
    if (hasAlpha) {
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, width, height);
      ctx.drawImage(bitmap, 0, 0);
    }
    const jpegBufferPromise = canvas.convertToBlob({
      type: "image/jpeg",
      quality: 1
    }).then(blob => {
      return blob.arrayBuffer();
    });
    const xobjectName = _primitives.Name.get("XObject");
    const imageName = _primitives.Name.get("Image");
    const image = new _primitives.Dict(xref);
    image.set("Type", xobjectName);
    image.set("Subtype", imageName);
    image.set("BitsPerComponent", 8);
    image.set("ColorSpace", _primitives.Name.get("DeviceRGB"));
    image.set("Filter", _primitives.Name.get("DCTDecode"));
    image.set("BBox", [0, 0, width, height]);
    image.set("Width", width);
    image.set("Height", height);
    let smaskStream = null;
    if (hasAlpha) {
      const alphaBuffer = new Uint8Array(buf32.length);
      if (_util.FeatureTest.isLittleEndian) {
        for (let i = 0, ii = buf32.length; i < ii; i++) {
          alphaBuffer[i] = buf32[i] >>> 24;
        }
      } else {
        for (let i = 0, ii = buf32.length; i < ii; i++) {
          alphaBuffer[i] = buf32[i] & 0xff;
        }
      }
      const smask = new _primitives.Dict(xref);
      smask.set("Type", xobjectName);
      smask.set("Subtype", imageName);
      smask.set("BitsPerComponent", 8);
      smask.set("ColorSpace", _primitives.Name.get("DeviceGray"));
      smask.set("Width", width);
      smask.set("Height", height);
      smaskStream = new _stream.Stream(alphaBuffer, 0, 0, smask);
    }
    const imageStream = new _stream.Stream(await jpegBufferPromise, 0, 0, image);
    return {
      imageStream,
      smaskStream,
      width,
      height
    };
  }
  static createNewDict(annotation, xref, {
    apRef,
    ap
  }) {
    const {
      rect,
      rotation,
      user
    } = annotation;
    const stamp = new _primitives.Dict(xref);
    stamp.set("Type", _primitives.Name.get("Annot"));
    stamp.set("Subtype", _primitives.Name.get("Stamp"));
    stamp.set("CreationDate", `D:${(0, _util.getModificationDate)()}`);
    stamp.set("Rect", rect);
    stamp.set("F", 4);
    stamp.set("Border", [0, 0, 0]);
    stamp.set("Rotate", rotation);
    if (user) {
      stamp.set("T", (0, _core_utils.isAscii)(user) ? user : (0, _core_utils.stringToUTF16String)(user, true));
    }
    if (apRef || ap) {
      const n = new _primitives.Dict(xref);
      stamp.set("AP", n);
      if (apRef) {
        n.set("N", apRef);
      } else {
        n.set("N", ap);
      }
    }
    return stamp;
  }
  static async createNewAppearanceStream(annotation, xref, params) {
    const {
      rotation
    } = annotation;
    const {
      imageRef,
      width,
      height
    } = params.image;
    const resources = new _primitives.Dict(xref);
    const xobject = new _primitives.Dict(xref);
    resources.set("XObject", xobject);
    xobject.set("Im0", imageRef);
    const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("FormType", 1);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", [0, 0, width, height]);
    appearanceStreamDict.set("Resources", resources);
    if (rotation) {
      const matrix = (0, _core_utils.getRotationMatrix)(rotation, width, height);
      appearanceStreamDict.set("Matrix", matrix);
    }
    const ap = new _stream.StringStream(appearance);
    ap.dict = appearanceStreamDict;
    return ap;
  }
}
class FileAttachmentAnnotation extends MarkupAnnotation {
  constructor(params) {
    super(params);
    const {
      dict,
      xref
    } = params;
    const file = new _file_spec.FileSpec(dict.get("FS"), xref);
    this.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.file = file.serializable;
    const name = dict.get("Name");
    this.data.name = name instanceof _primitives.Name ? (0, _util.stringToPDFString)(name.name) : "PushPin";
    const fillAlpha = dict.get("ca");
    this.data.fillAlpha = typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1 ? fillAlpha : null;
  }
}

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FakeUnicodeFont = void 0;
exports.createDefaultAppearance = createDefaultAppearance;
exports.getPdfColor = getPdfColor;
exports.parseAppearanceStream = parseAppearanceStream;
exports.parseDefaultAppearance = parseDefaultAppearance;
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _colorspace = __w_pdfjs_require__(12);
var _evaluator = __w_pdfjs_require__(13);
var _image_utils = __w_pdfjs_require__(59);
var _function = __w_pdfjs_require__(57);
var _stream = __w_pdfjs_require__(8);
class DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor {
  constructor(str) {
    super(new _stream.StringStream(str));
  }
  parse() {
    const operation = {
      fn: 0,
      args: []
    };
    const result = {
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3)
    };
    try {
      while (true) {
        operation.args.length = 0;
        if (!this.read(operation)) {
          break;
        }
        if (this.savedStatesDepth !== 0) {
          continue;
        }
        const {
          fn,
          args
        } = operation;
        switch (fn | 0) {
          case _util.OPS.setFont:
            const [fontName, fontSize] = args;
            if (fontName instanceof _primitives.Name) {
              result.fontName = fontName.name;
            }
            if (typeof fontSize === "number" && fontSize > 0) {
              result.fontSize = fontSize;
            }
            break;
          case _util.OPS.setFillRGBColor:
            _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.setFillGray:
            _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.setFillCMYKColor:
            _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
            break;
        }
      }
    } catch (reason) {
      (0, _util.warn)(`parseDefaultAppearance - ignoring errors: "${reason}".`);
    }
    return result;
  }
}
function parseDefaultAppearance(str) {
  return new DefaultAppearanceEvaluator(str).parse();
}
class AppearanceStreamEvaluator extends _evaluator.EvaluatorPreprocessor {
  constructor(stream, evaluatorOptions, xref) {
    super(stream);
    this.stream = stream;
    this.evaluatorOptions = evaluatorOptions;
    this.xref = xref;
    this.resources = stream.dict?.get("Resources");
  }
  parse() {
    const operation = {
      fn: 0,
      args: []
    };
    let result = {
      scaleFactor: 1,
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3),
      fillColorSpace: _colorspace.ColorSpace.singletons.gray
    };
    let breakLoop = false;
    const stack = [];
    try {
      while (true) {
        operation.args.length = 0;
        if (breakLoop || !this.read(operation)) {
          break;
        }
        const {
          fn,
          args
        } = operation;
        switch (fn | 0) {
          case _util.OPS.save:
            stack.push({
              scaleFactor: result.scaleFactor,
              fontSize: result.fontSize,
              fontName: result.fontName,
              fontColor: result.fontColor.slice(),
              fillColorSpace: result.fillColorSpace
            });
            break;
          case _util.OPS.restore:
            result = stack.pop() || result;
            break;
          case _util.OPS.setTextMatrix:
            result.scaleFactor *= Math.hypot(args[0], args[1]);
            break;
          case _util.OPS.setFont:
            const [fontName, fontSize] = args;
            if (fontName instanceof _primitives.Name) {
              result.fontName = fontName.name;
            }
            if (typeof fontSize === "number" && fontSize > 0) {
              result.fontSize = fontSize * result.scaleFactor;
            }
            break;
          case _util.OPS.setFillColorSpace:
            result.fillColorSpace = _colorspace.ColorSpace.parse({
              cs: args[0],
              xref: this.xref,
              resources: this.resources,
              pdfFunctionFactory: this._pdfFunctionFactory,
              localColorSpaceCache: this._localColorSpaceCache
            });
            break;
          case _util.OPS.setFillColor:
            const cs = result.fillColorSpace;
            cs.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.setFillRGBColor:
            _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.setFillGray:
            _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.setFillCMYKColor:
            _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case _util.OPS.showText:
          case _util.OPS.showSpacedText:
          case _util.OPS.nextLineShowText:
          case _util.OPS.nextLineSetSpacingShowText:
            breakLoop = true;
            break;
        }
      }
    } catch (reason) {
      (0, _util.warn)(`parseAppearanceStream - ignoring errors: "${reason}".`);
    }
    this.stream.reset();
    delete result.scaleFactor;
    delete result.fillColorSpace;
    return result;
  }
  get _localColorSpaceCache() {
    return (0, _util.shadow)(this, "_localColorSpaceCache", new _image_utils.LocalColorSpaceCache());
  }
  get _pdfFunctionFactory() {
    const pdfFunctionFactory = new _function.PDFFunctionFactory({
      xref: this.xref,
      isEvalSupported: this.evaluatorOptions.isEvalSupported
    });
    return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }
}
function parseAppearanceStream(stream, evaluatorOptions, xref) {
  return new AppearanceStreamEvaluator(stream, evaluatorOptions, xref).parse();
}
function getPdfColor(color, isFill) {
  if (color[0] === color[1] && color[1] === color[2]) {
    const gray = color[0] / 255;
    return `${(0, _core_utils.numberToString)(gray)} ${isFill ? "g" : "G"}`;
  }
  return Array.from(color, c => (0, _core_utils.numberToString)(c / 255)).join(" ") + ` ${isFill ? "rg" : "RG"}`;
}
function createDefaultAppearance({
  fontSize,
  fontName,
  fontColor
}) {
  return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`;
}
class FakeUnicodeFont {
  constructor(xref, fontFamily) {
    this.xref = xref;
    this.widths = null;
    this.firstChar = Infinity;
    this.lastChar = -Infinity;
    this.fontFamily = fontFamily;
    const canvas = new OffscreenCanvas(1, 1);
    this.ctxMeasure = canvas.getContext("2d");
    if (!FakeUnicodeFont._fontNameId) {
      FakeUnicodeFont._fontNameId = 1;
    }
    this.fontName = _primitives.Name.get(`InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`);
  }
  get toUnicodeRef() {
    if (!FakeUnicodeFont._toUnicodeRef) {
      const toUnicode = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe)
/Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
1 beginbfrange
<0000> <FFFF> <0000>
endbfrange
endcmap CMapName currentdict /CMap defineresource pop end end`;
      const toUnicodeStream = FakeUnicodeFont.toUnicodeStream = new _stream.StringStream(toUnicode);
      const toUnicodeDict = new _primitives.Dict(this.xref);
      toUnicodeStream.dict = toUnicodeDict;
      toUnicodeDict.set("Length", toUnicode.length);
      FakeUnicodeFont._toUnicodeRef = this.xref.getNewPersistentRef(toUnicodeStream);
    }
    return FakeUnicodeFont._toUnicodeRef;
  }
  get fontDescriptorRef() {
    if (!FakeUnicodeFont._fontDescriptorRef) {
      const fontDescriptor = new _primitives.Dict(this.xref);
      fontDescriptor.set("Type", _primitives.Name.get("FontDescriptor"));
      fontDescriptor.set("FontName", this.fontName);
      fontDescriptor.set("FontFamily", "MyriadPro Regular");
      fontDescriptor.set("FontBBox", [0, 0, 0, 0]);
      fontDescriptor.set("FontStretch", _primitives.Name.get("Normal"));
      fontDescriptor.set("FontWeight", 400);
      fontDescriptor.set("ItalicAngle", 0);
      FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(fontDescriptor);
    }
    return FakeUnicodeFont._fontDescriptorRef;
  }
  get descendantFontRef() {
    const descendantFont = new _primitives.Dict(this.xref);
    descendantFont.set("BaseFont", this.fontName);
    descendantFont.set("Type", _primitives.Name.get("Font"));
    descendantFont.set("Subtype", _primitives.Name.get("CIDFontType0"));
    descendantFont.set("CIDToGIDMap", _primitives.Name.get("Identity"));
    descendantFont.set("FirstChar", this.firstChar);
    descendantFont.set("LastChar", this.lastChar);
    descendantFont.set("FontDescriptor", this.fontDescriptorRef);
    descendantFont.set("DW", 1000);
    const widths = [];
    const chars = [...this.widths.entries()].sort();
    let currentChar = null;
    let currentWidths = null;
    for (const [char, width] of chars) {
      if (!currentChar) {
        currentChar = char;
        currentWidths = [width];
        continue;
      }
      if (char === currentChar + currentWidths.length) {
        currentWidths.push(width);
      } else {
        widths.push(currentChar, currentWidths);
        currentChar = char;
        currentWidths = [width];
      }
    }
    if (currentChar) {
      widths.push(currentChar, currentWidths);
    }
    descendantFont.set("W", widths);
    const cidSystemInfo = new _primitives.Dict(this.xref);
    cidSystemInfo.set("Ordering", "Identity");
    cidSystemInfo.set("Registry", "Adobe");
    cidSystemInfo.set("Supplement", 0);
    descendantFont.set("CIDSystemInfo", cidSystemInfo);
    return this.xref.getNewPersistentRef(descendantFont);
  }
  get baseFontRef() {
    const baseFont = new _primitives.Dict(this.xref);
    baseFont.set("BaseFont", this.fontName);
    baseFont.set("Type", _primitives.Name.get("Font"));
    baseFont.set("Subtype", _primitives.Name.get("Type0"));
    baseFont.set("Encoding", _primitives.Name.get("Identity-H"));
    baseFont.set("DescendantFonts", [this.descendantFontRef]);
    baseFont.set("ToUnicode", this.toUnicodeRef);
    return this.xref.getNewPersistentRef(baseFont);
  }
  get resources() {
    const resources = new _primitives.Dict(this.xref);
    const font = new _primitives.Dict(this.xref);
    font.set(this.fontName.name, this.baseFontRef);
    resources.set("Font", font);
    return resources;
  }
  _createContext() {
    this.widths = new Map();
    this.ctxMeasure.font = `1000px ${this.fontFamily}`;
    return this.ctxMeasure;
  }
  createFontResources(text) {
    const ctx = this._createContext();
    for (const line of text.split(/\r\n?|\n/)) {
      for (const char of line.split("")) {
        const code = char.charCodeAt(0);
        if (this.widths.has(code)) {
          continue;
        }
        const metrics = ctx.measureText(char);
        const width = Math.ceil(metrics.width);
        this.widths.set(code, width);
        this.firstChar = Math.min(code, this.firstChar);
        this.lastChar = Math.max(code, this.lastChar);
      }
    }
    return this.resources;
  }
  createAppearance(text, rect, rotation, fontSize, bgColor, strokeAlpha) {
    const ctx = this._createContext();
    const lines = [];
    let maxWidth = -Infinity;
    for (const line of text.split(/\r\n?|\n/)) {
      lines.push(line);
      const lineWidth = ctx.measureText(line).width;
      maxWidth = Math.max(maxWidth, lineWidth);
      for (const char of line.split("")) {
        const code = char.charCodeAt(0);
        let width = this.widths.get(code);
        if (width === undefined) {
          const metrics = ctx.measureText(char);
          width = Math.ceil(metrics.width);
          this.widths.set(code, width);
          this.firstChar = Math.min(code, this.firstChar);
          this.lastChar = Math.max(code, this.lastChar);
        }
      }
    }
    maxWidth *= fontSize / 1000;
    const [x1, y1, x2, y2] = rect;
    let w = x2 - x1;
    let h = y2 - y1;
    if (rotation % 180 !== 0) {
      [w, h] = [h, w];
    }
    let hscale = 1;
    if (maxWidth > w) {
      hscale = w / maxWidth;
    }
    let vscale = 1;
    const lineHeight = _util.LINE_FACTOR * fontSize;
    const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize;
    const maxHeight = lineHeight * lines.length;
    if (maxHeight > h) {
      vscale = h / maxHeight;
    }
    const fscale = Math.min(hscale, vscale);
    const newFontSize = fontSize * fscale;
    const buffer = ["q", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${getPdfColor(bgColor, true)}`, `/${this.fontName.name} ${(0, _core_utils.numberToString)(newFontSize)} Tf`];
    const {
      resources
    } = this;
    strokeAlpha = typeof strokeAlpha === "number" && strokeAlpha >= 0 && strokeAlpha <= 1 ? strokeAlpha : 1;
    if (strokeAlpha !== 1) {
      buffer.push("/R0 gs");
      const extGState = new _primitives.Dict(this.xref);
      const r0 = new _primitives.Dict(this.xref);
      r0.set("ca", strokeAlpha);
      r0.set("CA", strokeAlpha);
      r0.set("Type", _primitives.Name.get("ExtGState"));
      extGState.set("R0", r0);
      resources.set("ExtGState", extGState);
    }
    const vShift = (0, _core_utils.numberToString)(lineHeight);
    for (const line of lines) {
      buffer.push(`0 -${vShift} Td <${(0, _core_utils.stringToUTF16HexString)(line)}> Tj`);
    }
    buffer.push("ET", "Q");
    const appearance = buffer.join("\n");
    const appearanceStreamDict = new _primitives.Dict(this.xref);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceStreamDict.set("Type", _primitives.Name.get("XObject"));
    appearanceStreamDict.set("BBox", [0, 0, w, h]);
    appearanceStreamDict.set("Length", appearance.length);
    appearanceStreamDict.set("Resources", resources);
    if (rotation) {
      const matrix = (0, _core_utils.getRotationMatrix)(rotation, w, h);
      appearanceStreamDict.set("Matrix", matrix);
    }
    const ap = new _stream.StringStream(appearance);
    ap.dict = appearanceStreamDict;
    return ap;
  }
}
exports.FakeUnicodeFont = FakeUnicodeFont;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorSpace = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _core_utils = __w_pdfjs_require__(3);
function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
  const COMPONENTS = 3;
  alpha01 = alpha01 !== 1 ? 0 : alpha01;
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let newIndex = 0,
    oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1 * COMPONENTS;
  for (let i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
  }
  for (let i = 0; i < h2; i++) {
    const py = Math.floor(i * yRatio) * w1Scanline;
    for (let j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      newIndex += alpha01;
    }
  }
}
class ColorSpace {
  constructor(name, numComps) {
    if (this.constructor === ColorSpace) {
      (0, _util.unreachable)("Cannot initialize ColorSpace.");
    }
    this.name = name;
    this.numComps = numComps;
  }
  getRgb(src, srcOffset) {
    const rgb = new Uint8ClampedArray(3);
    this.getRgbItem(src, srcOffset, rgb, 0);
    return rgb;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(inputLength, alpha01) {
    (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(bits) {
    return false;
  }
  isDefaultDecode(decodeMap, bpc) {
    return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
  }
  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
    const count = originalWidth * originalHeight;
    let rgbBuf = null;
    const numComponentColors = 1 << bpc;
    const needsResizing = originalHeight !== height || originalWidth !== width;
    if (this.isPassthrough(bpc)) {
      rgbBuf = comps;
    } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
      for (let i = 0; i < numComponentColors; i++) {
        allColors[i] = i;
      }
      const colorMap = new Uint8ClampedArray(numComponentColors * 3);
      this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
      if (!needsResizing) {
        let destPos = 0;
        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          dest[destPos++] = colorMap[key];
          dest[destPos++] = colorMap[key + 1];
          dest[destPos++] = colorMap[key + 2];
          destPos += alpha01;
        }
      } else {
        rgbBuf = new Uint8Array(count * 3);
        let rgbPos = 0;
        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          rgbBuf[rgbPos++] = colorMap[key];
          rgbBuf[rgbPos++] = colorMap[key + 1];
          rgbBuf[rgbPos++] = colorMap[key + 2];
        }
      }
    } else if (!needsResizing) {
      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
    } else {
      rgbBuf = new Uint8ClampedArray(count * 3);
      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
    }
    if (rgbBuf) {
      if (needsResizing) {
        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
      } else {
        let destPos = 0,
          rgbPos = 0;
        for (let i = 0, ii = width * actualHeight; i < ii; i++) {
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          destPos += alpha01;
        }
      }
    }
  }
  get usesZeroToOneRange() {
    return (0, _util.shadow)(this, "usesZeroToOneRange", true);
  }
  static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    }
    if (!parsedColorSpace) {
      throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    }
    let csName, csRef;
    if (cacheKey instanceof _primitives.Ref) {
      csRef = cacheKey;
      cacheKey = xref.fetch(cacheKey);
    }
    if (cacheKey instanceof _primitives.Name) {
      csName = cacheKey.name;
    }
    if (csName || csRef) {
      localColorSpaceCache.set(csName, csRef, parsedColorSpace);
    }
  }
  static getCached(cacheKey, xref, localColorSpaceCache) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    }
    if (cacheKey instanceof _primitives.Ref) {
      const localColorSpace = localColorSpaceCache.getByRef(cacheKey);
      if (localColorSpace) {
        return localColorSpace;
      }
      try {
        cacheKey = xref.fetch(cacheKey);
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }
      }
    }
    if (cacheKey instanceof _primitives.Name) {
      const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);
      if (localColorSpace) {
        return localColorSpace;
      }
    }
    return null;
  }
  static async parseAsync({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    return parsedColorSpace;
  }
  static parse({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);
    if (cachedColorSpace) {
      return cachedColorSpace;
    }
    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    return parsedColorSpace;
  }
  static _parse(cs, xref, resources = null, pdfFunctionFactory) {
    cs = xref.fetchIfRef(cs);
    if (cs instanceof _primitives.Name) {
      switch (cs.name) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "Pattern":
          return new PatternCS(null);
        default:
          if (resources instanceof _primitives.Dict) {
            const colorSpaces = resources.get("ColorSpace");
            if (colorSpaces instanceof _primitives.Dict) {
              const resourcesCS = colorSpaces.get(cs.name);
              if (resourcesCS) {
                if (resourcesCS instanceof _primitives.Name) {
                  return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                }
                cs = resourcesCS;
                break;
              }
            }
          }
          throw new _util.FormatError(`Unrecognized ColorSpace: ${cs.name}`);
      }
    }
    if (Array.isArray(cs)) {
      const mode = xref.fetchIfRef(cs[0]).name;
      let params, numComps, baseCS, whitePoint, blackPoint, gamma;
      switch (mode) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "CalGray":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.get("Gamma");
          return new CalGrayCS(whitePoint, blackPoint, gamma);
        case "CalRGB":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.getArray("Gamma");
          const matrix = params.getArray("Matrix");
          return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
        case "ICCBased":
          const stream = xref.fetchIfRef(cs[1]);
          const dict = stream.dict;
          numComps = dict.get("N");
          const alt = dict.get("Alternate");
          if (alt) {
            const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);
            if (altCS.numComps === numComps) {
              return altCS;
            }
            (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (numComps === 1) {
            return this.singletons.gray;
          } else if (numComps === 3) {
            return this.singletons.rgb;
          } else if (numComps === 4) {
            return this.singletons.cmyk;
          }
          break;
        case "Pattern":
          baseCS = cs[1] || null;
          if (baseCS) {
            baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
          }
          return new PatternCS(baseCS);
        case "I":
        case "Indexed":
          baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
          const hiVal = xref.fetchIfRef(cs[2]) + 1;
          const lookup = xref.fetchIfRef(cs[3]);
          return new IndexedCS(baseCS, hiVal, lookup);
        case "Separation":
        case "DeviceN":
          const name = xref.fetchIfRef(cs[1]);
          numComps = Array.isArray(name) ? name.length : 1;
          baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
          const tintFn = pdfFunctionFactory.create(cs[3]);
          return new AlternateCS(numComps, baseCS, tintFn);
        case "Lab":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          const range = params.getArray("Range");
          return new LabCS(whitePoint, blackPoint, range);
        default:
          throw new _util.FormatError(`Unimplemented ColorSpace object: ${mode}`);
      }
    }
    throw new _util.FormatError(`Unrecognized ColorSpace object: ${cs}`);
  }
  static isDefaultDecode(decode, numComps) {
    if (!Array.isArray(decode)) {
      return true;
    }
    if (numComps * 2 !== decode.length) {
      (0, _util.warn)("The decode map is not the correct length");
      return true;
    }
    for (let i = 0, ii = decode.length; i < ii; i += 2) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }
    return true;
  }
  static get singletons() {
    return (0, _util.shadow)(this, "singletons", {
      get gray() {
        return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
      },
      get rgb() {
        return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
      },
      get cmyk() {
        return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
      }
    });
  }
}
exports.ColorSpace = ColorSpace;
class AlternateCS extends ColorSpace {
  constructor(numComps, base, tintFn) {
    super("Alternate", numComps);
    this.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const tmpBuf = this.tmpBuf;
    this.tintFn(src, srcOffset, tmpBuf, 0);
    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const tintFn = this.tintFn;
    const base = this.base;
    const scale = 1 / ((1 << bits) - 1);
    const baseNumComps = base.numComps;
    const usesZeroToOneRange = base.usesZeroToOneRange;
    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
    let pos = isPassthrough ? destOffset : 0;
    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
    const numComps = this.numComps;
    const scaled = new Float32Array(numComps);
    const tinted = new Float32Array(baseNumComps);
    let i, j;
    for (i = 0; i < count; i++) {
      for (j = 0; j < numComps; j++) {
        scaled[j] = src[srcOffset++] * scale;
      }
      tintFn(scaled, 0, tinted, 0);
      if (usesZeroToOneRange) {
        for (j = 0; j < baseNumComps; j++) {
          baseBuf[pos++] = tinted[j] * 255;
        }
      } else {
        base.getRgbItem(tinted, 0, baseBuf, pos);
        pos += baseNumComps;
      }
    }
    if (!isPassthrough) {
      base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
    }
  }
  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
  }
}
class PatternCS extends ColorSpace {
  constructor(baseCS) {
    super("Pattern", null);
    this.base = baseCS;
  }
  isDefaultDecode(decodeMap, bpc) {
    (0, _util.unreachable)("Should not call PatternCS.isDefaultDecode");
  }
}
class IndexedCS extends ColorSpace {
  constructor(base, highVal, lookup) {
    super("Indexed", 1);
    this.base = base;
    this.highVal = highVal;
    const length = base.numComps * highVal;
    this.lookup = new Uint8Array(length);
    if (lookup instanceof _base_stream.BaseStream) {
      const bytes = lookup.getBytes(length);
      this.lookup.set(bytes);
    } else if (typeof lookup === "string") {
      for (let i = 0; i < length; ++i) {
        this.lookup[i] = lookup.charCodeAt(i) & 0xff;
      }
    } else {
      throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);
    }
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const numComps = this.base.numComps;
    const start = src[srcOffset] * numComps;
    this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const base = this.base;
    const numComps = base.numComps;
    const outputDelta = base.getOutputLength(numComps, alpha01);
    const lookup = this.lookup;
    for (let i = 0; i < count; ++i) {
      const lookupPos = src[srcOffset++] * numComps;
      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
      destOffset += outputDelta;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
  }
  isDefaultDecode(decodeMap, bpc) {
    if (!Array.isArray(decodeMap)) {
      return true;
    }
    if (decodeMap.length !== 2) {
      (0, _util.warn)("Decode map length is not correct");
      return true;
    }
    if (!Number.isInteger(bpc) || bpc < 1) {
      (0, _util.warn)("Bits per component is not correct");
      return true;
    }
    return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
  }
}
class DeviceGrayCS extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    const c = src[srcOffset] * 255;
    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset,
      q = destOffset;
    for (let i = 0; i < count; ++i) {
      const c = scale * src[j++];
      dest[q++] = c;
      dest[q++] = c;
      dest[q++] = c;
      q += alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01);
  }
}
class DeviceRgbCS extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    dest[destOffset] = src[srcOffset] * 255;
    dest[destOffset + 1] = src[srcOffset + 1] * 255;
    dest[destOffset + 2] = src[srcOffset + 2] * 255;
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (bits === 8 && alpha01 === 0) {
      dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
      return;
    }
    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset,
      q = destOffset;
    for (let i = 0; i < count; ++i) {
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      q += alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01) / 3 | 0;
  }
  isPassthrough(bits) {
    return bits === 8;
  }
}
class DeviceCmykCS extends ColorSpace {
  constructor() {
    super("DeviceCMYK", 4);
  }
  #toRgb(src, srcOffset, srcScale, dest, destOffset) {
    const c = src[srcOffset] * srcScale;
    const m = src[srcOffset + 1] * srcScale;
    const y = src[srcOffset + 2] * srcScale;
    const k = src[srcOffset + 3] * srcScale;
    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    this.#toRgb(src, srcOffset, 1, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const scale = 1 / ((1 << bits) - 1);
    for (let i = 0; i < count; i++) {
      this.#toRgb(src, srcOffset, scale, dest, destOffset);
      srcOffset += 4;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength / 4 * (3 + alpha01) | 0;
  }
}
class CalGrayCS extends ColorSpace {
  constructor(whitePoint, blackPoint, gamma) {
    super("CalGray", 1);
    if (!whitePoint) {
      throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
    }
    [this.XW, this.YW, this.ZW] = whitePoint;
    [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];
    this.G = gamma || 1;
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      (0, _util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
      (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ` + `ZB: ${this.ZB}, only default values are supported.`);
    }
    if (this.G < 1) {
      (0, _util.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
      this.G = 1;
    }
  }
  #toRgb(src, srcOffset, dest, destOffset, scale) {
    const A = src[srcOffset] * scale;
    const AG = A ** this.G;
    const L = this.YW * AG;
    const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    this.#toRgb(src, srcOffset, dest, destOffset, 1);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const scale = 1 / ((1 << bits) - 1);
    for (let i = 0; i < count; ++i) {
      this.#toRgb(src, srcOffset, dest, destOffset, scale);
      srcOffset += 1;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01);
  }
}
class CalRGBCS extends ColorSpace {
  static #BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  static #BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  static #SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  static #FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  static #tempNormalizeMatrix = new Float32Array(3);
  static #tempConvertMatrix1 = new Float32Array(3);
  static #tempConvertMatrix2 = new Float32Array(3);
  static #DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8.0;
  constructor(whitePoint, blackPoint, gamma, matrix) {
    super("CalRGB", 3);
    if (!whitePoint) {
      throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
    }
    const [XW, YW, ZW] = this.whitePoint = whitePoint;
    const [XB, YB, ZB] = this.blackPoint = blackPoint || new Float32Array(3);
    [this.GR, this.GG, this.GB] = gamma || new Float32Array([1, 1, 1]);
    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (XW < 0 || ZW < 0 || YW !== 1) {
      throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    }
    if (XB < 0 || YB < 0 || ZB < 0) {
      (0, _util.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], ` + "falling back to default.");
      this.blackPoint = new Float32Array(3);
    }
    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
      (0, _util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ` + `${this.name}, falling back to default.`);
      this.GR = this.GG = this.GB = 1;
    }
  }
  #matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }
  #toFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }
  #toD65(sourceWhitePoint, LMS, result) {
    const D65X = 0.95047;
    const D65Y = 1;
    const D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }
  #sRGBTransferFunction(color) {
    if (color <= 0.0031308) {
      return this.#adjustToRange(0, 1, 12.92 * color);
    }
    if (color >= 0.99554525) {
      return 1;
    }
    return this.#adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
  }
  #adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }
  #decodeL(L) {
    if (L < 0) {
      return -this.#decodeL(-L);
    }
    if (L > 8.0) {
      return ((L + 16) / 116) ** 3;
    }
    return L * CalRGBCS.#DECODE_L_CONSTANT;
  }
  #compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }
    const zeroDecodeL = this.#decodeL(0);
    const X_DST = zeroDecodeL;
    const X_SRC = this.#decodeL(sourceBlackPoint[0]);
    const Y_DST = zeroDecodeL;
    const Y_SRC = this.#decodeL(sourceBlackPoint[1]);
    const Z_DST = zeroDecodeL;
    const Z_SRC = this.#decodeL(sourceBlackPoint[2]);
    const X_Scale = (1 - X_DST) / (1 - X_SRC);
    const X_Offset = 1 - X_Scale;
    const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    const Y_Offset = 1 - Y_Scale;
    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    const Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }
  #normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }
    const LMS = result;
    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_Flat = CalRGBCS.#tempNormalizeMatrix;
    this.#toFlat(sourceWhitePoint, LMS, LMS_Flat);
    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }
  #normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    const LMS = result;
    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_D65 = CalRGBCS.#tempNormalizeMatrix;
    this.#toD65(sourceWhitePoint, LMS, LMS_D65);
    this.#matrixProduct(CalRGBCS.#BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }
  #toRgb(src, srcOffset, dest, destOffset, scale) {
    const A = this.#adjustToRange(0, 1, src[srcOffset] * scale);
    const B = this.#adjustToRange(0, 1, src[srcOffset + 1] * scale);
    const C = this.#adjustToRange(0, 1, src[srcOffset + 2] * scale);
    const AGR = A === 1 ? 1 : A ** this.GR;
    const BGG = B === 1 ? 1 : B ** this.GG;
    const CGB = C === 1 ? 1 : C ** this.GB;
    const X = this.MXA * AGR + this.MXB * BGG + this.MXC * CGB;
    const Y = this.MYA * AGR + this.MYB * BGG + this.MYC * CGB;
    const Z = this.MZA * AGR + this.MZB * BGG + this.MZC * CGB;
    const XYZ = CalRGBCS.#tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    const XYZ_Flat = CalRGBCS.#tempConvertMatrix2;
    this.#normalizeWhitePointToFlat(this.whitePoint, XYZ, XYZ_Flat);
    const XYZ_Black = CalRGBCS.#tempConvertMatrix1;
    this.#compensateBlackPoint(this.blackPoint, XYZ_Flat, XYZ_Black);
    const XYZ_D65 = CalRGBCS.#tempConvertMatrix2;
    this.#normalizeWhitePointToD65(CalRGBCS.#FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    const SRGB = CalRGBCS.#tempConvertMatrix1;
    this.#matrixProduct(CalRGBCS.#SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    dest[destOffset] = this.#sRGBTransferFunction(SRGB[0]) * 255;
    dest[destOffset + 1] = this.#sRGBTransferFunction(SRGB[1]) * 255;
    dest[destOffset + 2] = this.#sRGBTransferFunction(SRGB[2]) * 255;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    this.#toRgb(src, srcOffset, dest, destOffset, 1);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const scale = 1 / ((1 << bits) - 1);
    for (let i = 0; i < count; ++i) {
      this.#toRgb(src, srcOffset, dest, destOffset, scale);
      srcOffset += 3;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01) / 3 | 0;
  }
}
class LabCS extends ColorSpace {
  constructor(whitePoint, blackPoint, range) {
    super("Lab", 3);
    if (!whitePoint) {
      throw new _util.FormatError("WhitePoint missing - required for color space Lab");
    }
    [this.XW, this.YW, this.ZW] = whitePoint;
    [this.amin, this.amax, this.bmin, this.bmax] = range || [-100, 100, -100, 100];
    [this.XB, this.YB, this.ZB] = blackPoint || [0, 0, 0];
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      (0, _util.info)("Invalid BlackPoint, falling back to default");
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.amin > this.amax || this.bmin > this.bmax) {
      (0, _util.info)("Invalid Range, falling back to defaults");
      this.amin = -100;
      this.amax = 100;
      this.bmin = -100;
      this.bmax = 100;
    }
  }
  #fn_g(x) {
    return x >= 6 / 29 ? x ** 3 : 108 / 841 * (x - 4 / 29);
  }
  #decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }
  #toRgb(src, srcOffset, maxVal, dest, destOffset) {
    let Ls = src[srcOffset];
    let as = src[srcOffset + 1];
    let bs = src[srcOffset + 2];
    if (maxVal !== false) {
      Ls = this.#decode(Ls, maxVal, 0, 100);
      as = this.#decode(as, maxVal, this.amin, this.amax);
      bs = this.#decode(bs, maxVal, this.bmin, this.bmax);
    }
    if (as > this.amax) {
      as = this.amax;
    } else if (as < this.amin) {
      as = this.amin;
    }
    if (bs > this.bmax) {
      bs = this.bmax;
    } else if (bs < this.bmin) {
      bs = this.bmin;
    }
    const M = (Ls + 16) / 116;
    const L = M + as / 500;
    const N = M - bs / 200;
    const X = this.XW * this.#fn_g(L);
    const Y = this.YW * this.#fn_g(M);
    const Z = this.ZW * this.#fn_g(N);
    let r, g, b;
    if (this.ZW < 1) {
      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
      b = X * 0.072 + Y * -0.229 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.204 + Z * 1.057;
    }
    dest[destOffset] = Math.sqrt(r) * 255;
    dest[destOffset + 1] = Math.sqrt(g) * 255;
    dest[destOffset + 2] = Math.sqrt(b) * 255;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    this.#toRgb(src, srcOffset, false, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const maxVal = (1 << bits) - 1;
    for (let i = 0; i < count; i++) {
      this.#toRgb(src, srcOffset, maxVal, dest, destOffset);
      srcOffset += 3;
      destOffset += 3 + alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01) / 3 | 0;
  }
  isDefaultDecode(decodeMap, bpc) {
    return true;
  }
  get usesZeroToOneRange() {
    return (0, _util.shadow)(this, "usesZeroToOneRange", false);
  }
}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PartialEvaluator = exports.EvaluatorPreprocessor = void 0;
var _util = __w_pdfjs_require__(2);
var _cmap = __w_pdfjs_require__(14);
var _primitives = __w_pdfjs_require__(4);
var _fonts = __w_pdfjs_require__(34);
var _encodings = __w_pdfjs_require__(37);
var _standard_fonts = __w_pdfjs_require__(41);
var _pattern = __w_pdfjs_require__(50);
var _xfa_fonts = __w_pdfjs_require__(51);
var _to_unicode_map = __w_pdfjs_require__(42);
var _function = __w_pdfjs_require__(57);
var _parser = __w_pdfjs_require__(16);
var _image_utils = __w_pdfjs_require__(59);
var _stream = __w_pdfjs_require__(8);
var _base_stream = __w_pdfjs_require__(5);
var _bidi = __w_pdfjs_require__(60);
var _colorspace = __w_pdfjs_require__(12);
var _decode_stream = __w_pdfjs_require__(18);
var _fonts_utils = __w_pdfjs_require__(38);
var _font_substitutions = __w_pdfjs_require__(61);
var _glyphlist = __w_pdfjs_require__(39);
var _metrics = __w_pdfjs_require__(45);
var _unicode = __w_pdfjs_require__(40);
var _image_resizer = __w_pdfjs_require__(62);
var _murmurhash = __w_pdfjs_require__(63);
var _operator_list = __w_pdfjs_require__(64);
var _image = __w_pdfjs_require__(65);
const DefaultPartialEvaluatorOptions = Object.freeze({
  maxImageSize: -1,
  disableFontFace: false,
  ignoreErrors: false,
  isEvalSupported: true,
  isOffscreenCanvasSupported: false,
  canvasMaxAreaInBytes: -1,
  fontExtraProperties: false,
  useSystemFonts: true,
  cMapUrl: null,
  standardFontDataUrl: null
});
const PatternType = {
  TILING: 1,
  SHADING: 2
};
const TEXT_CHUNK_BATCH_SIZE = 10;
const deferred = Promise.resolve();
function normalizeBlendMode(value, parsingArray = false) {
  if (Array.isArray(value)) {
    for (const val of value) {
      const maybeBM = normalizeBlendMode(val, true);
      if (maybeBM) {
        return maybeBM;
      }
    }
    (0, _util.warn)(`Unsupported blend mode Array: ${value}`);
    return "source-over";
  }
  if (!(value instanceof _primitives.Name)) {
    if (parsingArray) {
      return null;
    }
    return "source-over";
  }
  switch (value.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  if (parsingArray) {
    return null;
  }
  (0, _util.warn)(`Unsupported blend mode: ${value.name}`);
  return "source-over";
}
function incrementCachedImageMaskCount(data) {
  if (data.fn === _util.OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
    data.args[0].count++;
  }
}
class TimeSlotManager {
  static TIME_SLOT_DURATION_MS = 20;
  static CHECK_TIME_EVERY = 100;
  constructor() {
    this.reset();
  }
  check() {
    if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
      return false;
    }
    this.checked = 0;
    return this.endTime <= Date.now();
  }
  reset() {
    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
    this.checked = 0;
  }
}
class PartialEvaluator {
  constructor({
    xref,
    handler,
    pageIndex,
    idFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    systemFontCache,
    options = null
  }) {
    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.systemFontCache = systemFontCache;
    this.options = options || DefaultPartialEvaluatorOptions;
    this.parsingType3Font = false;
    this._regionalImageCache = new _image_utils.RegionalImageCache();
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
    _image_resizer.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
  }
  get _pdfFunctionFactory() {
    const pdfFunctionFactory = new _function.PDFFunctionFactory({
      xref: this.xref,
      isEvalSupported: this.options.isEvalSupported
    });
    return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }
  clone(newOptions = null) {
    const newEvaluator = Object.create(this);
    newEvaluator.options = Object.assign(Object.create(null), this.options, newOptions);
    return newEvaluator;
  }
  hasBlendModes(resources, nonBlendModesSet) {
    if (!(resources instanceof _primitives.Dict)) {
      return false;
    }
    if (resources.objId && nonBlendModesSet.has(resources.objId)) {
      return false;
    }
    const processed = new _primitives.RefSet(nonBlendModesSet);
    if (resources.objId) {
      processed.put(resources.objId);
    }
    const nodes = [resources],
      xref = this.xref;
    while (nodes.length) {
      const node = nodes.shift();
      const graphicStates = node.get("ExtGState");
      if (graphicStates instanceof _primitives.Dict) {
        for (let graphicState of graphicStates.getRawValues()) {
          if (graphicState instanceof _primitives.Ref) {
            if (processed.has(graphicState)) {
              continue;
            }
            try {
              graphicState = xref.fetch(graphicState);
            } catch (ex) {
              processed.put(graphicState);
              (0, _util.info)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
              continue;
            }
          }
          if (!(graphicState instanceof _primitives.Dict)) {
            continue;
          }
          if (graphicState.objId) {
            processed.put(graphicState.objId);
          }
          const bm = graphicState.get("BM");
          if (bm instanceof _primitives.Name) {
            if (bm.name !== "Normal") {
              return true;
            }
            continue;
          }
          if (bm !== undefined && Array.isArray(bm)) {
            for (const element of bm) {
              if (element instanceof _primitives.Name && element.name !== "Normal") {
                return true;
              }
            }
          }
        }
      }
      const xObjects = node.get("XObject");
      if (!(xObjects instanceof _primitives.Dict)) {
        continue;
      }
      for (let xObject of xObjects.getRawValues()) {
        if (xObject instanceof _primitives.Ref) {
          if (processed.has(xObject)) {
            continue;
          }
          try {
            xObject = xref.fetch(xObject);
          } catch (ex) {
            processed.put(xObject);
            (0, _util.info)(`hasBlendModes - ignoring XObject: "${ex}".`);
            continue;
          }
        }
        if (!(xObject instanceof _base_stream.BaseStream)) {
          continue;
        }
        if (xObject.dict.objId) {
          processed.put(xObject.dict.objId);
        }
        const xResources = xObject.dict.get("Resources");
        if (!(xResources instanceof _primitives.Dict)) {
          continue;
        }
        if (xResources.objId && processed.has(xResources.objId)) {
          continue;
        }
        nodes.push(xResources);
        if (xResources.objId) {
          processed.put(xResources.objId);
        }
      }
    }
    for (const ref of processed) {
      nonBlendModesSet.put(ref);
    }
    return false;
  }
  async fetchBuiltInCMap(name) {
    const cachedData = this.builtInCMapCache.get(name);
    if (cachedData) {
      return cachedData;
    }
    let data;
    if (this.options.cMapUrl !== null) {
      const url = `${this.options.cMapUrl}${name}.bcmap`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`);
      }
      data = {
        cMapData: new Uint8Array(await response.arrayBuffer()),
        compressionType: _util.CMapCompressionType.BINARY
      };
    } else {
      data = await this.handler.sendWithPromise("FetchBuiltInCMap", {
        name
      });
    }
    if (data.compressionType !== _util.CMapCompressionType.NONE) {
      this.builtInCMapCache.set(name, data);
    }
    return data;
  }
  async fetchStandardFontData(name) {
    const cachedData = this.standardFontDataCache.get(name);
    if (cachedData) {
      return new _stream.Stream(cachedData);
    }
    if (this.options.useSystemFonts && name !== "Symbol" && name !== "ZapfDingbats") {
      return null;
    }
    const standardFontNameToFileName = (0, _standard_fonts.getFontNameToFileMap)(),
      filename = standardFontNameToFileName[name];
    let data;
    if (this.options.standardFontDataUrl !== null) {
      const url = `${this.options.standardFontDataUrl}${filename}`;
      const response = await fetch(url);
      if (!response.ok) {
        (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`);
      } else {
        data = await response.arrayBuffer();
      }
    } else {
      try {
        data = await this.handler.sendWithPromise("FetchStandardFontData", {
          filename
        });
      } catch (e) {
        (0, _util.warn)(`fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`);
      }
    }
    if (!data) {
      return null;
    }
    this.standardFontDataCache.set(name, data);
    return new _stream.Stream(data);
  }
  async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
    const dict = xobj.dict;
    const matrix = dict.getArray("Matrix");
    let bbox = dict.getArray("BBox");
    bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
    let optionalContent, groupOptions;
    if (dict.has("OC")) {
      optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
    }
    if (optionalContent !== undefined) {
      operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    const group = dict.get("Group");
    if (group) {
      groupOptions = {
        matrix,
        bbox,
        smask,
        isolated: false,
        knockout: false
      };
      const groupSubtype = group.get("S");
      let colorSpace = null;
      if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
        groupOptions.isolated = group.get("I") || false;
        groupOptions.knockout = group.get("K") || false;
        if (group.has("CS")) {
          const cs = group.getRaw("CS");
          const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);
          if (cachedColorSpace) {
            colorSpace = cachedColorSpace;
          } else {
            colorSpace = await this.parseColorSpace({
              cs,
              resources,
              localColorSpaceCache
            });
          }
        }
      }
      if (smask?.backdrop) {
        colorSpace ||= _colorspace.ColorSpace.singletons.rgb;
        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
      }
      operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
    }
    const args = group ? [matrix, null] : [matrix, bbox];
    operatorList.addOp(_util.OPS.paintFormXObjectBegin, args);
    return this.getOperatorList({
      stream: xobj,
      task,
      resources: dict.get("Resources") || resources,
      operatorList,
      initialState
    }).then(function () {
      operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
      if (group) {
        operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
      }
      if (optionalContent !== undefined) {
        operatorList.addOp(_util.OPS.endMarkedContent, []);
      }
    });
  }
  _sendImgData(objId, imgData, cacheGlobally = false) {
    const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
    if (this.parsingType3Font || cacheGlobally) {
      return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
    }
    return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
  }
  async buildPaintImageXObject({
    resources,
    image,
    isInline = false,
    operatorList,
    cacheKey,
    localImageCache,
    localColorSpaceCache
  }) {
    const dict = image.dict;
    const imageRef = dict.objId;
    const w = dict.get("W", "Width");
    const h = dict.get("H", "Height");
    if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
      (0, _util.warn)("Image dimensions are missing, or not numbers.");
      return;
    }
    const maxImageSize = this.options.maxImageSize;
    if (maxImageSize !== -1 && w * h > maxImageSize) {
      const msg = "Image exceeded maximum allowed size and was removed.";
      if (this.options.ignoreErrors) {
        (0, _util.warn)(msg);
        return;
      }
      throw new Error(msg);
    }
    let optionalContent;
    if (dict.has("OC")) {
      optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
    }
    const imageMask = dict.get("IM", "ImageMask") || false;
    let imgData, args;
    if (imageMask) {
      const interpolate = dict.get("I", "Interpolate");
      const bitStrideLength = w + 7 >> 3;
      const imgArray = image.getBytes(bitStrideLength * h);
      const decode = dict.getArray("D", "Decode");
      if (this.parsingType3Font) {
        imgData = _image.PDFImage.createRawMask({
          imgArray,
          width: w,
          height: h,
          imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
          inverseDecode: decode?.[0] > 0,
          interpolate
        });
        imgData.cached = !!cacheKey;
        args = [imgData];
        operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
        if (cacheKey) {
          const cacheData = {
            fn: _util.OPS.paintImageMaskXObject,
            args,
            optionalContent
          };
          localImageCache.set(cacheKey, imageRef, cacheData);
          if (imageRef) {
            this._regionalImageCache.set(null, imageRef, cacheData);
          }
        }
        return;
      }
      imgData = await _image.PDFImage.createMask({
        imgArray,
        width: w,
        height: h,
        imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
        inverseDecode: decode?.[0] > 0,
        interpolate,
        isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
      });
      if (imgData.isSingleOpaquePixel) {
        operatorList.addImageOps(_util.OPS.paintSolidColorImageMask, [], optionalContent);
        if (cacheKey) {
          const cacheData = {
            fn: _util.OPS.paintSolidColorImageMask,
            args: [],
            optionalContent
          };
          localImageCache.set(cacheKey, imageRef, cacheData);
          if (imageRef) {
            this._regionalImageCache.set(null, imageRef, cacheData);
          }
        }
        return;
      }
      const objId = `mask_${this.idFactory.createObjId()}`;
      operatorList.addDependency(objId);
      this._sendImgData(objId, imgData);
      args = [{
        data: objId,
        width: imgData.width,
        height: imgData.height,
        interpolate: imgData.interpolate,
        count: 1
      }];
      operatorList.addImageOps(_util.OPS.paintImageMaskXObject, args, optionalContent);
      if (cacheKey) {
        const cacheData = {
          fn: _util.OPS.paintImageMaskXObject,
          args,
          optionalContent
        };
        localImageCache.set(cacheKey, imageRef, cacheData);
        if (imageRef) {
          this._regionalImageCache.set(null, imageRef, cacheData);
        }
      }
      return;
    }
    const SMALL_IMAGE_DIMENSIONS = 200;
    if (isInline && !dict.has("SMask") && !dict.has("Mask") && w + h < SMALL_IMAGE_DIMENSIONS) {
      const imageObj = new _image.PDFImage({
        xref: this.xref,
        res: resources,
        image,
        isInline,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache
      });
      imgData = await imageObj.createImageData(true, false);
      operatorList.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
      operatorList.addImageOps(_util.OPS.paintInlineImageXObject, [imgData], optionalContent);
      return;
    }
    let objId = `img_${this.idFactory.createObjId()}`,
      cacheGlobally = false;
    if (this.parsingType3Font) {
      objId = `${this.idFactory.getDocId()}_type3_${objId}`;
    } else if (imageRef) {
      cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);
      if (cacheGlobally) {
        objId = `${this.idFactory.getDocId()}_${objId}`;
      }
    }
    operatorList.addDependency(objId);
    args = [objId, w, h];
    _image.PDFImage.buildImage({
      xref: this.xref,
      res: resources,
      image,
      isInline,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).then(async imageObj => {
      imgData = await imageObj.createImageData(false, this.options.isOffscreenCanvasSupported);
      if (cacheKey && imageRef && cacheGlobally) {
        const length = imgData.bitmap ? imgData.width * imgData.height * 4 : imgData.data.length;
        this.globalImageCache.addByteSize(imageRef, length);
      }
      return this._sendImgData(objId, imgData, cacheGlobally);
    }).catch(reason => {
      (0, _util.warn)(`Unable to decode image "${objId}": "${reason}".`);
      return this._sendImgData(objId, null, cacheGlobally);
    });
    operatorList.addImageOps(_util.OPS.paintImageXObject, args, optionalContent);
    if (cacheKey) {
      const cacheData = {
        fn: _util.OPS.paintImageXObject,
        args,
        optionalContent
      };
      localImageCache.set(cacheKey, imageRef, cacheData);
      if (imageRef) {
        this._regionalImageCache.set(null, imageRef, cacheData);
        if (cacheGlobally) {
          (0, _util.assert)(!isInline, "Cannot cache an inline image globally.");
          this.globalImageCache.setData(imageRef, {
            objId,
            fn: _util.OPS.paintImageXObject,
            args,
            optionalContent,
            byteSize: 0
          });
        }
      }
    }
  }
  handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
    const smaskContent = smask.get("G");
    const smaskOptions = {
      subtype: smask.get("S").name,
      backdrop: smask.get("BC")
    };
    const transferObj = smask.get("TR");
    if ((0, _function.isPDFFunction)(transferObj)) {
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256);
      const tmp = new Float32Array(1);
      for (let i = 0; i < 256; i++) {
        tmp[0] = i / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[i] = tmp[0] * 255 | 0;
      }
      smaskOptions.transferMap = transferMap;
    }
    return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
  }
  handleTransferFunction(tr) {
    let transferArray;
    if (Array.isArray(tr)) {
      transferArray = tr;
    } else if ((0, _function.isPDFFunction)(tr)) {
      transferArray = [tr];
    } else {
      return null;
    }
    const transferMaps = [];
    let numFns = 0,
      numEffectfulFns = 0;
    for (const entry of transferArray) {
      const transferObj = this.xref.fetchIfRef(entry);
      numFns++;
      if ((0, _primitives.isName)(transferObj, "Identity")) {
        transferMaps.push(null);
        continue;
      } else if (!(0, _function.isPDFFunction)(transferObj)) {
        return null;
      }
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256),
        tmp = new Float32Array(1);
      for (let j = 0; j < 256; j++) {
        tmp[0] = j / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[j] = tmp[0] * 255 | 0;
      }
      transferMaps.push(transferMap);
      numEffectfulFns++;
    }
    if (!(numFns === 1 || numFns === 4)) {
      return null;
    }
    if (numEffectfulFns === 0) {
      return null;
    }
    return transferMaps;
  }
  handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, localTilingPatternCache) {
    const tilingOpList = new _operator_list.OperatorList();
    const patternResources = _primitives.Dict.merge({
      xref: this.xref,
      dictArray: [patternDict.get("Resources"), resources]
    });
    return this.getOperatorList({
      stream: pattern,
      task,
      resources: patternResources,
      operatorList: tilingOpList
    }).then(function () {
      const operatorListIR = tilingOpList.getIR();
      const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
      operatorList.addDependencies(tilingOpList.dependencies);
      operatorList.addOp(fn, tilingPatternIR);
      if (patternDict.objId) {
        localTilingPatternCache.set(null, patternDict.objId, {
          operatorListIR,
          dict: patternDict
        });
      }
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        (0, _util.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
        return;
      }
      throw reason;
    });
  }
  handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) {
    const fontName = fontArgs?.[0] instanceof _primitives.Name ? fontArgs[0].name : null;
    return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then(translated => {
      if (!translated.font.isType3Font) {
        return translated;
      }
      return translated.loadType3Data(this, resources, task).then(function () {
        operatorList.addDependencies(translated.type3Dependencies);
        return translated;
      }).catch(reason => {
        return new TranslatedFont({
          loadedName: "g_font_error",
          font: new _fonts.ErrorFont(`Type3 font load error: ${reason}`),
          dict: translated.font,
          evaluatorOptions: this.options
        });
      });
    }).then(translated => {
      state.font = translated.font;
      translated.send(this.handler);
      return translated.loadedName;
    });
  }
  handleText(chars, state) {
    const font = state.font;
    const glyphs = font.charsToGlyphs(chars);
    if (font.data) {
      const isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
      if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
        PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);
      }
    }
    return glyphs;
  }
  ensureStateFont(state) {
    if (state.font) {
      return;
    }
    const reason = new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");
    if (this.options.ignoreErrors) {
      (0, _util.warn)(`ensureStateFont: "${reason}".`);
      return;
    }
    throw reason;
  }
  async setGState({
    resources,
    gState,
    operatorList,
    cacheKey,
    task,
    stateManager,
    localGStateCache,
    localColorSpaceCache
  }) {
    const gStateRef = gState.objId;
    let isSimpleGState = true;
    const gStateObj = [];
    let promise = Promise.resolve();
    for (const key of gState.getKeys()) {
      const value = gState.get(key);
      switch (key) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          gStateObj.push([key, value]);
          break;
        case "Font":
          isSimpleGState = false;
          promise = promise.then(() => {
            return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {
              operatorList.addDependency(loadedName);
              gStateObj.push([key, [loadedName, value[1]]]);
            });
          });
          break;
        case "BM":
          gStateObj.push([key, normalizeBlendMode(value)]);
          break;
        case "SMask":
          if ((0, _primitives.isName)(value, "None")) {
            gStateObj.push([key, false]);
            break;
          }
          if (value instanceof _primitives.Dict) {
            isSimpleGState = false;
            promise = promise.then(() => {
              return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
            });
            gStateObj.push([key, true]);
          } else {
            (0, _util.warn)("Unsupported SMask type");
          }
          break;
        case "TR":
          const transferMaps = this.handleTransferFunction(value);
          gStateObj.push([key, transferMaps]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          (0, _util.info)("graphic state operator " + key);
          break;
        default:
          (0, _util.info)("Unknown graphic state operator " + key);
          break;
      }
    }
    return promise.then(function () {
      if (gStateObj.length > 0) {
        operatorList.addOp(_util.OPS.setGState, [gStateObj]);
      }
      if (isSimpleGState) {
        localGStateCache.set(cacheKey, gStateRef, gStateObj);
      }
    });
  }
  loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) {
    const errorFont = async () => {
      return new TranslatedFont({
        loadedName: "g_font_error",
        font: new _fonts.ErrorFont(`Font "${fontName}" is not available.`),
        dict: font,
        evaluatorOptions: this.options
      });
    };
    let fontRef;
    if (font) {
      if (font instanceof _primitives.Ref) {
        fontRef = font;
      }
    } else {
      const fontRes = resources.get("Font");
      if (fontRes) {
        fontRef = fontRes.getRaw(fontName);
      }
    }
    if (fontRef) {
      if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
        return errorFont();
      }
      if (this.fontCache.has(fontRef)) {
        return this.fontCache.get(fontRef);
      }
      font = this.xref.fetchIfRef(fontRef);
    }
    if (!(font instanceof _primitives.Dict)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font) {
        (0, _util.warn)(`Font "${fontName}" is not available.`);
        return errorFont();
      }
      (0, _util.warn)(`Font "${fontName}" is not available -- attempting to fallback to a default font.`);
      font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
    }
    if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
      return this.fontCache.get(font.cacheKey);
    }
    const fontCapability = new _util.PromiseCapability();
    let preEvaluatedFont;
    try {
      preEvaluatedFont = this.preEvaluateFont(font);
      preEvaluatedFont.cssFontInfo = cssFontInfo;
    } catch (reason) {
      (0, _util.warn)(`loadFont - preEvaluateFont failed: "${reason}".`);
      return errorFont();
    }
    const {
      descriptor,
      hash
    } = preEvaluatedFont;
    const fontRefIsRef = fontRef instanceof _primitives.Ref;
    let fontID;
    if (hash && descriptor instanceof _primitives.Dict) {
      const fontAliases = descriptor.fontAliases ||= Object.create(null);
      if (fontAliases[hash]) {
        const aliasFontRef = fontAliases[hash].aliasRef;
        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
          this.fontCache.putAlias(fontRef, aliasFontRef);
          return this.fontCache.get(fontRef);
        }
      } else {
        fontAliases[hash] = {
          fontID: this.idFactory.createFontId()
        };
      }
      if (fontRefIsRef) {
        fontAliases[hash].aliasRef = fontRef;
      }
      fontID = fontAliases[hash].fontID;
    } else {
      fontID = this.idFactory.createFontId();
    }
    (0, _util.assert)(fontID?.startsWith("f"), 'The "fontID" must be (correctly) defined.');
    if (fontRefIsRef) {
      this.fontCache.put(fontRef, fontCapability.promise);
    } else {
      font.cacheKey = `cacheKey_${fontID}`;
      this.fontCache.put(font.cacheKey, fontCapability.promise);
    }
    font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
    this.translateFont(preEvaluatedFont).then(translatedFont => {
      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: translatedFont,
        dict: font,
        evaluatorOptions: this.options
      }));
    }).catch(reason => {
      (0, _util.warn)(`loadFont - translateFont failed: "${reason}".`);
      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason),
        dict: font,
        evaluatorOptions: this.options
      }));
    });
    return fontCapability.promise;
  }
  buildPath(operatorList, fn, args, parsingText = false) {
    const lastIndex = operatorList.length - 1;
    if (!args) {
      args = [];
    }
    if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
      if (parsingText) {
        (0, _util.warn)(`Encountered path operator "${fn}" inside of a text object.`);
        operatorList.addOp(_util.OPS.save, null);
      }
      let minMax;
      switch (fn) {
        case _util.OPS.rectangle:
          const x = args[0] + args[2];
          const y = args[1] + args[3];
          minMax = [Math.min(args[0], x), Math.max(args[0], x), Math.min(args[1], y), Math.max(args[1], y)];
          break;
        case _util.OPS.moveTo:
        case _util.OPS.lineTo:
          minMax = [args[0], args[0], args[1], args[1]];
          break;
        default:
          minMax = [Infinity, -Infinity, Infinity, -Infinity];
          break;
      }
      operatorList.addOp(_util.OPS.constructPath, [[fn], args, minMax]);
      if (parsingText) {
        operatorList.addOp(_util.OPS.restore, null);
      }
    } else {
      const opArgs = operatorList.argsArray[lastIndex];
      opArgs[0].push(fn);
      opArgs[1].push(...args);
      const minMax = opArgs[2];
      switch (fn) {
        case _util.OPS.rectangle:
          const x = args[0] + args[2];
          const y = args[1] + args[3];
          minMax[0] = Math.min(minMax[0], args[0], x);
          minMax[1] = Math.max(minMax[1], args[0], x);
          minMax[2] = Math.min(minMax[2], args[1], y);
          minMax[3] = Math.max(minMax[3], args[1], y);
          break;
        case _util.OPS.moveTo:
        case _util.OPS.lineTo:
          minMax[0] = Math.min(minMax[0], args[0]);
          minMax[1] = Math.max(minMax[1], args[0]);
          minMax[2] = Math.min(minMax[2], args[1]);
          minMax[3] = Math.max(minMax[3], args[1]);
          break;
      }
    }
  }
  parseColorSpace({
    cs,
    resources,
    localColorSpaceCache
  }) {
    return _colorspace.ColorSpace.parseAsync({
      cs,
      xref: this.xref,
      resources,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return null;
      }
      if (this.options.ignoreErrors) {
        (0, _util.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
        return null;
      }
      throw reason;
    });
  }
  parseShading({
    shading,
    resources,
    localColorSpaceCache,
    localShadingPatternCache
  }) {
    let id = localShadingPatternCache.get(shading);
    if (!id) {
      var shadingFill = _pattern.Pattern.parseShading(shading, this.xref, resources, this._pdfFunctionFactory, localColorSpaceCache);
      const patternIR = shadingFill.getIR();
      id = `pattern_${this.idFactory.createObjId()}`;
      if (this.parsingType3Font) {
        id = `${this.idFactory.getDocId()}_type3_${id}`;
      }
      localShadingPatternCache.set(shading, id);
      if (this.parsingType3Font) {
        this.handler.send("commonobj", [id, "Pattern", patternIR]);
      } else {
        this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
      }
    }
    return id;
  }
  handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {
    const patternName = args.pop();
    if (patternName instanceof _primitives.Name) {
      const rawPattern = patterns.getRaw(patternName.name);
      const localTilingPattern = rawPattern instanceof _primitives.Ref && localTilingPatternCache.getByRef(rawPattern);
      if (localTilingPattern) {
        try {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
          operatorList.addOp(fn, tilingPatternIR);
          return undefined;
        } catch {}
      }
      const pattern = this.xref.fetchIfRef(rawPattern);
      if (pattern) {
        const dict = pattern instanceof _base_stream.BaseStream ? pattern.dict : pattern;
        const typeNum = dict.get("PatternType");
        if (typeNum === PatternType.TILING) {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, localTilingPatternCache);
        } else if (typeNum === PatternType.SHADING) {
          const shading = dict.get("Shading");
          const matrix = dict.getArray("Matrix");
          const objId = this.parseShading({
            shading,
            resources,
            localColorSpaceCache,
            localShadingPatternCache
          });
          operatorList.addOp(fn, ["Shading", objId, matrix]);
          return undefined;
        }
        throw new _util.FormatError(`Unknown PatternType: ${typeNum}`);
      }
    }
    throw new _util.FormatError(`Unknown PatternName: ${patternName}`);
  }
  _parseVisibilityExpression(array, nestingCounter, currentResult) {
    const MAX_NESTING = 10;
    if (++nestingCounter > MAX_NESTING) {
      (0, _util.warn)("Visibility expression is too deeply nested");
      return;
    }
    const length = array.length;
    const operator = this.xref.fetchIfRef(array[0]);
    if (length < 2 || !(operator instanceof _primitives.Name)) {
      (0, _util.warn)("Invalid visibility expression");
      return;
    }
    switch (operator.name) {
      case "And":
      case "Or":
      case "Not":
        currentResult.push(operator.name);
        break;
      default:
        (0, _util.warn)(`Invalid operator ${operator.name} in visibility expression`);
        return;
    }
    for (let i = 1; i < length; i++) {
      const raw = array[i];
      const object = this.xref.fetchIfRef(raw);
      if (Array.isArray(object)) {
        const nestedResult = [];
        currentResult.push(nestedResult);
        this._parseVisibilityExpression(object, nestingCounter, nestedResult);
      } else if (raw instanceof _primitives.Ref) {
        currentResult.push(raw.toString());
      }
    }
  }
  async parseMarkedContentProps(contentProperties, resources) {
    let optionalContent;
    if (contentProperties instanceof _primitives.Name) {
      const properties = resources.get("Properties");
      optionalContent = properties.get(contentProperties.name);
    } else if (contentProperties instanceof _primitives.Dict) {
      optionalContent = contentProperties;
    } else {
      throw new _util.FormatError("Optional content properties malformed.");
    }
    const optionalContentType = optionalContent.get("Type")?.name;
    if (optionalContentType === "OCG") {
      return {
        type: optionalContentType,
        id: optionalContent.objId
      };
    } else if (optionalContentType === "OCMD") {
      const expression = optionalContent.get("VE");
      if (Array.isArray(expression)) {
        const result = [];
        this._parseVisibilityExpression(expression, 0, result);
        if (result.length > 0) {
          return {
            type: "OCMD",
            expression: result
          };
        }
      }
      const optionalContentGroups = optionalContent.get("OCGs");
      if (Array.isArray(optionalContentGroups) || optionalContentGroups instanceof _primitives.Dict) {
        const groupIds = [];
        if (Array.isArray(optionalContentGroups)) {
          for (const ocg of optionalContentGroups) {
            groupIds.push(ocg.toString());
          }
        } else {
          groupIds.push(optionalContentGroups.objId);
        }
        return {
          type: optionalContentType,
          ids: groupIds,
          policy: optionalContent.get("P") instanceof _primitives.Name ? optionalContent.get("P").name : null,
          expression: null
        };
      } else if (optionalContentGroups instanceof _primitives.Ref) {
        return {
          type: optionalContentType,
          id: optionalContentGroups.toString()
        };
      }
    }
    return null;
  }
  getOperatorList({
    stream,
    task,
    resources,
    operatorList,
    initialState = null,
    fallbackFontDict = null
  }) {
    resources ||= _primitives.Dict.empty;
    initialState ||= new EvalState();
    if (!operatorList) {
      throw new Error('getOperatorList: missing "operatorList" parameter');
    }
    const self = this;
    const xref = this.xref;
    let parsingText = false;
    const localImageCache = new _image_utils.LocalImageCache();
    const localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
    const localGStateCache = new _image_utils.LocalGStateCache();
    const localTilingPatternCache = new _image_utils.LocalTilingPatternCache();
    const localShadingPatternCache = new Map();
    const xobjs = resources.get("XObject") || _primitives.Dict.empty;
    const patterns = resources.get("Pattern") || _primitives.Dict.empty;
    const stateManager = new StateManager(initialState);
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    const timeSlotManager = new TimeSlotManager();
    function closePendingRestoreOPS(argument) {
      for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
        operatorList.addOp(_util.OPS.restore, []);
      }
    }
    return new Promise(function promiseBody(resolve, reject) {
      const next = function (promise) {
        Promise.all([promise, operatorList.ready]).then(function () {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop, i, ii, cs, name, isValidName;
      while (!(stop = timeSlotManager.check())) {
        operation.args = null;
        if (!preprocessor.read(operation)) {
          break;
        }
        let args = operation.args;
        let fn = operation.fn;
        switch (fn | 0) {
          case _util.OPS.paintXObject:
            isValidName = args[0] instanceof _primitives.Name;
            name = args[0].name;
            if (isValidName) {
              const localImage = localImageCache.getByName(name);
              if (localImage) {
                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                incrementCachedImageMaskCount(localImage);
                args = null;
                continue;
              }
            }
            next(new Promise(function (resolveXObject, rejectXObject) {
              if (!isValidName) {
                throw new _util.FormatError("XObject must be referred to by name.");
              }
              let xobj = xobjs.getRaw(name);
              if (xobj instanceof _primitives.Ref) {
                const localImage = localImageCache.getByRef(xobj) || self._regionalImageCache.getByRef(xobj);
                if (localImage) {
                  operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                  incrementCachedImageMaskCount(localImage);
                  resolveXObject();
                  return;
                }
                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);
                if (globalImage) {
                  operatorList.addDependency(globalImage.objId);
                  operatorList.addImageOps(globalImage.fn, globalImage.args, globalImage.optionalContent);
                  resolveXObject();
                  return;
                }
                xobj = xref.fetch(xobj);
              }
              if (!(xobj instanceof _base_stream.BaseStream)) {
                throw new _util.FormatError("XObject should be a stream");
              }
              const type = xobj.dict.get("Subtype");
              if (!(type instanceof _primitives.Name)) {
                throw new _util.FormatError("XObject should have a Name subtype");
              }
              if (type.name === "Form") {
                stateManager.save();
                self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function () {
                  stateManager.restore();
                  resolveXObject();
                }, rejectXObject);
                return;
              } else if (type.name === "Image") {
                self.buildPaintImageXObject({
                  resources,
                  image: xobj,
                  operatorList,
                  cacheKey: name,
                  localImageCache,
                  localColorSpaceCache
                }).then(resolveXObject, rejectXObject);
                return;
              } else if (type.name === "PS") {
                (0, _util.info)("Ignored XObject subtype PS");
              } else {
                throw new _util.FormatError(`Unhandled XObject subtype ${type.name}`);
              }
              resolveXObject();
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }
              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case _util.OPS.setFont:
            var fontSize = args[1];
            next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function (loadedName) {
              operatorList.addDependency(loadedName);
              operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
            }));
            return;
          case _util.OPS.beginText:
            parsingText = true;
            break;
          case _util.OPS.endText:
            parsingText = false;
            break;
          case _util.OPS.endInlineImage:
            var cacheKey = args[0].cacheKey;
            if (cacheKey) {
              const localImage = localImageCache.getByName(cacheKey);
              if (localImage) {
                operatorList.addImageOps(localImage.fn, localImage.args, localImage.optionalContent);
                incrementCachedImageMaskCount(localImage);
                args = null;
                continue;
              }
            }
            next(self.buildPaintImageXObject({
              resources,
              image: args[0],
              isInline: true,
              operatorList,
              cacheKey,
              localImageCache,
              localColorSpaceCache
            }));
            return;
          case _util.OPS.showText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            args[0] = self.handleText(args[0], stateManager.state);
            break;
          case _util.OPS.showSpacedText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            var combinedGlyphs = [];
            var state = stateManager.state;
            for (const arrItem of args[0]) {
              if (typeof arrItem === "string") {
                combinedGlyphs.push(...self.handleText(arrItem, state));
              } else if (typeof arrItem === "number") {
                combinedGlyphs.push(arrItem);
              }
            }
            args[0] = combinedGlyphs;
            fn = _util.OPS.showText;
            break;
          case _util.OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            operatorList.addOp(_util.OPS.nextLine);
            args[0] = self.handleText(args[0], stateManager.state);
            fn = _util.OPS.showText;
            break;
          case _util.OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            operatorList.addOp(_util.OPS.nextLine);
            operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
            operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
            args[0] = self.handleText(args[0], stateManager.state);
            fn = _util.OPS.showText;
            break;
          case _util.OPS.setTextRenderingMode:
            stateManager.state.textRenderingMode = args[0];
            break;
          case _util.OPS.setFillColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
              if (cachedColorSpace) {
                stateManager.state.fillColorSpace = cachedColorSpace;
                continue;
              }
              next(self.parseColorSpace({
                cs: args[0],
                resources,
                localColorSpaceCache
              }).then(function (colorSpace) {
                if (colorSpace) {
                  stateManager.state.fillColorSpace = colorSpace;
                }
              }));
              return;
            }
          case _util.OPS.setStrokeColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);
              if (cachedColorSpace) {
                stateManager.state.strokeColorSpace = cachedColorSpace;
                continue;
              }
              next(self.parseColorSpace({
                cs: args[0],
                resources,
                localColorSpaceCache
              }).then(function (colorSpace) {
                if (colorSpace) {
                  stateManager.state.strokeColorSpace = colorSpace;
                }
              }));
              return;
            }
          case _util.OPS.setFillColor:
            cs = stateManager.state.fillColorSpace;
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;
          case _util.OPS.setStrokeColor:
            cs = stateManager.state.strokeColorSpace;
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;
          case _util.OPS.setFillGray:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;
          case _util.OPS.setStrokeGray:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;
          case _util.OPS.setFillCMYKColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;
          case _util.OPS.setStrokeCMYKColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;
          case _util.OPS.setFillRGBColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
            break;
          case _util.OPS.setStrokeRGBColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
            break;
          case _util.OPS.setFillColorN:
            cs = stateManager.state.fillColorSpace;
            if (cs.name === "Pattern") {
              next(self.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              return;
            }
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;
          case _util.OPS.setStrokeColorN:
            cs = stateManager.state.strokeColorSpace;
            if (cs.name === "Pattern") {
              next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              return;
            }
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;
          case _util.OPS.shadingFill:
            var shadingRes = resources.get("Shading");
            if (!shadingRes) {
              throw new _util.FormatError("No shading resource found");
            }
            var shading = shadingRes.get(args[0].name);
            if (!shading) {
              throw new _util.FormatError("No shading object found");
            }
            const patternId = self.parseShading({
              shading,
              resources,
              localColorSpaceCache,
              localShadingPatternCache
            });
            args = [patternId];
            fn = _util.OPS.shadingFill;
            break;
          case _util.OPS.setGState:
            isValidName = args[0] instanceof _primitives.Name;
            name = args[0].name;
            if (isValidName) {
              const localGStateObj = localGStateCache.getByName(name);
              if (localGStateObj) {
                if (localGStateObj.length > 0) {
                  operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                }
                args = null;
                continue;
              }
            }
            next(new Promise(function (resolveGState, rejectGState) {
              if (!isValidName) {
                throw new _util.FormatError("GState must be referred to by name.");
              }
              const extGState = resources.get("ExtGState");
              if (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState should be a dictionary.");
              }
              const gState = extGState.get(name);
              if (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState should be a dictionary.");
              }
              self.setGState({
                resources,
                gState,
                operatorList,
                cacheKey: name,
                task,
                stateManager,
                localGStateCache,
                localColorSpaceCache
              }).then(resolveGState, rejectGState);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }
              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getOperatorList - ignoring ExtGState: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case _util.OPS.moveTo:
          case _util.OPS.lineTo:
          case _util.OPS.curveTo:
          case _util.OPS.curveTo2:
          case _util.OPS.curveTo3:
          case _util.OPS.closePath:
          case _util.OPS.rectangle:
            self.buildPath(operatorList, fn, args, parsingText);
            continue;
          case _util.OPS.markPoint:
          case _util.OPS.markPointProps:
          case _util.OPS.beginCompat:
          case _util.OPS.endCompat:
            continue;
          case _util.OPS.beginMarkedContentProps:
            if (!(args[0] instanceof _primitives.Name)) {
              (0, _util.warn)(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
              continue;
            }
            if (args[0].name === "OC") {
              next(self.parseMarkedContentProps(args[1], resources).then(data => {
                operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
              }).catch(reason => {
                if (reason instanceof _util.AbortException) {
                  return;
                }
                if (self.options.ignoreErrors) {
                  (0, _util.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${reason}".`);
                  return;
                }
                throw reason;
              }));
              return;
            }
            args = [args[0].name, args[1] instanceof _primitives.Dict ? args[1].get("MCID") : null];
            break;
          case _util.OPS.beginMarkedContent:
          case _util.OPS.endMarkedContent:
          default:
            if (args !== null) {
              for (i = 0, ii = args.length; i < ii; i++) {
                if (args[i] instanceof _primitives.Dict) {
                  break;
                }
              }
              if (i < ii) {
                (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                continue;
              }
            }
        }
        operatorList.addOp(fn, args);
      }
      if (stop) {
        next(deferred);
        return;
      }
      closePendingRestoreOPS();
      resolve();
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        (0, _util.warn)(`getOperatorList - ignoring errors during "${task.name}" ` + `task: "${reason}".`);
        closePendingRestoreOPS();
        return;
      }
      throw reason;
    });
  }
  getTextContent({
    stream,
    task,
    resources,
    stateManager = null,
    includeMarkedContent = false,
    sink,
    seenStyles = new Set(),
    viewBox,
    markedContentData = null,
    disableNormalization = false
  }) {
    resources ||= _primitives.Dict.empty;
    stateManager ||= new StateManager(new TextState());
    if (includeMarkedContent) {
      markedContentData ||= {
        level: 0
      };
    }
    const textContent = {
      items: [],
      styles: Object.create(null)
    };
    const textContentItem = {
      initialized: false,
      str: [],
      totalWidth: 0,
      totalHeight: 0,
      width: 0,
      height: 0,
      vertical: false,
      prevTransform: null,
      textAdvanceScale: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: Infinity,
      negativeSpaceMax: -Infinity,
      notASpace: -Infinity,
      transform: null,
      fontName: null,
      hasEOL: false
    };
    const twoLastChars = [" ", " "];
    let twoLastCharsPos = 0;
    function saveLastChar(char) {
      const nextPos = (twoLastCharsPos + 1) % 2;
      const ret = twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
      twoLastChars[twoLastCharsPos] = char;
      twoLastCharsPos = nextPos;
      return ret;
    }
    function shouldAddWhitepsace() {
      return twoLastChars[twoLastCharsPos] !== " " && twoLastChars[(twoLastCharsPos + 1) % 2] === " ";
    }
    function resetLastChars() {
      twoLastChars[0] = twoLastChars[1] = " ";
      twoLastCharsPos = 0;
    }
    const TRACKING_SPACE_FACTOR = 0.102;
    const NOT_A_SPACE_FACTOR = 0.03;
    const NEGATIVE_SPACE_FACTOR = -0.2;
    const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
    const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
    const VERTICAL_SHIFT_RATIO = 0.25;
    const self = this;
    const xref = this.xref;
    const showSpacedTextBuffer = [];
    let xobjs = null;
    const emptyXObjectCache = new _image_utils.LocalImageCache();
    const emptyGStateCache = new _image_utils.LocalGStateCache();
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    let textState;
    function pushWhitespace({
      width = 0,
      height = 0,
      transform = textContentItem.prevTransform,
      fontName = textContentItem.fontName
    }) {
      textContent.items.push({
        str: " ",
        dir: "ltr",
        width,
        height,
        transform,
        fontName,
        hasEOL: false
      });
    }
    function getCurrentTextTransform() {
      const font = textState.font;
      const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
      if (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
        const glyphHeight = font.bbox[3] - font.bbox[1];
        if (glyphHeight > 0) {
          tsm[3] *= glyphHeight * textState.fontMatrix[3];
        }
      }
      return _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
    }
    function ensureTextContentItem() {
      if (textContentItem.initialized) {
        return textContentItem;
      }
      const {
        font,
        loadedName
      } = textState;
      if (!seenStyles.has(loadedName)) {
        seenStyles.add(loadedName);
        textContent.styles[loadedName] = {
          fontFamily: font.fallbackName,
          ascent: font.ascent,
          descent: font.descent,
          vertical: font.vertical
        };
      }
      textContentItem.fontName = loadedName;
      const trm = textContentItem.transform = getCurrentTextTransform();
      if (!font.vertical) {
        textContentItem.width = textContentItem.totalWidth = 0;
        textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
        textContentItem.vertical = false;
      } else {
        textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
        textContentItem.height = textContentItem.totalHeight = 0;
        textContentItem.vertical = true;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
      const {
        fontSize
      } = textState;
      textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
      textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
      textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
      textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
      textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
      textContentItem.hasEOL = false;
      textContentItem.initialized = true;
      return textContentItem;
    }
    function updateAdvanceScale() {
      if (!textContentItem.initialized) {
        return;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      const scaleFactor = scaleCtmX * scaleLineX;
      if (scaleFactor === textContentItem.textAdvanceScale) {
        return;
      }
      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
        textContentItem.width = 0;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
        textContentItem.height = 0;
      }
      textContentItem.textAdvanceScale = scaleFactor;
    }
    function runBidiTransform(textChunk) {
      let text = textChunk.str.join("");
      if (!disableNormalization) {
        text = (0, _util.normalizeUnicode)(text);
      }
      const bidiResult = (0, _bidi.bidi)(text, -1, textChunk.vertical);
      return {
        str: bidiResult.str,
        dir: bidiResult.dir,
        width: Math.abs(textChunk.totalWidth),
        height: Math.abs(textChunk.totalHeight),
        transform: textChunk.transform,
        fontName: textChunk.fontName,
        hasEOL: textChunk.hasEOL
      };
    }
    function handleSetFont(fontName, fontRef) {
      return self.loadFont(fontName, fontRef, resources).then(function (translated) {
        if (!translated.font.isType3Font) {
          return translated;
        }
        return translated.loadType3Data(self, resources, task).catch(function () {}).then(function () {
          return translated;
        });
      }).then(function (translated) {
        textState.loadedName = translated.loadedName;
        textState.font = translated.font;
        textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      });
    }
    function applyInverseRotation(x, y, matrix) {
      const scale = Math.hypot(matrix[0], matrix[1]);
      return [(matrix[0] * x + matrix[1] * y) / scale, (matrix[2] * x + matrix[3] * y) / scale];
    }
    function compareWithLastPosition(glyphWidth) {
      const currentTransform = getCurrentTextTransform();
      let posX = currentTransform[4];
      let posY = currentTransform[5];
      if (textState.font?.vertical) {
        if (posX < viewBox[0] || posX > viewBox[2] || posY + glyphWidth < viewBox[1] || posY > viewBox[3]) {
          return false;
        }
      } else if (posX + glyphWidth < viewBox[0] || posX > viewBox[2] || posY < viewBox[1] || posY > viewBox[3]) {
        return false;
      }
      if (!textState.font || !textContentItem.prevTransform) {
        return true;
      }
      let lastPosX = textContentItem.prevTransform[4];
      let lastPosY = textContentItem.prevTransform[5];
      if (lastPosX === posX && lastPosY === posY) {
        return true;
      }
      let rotate = -1;
      if (currentTransform[0] && currentTransform[1] === 0 && currentTransform[2] === 0) {
        rotate = currentTransform[0] > 0 ? 0 : 180;
      } else if (currentTransform[1] && currentTransform[0] === 0 && currentTransform[3] === 0) {
        rotate = currentTransform[1] > 0 ? 90 : 270;
      }
      switch (rotate) {
        case 0:
          break;
        case 90:
          [posX, posY] = [posY, posX];
          [lastPosX, lastPosY] = [lastPosY, lastPosX];
          break;
        case 180:
          [posX, posY, lastPosX, lastPosY] = [-posX, -posY, -lastPosX, -lastPosY];
          break;
        case 270:
          [posX, posY] = [-posY, -posX];
          [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
          break;
        default:
          [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
          [lastPosX, lastPosY] = applyInverseRotation(lastPosX, lastPosY, textContentItem.prevTransform);
      }
      if (textState.font.vertical) {
        const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
        const advanceX = posX - lastPosX;
        const textOrientation = Math.sign(textContentItem.height);
        if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
          if (Math.abs(advanceX) > 0.5 * textContentItem.width) {
            appendEOL();
            return true;
          }
          resetLastChars();
          flushTextContentItem();
          return true;
        }
        if (Math.abs(advanceX) > textContentItem.width) {
          appendEOL();
          return true;
        }
        if (advanceY <= textOrientation * textContentItem.notASpace) {
          resetLastChars();
        }
        if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
          if (shouldAddWhitepsace()) {
            resetLastChars();
            flushTextContentItem();
            pushWhitespace({
              height: Math.abs(advanceY)
            });
          } else {
            textContentItem.height += advanceY;
          }
        } else if (!addFakeSpaces(advanceY, textContentItem.prevTransform, textOrientation)) {
          if (textContentItem.str.length === 0) {
            resetLastChars();
            pushWhitespace({
              height: Math.abs(advanceY)
            });
          } else {
            textContentItem.height += advanceY;
          }
        }
        if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
          flushTextContentItem();
        }
        return true;
      }
      const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
      const advanceY = posY - lastPosY;
      const textOrientation = Math.sign(textContentItem.width);
      if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
        if (Math.abs(advanceY) > 0.5 * textContentItem.height) {
          appendEOL();
          return true;
        }
        resetLastChars();
        flushTextContentItem();
        return true;
      }
      if (Math.abs(advanceY) > textContentItem.height) {
        appendEOL();
        return true;
      }
      if (advanceX <= textOrientation * textContentItem.notASpace) {
        resetLastChars();
      }
      if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
        if (shouldAddWhitepsace()) {
          resetLastChars();
          flushTextContentItem();
          pushWhitespace({
            width: Math.abs(advanceX)
          });
        } else {
          textContentItem.width += advanceX;
        }
      } else if (!addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)) {
        if (textContentItem.str.length === 0) {
          resetLastChars();
          pushWhitespace({
            width: Math.abs(advanceX)
          });
        } else {
          textContentItem.width += advanceX;
        }
      }
      if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
        flushTextContentItem();
      }
      return true;
    }
    function buildTextContentItem({
      chars,
      extraSpacing
    }) {
      const font = textState.font;
      if (!chars) {
        const charSpacing = textState.charSpacing + extraSpacing;
        if (charSpacing) {
          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } else {
            textState.translateTextMatrix(0, -charSpacing);
          }
        }
        return;
      }
      const glyphs = font.charsToGlyphs(chars);
      const scale = textState.fontMatrix[0] * textState.fontSize;
      for (let i = 0, ii = glyphs.length; i < ii; i++) {
        const glyph = glyphs[i];
        const {
          category
        } = glyph;
        if (category.isInvisibleFormatMark) {
          continue;
        }
        let charSpacing = textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
        let glyphWidth = glyph.width;
        if (font.vertical) {
          glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
        }
        let scaledDim = glyphWidth * scale;
        if (category.isWhitespace) {
          if (!font.vertical) {
            charSpacing += scaledDim + textState.wordSpacing;
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } else {
            charSpacing += -scaledDim + textState.wordSpacing;
            textState.translateTextMatrix(0, -charSpacing);
          }
          saveLastChar(" ");
          continue;
        }
        if (!category.isZeroWidthDiacritic && !compareWithLastPosition(scaledDim)) {
          if (!font.vertical) {
            textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
          } else {
            textState.translateTextMatrix(0, scaledDim);
          }
          continue;
        }
        const textChunk = ensureTextContentItem();
        if (category.isZeroWidthDiacritic) {
          scaledDim = 0;
        }
        if (!font.vertical) {
          scaledDim *= textState.textHScale;
          textState.translateTextMatrix(scaledDim, 0);
          textChunk.width += scaledDim;
        } else {
          textState.translateTextMatrix(0, scaledDim);
          scaledDim = Math.abs(scaledDim);
          textChunk.height += scaledDim;
        }
        if (scaledDim) {
          textChunk.prevTransform = getCurrentTextTransform();
        }
        const glyphUnicode = glyph.unicode;
        if (saveLastChar(glyphUnicode)) {
          textChunk.str.push(" ");
        }
        textChunk.str.push(glyphUnicode);
        if (charSpacing) {
          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } else {
            textState.translateTextMatrix(0, -charSpacing);
          }
        }
      }
    }
    function appendEOL() {
      resetLastChars();
      if (textContentItem.initialized) {
        textContentItem.hasEOL = true;
        flushTextContentItem();
      } else {
        textContent.items.push({
          str: "",
          dir: "ltr",
          width: 0,
          height: 0,
          transform: getCurrentTextTransform(),
          fontName: textState.loadedName,
          hasEOL: true
        });
      }
    }
    function addFakeSpaces(width, transf, textOrientation) {
      if (textOrientation * textContentItem.spaceInFlowMin <= width && width <= textOrientation * textContentItem.spaceInFlowMax) {
        if (textContentItem.initialized) {
          resetLastChars();
          textContentItem.str.push(" ");
        }
        return false;
      }
      const fontName = textContentItem.fontName;
      let height = 0;
      if (textContentItem.vertical) {
        height = width;
        width = 0;
      }
      flushTextContentItem();
      resetLastChars();
      pushWhitespace({
        width: Math.abs(width),
        height: Math.abs(height),
        transform: transf || getCurrentTextTransform(),
        fontName
      });
      return true;
    }
    function flushTextContentItem() {
      if (!textContentItem.initialized || !textContentItem.str) {
        return;
      }
      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
      }
      textContent.items.push(runBidiTransform(textContentItem));
      textContentItem.initialized = false;
      textContentItem.str.length = 0;
    }
    function enqueueChunk(batch = false) {
      const length = textContent.items.length;
      if (length === 0) {
        return;
      }
      if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
        return;
      }
      sink.enqueue(textContent, length);
      textContent.items = [];
      textContent.styles = Object.create(null);
    }
    const timeSlotManager = new TimeSlotManager();
    return new Promise(function promiseBody(resolve, reject) {
      const next = function (promise) {
        enqueueChunk(true);
        Promise.all([promise, sink.ready]).then(function () {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop,
        args = [];
      while (!(stop = timeSlotManager.check())) {
        args.length = 0;
        operation.args = args;
        if (!preprocessor.read(operation)) {
          break;
        }
        const previousState = textState;
        textState = stateManager.state;
        const fn = operation.fn;
        args = operation.args;
        switch (fn | 0) {
          case _util.OPS.setFont:
            var fontNameArg = args[0].name,
              fontSizeArg = args[1];
            if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
              break;
            }
            flushTextContentItem();
            textState.fontName = fontNameArg;
            textState.fontSize = fontSizeArg;
            next(handleSetFont(fontNameArg, null));
            return;
          case _util.OPS.setTextRise:
            textState.textRise = args[0];
            break;
          case _util.OPS.setHScale:
            textState.textHScale = args[0] / 100;
            break;
          case _util.OPS.setLeading:
            textState.leading = args[0];
            break;
          case _util.OPS.moveText:
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;
          case _util.OPS.setLeadingMoveText:
            textState.leading = -args[1];
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;
          case _util.OPS.nextLine:
            textState.carriageReturn();
            break;
          case _util.OPS.setTextMatrix:
            textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            updateAdvanceScale();
            break;
          case _util.OPS.setCharSpacing:
            textState.charSpacing = args[0];
            break;
          case _util.OPS.setWordSpacing:
            textState.wordSpacing = args[0];
            break;
          case _util.OPS.beginText:
            textState.textMatrix = _util.IDENTITY_MATRIX.slice();
            textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
            break;
          case _util.OPS.showSpacedText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1000;
            const elements = args[0];
            for (let i = 0, ii = elements.length; i < ii; i++) {
              const item = elements[i];
              if (typeof item === "string") {
                showSpacedTextBuffer.push(item);
              } else if (typeof item === "number" && item !== 0) {
                const str = showSpacedTextBuffer.join("");
                showSpacedTextBuffer.length = 0;
                buildTextContentItem({
                  chars: str,
                  extraSpacing: item * spaceFactor
                });
              }
            }
            if (showSpacedTextBuffer.length > 0) {
              const str = showSpacedTextBuffer.join("");
              showSpacedTextBuffer.length = 0;
              buildTextContentItem({
                chars: str,
                extraSpacing: 0
              });
            }
            break;
          case _util.OPS.showText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0
            });
            break;
          case _util.OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0
            });
            break;
          case _util.OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }
            textState.wordSpacing = args[0];
            textState.charSpacing = args[1];
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[2],
              extraSpacing: 0
            });
            break;
          case _util.OPS.paintXObject:
            flushTextContentItem();
            if (!xobjs) {
              xobjs = resources.get("XObject") || _primitives.Dict.empty;
            }
            var isValidName = args[0] instanceof _primitives.Name;
            var name = args[0].name;
            if (isValidName && emptyXObjectCache.getByName(name)) {
              break;
            }
            next(new Promise(function (resolveXObject, rejectXObject) {
              if (!isValidName) {
                throw new _util.FormatError("XObject must be referred to by name.");
              }
              let xobj = xobjs.getRaw(name);
              if (xobj instanceof _primitives.Ref) {
                if (emptyXObjectCache.getByRef(xobj)) {
                  resolveXObject();
                  return;
                }
                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);
                if (globalImage) {
                  resolveXObject();
                  return;
                }
                xobj = xref.fetch(xobj);
              }
              if (!(xobj instanceof _base_stream.BaseStream)) {
                throw new _util.FormatError("XObject should be a stream");
              }
              const type = xobj.dict.get("Subtype");
              if (!(type instanceof _primitives.Name)) {
                throw new _util.FormatError("XObject should have a Name subtype");
              }
              if (type.name !== "Form") {
                emptyXObjectCache.set(name, xobj.dict.objId, true);
                resolveXObject();
                return;
              }
              const currentState = stateManager.state.clone();
              const xObjStateManager = new StateManager(currentState);
              const matrix = xobj.dict.getArray("Matrix");
              if (Array.isArray(matrix) && matrix.length === 6) {
                xObjStateManager.transform(matrix);
              }
              enqueueChunk();
              const sinkWrapper = {
                enqueueInvoked: false,
                enqueue(chunk, size) {
                  this.enqueueInvoked = true;
                  sink.enqueue(chunk, size);
                },
                get desiredSize() {
                  return sink.desiredSize;
                },
                get ready() {
                  return sink.ready;
                }
              };
              self.getTextContent({
                stream: xobj,
                task,
                resources: xobj.dict.get("Resources") || resources,
                stateManager: xObjStateManager,
                includeMarkedContent,
                sink: sinkWrapper,
                seenStyles,
                viewBox,
                markedContentData,
                disableNormalization
              }).then(function () {
                if (!sinkWrapper.enqueueInvoked) {
                  emptyXObjectCache.set(name, xobj.dict.objId, true);
                }
                resolveXObject();
              }, rejectXObject);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }
              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case _util.OPS.setGState:
            isValidName = args[0] instanceof _primitives.Name;
            name = args[0].name;
            if (isValidName && emptyGStateCache.getByName(name)) {
              break;
            }
            next(new Promise(function (resolveGState, rejectGState) {
              if (!isValidName) {
                throw new _util.FormatError("GState must be referred to by name.");
              }
              const extGState = resources.get("ExtGState");
              if (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState should be a dictionary.");
              }
              const gState = extGState.get(name);
              if (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState should be a dictionary.");
              }
              const gStateFont = gState.get("Font");
              if (!gStateFont) {
                emptyGStateCache.set(name, gState.objId, true);
                resolveGState();
                return;
              }
              flushTextContentItem();
              textState.fontName = null;
              textState.fontSize = gStateFont[1];
              handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }
              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignoring ExtGState: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case _util.OPS.beginMarkedContent:
            flushTextContentItem();
            if (includeMarkedContent) {
              markedContentData.level++;
              textContent.items.push({
                type: "beginMarkedContent",
                tag: args[0] instanceof _primitives.Name ? args[0].name : null
              });
            }
            break;
          case _util.OPS.beginMarkedContentProps:
            flushTextContentItem();
            if (includeMarkedContent) {
              markedContentData.level++;
              let mcid = null;
              if (args[1] instanceof _primitives.Dict) {
                mcid = args[1].get("MCID");
              }
              textContent.items.push({
                type: "beginMarkedContentProps",
                id: Number.isInteger(mcid) ? `${self.idFactory.getPageObjId()}_mc${mcid}` : null,
                tag: args[0] instanceof _primitives.Name ? args[0].name : null
              });
            }
            break;
          case _util.OPS.endMarkedContent:
            flushTextContentItem();
            if (includeMarkedContent) {
              if (markedContentData.level === 0) {
                break;
              }
              markedContentData.level--;
              textContent.items.push({
                type: "endMarkedContent"
              });
            }
            break;
          case _util.OPS.restore:
            if (previousState && (previousState.font !== textState.font || previousState.fontSize !== textState.fontSize || previousState.fontName !== textState.fontName)) {
              flushTextContentItem();
            }
            break;
        }
        if (textContent.items.length >= sink.desiredSize) {
          stop = true;
          break;
        }
      }
      if (stop) {
        next(deferred);
        return;
      }
      flushTextContentItem();
      enqueueChunk();
      resolve();
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        (0, _util.warn)(`getTextContent - ignoring errors during "${task.name}" ` + `task: "${reason}".`);
        flushTextContentItem();
        enqueueChunk();
        return;
      }
      throw reason;
    });
  }
  extractDataStructures(dict, baseDict, properties) {
    const xref = this.xref;
    let cidToGidBytes;
    const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));
    if (properties.composite) {
      const cidSystemInfo = dict.get("CIDSystemInfo");
      if (cidSystemInfo instanceof _primitives.Dict) {
        properties.cidSystemInfo = {
          registry: (0, _util.stringToPDFString)(cidSystemInfo.get("Registry")),
          ordering: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordering")),
          supplement: cidSystemInfo.get("Supplement")
        };
      }
      try {
        const cidToGidMap = dict.get("CIDToGIDMap");
        if (cidToGidMap instanceof _base_stream.BaseStream) {
          cidToGidBytes = cidToGidMap.getBytes();
        }
      } catch (ex) {
        if (!this.options.ignoreErrors) {
          throw ex;
        }
        (0, _util.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
      }
    }
    const differences = [];
    let baseEncodingName = null;
    let encoding;
    if (dict.has("Encoding")) {
      encoding = dict.get("Encoding");
      if (encoding instanceof _primitives.Dict) {
        baseEncodingName = encoding.get("BaseEncoding");
        baseEncodingName = baseEncodingName instanceof _primitives.Name ? baseEncodingName.name : null;
        if (encoding.has("Differences")) {
          const diffEncoding = encoding.get("Differences");
          let index = 0;
          for (const entry of diffEncoding) {
            const data = xref.fetchIfRef(entry);
            if (typeof data === "number") {
              index = data;
            } else if (data instanceof _primitives.Name) {
              differences[index++] = data.name;
            } else {
              throw new _util.FormatError(`Invalid entry in 'Differences' array: ${data}`);
            }
          }
        }
      } else if (encoding instanceof _primitives.Name) {
        baseEncodingName = encoding.name;
      } else {
        const msg = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors) {
          throw new _util.FormatError(msg);
        }
        (0, _util.warn)(msg);
      }
      if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
        baseEncodingName = null;
      }
    }
    const nonEmbeddedFont = !properties.file || properties.isInternalFont,
      isSymbolsFontName = (0, _standard_fonts.getSymbolsFonts)()[properties.name];
    if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
      baseEncodingName = null;
    }
    if (baseEncodingName) {
      properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName);
    } else {
      const isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
      const isNonsymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Nonsymbolic);
      encoding = _encodings.StandardEncoding;
      if (properties.type === "TrueType" && !isNonsymbolicFont) {
        encoding = _encodings.WinAnsiEncoding;
      }
      if (isSymbolicFont || isSymbolsFontName) {
        encoding = _encodings.MacRomanEncoding;
        if (nonEmbeddedFont) {
          if (/Symbol/i.test(properties.name)) {
            encoding = _encodings.SymbolSetEncoding;
          } else if (/Dingbats/i.test(properties.name)) {
            encoding = _encodings.ZapfDingbatsEncoding;
          } else if (/Wingdings/i.test(properties.name)) {
            encoding = _encodings.WinAnsiEncoding;
          }
        }
      }
      properties.defaultEncoding = encoding;
    }
    properties.differences = differences;
    properties.baseEncodingName = baseEncodingName;
    properties.hasEncoding = !!baseEncodingName || differences.length > 0;
    properties.dict = dict;
    return toUnicodePromise.then(readToUnicode => {
      properties.toUnicode = readToUnicode;
      return this.buildToUnicode(properties);
    }).then(builtToUnicode => {
      properties.toUnicode = builtToUnicode;
      if (cidToGidBytes) {
        properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
      }
      return properties;
    });
  }
  _simpleFontToUnicode(properties, forceGlyphs = false) {
    (0, _util.assert)(!properties.composite, "Must be a simple font.");
    const toUnicode = [];
    const encoding = properties.defaultEncoding.slice();
    const baseEncodingName = properties.baseEncodingName;
    const differences = properties.differences;
    for (const charcode in differences) {
      const glyphName = differences[charcode];
      if (glyphName === ".notdef") {
        continue;
      }
      encoding[charcode] = glyphName;
    }
    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
    for (const charcode in encoding) {
      let glyphName = encoding[charcode];
      if (glyphName === "") {
        continue;
      }
      let unicode = glyphsUnicodeMap[glyphName];
      if (unicode !== undefined) {
        toUnicode[charcode] = String.fromCharCode(unicode);
        continue;
      }
      let code = 0;
      switch (glyphName[0]) {
        case "G":
          if (glyphName.length === 3) {
            code = parseInt(glyphName.substring(1), 16);
          }
          break;
        case "g":
          if (glyphName.length === 5) {
            code = parseInt(glyphName.substring(1), 16);
          }
          break;
        case "C":
        case "c":
          if (glyphName.length >= 3 && glyphName.length <= 4) {
            const codeStr = glyphName.substring(1);
            if (forceGlyphs) {
              code = parseInt(codeStr, 16);
              break;
            }
            code = +codeStr;
            if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
              return this._simpleFontToUnicode(properties, true);
            }
          }
          break;
        case "u":
          unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
          if (unicode !== -1) {
            code = unicode;
          }
          break;
        default:
          switch (glyphName) {
            case "f_h":
            case "f_t":
            case "T_h":
              toUnicode[charcode] = glyphName.replaceAll("_", "");
              continue;
          }
          break;
      }
      if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
        if (baseEncodingName && code === +charcode) {
          const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
          if (baseEncoding && (glyphName = baseEncoding[charcode])) {
            toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
            continue;
          }
        }
        toUnicode[charcode] = String.fromCodePoint(code);
      }
    }
    return toUnicode;
  }
  async buildToUnicode(properties) {
    properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
    if (properties.hasIncludedToUnicodeMap) {
      if (!properties.composite && properties.hasEncoding) {
        properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
      }
      return properties.toUnicode;
    }
    if (!properties.composite) {
      return new _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(properties));
    }
    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
      const {
        registry,
        ordering
      } = properties.cidSystemInfo;
      const ucs2CMapName = _primitives.Name.get(`${registry}-${ordering}-UCS2`);
      const ucs2CMap = await _cmap.CMapFactory.create({
        encoding: ucs2CMapName,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      const toUnicode = [],
        buf = [];
      properties.cMap.forEach(function (charcode, cid) {
        if (cid > 0xffff) {
          throw new _util.FormatError("Max size of CID is 65,535");
        }
        const ucs2 = ucs2CMap.lookup(cid);
        if (ucs2) {
          buf.length = 0;
          for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
            buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
          }
          toUnicode[charcode] = String.fromCharCode(...buf);
        }
      });
      return new _to_unicode_map.ToUnicodeMap(toUnicode);
    }
    return new _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
  }
  readToUnicode(cmapObj) {
    if (!cmapObj) {
      return Promise.resolve(null);
    }
    if (cmapObj instanceof _primitives.Name) {
      return _cmap.CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function (cmap) {
        if (cmap instanceof _cmap.IdentityCMap) {
          return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }
        return new _to_unicode_map.ToUnicodeMap(cmap.getMap());
      });
    } else if (cmapObj instanceof _base_stream.BaseStream) {
      return _cmap.CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function (cmap) {
        if (cmap instanceof _cmap.IdentityCMap) {
          return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }
        const map = new Array(cmap.length);
        cmap.forEach(function (charCode, token) {
          if (typeof token === "number") {
            map[charCode] = String.fromCodePoint(token);
            return;
          }
          const str = [];
          for (let k = 0; k < token.length; k += 2) {
            const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            if ((w1 & 0xf800) !== 0xd800) {
              str.push(w1);
              continue;
            }
            k += 2;
            const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
          }
          map[charCode] = String.fromCodePoint(...str);
        });
        return new _to_unicode_map.ToUnicodeMap(map);
      }, reason => {
        if (reason instanceof _util.AbortException) {
          return null;
        }
        if (this.options.ignoreErrors) {
          (0, _util.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
          return null;
        }
        throw reason;
      });
    }
    return Promise.resolve(null);
  }
  readCidToGidMap(glyphsData, toUnicode) {
    const result = [];
    for (let j = 0, jj = glyphsData.length; j < jj; j++) {
      const glyphID = glyphsData[j++] << 8 | glyphsData[j];
      const code = j >> 1;
      if (glyphID === 0 && !toUnicode.has(code)) {
        continue;
      }
      result[code] = glyphID;
    }
    return result;
  }
  extractWidths(dict, descriptor, properties) {
    const xref = this.xref;
    let glyphsWidths = [];
    let defaultWidth = 0;
    const glyphsVMetrics = [];
    let defaultVMetrics;
    let i, ii, j, jj, start, code, widths;
    if (properties.composite) {
      defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
      widths = dict.get("W");
      if (widths) {
        for (i = 0, ii = widths.length; i < ii; i++) {
          start = xref.fetchIfRef(widths[i++]);
          code = xref.fetchIfRef(widths[i]);
          if (Array.isArray(code)) {
            for (j = 0, jj = code.length; j < jj; j++) {
              glyphsWidths[start++] = xref.fetchIfRef(code[j]);
            }
          } else {
            const width = xref.fetchIfRef(widths[++i]);
            for (j = start; j <= code; j++) {
              glyphsWidths[j] = width;
            }
          }
        }
      }
      if (properties.vertical) {
        let vmetrics = dict.getArray("DW2") || [880, -1000];
        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
        vmetrics = dict.get("W2");
        if (vmetrics) {
          for (i = 0, ii = vmetrics.length; i < ii; i++) {
            start = xref.fetchIfRef(vmetrics[i++]);
            code = xref.fetchIfRef(vmetrics[i]);
            if (Array.isArray(code)) {
              for (j = 0, jj = code.length; j < jj; j++) {
                glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
              }
            } else {
              const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
              for (j = start; j <= code; j++) {
                glyphsVMetrics[j] = vmetric;
              }
            }
          }
        }
      }
    } else {
      const firstChar = properties.firstChar;
      widths = dict.get("Widths");
      if (widths) {
        j = firstChar;
        for (i = 0, ii = widths.length; i < ii; i++) {
          glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
        }
        defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
      } else {
        const baseFontName = dict.get("BaseFont");
        if (baseFontName instanceof _primitives.Name) {
          const metrics = this.getBaseFontMetrics(baseFontName.name);
          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
          defaultWidth = metrics.defaultWidth;
        }
      }
    }
    let isMonospace = true;
    let firstWidth = defaultWidth;
    for (const glyph in glyphsWidths) {
      const glyphWidth = glyphsWidths[glyph];
      if (!glyphWidth) {
        continue;
      }
      if (!firstWidth) {
        firstWidth = glyphWidth;
        continue;
      }
      if (firstWidth !== glyphWidth) {
        isMonospace = false;
        break;
      }
    }
    if (isMonospace) {
      properties.flags |= _fonts_utils.FontFlags.FixedPitch;
    } else {
      properties.flags &= ~_fonts_utils.FontFlags.FixedPitch;
    }
    properties.defaultWidth = defaultWidth;
    properties.widths = glyphsWidths;
    properties.defaultVMetrics = defaultVMetrics;
    properties.vmetrics = glyphsVMetrics;
  }
  isSerifFont(baseFontName) {
    const fontNameWoStyle = baseFontName.split("-")[0];
    return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || /serif/gi.test(fontNameWoStyle);
  }
  getBaseFontMetrics(name) {
    let defaultWidth = 0;
    let widths = Object.create(null);
    let monospace = false;
    const stdFontMap = (0, _standard_fonts.getStdFontMap)();
    let lookupName = stdFontMap[name] || name;
    const Metrics = (0, _metrics.getMetrics)();
    if (!(lookupName in Metrics)) {
      lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
    }
    const glyphWidths = Metrics[lookupName];
    if (typeof glyphWidths === "number") {
      defaultWidth = glyphWidths;
      monospace = true;
    } else {
      widths = glyphWidths();
    }
    return {
      defaultWidth,
      monospace,
      widths
    };
  }
  buildCharCodeToWidth(widthsByGlyphName, properties) {
    const widths = Object.create(null);
    const differences = properties.differences;
    const encoding = properties.defaultEncoding;
    for (let charCode = 0; charCode < 256; charCode++) {
      if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
        widths[charCode] = widthsByGlyphName[differences[charCode]];
        continue;
      }
      if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
        widths[charCode] = widthsByGlyphName[encoding[charCode]];
        continue;
      }
    }
    return widths;
  }
  preEvaluateFont(dict) {
    const baseDict = dict;
    let type = dict.get("Subtype");
    if (!(type instanceof _primitives.Name)) {
      throw new _util.FormatError("invalid font Subtype");
    }
    let composite = false;
    let hash, toUnicode;
    if (type.name === "Type0") {
      const df = dict.get("DescendantFonts");
      if (!df) {
        throw new _util.FormatError("Descendant fonts are not specified");
      }
      dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
      if (!(dict instanceof _primitives.Dict)) {
        throw new _util.FormatError("Descendant font is not a dictionary.");
      }
      type = dict.get("Subtype");
      if (!(type instanceof _primitives.Name)) {
        throw new _util.FormatError("invalid font Subtype");
      }
      composite = true;
    }
    const firstChar = dict.get("FirstChar") || 0,
      lastChar = dict.get("LastChar") || (composite ? 0xffff : 0xff);
    const descriptor = dict.get("FontDescriptor");
    if (descriptor) {
      hash = new _murmurhash.MurmurHash3_64();
      const encoding = baseDict.getRaw("Encoding");
      if (encoding instanceof _primitives.Name) {
        hash.update(encoding.name);
      } else if (encoding instanceof _primitives.Ref) {
        hash.update(encoding.toString());
      } else if (encoding instanceof _primitives.Dict) {
        for (const entry of encoding.getRawValues()) {
          if (entry instanceof _primitives.Name) {
            hash.update(entry.name);
          } else if (entry instanceof _primitives.Ref) {
            hash.update(entry.toString());
          } else if (Array.isArray(entry)) {
            const diffLength = entry.length,
              diffBuf = new Array(diffLength);
            for (let j = 0; j < diffLength; j++) {
              const diffEntry = entry[j];
              if (diffEntry instanceof _primitives.Name) {
                diffBuf[j] = diffEntry.name;
              } else if (typeof diffEntry === "number" || diffEntry instanceof _primitives.Ref) {
                diffBuf[j] = diffEntry.toString();
              }
            }
            hash.update(diffBuf.join());
          }
        }
      }
      hash.update(`${firstChar}-${lastChar}`);
      toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
      if (toUnicode instanceof _base_stream.BaseStream) {
        const stream = toUnicode.str || toUnicode;
        const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
        hash.update(uint8array);
      } else if (toUnicode instanceof _primitives.Name) {
        hash.update(toUnicode.name);
      }
      const widths = dict.get("Widths") || baseDict.get("Widths");
      if (Array.isArray(widths)) {
        const widthsBuf = [];
        for (const entry of widths) {
          if (typeof entry === "number" || entry instanceof _primitives.Ref) {
            widthsBuf.push(entry.toString());
          }
        }
        hash.update(widthsBuf.join());
      }
      if (composite) {
        hash.update("compositeFont");
        const compositeWidths = dict.get("W") || baseDict.get("W");
        if (Array.isArray(compositeWidths)) {
          const widthsBuf = [];
          for (const entry of compositeWidths) {
            if (typeof entry === "number" || entry instanceof _primitives.Ref) {
              widthsBuf.push(entry.toString());
            } else if (Array.isArray(entry)) {
              const subWidthsBuf = [];
              for (const element of entry) {
                if (typeof element === "number" || element instanceof _primitives.Ref) {
                  subWidthsBuf.push(element.toString());
                }
              }
              widthsBuf.push(`[${subWidthsBuf.join()}]`);
            }
          }
          hash.update(widthsBuf.join());
        }
        const cidToGidMap = dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
        if (cidToGidMap instanceof _primitives.Name) {
          hash.update(cidToGidMap.name);
        } else if (cidToGidMap instanceof _primitives.Ref) {
          hash.update(cidToGidMap.toString());
        } else if (cidToGidMap instanceof _base_stream.BaseStream) {
          hash.update(cidToGidMap.peekBytes());
        }
      }
    }
    return {
      descriptor,
      dict,
      baseDict,
      composite,
      type: type.name,
      firstChar,
      lastChar,
      toUnicode,
      hash: hash ? hash.hexdigest() : ""
    };
  }
  async translateFont({
    descriptor,
    dict,
    baseDict,
    composite,
    type,
    firstChar,
    lastChar,
    toUnicode,
    cssFontInfo
  }) {
    const isType3Font = type === "Type3";
    let properties;
    if (!descriptor) {
      if (isType3Font) {
        descriptor = new _primitives.Dict(null);
        descriptor.set("FontName", _primitives.Name.get(type));
        descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
      } else {
        let baseFontName = dict.get("BaseFont");
        if (!(baseFontName instanceof _primitives.Name)) {
          throw new _util.FormatError("Base font is not specified");
        }
        baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
        const metrics = this.getBaseFontMetrics(baseFontName);
        const fontNameWoStyle = baseFontName.split("-")[0];
        const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic);
        properties = {
          type,
          name: baseFontName,
          loadedName: baseDict.loadedName,
          systemFontInfo: null,
          widths: metrics.widths,
          defaultWidth: metrics.defaultWidth,
          isSimulatedFlags: true,
          flags,
          firstChar,
          lastChar,
          toUnicode,
          xHeight: 0,
          capHeight: 0,
          italicAngle: 0,
          isType3Font
        };
        const widths = dict.get("Widths");
        const standardFontName = (0, _standard_fonts.getStandardFontName)(baseFontName);
        let file = null;
        if (standardFontName) {
          file = await this.fetchStandardFontData(standardFontName);
          properties.isInternalFont = !!file;
        }
        if (!properties.isInternalFont && this.options.useSystemFonts) {
          properties.systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, baseFontName, standardFontName);
        }
        return this.extractDataStructures(dict, dict, properties).then(newProperties => {
          if (widths) {
            const glyphWidths = [];
            let j = firstChar;
            for (const width of widths) {
              glyphWidths[j++] = this.xref.fetchIfRef(width);
            }
            newProperties.widths = glyphWidths;
          } else {
            newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
          }
          return new _fonts.Font(baseFontName, file, newProperties);
        });
      }
    }
    let fontName = descriptor.get("FontName");
    let baseFont = dict.get("BaseFont");
    if (typeof fontName === "string") {
      fontName = _primitives.Name.get(fontName);
    }
    if (typeof baseFont === "string") {
      baseFont = _primitives.Name.get(baseFont);
    }
    const fontNameStr = fontName?.name;
    const baseFontStr = baseFont?.name;
    if (!isType3Font && fontNameStr !== baseFontStr) {
      (0, _util.info)(`The FontDescriptor's FontName is "${fontNameStr}" but ` + `should be the same as the Font's BaseFont "${baseFontStr}".`);
      if (fontNameStr && baseFontStr && (baseFontStr.startsWith(fontNameStr) || !(0, _standard_fonts.isKnownFontName)(fontNameStr) && (0, _standard_fonts.isKnownFontName)(baseFontStr))) {
        fontName = null;
      }
    }
    fontName ||= baseFont;
    if (!(fontName instanceof _primitives.Name)) {
      throw new _util.FormatError("invalid font name");
    }
    let fontFile, subtype, length1, length2, length3;
    try {
      fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
    } catch (ex) {
      if (!this.options.ignoreErrors) {
        throw ex;
      }
      (0, _util.warn)(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
      fontFile = new _stream.NullStream();
    }
    let isInternalFont = false;
    let glyphScaleFactors = null;
    let systemFontInfo = null;
    if (fontFile) {
      if (fontFile.dict) {
        const subtypeEntry = fontFile.dict.get("Subtype");
        if (subtypeEntry instanceof _primitives.Name) {
          subtype = subtypeEntry.name;
        }
        length1 = fontFile.dict.get("Length1");
        length2 = fontFile.dict.get("Length2");
        length3 = fontFile.dict.get("Length3");
      }
    } else if (cssFontInfo) {
      const standardFontName = (0, _xfa_fonts.getXfaFontName)(fontName.name);
      if (standardFontName) {
        cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
        cssFontInfo.metrics = standardFontName.metrics || null;
        glyphScaleFactors = standardFontName.factors || null;
        fontFile = await this.fetchStandardFontData(standardFontName.name);
        isInternalFont = !!fontFile;
        baseDict = dict = (0, _xfa_fonts.getXfaFontDict)(fontName.name);
        composite = true;
      }
    } else if (!isType3Font) {
      const standardFontName = (0, _standard_fonts.getStandardFontName)(fontName.name);
      if (standardFontName) {
        fontFile = await this.fetchStandardFontData(standardFontName);
        isInternalFont = !!fontFile;
      }
      if (!isInternalFont && this.options.useSystemFonts) {
        systemFontInfo = (0, _font_substitutions.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, fontName.name, standardFontName);
      }
    }
    properties = {
      type,
      name: fontName.name,
      subtype,
      file: fontFile,
      length1,
      length2,
      length3,
      isInternalFont,
      loadedName: baseDict.loadedName,
      composite,
      fixedPitch: false,
      fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
      firstChar,
      lastChar,
      toUnicode,
      bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
      ascent: descriptor.get("Ascent"),
      descent: descriptor.get("Descent"),
      xHeight: descriptor.get("XHeight") || 0,
      capHeight: descriptor.get("CapHeight") || 0,
      flags: descriptor.get("Flags"),
      italicAngle: descriptor.get("ItalicAngle") || 0,
      isType3Font,
      cssFontInfo,
      scaleFactors: glyphScaleFactors,
      systemFontInfo
    };
    if (composite) {
      const cidEncoding = baseDict.get("Encoding");
      if (cidEncoding instanceof _primitives.Name) {
        properties.cidEncoding = cidEncoding.name;
      }
      const cMap = await _cmap.CMapFactory.create({
        encoding: cidEncoding,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      properties.cMap = cMap;
      properties.vertical = properties.cMap.vertical;
    }
    return this.extractDataStructures(dict, baseDict, properties).then(newProperties => {
      this.extractWidths(dict, descriptor, newProperties);
      return new _fonts.Font(fontName.name, fontFile, newProperties);
    });
  }
  static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
    function buildPath(fontChar) {
      const glyphName = `${font.loadedName}_path_${fontChar}`;
      try {
        if (font.renderer.hasBuiltPath(fontChar)) {
          return;
        }
        handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
      } catch (reason) {
        if (evaluatorOptions.ignoreErrors) {
          (0, _util.warn)(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
          return;
        }
        throw reason;
      }
    }
    for (const glyph of glyphs) {
      buildPath(glyph.fontChar);
      const accent = glyph.accent;
      if (accent?.fontChar) {
        buildPath(accent.fontChar);
      }
    }
  }
  static get fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("Helvetica"));
    dict.set("Type", _primitives.Name.get("FallbackType"));
    dict.set("Subtype", _primitives.Name.get("FallbackType"));
    dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }
}
exports.PartialEvaluator = PartialEvaluator;
class TranslatedFont {
  constructor({
    loadedName,
    font,
    dict,
    evaluatorOptions
  }) {
    this.loadedName = loadedName;
    this.font = font;
    this.dict = dict;
    this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
    this.type3Loaded = null;
    this.type3Dependencies = font.isType3Font ? new Set() : null;
    this.sent = false;
  }
  send(handler) {
    if (this.sent) {
      return;
    }
    this.sent = true;
    handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
  }
  fallback(handler) {
    if (!this.font.data) {
      return;
    }
    this.font.disableFontFace = true;
    PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);
  }
  loadType3Data(evaluator, resources, task) {
    if (this.type3Loaded) {
      return this.type3Loaded;
    }
    if (!this.font.isType3Font) {
      throw new Error("Must be a Type3 font.");
    }
    const type3Evaluator = evaluator.clone({
      ignoreErrors: false
    });
    type3Evaluator.parsingType3Font = true;
    const type3FontRefs = new _primitives.RefSet(evaluator.type3FontRefs);
    if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
      type3FontRefs.put(this.dict.objId);
    }
    type3Evaluator.type3FontRefs = type3FontRefs;
    const translatedFont = this.font,
      type3Dependencies = this.type3Dependencies;
    let loadCharProcsPromise = Promise.resolve();
    const charProcs = this.dict.get("CharProcs");
    const fontResources = this.dict.get("Resources") || resources;
    const charProcOperatorList = Object.create(null);
    const fontBBox = _util.Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
      width = fontBBox[2] - fontBBox[0],
      height = fontBBox[3] - fontBBox[1];
    const fontBBoxSize = Math.hypot(width, height);
    for (const key of charProcs.getKeys()) {
      loadCharProcsPromise = loadCharProcsPromise.then(() => {
        const glyphStream = charProcs.get(key);
        const operatorList = new _operator_list.OperatorList();
        return type3Evaluator.getOperatorList({
          stream: glyphStream,
          task,
          resources: fontResources,
          operatorList
        }).then(() => {
          if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
            this._removeType3ColorOperators(operatorList, fontBBoxSize);
          }
          charProcOperatorList[key] = operatorList.getIR();
          for (const dependency of operatorList.dependencies) {
            type3Dependencies.add(dependency);
          }
        }).catch(function (reason) {
          (0, _util.warn)(`Type3 font resource "${key}" is not available.`);
          const dummyOperatorList = new _operator_list.OperatorList();
          charProcOperatorList[key] = dummyOperatorList.getIR();
        });
      });
    }
    this.type3Loaded = loadCharProcsPromise.then(() => {
      translatedFont.charProcOperatorList = charProcOperatorList;
      if (this._bbox) {
        translatedFont.isCharBBox = true;
        translatedFont.bbox = this._bbox;
      }
    });
    return this.type3Loaded;
  }
  _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
    const charBBox = _util.Util.normalizeRect(operatorList.argsArray[0].slice(2)),
      width = charBBox[2] - charBBox[0],
      height = charBBox[3] - charBBox[1];
    const charBBoxSize = Math.hypot(width, height);
    if (width === 0 || height === 0) {
      operatorList.fnArray.splice(0, 1);
      operatorList.argsArray.splice(0, 1);
    } else if (fontBBoxSize === 0 || Math.round(charBBoxSize / fontBBoxSize) >= 10) {
      if (!this._bbox) {
        this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
      }
      this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
      this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
      this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
      this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
    }
    let i = 0,
      ii = operatorList.length;
    while (i < ii) {
      switch (operatorList.fnArray[i]) {
        case _util.OPS.setCharWidthAndBounds:
          break;
        case _util.OPS.setStrokeColorSpace:
        case _util.OPS.setFillColorSpace:
        case _util.OPS.setStrokeColor:
        case _util.OPS.setStrokeColorN:
        case _util.OPS.setFillColor:
        case _util.OPS.setFillColorN:
        case _util.OPS.setStrokeGray:
        case _util.OPS.setFillGray:
        case _util.OPS.setStrokeRGBColor:
        case _util.OPS.setFillRGBColor:
        case _util.OPS.setStrokeCMYKColor:
        case _util.OPS.setFillCMYKColor:
        case _util.OPS.shadingFill:
        case _util.OPS.setRenderingIntent:
          operatorList.fnArray.splice(i, 1);
          operatorList.argsArray.splice(i, 1);
          ii--;
          continue;
        case _util.OPS.setGState:
          const [gStateObj] = operatorList.argsArray[i];
          let j = 0,
            jj = gStateObj.length;
          while (j < jj) {
            const [gStateKey] = gStateObj[j];
            switch (gStateKey) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                gStateObj.splice(j, 1);
                jj--;
                continue;
            }
            j++;
          }
          break;
      }
      i++;
    }
  }
}
class StateManager {
  constructor(initialState = new EvalState()) {
    this.state = initialState;
    this.stateStack = [];
  }
  save() {
    const old = this.state;
    this.stateStack.push(this.state);
    this.state = old.clone();
  }
  restore() {
    const prev = this.stateStack.pop();
    if (prev) {
      this.state = prev;
    }
  }
  transform(args) {
    this.state.ctm = _util.Util.transform(this.state.ctm, args);
  }
}
class TextState {
  constructor() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.loadedName = null;
    this.font = null;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.textMatrix = _util.IDENTITY_MATRIX.slice();
    this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  setTextMatrix(a, b, c, d, e, f) {
    const m = this.textMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  setTextLineMatrix(a, b, c, d, e, f) {
    const m = this.textLineMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  translateTextMatrix(x, y) {
    const m = this.textMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  translateTextLineMatrix(x, y) {
    const m = this.textLineMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const clone = Object.create(this);
    clone.textMatrix = this.textMatrix.slice();
    clone.textLineMatrix = this.textLineMatrix.slice();
    clone.fontMatrix = this.fontMatrix.slice();
    return clone;
  }
}
class EvalState {
  constructor() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.font = null;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
    this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
  }
  clone() {
    return Object.create(this);
  }
}
class EvaluatorPreprocessor {
  static get opMap() {
    return (0, _util.shadow)(this, "opMap", {
      w: {
        id: _util.OPS.setLineWidth,
        numArgs: 1,
        variableArgs: false
      },
      J: {
        id: _util.OPS.setLineCap,
        numArgs: 1,
        variableArgs: false
      },
      j: {
        id: _util.OPS.setLineJoin,
        numArgs: 1,
        variableArgs: false
      },
      M: {
        id: _util.OPS.setMiterLimit,
        numArgs: 1,
        variableArgs: false
      },
      d: {
        id: _util.OPS.setDash,
        numArgs: 2,
        variableArgs: false
      },
      ri: {
        id: _util.OPS.setRenderingIntent,
        numArgs: 1,
        variableArgs: false
      },
      i: {
        id: _util.OPS.setFlatness,
        numArgs: 1,
        variableArgs: false
      },
      gs: {
        id: _util.OPS.setGState,
        numArgs: 1,
        variableArgs: false
      },
      q: {
        id: _util.OPS.save,
        numArgs: 0,
        variableArgs: false
      },
      Q: {
        id: _util.OPS.restore,
        numArgs: 0,
        variableArgs: false
      },
      cm: {
        id: _util.OPS.transform,
        numArgs: 6,
        variableArgs: false
      },
      m: {
        id: _util.OPS.moveTo,
        numArgs: 2,
        variableArgs: false
      },
      l: {
        id: _util.OPS.lineTo,
        numArgs: 2,
        variableArgs: false
      },
      c: {
        id: _util.OPS.curveTo,
        numArgs: 6,
        variableArgs: false
      },
      v: {
        id: _util.OPS.curveTo2,
        numArgs: 4,
        variableArgs: false
      },
      y: {
        id: _util.OPS.curveTo3,
        numArgs: 4,
        variableArgs: false
      },
      h: {
        id: _util.OPS.closePath,
        numArgs: 0,
        variableArgs: false
      },
      re: {
        id: _util.OPS.rectangle,
        numArgs: 4,
        variableArgs: false
      },
      S: {
        id: _util.OPS.stroke,
        numArgs: 0,
        variableArgs: false
      },
      s: {
        id: _util.OPS.closeStroke,
        numArgs: 0,
        variableArgs: false
      },
      f: {
        id: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      },
      F: {
        id: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      },
      "f*": {
        id: _util.OPS.eoFill,
        numArgs: 0,
        variableArgs: false
      },
      B: {
        id: _util.OPS.fillStroke,
        numArgs: 0,
        variableArgs: false
      },
      "B*": {
        id: _util.OPS.eoFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      b: {
        id: _util.OPS.closeFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      "b*": {
        id: _util.OPS.closeEOFillStroke,
        numArgs: 0,
        variableArgs: false
      },
      n: {
        id: _util.OPS.endPath,
        numArgs: 0,
        variableArgs: false
      },
      W: {
        id: _util.OPS.clip,
        numArgs: 0,
        variableArgs: false
      },
      "W*": {
        id: _util.OPS.eoClip,
        numArgs: 0,
        variableArgs: false
      },
      BT: {
        id: _util.OPS.beginText,
        numArgs: 0,
        variableArgs: false
      },
      ET: {
        id: _util.OPS.endText,
        numArgs: 0,
        variableArgs: false
      },
      Tc: {
        id: _util.OPS.setCharSpacing,
        numArgs: 1,
        variableArgs: false
      },
      Tw: {
        id: _util.OPS.setWordSpacing,
        numArgs: 1,
        variableArgs: false
      },
      Tz: {
        id: _util.OPS.setHScale,
        numArgs: 1,
        variableArgs: false
      },
      TL: {
        id: _util.OPS.setLeading,
        numArgs: 1,
        variableArgs: false
      },
      Tf: {
        id: _util.OPS.setFont,
        numArgs: 2,
        variableArgs: false
      },
      Tr: {
        id: _util.OPS.setTextRenderingMode,
        numArgs: 1,
        variableArgs: false
      },
      Ts: {
        id: _util.OPS.setTextRise,
        numArgs: 1,
        variableArgs: false
      },
      Td: {
        id: _util.OPS.moveText,
        numArgs: 2,
        variableArgs: false
      },
      TD: {
        id: _util.OPS.setLeadingMoveText,
        numArgs: 2,
        variableArgs: false
      },
      Tm: {
        id: _util.OPS.setTextMatrix,
        numArgs: 6,
        variableArgs: false
      },
      "T*": {
        id: _util.OPS.nextLine,
        numArgs: 0,
        variableArgs: false
      },
      Tj: {
        id: _util.OPS.showText,
        numArgs: 1,
        variableArgs: false
      },
      TJ: {
        id: _util.OPS.showSpacedText,
        numArgs: 1,
        variableArgs: false
      },
      "'": {
        id: _util.OPS.nextLineShowText,
        numArgs: 1,
        variableArgs: false
      },
      '"': {
        id: _util.OPS.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: false
      },
      d0: {
        id: _util.OPS.setCharWidth,
        numArgs: 2,
        variableArgs: false
      },
      d1: {
        id: _util.OPS.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: false
      },
      CS: {
        id: _util.OPS.setStrokeColorSpace,
        numArgs: 1,
        variableArgs: false
      },
      cs: {
        id: _util.OPS.setFillColorSpace,
        numArgs: 1,
        variableArgs: false
      },
      SC: {
        id: _util.OPS.setStrokeColor,
        numArgs: 4,
        variableArgs: true
      },
      SCN: {
        id: _util.OPS.setStrokeColorN,
        numArgs: 33,
        variableArgs: true
      },
      sc: {
        id: _util.OPS.setFillColor,
        numArgs: 4,
        variableArgs: true
      },
      scn: {
        id: _util.OPS.setFillColorN,
        numArgs: 33,
        variableArgs: true
      },
      G: {
        id: _util.OPS.setStrokeGray,
        numArgs: 1,
        variableArgs: false
      },
      g: {
        id: _util.OPS.setFillGray,
        numArgs: 1,
        variableArgs: false
      },
      RG: {
        id: _util.OPS.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: false
      },
      rg: {
        id: _util.OPS.setFillRGBColor,
        numArgs: 3,
        variableArgs: false
      },
      K: {
        id: _util.OPS.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: false
      },
      k: {
        id: _util.OPS.setFillCMYKColor,
        numArgs: 4,
        variableArgs: false
      },
      sh: {
        id: _util.OPS.shadingFill,
        numArgs: 1,
        variableArgs: false
      },
      BI: {
        id: _util.OPS.beginInlineImage,
        numArgs: 0,
        variableArgs: false
      },
      ID: {
        id: _util.OPS.beginImageData,
        numArgs: 0,
        variableArgs: false
      },
      EI: {
        id: _util.OPS.endInlineImage,
        numArgs: 1,
        variableArgs: false
      },
      Do: {
        id: _util.OPS.paintXObject,
        numArgs: 1,
        variableArgs: false
      },
      MP: {
        id: _util.OPS.markPoint,
        numArgs: 1,
        variableArgs: false
      },
      DP: {
        id: _util.OPS.markPointProps,
        numArgs: 2,
        variableArgs: false
      },
      BMC: {
        id: _util.OPS.beginMarkedContent,
        numArgs: 1,
        variableArgs: false
      },
      BDC: {
        id: _util.OPS.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: false
      },
      EMC: {
        id: _util.OPS.endMarkedContent,
        numArgs: 0,
        variableArgs: false
      },
      BX: {
        id: _util.OPS.beginCompat,
        numArgs: 0,
        variableArgs: false
      },
      EX: {
        id: _util.OPS.endCompat,
        numArgs: 0,
        variableArgs: false
      },
      BM: null,
      BD: null,
      true: null,
      fa: null,
      fal: null,
      fals: null,
      false: null,
      nu: null,
      nul: null,
      null: null
    });
  }
  static MAX_INVALID_PATH_OPS = 10;
  constructor(stream, xref, stateManager = new StateManager()) {
    this.parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream, EvaluatorPreprocessor.opMap),
      xref
    });
    this.stateManager = stateManager;
    this.nonProcessedArgs = [];
    this._isPathOp = false;
    this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(operation) {
    let args = operation.args;
    while (true) {
      const obj = this.parser.getObj();
      if (obj instanceof _primitives.Cmd) {
        const cmd = obj.cmd;
        const opSpec = EvaluatorPreprocessor.opMap[cmd];
        if (!opSpec) {
          (0, _util.warn)(`Unknown command "${cmd}".`);
          continue;
        }
        const fn = opSpec.id;
        const numArgs = opSpec.numArgs;
        let argsLength = args !== null ? args.length : 0;
        if (!this._isPathOp) {
          this._numInvalidPathOPS = 0;
        }
        this._isPathOp = fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath;
        if (!opSpec.variableArgs) {
          if (argsLength !== numArgs) {
            const nonProcessedArgs = this.nonProcessedArgs;
            while (argsLength > numArgs) {
              nonProcessedArgs.push(args.shift());
              argsLength--;
            }
            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
              if (args === null) {
                args = [];
              }
              args.unshift(nonProcessedArgs.pop());
              argsLength++;
            }
          }
          if (argsLength < numArgs) {
            const partialMsg = `command ${cmd}: expected ${numArgs} args, ` + `but received ${argsLength} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
              throw new _util.FormatError(`Invalid ${partialMsg}`);
            }
            (0, _util.warn)(`Skipping ${partialMsg}`);
            if (args !== null) {
              args.length = 0;
            }
            continue;
          }
        } else if (argsLength > numArgs) {
          (0, _util.info)(`Command ${cmd}: expected [0, ${numArgs}] args, ` + `but received ${argsLength} args.`);
        }
        this.preprocessCommand(fn, args);
        operation.fn = fn;
        operation.args = args;
        return true;
      }
      if (obj === _primitives.EOF) {
        return false;
      }
      if (obj !== null) {
        if (args === null) {
          args = [];
        }
        args.push(obj);
        if (args.length > 33) {
          throw new _util.FormatError("Too many arguments");
        }
      }
    }
  }
  preprocessCommand(fn, args) {
    switch (fn | 0) {
      case _util.OPS.save:
        this.stateManager.save();
        break;
      case _util.OPS.restore:
        this.stateManager.restore();
        break;
      case _util.OPS.transform:
        this.stateManager.transform(args);
        break;
    }
  }
}
exports.EvaluatorPreprocessor = EvaluatorPreprocessor;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IdentityCMap = exports.CMapFactory = exports.CMap = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _binary_cmap = __w_pdfjs_require__(15);
var _parser = __w_pdfjs_require__(16);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
const BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
const MAX_MAP_RANGE = 2 ** 24 - 1;
class CMap {
  constructor(builtInCMap = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }
  addCodespaceRange(n, low, high) {
    this.codespaceRanges[n - 1].push(low, high);
    this.numCodespaceRanges++;
  }
  mapCidRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    }
    while (low <= high) {
      this._map[low++] = dstLow++;
    }
  }
  mapBfRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    }
    const lastByte = dstLow.length - 1;
    while (low <= high) {
      this._map[low++] = dstLow;
      const nextCharCode = dstLow.charCodeAt(lastByte) + 1;
      if (nextCharCode > 0xff) {
        dstLow = dstLow.substring(0, lastByte - 1) + String.fromCharCode(dstLow.charCodeAt(lastByte - 1) + 1) + "\x00";
        continue;
      }
      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(nextCharCode);
    }
  }
  mapBfRangeToArray(low, high, array) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    }
    const ii = array.length;
    let i = 0;
    while (low <= high && i < ii) {
      this._map[low] = array[i++];
      ++low;
    }
  }
  mapOne(src, dst) {
    this._map[src] = dst;
  }
  lookup(code) {
    return this._map[code];
  }
  contains(code) {
    return this._map[code] !== undefined;
  }
  forEach(callback) {
    const map = this._map;
    const length = map.length;
    if (length <= 0x10000) {
      for (let i = 0; i < length; i++) {
        if (map[i] !== undefined) {
          callback(i, map[i]);
        }
      }
    } else {
      for (const i in map) {
        callback(i, map[i]);
      }
    }
  }
  charCodeOf(value) {
    const map = this._map;
    if (map.length <= 0x10000) {
      return map.indexOf(value);
    }
    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(str, offset, out) {
    let c = 0;
    const codespaceRanges = this.codespaceRanges;
    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
      const codespaceRange = codespaceRanges[n];
      for (let k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        if (c >= low && c <= high) {
          out.charcode = c;
          out.length = n + 1;
          return;
        }
      }
    }
    out.charcode = 0;
    out.length = 1;
  }
  getCharCodeLength(charCode) {
    const codespaceRanges = this.codespaceRanges;
    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      const codespaceRange = codespaceRanges[n];
      for (let k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        if (charCode >= low && charCode <= high) {
          return n + 1;
        }
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
      return false;
    }
    if (this._map.length !== 0x10000) {
      return false;
    }
    for (let i = 0; i < 0x10000; i++) {
      if (this._map[i] !== i) {
        return false;
      }
    }
    return true;
  }
}
exports.CMap = CMap;
class IdentityCMap extends CMap {
  constructor(vertical, n) {
    super();
    this.vertical = vertical;
    this.addCodespaceRange(n, 0, 0xffff);
  }
  mapCidRange(low, high, dstLow) {
    (0, _util.unreachable)("should not call mapCidRange");
  }
  mapBfRange(low, high, dstLow) {
    (0, _util.unreachable)("should not call mapBfRange");
  }
  mapBfRangeToArray(low, high, array) {
    (0, _util.unreachable)("should not call mapBfRangeToArray");
  }
  mapOne(src, dst) {
    (0, _util.unreachable)("should not call mapCidOne");
  }
  lookup(code) {
    return Number.isInteger(code) && code <= 0xffff ? code : undefined;
  }
  contains(code) {
    return Number.isInteger(code) && code <= 0xffff;
  }
  forEach(callback) {
    for (let i = 0; i <= 0xffff; i++) {
      callback(i, i);
    }
  }
  charCodeOf(value) {
    return Number.isInteger(value) && value <= 0xffff ? value : -1;
  }
  getMap() {
    const map = new Array(0x10000);
    for (let i = 0; i <= 0xffff; i++) {
      map[i] = i;
    }
    return map;
  }
  get length() {
    return 0x10000;
  }
  get isIdentityCMap() {
    (0, _util.unreachable)("should not access .isIdentityCMap");
  }
}
exports.IdentityCMap = IdentityCMap;
function strToInt(str) {
  let a = 0;
  for (let i = 0; i < str.length; i++) {
    a = a << 8 | str.charCodeAt(i);
  }
  return a >>> 0;
}
function expectString(obj) {
  if (typeof obj !== "string") {
    throw new _util.FormatError("Malformed CMap: expected string.");
  }
}
function expectInt(obj) {
  if (!Number.isInteger(obj)) {
    throw new _util.FormatError("Malformed CMap: expected int.");
  }
}
function parseBfChar(cMap, lexer) {
  while (true) {
    let obj = lexer.getObj();
    if (obj === _primitives.EOF) {
      break;
    }
    if ((0, _primitives.isCmd)(obj, "endbfchar")) {
      return;
    }
    expectString(obj);
    const src = strToInt(obj);
    obj = lexer.getObj();
    expectString(obj);
    const dst = obj;
    cMap.mapOne(src, dst);
  }
}
function parseBfRange(cMap, lexer) {
  while (true) {
    let obj = lexer.getObj();
    if (obj === _primitives.EOF) {
      break;
    }
    if ((0, _primitives.isCmd)(obj, "endbfrange")) {
      return;
    }
    expectString(obj);
    const low = strToInt(obj);
    obj = lexer.getObj();
    expectString(obj);
    const high = strToInt(obj);
    obj = lexer.getObj();
    if (Number.isInteger(obj) || typeof obj === "string") {
      const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
      cMap.mapBfRange(low, high, dstLow);
    } else if ((0, _primitives.isCmd)(obj, "[")) {
      obj = lexer.getObj();
      const array = [];
      while (!(0, _primitives.isCmd)(obj, "]") && obj !== _primitives.EOF) {
        array.push(obj);
        obj = lexer.getObj();
      }
      cMap.mapBfRangeToArray(low, high, array);
    } else {
      break;
    }
  }
  throw new _util.FormatError("Invalid bf range.");
}
function parseCidChar(cMap, lexer) {
  while (true) {
    let obj = lexer.getObj();
    if (obj === _primitives.EOF) {
      break;
    }
    if ((0, _primitives.isCmd)(obj, "endcidchar")) {
      return;
    }
    expectString(obj);
    const src = strToInt(obj);
    obj = lexer.getObj();
    expectInt(obj);
    const dst = obj;
    cMap.mapOne(src, dst);
  }
}
function parseCidRange(cMap, lexer) {
  while (true) {
    let obj = lexer.getObj();
    if (obj === _primitives.EOF) {
      break;
    }
    if ((0, _primitives.isCmd)(obj, "endcidrange")) {
      return;
    }
    expectString(obj);
    const low = strToInt(obj);
    obj = lexer.getObj();
    expectString(obj);
    const high = strToInt(obj);
    obj = lexer.getObj();
    expectInt(obj);
    const dstLow = obj;
    cMap.mapCidRange(low, high, dstLow);
  }
}
function parseCodespaceRange(cMap, lexer) {
  while (true) {
    let obj = lexer.getObj();
    if (obj === _primitives.EOF) {
      break;
    }
    if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
      return;
    }
    if (typeof obj !== "string") {
      break;
    }
    const low = strToInt(obj);
    obj = lexer.getObj();
    if (typeof obj !== "string") {
      break;
    }
    const high = strToInt(obj);
    cMap.addCodespaceRange(obj.length, low, high);
  }
  throw new _util.FormatError("Invalid codespace range.");
}
function parseWMode(cMap, lexer) {
  const obj = lexer.getObj();
  if (Number.isInteger(obj)) {
    cMap.vertical = !!obj;
  }
}
function parseCMapName(cMap, lexer) {
  const obj = lexer.getObj();
  if (obj instanceof _primitives.Name) {
    cMap.name = obj.name;
  }
}
async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
  let previous, embeddedUseCMap;
  objLoop: while (true) {
    try {
      const obj = lexer.getObj();
      if (obj === _primitives.EOF) {
        break;
      } else if (obj instanceof _primitives.Name) {
        if (obj.name === "WMode") {
          parseWMode(cMap, lexer);
        } else if (obj.name === "CMapName") {
          parseCMapName(cMap, lexer);
        }
        previous = obj;
      } else if (obj instanceof _primitives.Cmd) {
        switch (obj.cmd) {
          case "endcmap":
            break objLoop;
          case "usecmap":
            if (previous instanceof _primitives.Name) {
              embeddedUseCMap = previous.name;
            }
            break;
          case "begincodespacerange":
            parseCodespaceRange(cMap, lexer);
            break;
          case "beginbfchar":
            parseBfChar(cMap, lexer);
            break;
          case "begincidchar":
            parseCidChar(cMap, lexer);
            break;
          case "beginbfrange":
            parseBfRange(cMap, lexer);
            break;
          case "begincidrange":
            parseCidRange(cMap, lexer);
            break;
        }
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Invalid cMap data: " + ex);
      continue;
    }
  }
  if (!useCMap && embeddedUseCMap) {
    useCMap = embeddedUseCMap;
  }
  if (useCMap) {
    return extendCMap(cMap, fetchBuiltInCMap, useCMap);
  }
  return cMap;
}
async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
  cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);
  if (cMap.numCodespaceRanges === 0) {
    const useCodespaceRanges = cMap.useCMap.codespaceRanges;
    for (let i = 0; i < useCodespaceRanges.length; i++) {
      cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
    }
    cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
  }
  cMap.useCMap.forEach(function (key, value) {
    if (!cMap.contains(key)) {
      cMap.mapOne(key, cMap.useCMap.lookup(key));
    }
  });
  return cMap;
}
async function createBuiltInCMap(name, fetchBuiltInCMap) {
  if (name === "Identity-H") {
    return new IdentityCMap(false, 2);
  } else if (name === "Identity-V") {
    return new IdentityCMap(true, 2);
  }
  if (!BUILT_IN_CMAPS.includes(name)) {
    throw new Error("Unknown CMap name: " + name);
  }
  if (!fetchBuiltInCMap) {
    throw new Error("Built-in CMap parameters are not provided.");
  }
  const {
    cMapData,
    compressionType
  } = await fetchBuiltInCMap(name);
  const cMap = new CMap(true);
  if (compressionType === _util.CMapCompressionType.BINARY) {
    return new _binary_cmap.BinaryCMapReader().process(cMapData, cMap, useCMap => {
      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
    });
  }
  if (compressionType === _util.CMapCompressionType.NONE) {
    const lexer = new _parser.Lexer(new _stream.Stream(cMapData));
    return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
  }
  throw new Error(`Invalid CMap "compressionType" value: ${compressionType}`);
}
class CMapFactory {
  static async create({
    encoding,
    fetchBuiltInCMap,
    useCMap
  }) {
    if (encoding instanceof _primitives.Name) {
      return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
    } else if (encoding instanceof _base_stream.BaseStream) {
      const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap);
      if (parsedCMap.isIdentityCMap) {
        return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
      }
      return parsedCMap;
    }
    throw new Error("Encoding required.");
  }
}
exports.CMapFactory = CMapFactory;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BinaryCMapReader = void 0;
var _util = __w_pdfjs_require__(2);
function hexToInt(a, size) {
  let n = 0;
  for (let i = 0; i <= size; i++) {
    n = n << 8 | a[i];
  }
  return n >>> 0;
}
function hexToStr(a, size) {
  if (size === 1) {
    return String.fromCharCode(a[0], a[1]);
  }
  if (size === 3) {
    return String.fromCharCode(a[0], a[1], a[2], a[3]);
  }
  return String.fromCharCode(...a.subarray(0, size + 1));
}
function addHex(a, b, size) {
  let c = 0;
  for (let i = size; i >= 0; i--) {
    c += a[i] + b[i];
    a[i] = c & 255;
    c >>= 8;
  }
}
function incHex(a, size) {
  let c = 1;
  for (let i = size; i >= 0 && c > 0; i--) {
    c += a[i];
    a[i] = c & 255;
    c >>= 8;
  }
}
const MAX_NUM_SIZE = 16;
const MAX_ENCODED_NUM_SIZE = 19;
class BinaryCMapStream {
  constructor(data) {
    this.buffer = data;
    this.pos = 0;
    this.end = data.length;
    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
  }
  readByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.buffer[this.pos++];
  }
  readNumber() {
    let n = 0;
    let last;
    do {
      const b = this.readByte();
      if (b < 0) {
        throw new _util.FormatError("unexpected EOF in bcmap");
      }
      last = !(b & 0x80);
      n = n << 7 | b & 0x7f;
    } while (!last);
    return n;
  }
  readSigned() {
    const n = this.readNumber();
    return n & 1 ? ~(n >>> 1) : n >>> 1;
  }
  readHex(num, size) {
    num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
    this.pos += size + 1;
  }
  readHexNumber(num, size) {
    let last;
    const stack = this.tmpBuf;
    let sp = 0;
    do {
      const b = this.readByte();
      if (b < 0) {
        throw new _util.FormatError("unexpected EOF in bcmap");
      }
      last = !(b & 0x80);
      stack[sp++] = b & 0x7f;
    } while (!last);
    let i = size,
      buffer = 0,
      bufferSize = 0;
    while (i >= 0) {
      while (bufferSize < 8 && stack.length > 0) {
        buffer |= stack[--sp] << bufferSize;
        bufferSize += 7;
      }
      num[i] = buffer & 255;
      i--;
      buffer >>= 8;
      bufferSize -= 8;
    }
  }
  readHexSigned(num, size) {
    this.readHexNumber(num, size);
    const sign = num[size] & 1 ? 255 : 0;
    let c = 0;
    for (let i = 0; i <= size; i++) {
      c = (c & 1) << 8 | num[i];
      num[i] = c >> 1 ^ sign;
    }
  }
  readString() {
    const len = this.readNumber(),
      buf = new Array(len);
    for (let i = 0; i < len; i++) {
      buf[i] = this.readNumber();
    }
    return String.fromCharCode(...buf);
  }
}
class BinaryCMapReader {
  async process(data, cMap, extend) {
    const stream = new BinaryCMapStream(data);
    const header = stream.readByte();
    cMap.vertical = !!(header & 1);
    let useCMap = null;
    const start = new Uint8Array(MAX_NUM_SIZE);
    const end = new Uint8Array(MAX_NUM_SIZE);
    const char = new Uint8Array(MAX_NUM_SIZE);
    const charCode = new Uint8Array(MAX_NUM_SIZE);
    const tmp = new Uint8Array(MAX_NUM_SIZE);
    let code;
    let b;
    while ((b = stream.readByte()) >= 0) {
      const type = b >> 5;
      if (type === 7) {
        switch (b & 0x1f) {
          case 0:
            stream.readString();
            break;
          case 1:
            useCMap = stream.readString();
            break;
        }
        continue;
      }
      const sequence = !!(b & 0x10);
      const dataSize = b & 15;
      if (dataSize + 1 > MAX_NUM_SIZE) {
        throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      }
      const ucs2DataSize = 1;
      const subitemsCount = stream.readNumber();
      switch (type) {
        case 0:
          stream.readHex(start, dataSize);
          stream.readHexNumber(end, dataSize);
          addHex(end, start, dataSize);
          cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
          for (let i = 1; i < subitemsCount; i++) {
            incHex(end, dataSize);
            stream.readHexNumber(start, dataSize);
            addHex(start, end, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
          }
          break;
        case 1:
          stream.readHex(start, dataSize);
          stream.readHexNumber(end, dataSize);
          addHex(end, start, dataSize);
          stream.readNumber();
          for (let i = 1; i < subitemsCount; i++) {
            incHex(end, dataSize);
            stream.readHexNumber(start, dataSize);
            addHex(start, end, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            stream.readNumber();
          }
          break;
        case 2:
          stream.readHex(char, dataSize);
          code = stream.readNumber();
          cMap.mapOne(hexToInt(char, dataSize), code);
          for (let i = 1; i < subitemsCount; i++) {
            incHex(char, dataSize);
            if (!sequence) {
              stream.readHexNumber(tmp, dataSize);
              addHex(char, tmp, dataSize);
            }
            code = stream.readSigned() + (code + 1);
            cMap.mapOne(hexToInt(char, dataSize), code);
          }
          break;
        case 3:
          stream.readHex(start, dataSize);
          stream.readHexNumber(end, dataSize);
          addHex(end, start, dataSize);
          code = stream.readNumber();
          cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
          for (let i = 1; i < subitemsCount; i++) {
            incHex(end, dataSize);
            if (!sequence) {
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
            } else {
              start.set(end);
            }
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
          }
          break;
        case 4:
          stream.readHex(char, ucs2DataSize);
          stream.readHex(charCode, dataSize);
          cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
          for (let i = 1; i < subitemsCount; i++) {
            incHex(char, ucs2DataSize);
            if (!sequence) {
              stream.readHexNumber(tmp, ucs2DataSize);
              addHex(char, tmp, ucs2DataSize);
            }
            incHex(charCode, dataSize);
            stream.readHexSigned(tmp, dataSize);
            addHex(charCode, tmp, dataSize);
            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
          }
          break;
        case 5:
          stream.readHex(start, ucs2DataSize);
          stream.readHexNumber(end, ucs2DataSize);
          addHex(end, start, ucs2DataSize);
          stream.readHex(charCode, dataSize);
          cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
          for (let i = 1; i < subitemsCount; i++) {
            incHex(end, ucs2DataSize);
            if (!sequence) {
              stream.readHexNumber(start, ucs2DataSize);
              addHex(start, end, ucs2DataSize);
            } else {
              start.set(end);
            }
            stream.readHexNumber(end, ucs2DataSize);
            addHex(end, start, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
          }
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);
      }
    }
    if (useCMap) {
      return extend(useCMap);
    }
    return cMap;
  }
}
exports.BinaryCMapReader = BinaryCMapReader;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Parser = exports.Linearization = exports.Lexer = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _ascii_85_stream = __w_pdfjs_require__(17);
var _ascii_hex_stream = __w_pdfjs_require__(19);
var _ccitt_stream = __w_pdfjs_require__(20);
var _flate_stream = __w_pdfjs_require__(22);
var _jbig2_stream = __w_pdfjs_require__(23);
var _jpeg_stream = __w_pdfjs_require__(26);
var _jpx_stream = __w_pdfjs_require__(29);
var _lzw_stream = __w_pdfjs_require__(31);
var _predictor_stream = __w_pdfjs_require__(32);
var _run_length_stream = __w_pdfjs_require__(33);
const MAX_LENGTH_TO_CACHE = 1000;
function getInlineImageCacheKey(bytes) {
  const strBuf = [],
    ii = bytes.length;
  let i = 0;
  while (i < ii - 1) {
    strBuf.push(bytes[i++] << 8 | bytes[i++]);
  }
  if (i < ii) {
    strBuf.push(bytes[i]);
  }
  return ii + "_" + String.fromCharCode.apply(null, strBuf);
}
class Parser {
  constructor({
    lexer,
    xref,
    allowStreams = false,
    recoveryMode = false
  }) {
    this.lexer = lexer;
    this.xref = xref;
    this.allowStreams = allowStreams;
    this.recoveryMode = recoveryMode;
    this.imageCache = Object.create(null);
    this._imageId = 0;
    this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj();
    this.buf2 = this.lexer.getObj();
  }
  shift() {
    if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
      this.buf1 = this.buf2;
      this.buf2 = null;
    } else {
      this.buf1 = this.buf2;
      this.buf2 = this.lexer.getObj();
    }
  }
  tryShift() {
    try {
      this.shift();
      return true;
    } catch (e) {
      if (e instanceof _core_utils.MissingDataException) {
        throw e;
      }
      return false;
    }
  }
  getObj(cipherTransform = null) {
    const buf1 = this.buf1;
    this.shift();
    if (buf1 instanceof _primitives.Cmd) {
      switch (buf1.cmd) {
        case "BI":
          return this.makeInlineImage(cipherTransform);
        case "[":
          const array = [];
          while (!(0, _primitives.isCmd)(this.buf1, "]") && this.buf1 !== _primitives.EOF) {
            array.push(this.getObj(cipherTransform));
          }
          if (this.buf1 === _primitives.EOF) {
            if (this.recoveryMode) {
              return array;
            }
            throw new _core_utils.ParserEOFException("End of file inside array.");
          }
          this.shift();
          return array;
        case "<<":
          const dict = new _primitives.Dict(this.xref);
          while (!(0, _primitives.isCmd)(this.buf1, ">>") && this.buf1 !== _primitives.EOF) {
            if (!(this.buf1 instanceof _primitives.Name)) {
              (0, _util.info)("Malformed dictionary: key must be a name object");
              this.shift();
              continue;
            }
            const key = this.buf1.name;
            this.shift();
            if (this.buf1 === _primitives.EOF) {
              break;
            }
            dict.set(key, this.getObj(cipherTransform));
          }
          if (this.buf1 === _primitives.EOF) {
            if (this.recoveryMode) {
              return dict;
            }
            throw new _core_utils.ParserEOFException("End of file inside dictionary.");
          }
          if ((0, _primitives.isCmd)(this.buf2, "stream")) {
            return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
          }
          this.shift();
          return dict;
        default:
          return buf1;
      }
    }
    if (Number.isInteger(buf1)) {
      if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
        const ref = _primitives.Ref.get(buf1, this.buf1);
        this.shift();
        this.shift();
        return ref;
      }
      return buf1;
    }
    if (typeof buf1 === "string") {
      if (cipherTransform) {
        return cipherTransform.decryptString(buf1);
      }
      return buf1;
    }
    return buf1;
  }
  findDefaultInlineStreamEnd(stream) {
    const E = 0x45,
      I = 0x49,
      SPACE = 0x20,
      LF = 0xa,
      CR = 0xd,
      NUL = 0x0;
    const {
        knownCommands
      } = this.lexer,
      startPos = stream.pos,
      n = 15;
    let state = 0,
      ch,
      maybeEIPos;
    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I ? 2 : 0;
      } else {
        if (ch === SPACE || ch === LF || ch === CR) {
          maybeEIPos = stream.pos;
          const followingBytes = stream.peekBytes(n);
          const ii = followingBytes.length;
          if (ii === 0) {
            break;
          }
          for (let i = 0; i < ii; i++) {
            ch = followingBytes[i];
            if (ch === NUL && followingBytes[i + 1] !== NUL) {
              continue;
            }
            if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7f)) {
              state = 0;
              break;
            }
          }
          if (state !== 2) {
            continue;
          }
          if (!knownCommands) {
            (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
            continue;
          }
          const tmpLexer = new Lexer(new _stream.Stream(followingBytes.slice()), knownCommands);
          tmpLexer._hexStringWarn = () => {};
          let numArgs = 0;
          while (true) {
            const nextObj = tmpLexer.getObj();
            if (nextObj === _primitives.EOF) {
              state = 0;
              break;
            }
            if (nextObj instanceof _primitives.Cmd) {
              const knownCommand = knownCommands[nextObj.cmd];
              if (!knownCommand) {
                state = 0;
                break;
              } else if (knownCommand.variableArgs ? numArgs <= knownCommand.numArgs : numArgs === knownCommand.numArgs) {
                break;
              }
              numArgs = 0;
              continue;
            }
            numArgs++;
          }
          if (state === 2) {
            break;
          }
        } else {
          state = 0;
        }
      }
    }
    if (ch === -1) {
      (0, _util.warn)("findDefaultInlineStreamEnd: " + "Reached the end of the stream without finding a valid EI marker");
      if (maybeEIPos) {
        (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
        stream.skip(-(stream.pos - maybeEIPos));
      }
    }
    let endOffset = 4;
    stream.skip(-endOffset);
    ch = stream.peekByte();
    stream.skip(endOffset);
    if (!(0, _core_utils.isWhiteSpace)(ch)) {
      endOffset--;
    }
    return stream.pos - endOffset - startPos;
  }
  findDCTDecodeInlineStreamEnd(stream) {
    const startPos = stream.pos;
    let foundEOI = false,
      b,
      markerLength;
    while ((b = stream.getByte()) !== -1) {
      if (b !== 0xff) {
        continue;
      }
      switch (stream.getByte()) {
        case 0x00:
          break;
        case 0xff:
          stream.skip(-1);
          break;
        case 0xd9:
          foundEOI = true;
          break;
        case 0xc0:
        case 0xc1:
        case 0xc2:
        case 0xc3:
        case 0xc5:
        case 0xc6:
        case 0xc7:
        case 0xc9:
        case 0xca:
        case 0xcb:
        case 0xcd:
        case 0xce:
        case 0xcf:
        case 0xc4:
        case 0xcc:
        case 0xda:
        case 0xdb:
        case 0xdc:
        case 0xdd:
        case 0xde:
        case 0xdf:
        case 0xe0:
        case 0xe1:
        case 0xe2:
        case 0xe3:
        case 0xe4:
        case 0xe5:
        case 0xe6:
        case 0xe7:
        case 0xe8:
        case 0xe9:
        case 0xea:
        case 0xeb:
        case 0xec:
        case 0xed:
        case 0xee:
        case 0xef:
        case 0xfe:
          markerLength = stream.getUint16();
          if (markerLength > 2) {
            stream.skip(markerLength - 2);
          } else {
            stream.skip(-2);
          }
          break;
      }
      if (foundEOI) {
        break;
      }
    }
    const length = stream.pos - startPos;
    if (b === -1) {
      (0, _util.warn)("Inline DCTDecode image stream: " + "EOI marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  findASCII85DecodeInlineStreamEnd(stream) {
    const TILDE = 0x7e,
      GT = 0x3e;
    const startPos = stream.pos;
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === TILDE) {
        const tildePos = stream.pos;
        ch = stream.peekByte();
        while ((0, _core_utils.isWhiteSpace)(ch)) {
          stream.skip();
          ch = stream.peekByte();
        }
        if (ch === GT) {
          stream.skip();
          break;
        }
        if (stream.pos > tildePos) {
          const maybeEI = stream.peekBytes(2);
          if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {
            break;
          }
        }
      }
    }
    const length = stream.pos - startPos;
    if (ch === -1) {
      (0, _util.warn)("Inline ASCII85Decode image stream: " + "EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  findASCIIHexDecodeInlineStreamEnd(stream) {
    const GT = 0x3e;
    const startPos = stream.pos;
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === GT) {
        break;
      }
    }
    const length = stream.pos - startPos;
    if (ch === -1) {
      (0, _util.warn)("Inline ASCIIHexDecode image stream: " + "EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  inlineStreamSkipEI(stream) {
    const E = 0x45,
      I = 0x49;
    let state = 0,
      ch;
    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I ? 2 : 0;
      } else if (state === 2) {
        break;
      }
    }
  }
  makeInlineImage(cipherTransform) {
    const lexer = this.lexer;
    const stream = lexer.stream;
    const dictMap = Object.create(null);
    let dictLength;
    while (!(0, _primitives.isCmd)(this.buf1, "ID") && this.buf1 !== _primitives.EOF) {
      if (!(this.buf1 instanceof _primitives.Name)) {
        throw new _util.FormatError("Dictionary key must be a name object");
      }
      const key = this.buf1.name;
      this.shift();
      if (this.buf1 === _primitives.EOF) {
        break;
      }
      dictMap[key] = this.getObj(cipherTransform);
    }
    if (lexer.beginInlineImagePos !== -1) {
      dictLength = stream.pos - lexer.beginInlineImagePos;
    }
    const filter = this.xref.fetchIfRef(dictMap.F || dictMap.Filter);
    let filterName;
    if (filter instanceof _primitives.Name) {
      filterName = filter.name;
    } else if (Array.isArray(filter)) {
      const filterZero = this.xref.fetchIfRef(filter[0]);
      if (filterZero instanceof _primitives.Name) {
        filterName = filterZero.name;
      }
    }
    const startPos = stream.pos;
    let length;
    switch (filterName) {
      case "DCT":
      case "DCTDecode":
        length = this.findDCTDecodeInlineStreamEnd(stream);
        break;
      case "A85":
      case "ASCII85Decode":
        length = this.findASCII85DecodeInlineStreamEnd(stream);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        length = this.findASCIIHexDecodeInlineStreamEnd(stream);
        break;
      default:
        length = this.findDefaultInlineStreamEnd(stream);
    }
    let cacheKey;
    if (length < MAX_LENGTH_TO_CACHE && dictLength > 0) {
      const initialStreamPos = stream.pos;
      stream.pos = lexer.beginInlineImagePos;
      cacheKey = getInlineImageCacheKey(stream.getBytes(dictLength + length));
      stream.pos = initialStreamPos;
      const cacheEntry = this.imageCache[cacheKey];
      if (cacheEntry !== undefined) {
        this.buf2 = _primitives.Cmd.get("EI");
        this.shift();
        cacheEntry.reset();
        return cacheEntry;
      }
    }
    const dict = new _primitives.Dict(this.xref);
    for (const key in dictMap) {
      dict.set(key, dictMap[key]);
    }
    let imageStream = stream.makeSubStream(startPos, length, dict);
    if (cipherTransform) {
      imageStream = cipherTransform.createStream(imageStream, length);
    }
    imageStream = this.filter(imageStream, dict, length);
    imageStream.dict = dict;
    if (cacheKey !== undefined) {
      imageStream.cacheKey = `inline_img_${++this._imageId}`;
      this.imageCache[cacheKey] = imageStream;
    }
    this.buf2 = _primitives.Cmd.get("EI");
    this.shift();
    return imageStream;
  }
  _findStreamLength(startPos, signature) {
    const {
      stream
    } = this.lexer;
    stream.pos = startPos;
    const SCAN_BLOCK_LENGTH = 2048;
    const signatureLength = signature.length;
    while (stream.pos < stream.end) {
      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      const scanLength = scanBytes.length - signatureLength;
      if (scanLength <= 0) {
        break;
      }
      let pos = 0;
      while (pos < scanLength) {
        let j = 0;
        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
          j++;
        }
        if (j >= signatureLength) {
          stream.pos += pos;
          return stream.pos - startPos;
        }
        pos++;
      }
      stream.pos += scanLength;
    }
    return -1;
  }
  makeStream(dict, cipherTransform) {
    const lexer = this.lexer;
    let stream = lexer.stream;
    lexer.skipToNextLine();
    const startPos = stream.pos - 1;
    let length = dict.get("Length");
    if (!Number.isInteger(length)) {
      (0, _util.info)(`Bad length "${length && length.toString()}" in stream.`);
      length = 0;
    }
    stream.pos = startPos + length;
    lexer.nextChar();
    if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
      this.shift();
    } else {
      const ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
      let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
      if (actualLength < 0) {
        const MAX_TRUNCATION = 1;
        for (let i = 1; i <= MAX_TRUNCATION; i++) {
          const end = ENDSTREAM_SIGNATURE.length - i;
          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
          if (maybeLength >= 0) {
            const lastByte = stream.peekBytes(end + 1)[end];
            if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
              break;
            }
            (0, _util.info)(`Found "${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}" when ` + "searching for endstream command.");
            actualLength = maybeLength;
            break;
          }
        }
        if (actualLength < 0) {
          throw new _util.FormatError("Missing endstream command.");
        }
      }
      length = actualLength;
      lexer.nextChar();
      this.shift();
      this.shift();
    }
    this.shift();
    stream = stream.makeSubStream(startPos, length, dict);
    if (cipherTransform) {
      stream = cipherTransform.createStream(stream, length);
    }
    stream = this.filter(stream, dict, length);
    stream.dict = dict;
    return stream;
  }
  filter(stream, dict, length) {
    let filter = dict.get("F", "Filter");
    let params = dict.get("DP", "DecodeParms");
    if (filter instanceof _primitives.Name) {
      if (Array.isArray(params)) {
        (0, _util.warn)("/DecodeParms should not be an Array, when /Filter is a Name.");
      }
      return this.makeFilter(stream, filter.name, length, params);
    }
    let maybeLength = length;
    if (Array.isArray(filter)) {
      const filterArray = filter;
      const paramsArray = params;
      for (let i = 0, ii = filterArray.length; i < ii; ++i) {
        filter = this.xref.fetchIfRef(filterArray[i]);
        if (!(filter instanceof _primitives.Name)) {
          throw new _util.FormatError(`Bad filter name "${filter}"`);
        }
        params = null;
        if (Array.isArray(paramsArray) && i in paramsArray) {
          params = this.xref.fetchIfRef(paramsArray[i]);
        }
        stream = this.makeFilter(stream, filter.name, maybeLength, params);
        maybeLength = null;
      }
    }
    return stream;
  }
  makeFilter(stream, name, maybeLength, params) {
    if (maybeLength === 0) {
      (0, _util.warn)(`Empty "${name}" stream.`);
      return new _stream.NullStream();
    }
    try {
      switch (name) {
        case "Fl":
        case "FlateDecode":
          if (params) {
            return new _predictor_stream.PredictorStream(new _flate_stream.FlateStream(stream, maybeLength), maybeLength, params);
          }
          return new _flate_stream.FlateStream(stream, maybeLength);
        case "LZW":
        case "LZWDecode":
          let earlyChange = 1;
          if (params) {
            if (params.has("EarlyChange")) {
              earlyChange = params.get("EarlyChange");
            }
            return new _predictor_stream.PredictorStream(new _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
          }
          return new _lzw_stream.LZWStream(stream, maybeLength, earlyChange);
        case "DCT":
        case "DCTDecode":
          return new _jpeg_stream.JpegStream(stream, maybeLength, params);
        case "JPX":
        case "JPXDecode":
          return new _jpx_stream.JpxStream(stream, maybeLength, params);
        case "A85":
        case "ASCII85Decode":
          return new _ascii_85_stream.Ascii85Stream(stream, maybeLength);
        case "AHx":
        case "ASCIIHexDecode":
          return new _ascii_hex_stream.AsciiHexStream(stream, maybeLength);
        case "CCF":
        case "CCITTFaxDecode":
          return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
        case "RL":
        case "RunLengthDecode":
          return new _run_length_stream.RunLengthStream(stream, maybeLength);
        case "JBIG2Decode":
          return new _jbig2_stream.Jbig2Stream(stream, maybeLength, params);
      }
      (0, _util.warn)(`Filter "${name}" is not supported.`);
      return stream;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`Invalid stream: "${ex}"`);
      return new _stream.NullStream();
    }
  }
}
exports.Parser = Parser;
const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function toHexDigit(ch) {
  if (ch >= 0x30 && ch <= 0x39) {
    return ch & 0x0f;
  }
  if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
    return (ch & 0x0f) + 9;
  }
  return -1;
}
class Lexer {
  constructor(stream, knownCommands = null) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let ch = this.currentChar;
    let eNotation = false;
    let divideBy = 0;
    let sign = 1;
    if (ch === 0x2d) {
      sign = -1;
      ch = this.nextChar();
      if (ch === 0x2d) {
        ch = this.nextChar();
      }
    } else if (ch === 0x2b) {
      ch = this.nextChar();
    }
    if (ch === 0x0a || ch === 0x0d) {
      do {
        ch = this.nextChar();
      } while (ch === 0x0a || ch === 0x0d);
    }
    if (ch === 0x2e) {
      divideBy = 10;
      ch = this.nextChar();
    }
    if (ch < 0x30 || ch > 0x39) {
      const msg = `Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`;
      if ((0, _core_utils.isWhiteSpace)(ch) || ch === -1) {
        (0, _util.info)(`Lexer.getNumber - "${msg}".`);
        return 0;
      }
      throw new _util.FormatError(msg);
    }
    let baseValue = ch - 0x30;
    let powerValue = 0;
    let powerValueSign = 1;
    while ((ch = this.nextChar()) >= 0) {
      if (ch >= 0x30 && ch <= 0x39) {
        const currentDigit = ch - 0x30;
        if (eNotation) {
          powerValue = powerValue * 10 + currentDigit;
        } else {
          if (divideBy !== 0) {
            divideBy *= 10;
          }
          baseValue = baseValue * 10 + currentDigit;
        }
      } else if (ch === 0x2e) {
        if (divideBy === 0) {
          divideBy = 1;
        } else {
          break;
        }
      } else if (ch === 0x2d) {
        (0, _util.warn)("Badly formatted number: minus sign in the middle");
      } else if (ch === 0x45 || ch === 0x65) {
        ch = this.peekChar();
        if (ch === 0x2b || ch === 0x2d) {
          powerValueSign = ch === 0x2d ? -1 : 1;
          this.nextChar();
        } else if (ch < 0x30 || ch > 0x39) {
          break;
        }
        eNotation = true;
      } else {
        break;
      }
    }
    if (divideBy !== 0) {
      baseValue /= divideBy;
    }
    if (eNotation) {
      baseValue *= 10 ** (powerValueSign * powerValue);
    }
    return sign * baseValue;
  }
  getString() {
    let numParen = 1;
    let done = false;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.nextChar();
    while (true) {
      let charBuffered = false;
      switch (ch | 0) {
        case -1:
          (0, _util.warn)("Unterminated string");
          done = true;
          break;
        case 0x28:
          ++numParen;
          strBuf.push("(");
          break;
        case 0x29:
          if (--numParen === 0) {
            this.nextChar();
            done = true;
          } else {
            strBuf.push(")");
          }
          break;
        case 0x5c:
          ch = this.nextChar();
          switch (ch) {
            case -1:
              (0, _util.warn)("Unterminated string");
              done = true;
              break;
            case 0x6e:
              strBuf.push("\n");
              break;
            case 0x72:
              strBuf.push("\r");
              break;
            case 0x74:
              strBuf.push("\t");
              break;
            case 0x62:
              strBuf.push("\b");
              break;
            case 0x66:
              strBuf.push("\f");
              break;
            case 0x5c:
            case 0x28:
            case 0x29:
              strBuf.push(String.fromCharCode(ch));
              break;
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
              let x = ch & 0x0f;
              ch = this.nextChar();
              charBuffered = true;
              if (ch >= 0x30 && ch <= 0x37) {
                x = (x << 3) + (ch & 0x0f);
                ch = this.nextChar();
                if (ch >= 0x30 && ch <= 0x37) {
                  charBuffered = false;
                  x = (x << 3) + (ch & 0x0f);
                }
              }
              strBuf.push(String.fromCharCode(x));
              break;
            case 0x0d:
              if (this.peekChar() === 0x0a) {
                this.nextChar();
              }
              break;
            case 0x0a:
              break;
            default:
              strBuf.push(String.fromCharCode(ch));
              break;
          }
          break;
        default:
          strBuf.push(String.fromCharCode(ch));
          break;
      }
      if (done) {
        break;
      }
      if (!charBuffered) {
        ch = this.nextChar();
      }
    }
    return strBuf.join("");
  }
  getName() {
    let ch, previousCh;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      if (ch === 0x23) {
        ch = this.nextChar();
        if (specialChars[ch]) {
          (0, _util.warn)("Lexer_getName: " + "NUMBER SIGN (#) should be followed by a hexadecimal number.");
          strBuf.push("#");
          break;
        }
        const x = toHexDigit(ch);
        if (x !== -1) {
          previousCh = ch;
          ch = this.nextChar();
          const x2 = toHexDigit(ch);
          if (x2 === -1) {
            (0, _util.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) ` + "in hexadecimal number.");
            strBuf.push("#", String.fromCharCode(previousCh));
            if (specialChars[ch]) {
              break;
            }
            strBuf.push(String.fromCharCode(ch));
            continue;
          }
          strBuf.push(String.fromCharCode(x << 4 | x2));
        } else {
          strBuf.push("#", String.fromCharCode(ch));
        }
      } else {
        strBuf.push(String.fromCharCode(ch));
      }
    }
    if (strBuf.length > 127) {
      (0, _util.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
    }
    return _primitives.Name.get(strBuf.join(""));
  }
  _hexStringWarn(ch) {
    const MAX_HEX_STRING_NUM_WARN = 5;
    if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
      (0, _util.warn)("getHexString - ignoring additional invalid characters.");
      return;
    }
    if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
      return;
    }
    (0, _util.warn)(`getHexString - ignoring invalid character: ${ch}`);
  }
  getHexString() {
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.currentChar;
    let isFirstHex = true;
    let firstDigit, secondDigit;
    this._hexStringNumWarn = 0;
    while (true) {
      if (ch < 0) {
        (0, _util.warn)("Unterminated hex string");
        break;
      } else if (ch === 0x3e) {
        this.nextChar();
        break;
      } else if (specialChars[ch] === 1) {
        ch = this.nextChar();
        continue;
      } else {
        if (isFirstHex) {
          firstDigit = toHexDigit(ch);
          if (firstDigit === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continue;
          }
        } else {
          secondDigit = toHexDigit(ch);
          if (secondDigit === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continue;
          }
          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
        }
        isFirstHex = !isFirstHex;
        ch = this.nextChar();
      }
    }
    return strBuf.join("");
  }
  getObj() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch < 0) {
        return _primitives.EOF;
      }
      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (specialChars[ch] !== 1) {
        break;
      }
      ch = this.nextChar();
    }
    switch (ch | 0) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x2b:
      case 0x2d:
      case 0x2e:
        return this.getNumber();
      case 0x28:
        return this.getString();
      case 0x2f:
        return this.getName();
      case 0x5b:
        this.nextChar();
        return _primitives.Cmd.get("[");
      case 0x5d:
        this.nextChar();
        return _primitives.Cmd.get("]");
      case 0x3c:
        ch = this.nextChar();
        if (ch === 0x3c) {
          this.nextChar();
          return _primitives.Cmd.get("<<");
        }
        return this.getHexString();
      case 0x3e:
        ch = this.nextChar();
        if (ch === 0x3e) {
          this.nextChar();
          return _primitives.Cmd.get(">>");
        }
        return _primitives.Cmd.get(">");
      case 0x7b:
        this.nextChar();
        return _primitives.Cmd.get("{");
      case 0x7d:
        this.nextChar();
        return _primitives.Cmd.get("}");
      case 0x29:
        this.nextChar();
        throw new _util.FormatError(`Illegal character: ${ch}`);
    }
    let str = String.fromCharCode(ch);
    if (ch < 0x20 || ch > 0x7f) {
      const nextCh = this.peekChar();
      if (nextCh >= 0x20 && nextCh <= 0x7f) {
        this.nextChar();
        return _primitives.Cmd.get(str);
      }
    }
    const knownCommands = this.knownCommands;
    let knownCommandFound = knownCommands?.[str] !== undefined;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      const possibleCommand = str + String.fromCharCode(ch);
      if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
        break;
      }
      if (str.length === 128) {
        throw new _util.FormatError(`Command token too long: ${str.length}`);
      }
      str = possibleCommand;
      knownCommandFound = knownCommands?.[str] !== undefined;
    }
    if (str === "true") {
      return true;
    }
    if (str === "false") {
      return false;
    }
    if (str === "null") {
      return null;
    }
    if (str === "BI") {
      this.beginInlineImagePos = this.stream.pos;
    }
    return _primitives.Cmd.get(str);
  }
  skipToNextLine() {
    let ch = this.currentChar;
    while (ch >= 0) {
      if (ch === 0x0d) {
        ch = this.nextChar();
        if (ch === 0x0a) {
          this.nextChar();
        }
        break;
      } else if (ch === 0x0a) {
        this.nextChar();
        break;
      }
      ch = this.nextChar();
    }
  }
}
exports.Lexer = Lexer;
class Linearization {
  static create(stream) {
    function getInt(linDict, name, allowZeroValue = false) {
      const obj = linDict.get(name);
      if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
        return obj;
      }
      throw new Error(`The "${name}" parameter in the linearization ` + "dictionary is invalid.");
    }
    function getHints(linDict) {
      const hints = linDict.get("H");
      let hintsLength;
      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
        for (let index = 0; index < hintsLength; index++) {
          const hint = hints[index];
          if (!(Number.isInteger(hint) && hint > 0)) {
            throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
          }
        }
        return hints;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }
    const parser = new Parser({
      lexer: new Lexer(stream),
      xref: null
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    const linDict = parser.getObj();
    let obj, length;
    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && linDict instanceof _primitives.Dict && typeof (obj = linDict.get("Linearized")) === "number" && obj > 0)) {
      return null;
    } else if ((length = getInt(linDict, "L")) !== stream.length) {
      throw new Error('The "L" parameter in the linearization dictionary ' + "does not equal the stream length.");
    }
    return {
      length,
      hints: getHints(linDict),
      objectNumberFirst: getInt(linDict, "O"),
      endFirst: getInt(linDict, "E"),
      numPages: getInt(linDict, "N"),
      mainXRefEntriesOffset: getInt(linDict, "T"),
      pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
    };
  }
}
exports.Linearization = Linearization;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Ascii85Stream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _core_utils = __w_pdfjs_require__(3);
class Ascii85Stream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength *= 0.8;
    }
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);
  }
  readBlock() {
    const TILDA_CHAR = 0x7e;
    const Z_LOWER_CHAR = 0x7a;
    const EOF = -1;
    const str = this.str;
    let c = str.getByte();
    while ((0, _core_utils.isWhiteSpace)(c)) {
      c = str.getByte();
    }
    if (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }
    const bufferLength = this.bufferLength;
    let buffer, i;
    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);
      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }
      this.bufferLength += 4;
    } else {
      const input = this.input;
      input[0] = c;
      for (i = 1; i < 5; ++i) {
        c = str.getByte();
        while ((0, _core_utils.isWhiteSpace)(c)) {
          c = str.getByte();
        }
        input[i] = c;
        if (c === EOF || c === TILDA_CHAR) {
          break;
        }
      }
      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;
      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }
        this.eof = true;
      }
      let t = 0;
      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }
      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 0xff;
        t >>= 8;
      }
    }
  }
}
exports.Ascii85Stream = Ascii85Stream;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamsSequenceStream = exports.DecodeStream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _stream = __w_pdfjs_require__(8);
const emptyBuffer = new Uint8Array(0);
class DecodeStream extends _base_stream.BaseStream {
  constructor(maybeMinBufferLength) {
    super();
    this._rawMinBufferLength = maybeMinBufferLength || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;
    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }
  get isEmpty() {
    while (!this.eof && this.bufferLength === 0) {
      this.readBlock();
    }
    return this.bufferLength === 0;
  }
  ensureBuffer(requested) {
    const buffer = this.buffer;
    if (requested <= buffer.byteLength) {
      return buffer;
    }
    let size = this.minBufferLength;
    while (size < requested) {
      size *= 2;
    }
    const buffer2 = new Uint8Array(size);
    buffer2.set(buffer);
    return this.buffer = buffer2;
  }
  getByte() {
    const pos = this.pos;
    while (this.bufferLength <= pos) {
      if (this.eof) {
        return -1;
      }
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(length) {
    const pos = this.pos;
    let end;
    if (length) {
      this.ensureBuffer(pos + length);
      end = pos + length;
      while (!this.eof && this.bufferLength < end) {
        this.readBlock();
      }
      const bufEnd = this.bufferLength;
      if (end > bufEnd) {
        end = bufEnd;
      }
    } else {
      while (!this.eof) {
        this.readBlock();
      }
      end = this.bufferLength;
    }
    this.pos = end;
    return this.buffer.subarray(pos, end);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(start, length, dict = null) {
    if (length === undefined) {
      while (!this.eof) {
        this.readBlock();
      }
    } else {
      const end = start + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
    }
    return new _stream.Stream(this.buffer, start, length, dict);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
exports.DecodeStream = DecodeStream;
class StreamsSequenceStream extends DecodeStream {
  constructor(streams, onError = null) {
    let maybeLength = 0;
    for (const stream of streams) {
      maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
    }
    super(maybeLength);
    this.streams = streams;
    this._onError = onError;
  }
  readBlock() {
    const streams = this.streams;
    if (streams.length === 0) {
      this.eof = true;
      return;
    }
    const stream = streams.shift();
    let chunk;
    try {
      chunk = stream.getBytes();
    } catch (reason) {
      if (this._onError) {
        this._onError(reason, stream.dict?.objId);
        return;
      }
      throw reason;
    }
    const bufferLength = this.bufferLength;
    const newLength = bufferLength + chunk.length;
    const buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  }
  getBaseStreams() {
    const baseStreamsBuf = [];
    for (const stream of this.streams) {
      const baseStreams = stream.getBaseStreams();
      if (baseStreams) {
        baseStreamsBuf.push(...baseStreams);
      }
    }
    return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
  }
}
exports.StreamsSequenceStream = StreamsSequenceStream;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AsciiHexStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
class AsciiHexStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength *= 0.5;
    }
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;
  }
  readBlock() {
    const UPSTREAM_BLOCK_SIZE = 8000;
    const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
    if (!bytes.length) {
      this.eof = true;
      return;
    }
    const maxDecodeLength = bytes.length + 1 >> 1;
    const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    let bufferLength = this.bufferLength;
    let firstDigit = this.firstDigit;
    for (const ch of bytes) {
      let digit;
      if (ch >= 0x30 && ch <= 0x39) {
        digit = ch & 0x0f;
      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
        digit = (ch & 0x0f) + 9;
      } else if (ch === 0x3e) {
        this.eof = true;
        break;
      } else {
        continue;
      }
      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }
    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }
    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  }
}
exports.AsciiHexStream = AsciiHexStream;

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxStream = void 0;
var _ccitt = __w_pdfjs_require__(21);
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
class CCITTFaxStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    if (!(params instanceof _primitives.Dict)) {
      params = _primitives.Dict.empty;
    }
    const source = {
      next() {
        return str.getByte();
      }
    };
    this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
      K: params.get("K"),
      EndOfLine: params.get("EndOfLine"),
      EncodedByteAlign: params.get("EncodedByteAlign"),
      Columns: params.get("Columns"),
      Rows: params.get("Rows"),
      EndOfBlock: params.get("EndOfBlock"),
      BlackIs1: params.get("BlackIs1")
    });
  }
  readBlock() {
    while (!this.eof) {
      const c = this.ccittFaxDecoder.readNextChar();
      if (c === -1) {
        this.eof = true;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = c;
    }
  }
}
exports.CCITTFaxStream = CCITTFaxStream;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxDecoder = void 0;
var _util = __w_pdfjs_require__(2);
const ccittEOL = -2;
const ccittEOF = -1;
const twoDimPass = 0;
const twoDimHoriz = 1;
const twoDimVert0 = 2;
const twoDimVertR1 = 3;
const twoDimVertL1 = 4;
const twoDimVertR2 = 5;
const twoDimVertL2 = 6;
const twoDimVertR3 = 7;
const twoDimVertL3 = 8;
const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class CCITTFaxDecoder {
  constructor(source, options = {}) {
    if (!source || typeof source.next !== "function") {
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    }
    this.source = source;
    this.eof = false;
    this.encoding = options.K || 0;
    this.eoline = options.EndOfLine || false;
    this.byteAlign = options.EncodedByteAlign || false;
    this.columns = options.Columns || 1728;
    this.rows = options.Rows || 0;
    this.eoblock = options.EndOfBlock ?? true;
    this.black = options.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    let code1;
    while ((code1 = this._lookBits(12)) === 0) {
      this._eatBits(1);
    }
    if (code1 === 1) {
      this._eatBits(12);
    }
    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);
      this._eatBits(1);
    }
  }
  readNextChar() {
    if (this.eof) {
      return -1;
    }
    const refLine = this.refLine;
    const codingLine = this.codingLine;
    const columns = this.columns;
    let refPos, blackPixels, bits, i;
    if (this.outputBits === 0) {
      if (this.rowsDone) {
        this.eof = true;
      }
      if (this.eof) {
        return -1;
      }
      this.err = false;
      let code1, code2, code3;
      if (this.nextLine2D) {
        for (i = 0; codingLine[i] < columns; ++i) {
          refLine[i] = codingLine[i];
        }
        refLine[i++] = columns;
        refLine[i] = columns;
        codingLine[0] = 0;
        this.codingPos = 0;
        refPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = this._getTwoDimCode();
          switch (code1) {
            case twoDimPass:
              this._addPixels(refLine[refPos + 1], blackPixels);
              if (refLine[refPos + 1] < columns) {
                refPos += 2;
              }
              break;
            case twoDimHoriz:
              code1 = code2 = 0;
              if (blackPixels) {
                do {
                  code1 += code3 = this._getBlackCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this._getWhiteCode();
                } while (code3 >= 64);
              } else {
                do {
                  code1 += code3 = this._getWhiteCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this._getBlackCode();
                } while (code3 >= 64);
              }
              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
              if (codingLine[this.codingPos] < columns) {
                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
              }
              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                refPos += 2;
              }
              break;
            case twoDimVertR3:
              this._addPixels(refLine[refPos] + 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR2:
              this._addPixels(refLine[refPos] + 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR1:
              this._addPixels(refLine[refPos] + 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVert0:
              this._addPixels(refLine[refPos], blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL3:
              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL2:
              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL1:
              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case ccittEOF:
              this._addPixels(columns, 0);
              this.eof = true;
              break;
            default:
              (0, _util.info)("bad 2d code");
              this._addPixels(columns, 0);
              this.err = true;
          }
        }
      } else {
        codingLine[0] = 0;
        this.codingPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = 0;
          if (blackPixels) {
            do {
              code1 += code3 = this._getBlackCode();
            } while (code3 >= 64);
          } else {
            do {
              code1 += code3 = this._getWhiteCode();
            } while (code3 >= 64);
          }
          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
          blackPixels ^= 1;
        }
      }
      let gotEOL = false;
      if (this.byteAlign) {
        this.inputBits &= ~7;
      }
      if (!this.eoblock && this.row === this.rows - 1) {
        this.rowsDone = true;
      } else {
        code1 = this._lookBits(12);
        if (this.eoline) {
          while (code1 !== ccittEOF && code1 !== 1) {
            this._eatBits(1);
            code1 = this._lookBits(12);
          }
        } else {
          while (code1 === 0) {
            this._eatBits(1);
            code1 = this._lookBits(12);
          }
        }
        if (code1 === 1) {
          this._eatBits(12);
          gotEOL = true;
        } else if (code1 === ccittEOF) {
          this.eof = true;
        }
      }
      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);
        this._eatBits(1);
      }
      if (this.eoblock && gotEOL && this.byteAlign) {
        code1 = this._lookBits(12);
        if (code1 === 1) {
          this._eatBits(12);
          if (this.encoding > 0) {
            this._lookBits(1);
            this._eatBits(1);
          }
          if (this.encoding >= 0) {
            for (i = 0; i < 4; ++i) {
              code1 = this._lookBits(12);
              if (code1 !== 1) {
                (0, _util.info)("bad rtc code: " + code1);
              }
              this._eatBits(12);
              if (this.encoding > 0) {
                this._lookBits(1);
                this._eatBits(1);
              }
            }
          }
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        while (true) {
          code1 = this._lookBits(13);
          if (code1 === ccittEOF) {
            this.eof = true;
            return -1;
          }
          if (code1 >> 1 === 1) {
            break;
          }
          this._eatBits(1);
        }
        this._eatBits(12);
        if (this.encoding > 0) {
          this._eatBits(1);
          this.nextLine2D = !(code1 & 1);
        }
      }
      this.outputBits = codingLine[0] > 0 ? codingLine[this.codingPos = 0] : codingLine[this.codingPos = 1];
      this.row++;
    }
    let c;
    if (this.outputBits >= 8) {
      c = this.codingPos & 1 ? 0 : 0xff;
      this.outputBits -= 8;
      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
        this.codingPos++;
        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
      }
    } else {
      bits = 8;
      c = 0;
      do {
        if (typeof this.outputBits !== "number") {
          throw new _util.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        }
        if (this.outputBits > bits) {
          c <<= bits;
          if (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - bits;
          }
          this.outputBits -= bits;
          bits = 0;
        } else {
          c <<= this.outputBits;
          if (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - this.outputBits;
          }
          bits -= this.outputBits;
          this.outputBits = 0;
          if (codingLine[this.codingPos] < columns) {
            this.codingPos++;
            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
          } else if (bits > 0) {
            c <<= bits;
            bits = 0;
          }
        }
      } while (bits);
    }
    if (this.black) {
      c ^= 0xff;
    }
    return c;
  }
  _addPixels(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        (0, _util.info)("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  _addPixelsNeg(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        (0, _util.info)("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    } else if (a1 < codingLine[codingPos]) {
      if (a1 < 0) {
        (0, _util.info)("invalid code");
        this.err = true;
        a1 = 0;
      }
      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
        --codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  _findTableCode(start, end, table, limit) {
    const limitValue = limit || 0;
    for (let i = start; i <= end; ++i) {
      let code = this._lookBits(i);
      if (code === ccittEOF) {
        return [true, 1, false];
      }
      if (i < end) {
        code <<= end - i;
      }
      if (!limitValue || code >= limitValue) {
        const p = table[code - limitValue];
        if (p[0] === i) {
          this._eatBits(i);
          return [true, p[1], true];
        }
      }
    }
    return [false, 0, false];
  }
  _getTwoDimCode() {
    let code = 0;
    let p;
    if (this.eoblock) {
      code = this._lookBits(7);
      p = twoDimTable[code];
      if (p?.[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      const result = this._findTableCode(1, 7, twoDimTable);
      if (result[0] && result[2]) {
        return result[1];
      }
    }
    (0, _util.info)("Bad two dim code");
    return ccittEOF;
  }
  _getWhiteCode() {
    let code = 0;
    let p;
    if (this.eoblock) {
      code = this._lookBits(12);
      if (code === ccittEOF) {
        return 1;
      }
      p = code >> 5 === 0 ? whiteTable1[code] : whiteTable2[code >> 3];
      if (p[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      let result = this._findTableCode(1, 9, whiteTable2);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(11, 12, whiteTable1);
      if (result[0]) {
        return result[1];
      }
    }
    (0, _util.info)("bad white code");
    this._eatBits(1);
    return 1;
  }
  _getBlackCode() {
    let code, p;
    if (this.eoblock) {
      code = this._lookBits(13);
      if (code === ccittEOF) {
        return 1;
      }
      if (code >> 7 === 0) {
        p = blackTable1[code];
      } else if (code >> 9 === 0 && code >> 7 !== 0) {
        p = blackTable2[(code >> 1) - 64];
      } else {
        p = blackTable3[code >> 7];
      }
      if (p[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      let result = this._findTableCode(2, 6, blackTable3);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(7, 12, blackTable2, 64);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(10, 13, blackTable1);
      if (result[0]) {
        return result[1];
      }
    }
    (0, _util.info)("bad black code");
    this._eatBits(1);
    return 1;
  }
  _lookBits(n) {
    let c;
    while (this.inputBits < n) {
      if ((c = this.source.next()) === -1) {
        if (this.inputBits === 0) {
          return ccittEOF;
        }
        return this.inputBuf << n - this.inputBits & 0xffff >> 16 - n;
      }
      this.inputBuf = this.inputBuf << 8 | c;
      this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - n & 0xffff >> 16 - n;
  }
  _eatBits(n) {
    if ((this.inputBits -= n) < 0) {
      this.inputBits = 0;
    }
  }
}
exports.CCITTFaxDecoder = CCITTFaxDecoder;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FlateStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _util = __w_pdfjs_require__(2);
const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
const distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
const fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
const fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];
class FlateStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    const cmf = str.getByte();
    const flg = str.getByte();
    if (cmf === -1 || flg === -1) {
      throw new _util.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
    }
    if ((cmf & 0x0f) !== 0x08) {
      throw new _util.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
    }
    if (((cmf << 8) + flg) % 31 !== 0) {
      throw new _util.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
    }
    if (flg & 0x20) {
      throw new _util.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
    }
    this.codeSize = 0;
    this.codeBuf = 0;
  }
  getBits(bits) {
    const str = this.str;
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;
    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad encoding in flate stream");
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  }
  getCode(table) {
    const str = this.str;
    const codes = table[0];
    const maxLen = table[1];
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;
    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    const code = codes[codeBuf & (1 << maxLen) - 1];
    const codeLen = code >> 16;
    const codeVal = code & 0xffff;
    if (codeLen < 1 || codeSize < codeLen) {
      throw new _util.FormatError("Bad encoding in flate stream");
    }
    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  }
  generateHuffmanTable(lengths) {
    const n = lengths.length;
    let maxLen = 0;
    let i;
    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }
    const size = 1 << maxLen;
    const codes = new Int32Array(size);
    for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (let val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          let code2 = 0;
          let t = code;
          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }
          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }
          ++code;
        }
      }
    }
    return [codes, maxLen];
  }
  readBlock() {
    let buffer, len;
    const str = this.str;
    let hdr = this.getBits(3);
    if (hdr & 1) {
      this.eof = true;
    }
    hdr >>= 1;
    if (hdr === 0) {
      let b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }
      let blockLen = b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }
      blockLen |= b << 8;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }
      let check = b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }
      check |= b << 8;
      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
        throw new _util.FormatError("Bad uncompressed block length in flate stream");
      }
      this.codeBuf = 0;
      this.codeSize = 0;
      const bufferLength = this.bufferLength,
        end = bufferLength + blockLen;
      buffer = this.ensureBuffer(end);
      this.bufferLength = end;
      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        const block = str.getBytes(blockLen);
        buffer.set(block, bufferLength);
        if (block.length < blockLen) {
          this.eof = true;
        }
      }
      return;
    }
    let litCodeTable;
    let distCodeTable;
    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      const numLitCodes = this.getBits(5) + 257;
      const numDistCodes = this.getBits(5) + 1;
      const numCodeLenCodes = this.getBits(4) + 4;
      const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      let i;
      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }
      const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      const codes = numLitCodes + numDistCodes;
      const codeLengths = new Uint8Array(codes);
      let bitsLength, bitsOffset, what;
      while (i < codes) {
        const code = this.getCode(codeLenCodeTab);
        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }
        let repeatLength = this.getBits(bitsLength) + bitsOffset;
        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }
      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      throw new _util.FormatError("Unknown block type in flate stream");
    }
    buffer = this.buffer;
    let limit = buffer ? buffer.length : 0;
    let pos = this.bufferLength;
    while (true) {
      let code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      let code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      const dist = (code1 & 0xffff) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (let k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  }
}
exports.FlateStream = FlateStream;

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Stream = void 0;
var _base_stream = __w_pdfjs_require__(5);
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _jbig = __w_pdfjs_require__(24);
var _util = __w_pdfjs_require__(2);
class Jbig2Stream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {}
  readBlock() {
    if (this.eof) {
      return;
    }
    const jbig2Image = new _jbig.Jbig2Image();
    const chunks = [];
    if (this.params instanceof _primitives.Dict) {
      const globalsStream = this.params.get("JBIG2Globals");
      if (globalsStream instanceof _base_stream.BaseStream) {
        const globals = globalsStream.getBytes();
        chunks.push({
          data: globals,
          start: 0,
          end: globals.length
        });
      }
    }
    chunks.push({
      data: this.bytes,
      start: 0,
      end: this.bytes.length
    });
    const data = jbig2Image.parseChunks(chunks);
    const dataLength = data.length;
    for (let i = 0; i < dataLength; i++) {
      data[i] ^= 0xff;
    }
    this.buffer = data;
    this.bufferLength = dataLength;
    this.eof = true;
  }
}
exports.Jbig2Stream = Jbig2Stream;

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Image = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _arithmetic_decoder = __w_pdfjs_require__(25);
var _ccitt = __w_pdfjs_require__(21);
class Jbig2Error extends _util.BaseException {
  constructor(msg) {
    super(`JBIG2 error: ${msg}`, "Jbig2Error");
  }
}
class ContextCache {
  getContexts(id) {
    if (id in this) {
      return this[id];
    }
    return this[id] = new Int8Array(1 << 16);
  }
}
class DecodingContext {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
  }
  get decoder() {
    const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
    return (0, _util.shadow)(this, "decoder", decoder);
  }
  get contextCache() {
    const cache = new ContextCache();
    return (0, _util.shadow)(this, "contextCache", cache);
  }
}
const MAX_INT_32 = 2 ** 31 - 1;
const MIN_INT_32 = -(2 ** 31);
function decodeInteger(contextCache, procedure, decoder) {
  const contexts = contextCache.getContexts(procedure);
  let prev = 1;
  function readBits(length) {
    let v = 0;
    for (let i = 0; i < length; i++) {
      const bit = decoder.readBit(contexts, prev);
      prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
      v = v << 1 | bit;
    }
    return v >>> 0;
  }
  const sign = readBits(1);
  const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let signedValue;
  if (sign === 0) {
    signedValue = value;
  } else if (value > 0) {
    signedValue = -value;
  }
  if (signedValue >= MIN_INT_32 && signedValue <= MAX_INT_32) {
    return signedValue;
  }
  return null;
}
function decodeIAID(contextCache, decoder, codeLength) {
  const contexts = contextCache.getContexts("IAID");
  let prev = 1;
  for (let i = 0; i < codeLength; i++) {
    const bit = decoder.readBit(contexts, prev);
    prev = prev << 1 | bit;
  }
  if (codeLength < 31) {
    return prev & (1 << codeLength) - 1;
  }
  return prev & 0x7fffffff;
}
const SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
const CodingTemplates = [[{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: 2,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -3,
  y: -1
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}]];
const RefinementTemplates = [{
  coding: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: -1,
    y: 1
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}, {
  coding: [{
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}];
const ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195];
const RefinementReusedContexts = [0x0020, 0x0008];
function decodeBitmapTemplate0(width, height, decodingContext) {
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  const bitmap = [];
  let contextLabel, i, j, pixel, row, row1, row2;
  const OLD_PIXEL_MASK = 0x7bf7;
  for (i = 0; i < height; i++) {
    row = bitmap[i] = new Uint8Array(width);
    row1 = i < 1 ? row : bitmap[i - 1];
    row2 = i < 2 ? row : bitmap[i - 2];
    contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
    for (j = 0; j < width; j++) {
      row[j] = pixel = decoder.readBit(contexts, contextLabel);
      contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
    }
  }
  return bitmap;
}
function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
  if (mmr) {
    const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
    return decodeMMRBitmap(input, width, height, false);
  }
  if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
    return decodeBitmapTemplate0(width, height, decodingContext);
  }
  const useskip = !!skip;
  const template = CodingTemplates[templateIndex].concat(at);
  template.sort(function (a, b) {
    return a.y - b.y || a.x - b.x;
  });
  const templateLength = template.length;
  const templateX = new Int8Array(templateLength);
  const templateY = new Int8Array(templateLength);
  const changingTemplateEntries = [];
  let reuseMask = 0,
    minX = 0,
    maxX = 0,
    minY = 0;
  let c, k;
  for (k = 0; k < templateLength; k++) {
    templateX[k] = template[k].x;
    templateY[k] = template[k].y;
    minX = Math.min(minX, template[k].x);
    maxX = Math.max(maxX, template[k].x);
    minY = Math.min(minY, template[k].y);
    if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
      reuseMask |= 1 << templateLength - 1 - k;
    } else {
      changingTemplateEntries.push(k);
    }
  }
  const changingEntriesLength = changingTemplateEntries.length;
  const changingTemplateX = new Int8Array(changingEntriesLength);
  const changingTemplateY = new Int8Array(changingEntriesLength);
  const changingTemplateBit = new Uint16Array(changingEntriesLength);
  for (c = 0; c < changingEntriesLength; c++) {
    k = changingTemplateEntries[c];
    changingTemplateX[c] = template[k].x;
    changingTemplateY[c] = template[k].y;
    changingTemplateBit[c] = 1 << templateLength - 1 - k;
  }
  const sbb_left = -minX;
  const sbb_top = -minY;
  const sbb_right = width - maxX;
  const pseudoPixelContext = ReusedContexts[templateIndex];
  let row = new Uint8Array(width);
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  let ltp = 0,
    j,
    i0,
    j0,
    contextLabel = 0,
    bit,
    shift;
  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;
      if (ltp) {
        bitmap.push(row);
        continue;
      }
    }
    row = new Uint8Array(row);
    bitmap.push(row);
    for (j = 0; j < width; j++) {
      if (useskip && skip[i][j]) {
        row[j] = 0;
        continue;
      }
      if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
        contextLabel = contextLabel << 1 & reuseMask;
        for (k = 0; k < changingEntriesLength; k++) {
          i0 = i + changingTemplateY[k];
          j0 = j + changingTemplateX[k];
          bit = bitmap[i0][j0];
          if (bit) {
            bit = changingTemplateBit[k];
            contextLabel |= bit;
          }
        }
      } else {
        contextLabel = 0;
        shift = templateLength - 1;
        for (k = 0; k < templateLength; k++, shift--) {
          j0 = j + templateX[k];
          if (j0 >= 0 && j0 < width) {
            i0 = i + templateY[k];
            if (i0 >= 0) {
              bit = bitmap[i0][j0];
              if (bit) {
                contextLabel |= bit << shift;
              }
            }
          }
        }
      }
      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }
  return bitmap;
}
function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
  let codingTemplate = RefinementTemplates[templateIndex].coding;
  if (templateIndex === 0) {
    codingTemplate = codingTemplate.concat([at[0]]);
  }
  const codingTemplateLength = codingTemplate.length;
  const codingTemplateX = new Int32Array(codingTemplateLength);
  const codingTemplateY = new Int32Array(codingTemplateLength);
  let k;
  for (k = 0; k < codingTemplateLength; k++) {
    codingTemplateX[k] = codingTemplate[k].x;
    codingTemplateY[k] = codingTemplate[k].y;
  }
  let referenceTemplate = RefinementTemplates[templateIndex].reference;
  if (templateIndex === 0) {
    referenceTemplate = referenceTemplate.concat([at[1]]);
  }
  const referenceTemplateLength = referenceTemplate.length;
  const referenceTemplateX = new Int32Array(referenceTemplateLength);
  const referenceTemplateY = new Int32Array(referenceTemplateLength);
  for (k = 0; k < referenceTemplateLength; k++) {
    referenceTemplateX[k] = referenceTemplate[k].x;
    referenceTemplateY[k] = referenceTemplate[k].y;
  }
  const referenceWidth = referenceBitmap[0].length;
  const referenceHeight = referenceBitmap.length;
  const pseudoPixelContext = RefinementReusedContexts[templateIndex];
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GR");
  let ltp = 0;
  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;
      if (ltp) {
        throw new Jbig2Error("prediction is not supported");
      }
    }
    const row = new Uint8Array(width);
    bitmap.push(row);
    for (let j = 0; j < width; j++) {
      let i0, j0;
      let contextLabel = 0;
      for (k = 0; k < codingTemplateLength; k++) {
        i0 = i + codingTemplateY[k];
        j0 = j + codingTemplateX[k];
        if (i0 < 0 || j0 < 0 || j0 >= width) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | bitmap[i0][j0];
        }
      }
      for (k = 0; k < referenceTemplateLength; k++) {
        i0 = i + referenceTemplateY[k] - offsetY;
        j0 = j + referenceTemplateX[k] - offsetX;
        if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
        }
      }
      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }
  return bitmap;
}
function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("symbol refinement with Huffman is not supported");
  }
  const newSymbols = [];
  let currentHeight = 0;
  let symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let tableB1, symbolWidths;
  if (huffman) {
    tableB1 = getStandardTable(1);
    symbolWidths = [];
    symbolCodeLength = Math.max(symbolCodeLength, 1);
  }
  while (newSymbols.length < numberOfNewSymbols) {
    const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
    currentHeight += deltaHeight;
    let currentWidth = 0,
      totalWidth = 0;
    const firstSymbol = huffman ? symbolWidths.length : 0;
    while (true) {
      const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
      if (deltaWidth === null) {
        break;
      }
      currentWidth += deltaWidth;
      totalWidth += currentWidth;
      let bitmap;
      if (refinement) {
        const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
        if (numberOfInstances > 1) {
          bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
        } else {
          const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
          const rdx = decodeInteger(contextCache, "IARDX", decoder);
          const rdy = decodeInteger(contextCache, "IARDY", decoder);
          const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
          bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
        }
        newSymbols.push(bitmap);
      } else if (huffman) {
        symbolWidths.push(currentWidth);
      } else {
        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
        newSymbols.push(bitmap);
      }
    }
    if (huffman && !refinement) {
      const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
      huffmanInput.byteAlign();
      let collectiveBitmap;
      if (bitmapSize === 0) {
        collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
      } else {
        const originalEnd = huffmanInput.end;
        const bitmapEnd = huffmanInput.position + bitmapSize;
        huffmanInput.end = bitmapEnd;
        collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
        huffmanInput.end = originalEnd;
        huffmanInput.position = bitmapEnd;
      }
      const numberOfSymbolsDecoded = symbolWidths.length;
      if (firstSymbol === numberOfSymbolsDecoded - 1) {
        newSymbols.push(collectiveBitmap);
      } else {
        let i,
          y,
          xMin = 0,
          xMax,
          bitmapWidth,
          symbolBitmap;
        for (i = firstSymbol; i < numberOfSymbolsDecoded; i++) {
          bitmapWidth = symbolWidths[i];
          xMax = xMin + bitmapWidth;
          symbolBitmap = [];
          for (y = 0; y < currentHeight; y++) {
            symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
          }
          newSymbols.push(symbolBitmap);
          xMin = xMax;
        }
      }
    }
  }
  const exportedSymbols = [],
    flags = [];
  let currentFlag = false,
    i,
    ii;
  const totalSymbolsLength = symbols.length + numberOfNewSymbols;
  while (flags.length < totalSymbolsLength) {
    let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
    while (runLength--) {
      flags.push(currentFlag);
    }
    currentFlag = !currentFlag;
  }
  for (i = 0, ii = symbols.length; i < ii; i++) {
    if (flags[i]) {
      exportedSymbols.push(symbols[i]);
    }
  }
  for (let j = 0; j < numberOfNewSymbols; i++, j++) {
    if (flags[i]) {
      exportedSymbols.push(newSymbols[j]);
    }
  }
  return exportedSymbols;
}
function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }
  const bitmap = [];
  let i, row;
  for (i = 0; i < height; i++) {
    row = new Uint8Array(width);
    if (defaultPixelValue) {
      for (let j = 0; j < width; j++) {
        row[j] = defaultPixelValue;
      }
    }
    bitmap.push(row);
  }
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
  let firstS = 0;
  i = 0;
  while (i < numberOfSymbolInstances) {
    const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
    stripT += deltaT;
    const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
    firstS += deltaFirstS;
    let currentS = firstS;
    do {
      let currentT = 0;
      if (stripSize > 1) {
        currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
      }
      const t = stripSize * stripT + currentT;
      const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
      const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
      let symbolBitmap = inputSymbols[symbolId];
      let symbolWidth = symbolBitmap[0].length;
      let symbolHeight = symbolBitmap.length;
      if (applyRefinement) {
        const rdw = decodeInteger(contextCache, "IARDW", decoder);
        const rdh = decodeInteger(contextCache, "IARDH", decoder);
        const rdx = decodeInteger(contextCache, "IARDX", decoder);
        const rdy = decodeInteger(contextCache, "IARDY", decoder);
        symbolWidth += rdw;
        symbolHeight += rdh;
        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
      }
      const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
      const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
      let s2, t2, symbolRow;
      if (transposed) {
        for (s2 = 0; s2 < symbolHeight; s2++) {
          row = bitmap[offsetS + s2];
          if (!row) {
            continue;
          }
          symbolRow = symbolBitmap[s2];
          const maxWidth = Math.min(width - offsetT, symbolWidth);
          switch (combinationOperator) {
            case 0:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] |= symbolRow[t2];
              }
              break;
            case 2:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] ^= symbolRow[t2];
              }
              break;
            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }
        currentS += symbolHeight - 1;
      } else {
        for (t2 = 0; t2 < symbolHeight; t2++) {
          row = bitmap[offsetT + t2];
          if (!row) {
            continue;
          }
          symbolRow = symbolBitmap[t2];
          switch (combinationOperator) {
            case 0:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] |= symbolRow[s2];
              }
              break;
            case 2:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] ^= symbolRow[s2];
              }
              break;
            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }
        currentS += symbolWidth - 1;
      }
      i++;
      const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
      if (deltaS === null) {
        break;
      }
      currentS += deltaS + dsOffset;
    } while (true);
  }
  return bitmap;
}
function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
  const at = [];
  if (!mmr) {
    at.push({
      x: -patternWidth,
      y: 0
    });
    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      }, {
        x: 2,
        y: -2
      }, {
        x: -2,
        y: -2
      });
    }
  }
  const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
  const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
  const patterns = [];
  for (let i = 0; i <= maxPatternIndex; i++) {
    const patternBitmap = [];
    const xMin = patternWidth * i;
    const xMax = xMin + patternWidth;
    for (let y = 0; y < patternHeight; y++) {
      patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
    }
    patterns.push(patternBitmap);
  }
  return patterns;
}
function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
  const skip = null;
  if (enableSkip) {
    throw new Jbig2Error("skip is not supported");
  }
  if (combinationOperator !== 0) {
    throw new Jbig2Error(`operator "${combinationOperator}" is not supported in halftone region`);
  }
  const regionBitmap = [];
  let i, j, row;
  for (i = 0; i < regionHeight; i++) {
    row = new Uint8Array(regionWidth);
    if (defaultPixelValue) {
      for (j = 0; j < regionWidth; j++) {
        row[j] = defaultPixelValue;
      }
    }
    regionBitmap.push(row);
  }
  const numberOfPatterns = patterns.length;
  const pattern0 = patterns[0];
  const patternWidth = pattern0[0].length,
    patternHeight = pattern0.length;
  const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
  const at = [];
  if (!mmr) {
    at.push({
      x: template <= 1 ? 3 : 2,
      y: -1
    });
    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      }, {
        x: 2,
        y: -2
      }, {
        x: -2,
        y: -2
      });
    }
  }
  const grayScaleBitPlanes = [];
  let mmrInput, bitmap;
  if (mmr) {
    mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
  }
  for (i = bitsPerValue - 1; i >= 0; i--) {
    if (mmr) {
      bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
    } else {
      bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
    }
    grayScaleBitPlanes[i] = bitmap;
  }
  let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
  for (mg = 0; mg < gridHeight; mg++) {
    for (ng = 0; ng < gridWidth; ng++) {
      bit = 0;
      patternIndex = 0;
      for (j = bitsPerValue - 1; j >= 0; j--) {
        bit ^= grayScaleBitPlanes[j][mg][ng];
        patternIndex |= bit << j;
      }
      patternBitmap = patterns[patternIndex];
      x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
      y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
      if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
        for (i = 0; i < patternHeight; i++) {
          regionRow = regionBitmap[y + i];
          patternRow = patternBitmap[i];
          for (j = 0; j < patternWidth; j++) {
            regionRow[x + j] |= patternRow[j];
          }
        }
      } else {
        let regionX, regionY;
        for (i = 0; i < patternHeight; i++) {
          regionY = y + i;
          if (regionY < 0 || regionY >= regionHeight) {
            continue;
          }
          regionRow = regionBitmap[regionY];
          patternRow = patternBitmap[i];
          for (j = 0; j < patternWidth; j++) {
            regionX = x + j;
            if (regionX >= 0 && regionX < regionWidth) {
              regionRow[regionX] |= patternRow[j];
            }
          }
        }
      }
    }
  }
  return regionBitmap;
}
function readSegmentHeader(data, start) {
  const segmentHeader = {};
  segmentHeader.number = (0, _core_utils.readUint32)(data, start);
  const flags = data[start + 4];
  const segmentType = flags & 0x3f;
  if (!SegmentTypes[segmentType]) {
    throw new Jbig2Error("invalid segment type: " + segmentType);
  }
  segmentHeader.type = segmentType;
  segmentHeader.typeName = SegmentTypes[segmentType];
  segmentHeader.deferredNonRetain = !!(flags & 0x80);
  const pageAssociationFieldSize = !!(flags & 0x40);
  const referredFlags = data[start + 5];
  let referredToCount = referredFlags >> 5 & 7;
  const retainBits = [referredFlags & 31];
  let position = start + 6;
  if (referredFlags === 7) {
    referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 0x1fffffff;
    position += 3;
    let bytes = referredToCount + 7 >> 3;
    retainBits[0] = data[position++];
    while (--bytes > 0) {
      retainBits.push(data[position++]);
    }
  } else if (referredFlags === 5 || referredFlags === 6) {
    throw new Jbig2Error("invalid referred-to flags");
  }
  segmentHeader.retainBits = retainBits;
  let referredToSegmentNumberSize = 4;
  if (segmentHeader.number <= 256) {
    referredToSegmentNumberSize = 1;
  } else if (segmentHeader.number <= 65536) {
    referredToSegmentNumberSize = 2;
  }
  const referredTo = [];
  let i, ii;
  for (i = 0; i < referredToCount; i++) {
    let number;
    if (referredToSegmentNumberSize === 1) {
      number = data[position];
    } else if (referredToSegmentNumberSize === 2) {
      number = (0, _core_utils.readUint16)(data, position);
    } else {
      number = (0, _core_utils.readUint32)(data, position);
    }
    referredTo.push(number);
    position += referredToSegmentNumberSize;
  }
  segmentHeader.referredTo = referredTo;
  if (!pageAssociationFieldSize) {
    segmentHeader.pageAssociation = data[position++];
  } else {
    segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
    position += 4;
  }
  segmentHeader.length = (0, _core_utils.readUint32)(data, position);
  position += 4;
  if (segmentHeader.length === 0xffffffff) {
    if (segmentType === 38) {
      const genericRegionInfo = readRegionSegmentInformation(data, position);
      const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
      const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
      const searchPatternLength = 6;
      const searchPattern = new Uint8Array(searchPatternLength);
      if (!genericRegionMmr) {
        searchPattern[0] = 0xff;
        searchPattern[1] = 0xac;
      }
      searchPattern[2] = genericRegionInfo.height >>> 24 & 0xff;
      searchPattern[3] = genericRegionInfo.height >> 16 & 0xff;
      searchPattern[4] = genericRegionInfo.height >> 8 & 0xff;
      searchPattern[5] = genericRegionInfo.height & 0xff;
      for (i = position, ii = data.length; i < ii; i++) {
        let j = 0;
        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
          j++;
        }
        if (j === searchPatternLength) {
          segmentHeader.length = i + searchPatternLength;
          break;
        }
      }
      if (segmentHeader.length === 0xffffffff) {
        throw new Jbig2Error("segment end was not found");
      }
    } else {
      throw new Jbig2Error("invalid unknown segment length");
    }
  }
  segmentHeader.headerEnd = position;
  return segmentHeader;
}
function readSegments(header, data, start, end) {
  const segments = [];
  let position = start;
  while (position < end) {
    const segmentHeader = readSegmentHeader(data, position);
    position = segmentHeader.headerEnd;
    const segment = {
      header: segmentHeader,
      data
    };
    if (!header.randomAccess) {
      segment.start = position;
      position += segmentHeader.length;
      segment.end = position;
    }
    segments.push(segment);
    if (segmentHeader.type === 51) {
      break;
    }
  }
  if (header.randomAccess) {
    for (let i = 0, ii = segments.length; i < ii; i++) {
      segments[i].start = position;
      position += segments[i].header.length;
      segments[i].end = position;
    }
  }
  return segments;
}
function readRegionSegmentInformation(data, start) {
  return {
    width: (0, _core_utils.readUint32)(data, start),
    height: (0, _core_utils.readUint32)(data, start + 4),
    x: (0, _core_utils.readUint32)(data, start + 8),
    y: (0, _core_utils.readUint32)(data, start + 12),
    combinationOperator: data[start + 16] & 7
  };
}
const RegionSegmentInformationFieldLength = 17;
function processSegment(segment, visitor) {
  const header = segment.header;
  const data = segment.data,
    end = segment.end;
  let position = segment.start;
  let args, at, i, atLength;
  switch (header.type) {
    case 0:
      const dictionary = {};
      const dictionaryFlags = (0, _core_utils.readUint16)(data, position);
      dictionary.huffman = !!(dictionaryFlags & 1);
      dictionary.refinement = !!(dictionaryFlags & 2);
      dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
      dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
      dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
      dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
      dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
      dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
      dictionary.template = dictionaryFlags >> 10 & 3;
      dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
      position += 2;
      if (!dictionary.huffman) {
        atLength = dictionary.template === 0 ? 4 : 1;
        at = [];
        for (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }
        dictionary.at = at;
      }
      if (dictionary.refinement && !dictionary.refinementTemplate) {
        at = [];
        for (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }
        dictionary.refinementAt = at;
      }
      dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
      position += 4;
      dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [dictionary, header.number, header.referredTo, data, position, end];
      break;
    case 6:
    case 7:
      const textRegion = {};
      textRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
      position += 2;
      textRegion.huffman = !!(textRegionSegmentFlags & 1);
      textRegion.refinement = !!(textRegionSegmentFlags & 2);
      textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
      textRegion.stripSize = 1 << textRegion.logStripSize;
      textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
      textRegion.transposed = !!(textRegionSegmentFlags & 64);
      textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
      textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
      textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
      textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
      if (textRegion.huffman) {
        const textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
        position += 2;
        textRegion.huffmanFS = textRegionHuffmanFlags & 3;
        textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
        textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
        textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
        textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
        textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
        textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
        textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 0x4000);
      }
      if (textRegion.refinement && !textRegion.refinementTemplate) {
        at = [];
        for (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }
        textRegion.refinementAt = at;
      }
      textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [textRegion, header.referredTo, data, position, end];
      break;
    case 16:
      const patternDictionary = {};
      const patternDictionaryFlags = data[position++];
      patternDictionary.mmr = !!(patternDictionaryFlags & 1);
      patternDictionary.template = patternDictionaryFlags >> 1 & 3;
      patternDictionary.patternWidth = data[position++];
      patternDictionary.patternHeight = data[position++];
      patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [patternDictionary, header.number, data, position, end];
      break;
    case 22:
    case 23:
      const halftoneRegion = {};
      halftoneRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const halftoneRegionFlags = data[position++];
      halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
      halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
      halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
      halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
      halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
      halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
      position += 4;
      halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
      position += 4;
      halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
      position += 4;
      halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
      position += 4;
      halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
      position += 2;
      halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
      position += 2;
      args = [halftoneRegion, header.referredTo, data, position, end];
      break;
    case 38:
    case 39:
      const genericRegion = {};
      genericRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const genericRegionSegmentFlags = data[position++];
      genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
      genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
      genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
      if (!genericRegion.mmr) {
        atLength = genericRegion.template === 0 ? 4 : 1;
        at = [];
        for (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }
        genericRegion.at = at;
      }
      args = [genericRegion, data, position, end];
      break;
    case 48:
      const pageInfo = {
        width: (0, _core_utils.readUint32)(data, position),
        height: (0, _core_utils.readUint32)(data, position + 4),
        resolutionX: (0, _core_utils.readUint32)(data, position + 8),
        resolutionY: (0, _core_utils.readUint32)(data, position + 12)
      };
      if (pageInfo.height === 0xffffffff) {
        delete pageInfo.height;
      }
      const pageSegmentFlags = data[position + 16];
      (0, _core_utils.readUint16)(data, position + 17);
      pageInfo.lossless = !!(pageSegmentFlags & 1);
      pageInfo.refinement = !!(pageSegmentFlags & 2);
      pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
      pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
      pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
      pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
      args = [pageInfo];
      break;
    case 49:
      break;
    case 50:
      break;
    case 51:
      break;
    case 53:
      args = [header.number, data, position, end];
      break;
    case 62:
      break;
    default:
      throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
  }
  const callbackName = "on" + header.typeName;
  if (callbackName in visitor) {
    visitor[callbackName].apply(visitor, args);
  }
}
function processSegments(segments, visitor) {
  for (let i = 0, ii = segments.length; i < ii; i++) {
    processSegment(segments[i], visitor);
  }
}
function parseJbig2Chunks(chunks) {
  const visitor = new SimpleSegmentVisitor();
  for (let i = 0, ii = chunks.length; i < ii; i++) {
    const chunk = chunks[i];
    const segments = readSegments({}, chunk.data, chunk.start, chunk.end);
    processSegments(segments, visitor);
  }
  return visitor.buffer;
}
function parseJbig2(data) {
  throw new Error("Not implemented: parseJbig2");
}
class SimpleSegmentVisitor {
  onPageInformation(info) {
    this.currentPageInfo = info;
    const rowSize = info.width + 7 >> 3;
    const buffer = new Uint8ClampedArray(rowSize * info.height);
    if (info.defaultPixelValue) {
      buffer.fill(0xff);
    }
    this.buffer = buffer;
  }
  drawBitmap(regionInfo, bitmap) {
    const pageInfo = this.currentPageInfo;
    const width = regionInfo.width,
      height = regionInfo.height;
    const rowSize = pageInfo.width + 7 >> 3;
    const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
    const buffer = this.buffer;
    const mask0 = 128 >> (regionInfo.x & 7);
    let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
    let i, j, mask, offset;
    switch (combinationOperator) {
      case 0:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;
          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] |= mask;
            }
            mask >>= 1;
            if (!mask) {
              mask = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        break;
      case 2:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;
          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] ^= mask;
            }
            mask >>= 1;
            if (!mask) {
              mask = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        break;
      default:
        throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
    }
  }
  onImmediateGenericRegion(region, data, start, end) {
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
    let huffmanTables, huffmanInput;
    if (dictionary.huffman) {
      huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
      huffmanInput = new Reader(data, start, end);
    }
    let symbols = this.symbols;
    if (!symbols) {
      this.symbols = symbols = {};
    }
    const inputSymbols = [];
    for (const referredSegment of referredSegments) {
      const referredSymbols = symbols[referredSegment];
      if (referredSymbols) {
        inputSymbols.push(...referredSymbols);
      }
    }
    const decodingContext = new DecodingContext(data, start, end);
    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
  }
  onImmediateTextRegion(region, referredSegments, data, start, end) {
    const regionInfo = region.info;
    let huffmanTables, huffmanInput;
    const symbols = this.symbols;
    const inputSymbols = [];
    for (const referredSegment of referredSegments) {
      const referredSymbols = symbols[referredSegment];
      if (referredSymbols) {
        inputSymbols.push(...referredSymbols);
      }
    }
    const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
    if (region.huffman) {
      huffmanInput = new Reader(data, start, end);
      huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
    }
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(dictionary, currentSegment, data, start, end) {
    let patterns = this.patterns;
    if (!patterns) {
      this.patterns = patterns = {};
    }
    const decodingContext = new DecodingContext(data, start, end);
    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
  }
  onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
    const patterns = this.patterns[referredSegments[0]];
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(currentSegment, data, start, end) {
    let customTables = this.customTables;
    if (!customTables) {
      this.customTables = customTables = {};
    }
    customTables[currentSegment] = decodeTablesSegment(data, start, end);
  }
}
class HuffmanLine {
  constructor(lineData) {
    if (lineData.length === 2) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = lineData[0];
      this.rangeLength = 0;
      this.prefixCode = lineData[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = lineData[0];
      this.prefixLength = lineData[1];
      this.rangeLength = lineData[2];
      this.prefixCode = lineData[3];
      this.isLowerRange = lineData[4] === "lower";
    }
  }
}
class HuffmanTreeNode {
  constructor(line) {
    this.children = [];
    if (line) {
      this.isLeaf = true;
      this.rangeLength = line.rangeLength;
      this.rangeLow = line.rangeLow;
      this.isLowerRange = line.isLowerRange;
      this.isOOB = line.isOOB;
    } else {
      this.isLeaf = false;
    }
  }
  buildTree(line, shift) {
    const bit = line.prefixCode >> shift & 1;
    if (shift <= 0) {
      this.children[bit] = new HuffmanTreeNode(line);
    } else {
      let node = this.children[bit];
      if (!node) {
        this.children[bit] = node = new HuffmanTreeNode(null);
      }
      node.buildTree(line, shift - 1);
    }
  }
  decodeNode(reader) {
    if (this.isLeaf) {
      if (this.isOOB) {
        return null;
      }
      const htOffset = reader.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
    }
    const node = this.children[reader.readBit()];
    if (!node) {
      throw new Jbig2Error("invalid Huffman data");
    }
    return node.decodeNode(reader);
  }
}
class HuffmanTable {
  constructor(lines, prefixCodesDone) {
    if (!prefixCodesDone) {
      this.assignPrefixCodes(lines);
    }
    this.rootNode = new HuffmanTreeNode(null);
    for (let i = 0, ii = lines.length; i < ii; i++) {
      const line = lines[i];
      if (line.prefixLength > 0) {
        this.rootNode.buildTree(line, line.prefixLength - 1);
      }
    }
  }
  decode(reader) {
    return this.rootNode.decodeNode(reader);
  }
  assignPrefixCodes(lines) {
    const linesLength = lines.length;
    let prefixLengthMax = 0;
    for (let i = 0; i < linesLength; i++) {
      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
    }
    const histogram = new Uint32Array(prefixLengthMax + 1);
    for (let i = 0; i < linesLength; i++) {
      histogram[lines[i].prefixLength]++;
    }
    let currentLength = 1,
      firstCode = 0,
      currentCode,
      currentTemp,
      line;
    histogram[0] = 0;
    while (currentLength <= prefixLengthMax) {
      firstCode = firstCode + histogram[currentLength - 1] << 1;
      currentCode = firstCode;
      currentTemp = 0;
      while (currentTemp < linesLength) {
        line = lines[currentTemp];
        if (line.prefixLength === currentLength) {
          line.prefixCode = currentCode;
          currentCode++;
        }
        currentTemp++;
      }
      currentLength++;
    }
  }
}
function decodeTablesSegment(data, start, end) {
  const flags = data[start];
  const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 0xffffffff;
  const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 0xffffffff;
  const reader = new Reader(data, start + 9, end);
  const prefixSizeBits = (flags >> 1 & 7) + 1;
  const rangeSizeBits = (flags >> 4 & 7) + 1;
  const lines = [];
  let prefixLength,
    rangeLength,
    currentRangeLow = lowestValue;
  do {
    prefixLength = reader.readBits(prefixSizeBits);
    rangeLength = reader.readBits(rangeSizeBits);
    lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
    currentRangeLow += 1 << rangeLength;
  } while (currentRangeLow < highestValue);
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
  if (flags & 1) {
    prefixLength = reader.readBits(prefixSizeBits);
    lines.push(new HuffmanLine([prefixLength, 0]));
  }
  return new HuffmanTable(lines, false);
}
const standardTablesCache = {};
function getStandardTable(number) {
  let table = standardTablesCache[number];
  if (table) {
    return table;
  }
  let lines;
  switch (number) {
    case 1:
      lines = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]];
      break;
    case 2:
      lines = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]];
      break;
    case 3:
      lines = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, "lower"], [75, 7, 32, 0x7e], [6, 0x3e]];
      break;
    case 4:
      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]];
      break;
    case 5:
      lines = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, "lower"], [76, 6, 32, 0x3e]];
      break;
    case 6:
      lines = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, "lower"], [2048, 6, 32, 0x3f]];
      break;
    case 7:
      lines = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, "lower"], [2048, 5, 32, 0x1f]];
      break;
    case 8:
      lines = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, "lower"], [1670, 9, 32, 0x1ff], [2, 0x1]];
      break;
    case 9:
      lines = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, "lower"], [3339, 9, 32, 0x1ff], [2, 0x0]];
      break;
    case 10:
      lines = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, "lower"], [4166, 8, 32, 0xff], [2, 0x2]];
      break;
    case 11:
      lines = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      break;
    case 12:
      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]];
      break;
    case 13:
      lines = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      break;
    case 14:
      lines = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]];
      break;
    case 15:
      lines = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, "lower"], [25, 7, 32, 0x7f]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${number} does not exist`);
  }
  for (let i = 0, ii = lines.length; i < ii; i++) {
    lines[i] = new HuffmanLine(lines[i]);
  }
  table = new HuffmanTable(lines, true);
  standardTablesCache[number] = table;
  return table;
}
class Reader {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
    this.position = start;
    this.shift = -1;
    this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) {
        throw new Jbig2Error("end of data while reading bit");
      }
      this.currentByte = this.data[this.position++];
      this.shift = 7;
    }
    const bit = this.currentByte >> this.shift & 1;
    this.shift--;
    return bit;
  }
  readBits(numBits) {
    let result = 0,
      i;
    for (i = numBits - 1; i >= 0; i--) {
      result |= this.readBit() << i;
    }
    return result;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    if (this.position >= this.end) {
      return -1;
    }
    return this.data[this.position++];
  }
}
function getCustomHuffmanTable(index, referredTo, customTables) {
  let currentIndex = 0;
  for (let i = 0, ii = referredTo.length; i < ii; i++) {
    const table = customTables[referredTo[i]];
    if (table) {
      if (index === currentIndex) {
        return table;
      }
      currentIndex++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
  const codes = [];
  for (let i = 0; i <= 34; i++) {
    const codeLength = reader.readBits(4);
    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
  }
  const runCodesTable = new HuffmanTable(codes, false);
  codes.length = 0;
  for (let i = 0; i < numberOfSymbols;) {
    const codeLength = runCodesTable.decode(reader);
    if (codeLength >= 32) {
      let repeatedLength, numberOfRepeats, j;
      switch (codeLength) {
        case 32:
          if (i === 0) {
            throw new Jbig2Error("no previous value in symbol ID table");
          }
          numberOfRepeats = reader.readBits(2) + 3;
          repeatedLength = codes[i - 1].prefixLength;
          break;
        case 33:
          numberOfRepeats = reader.readBits(3) + 3;
          repeatedLength = 0;
          break;
        case 34:
          numberOfRepeats = reader.readBits(7) + 11;
          repeatedLength = 0;
          break;
        default:
          throw new Jbig2Error("invalid code length in symbol ID table");
      }
      for (j = 0; j < numberOfRepeats; j++) {
        codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
        i++;
      }
    } else {
      codes.push(new HuffmanLine([i, codeLength, 0, 0]));
      i++;
    }
  }
  reader.byteAlign();
  const symbolIDTable = new HuffmanTable(codes, false);
  let customIndex = 0,
    tableFirstS,
    tableDeltaS,
    tableDeltaT;
  switch (textRegion.huffmanFS) {
    case 0:
    case 1:
      tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
      break;
    case 3:
      tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman FS selector");
  }
  switch (textRegion.huffmanDS) {
    case 0:
    case 1:
    case 2:
      tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
      break;
    case 3:
      tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DS selector");
  }
  switch (textRegion.huffmanDT) {
    case 0:
    case 1:
    case 2:
      tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
      break;
    case 3:
      tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DT selector");
  }
  if (textRegion.refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }
  return {
    symbolIDTable,
    tableFirstS,
    tableDeltaS,
    tableDeltaT
  };
}
function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
  let customIndex = 0,
    tableDeltaHeight,
    tableDeltaWidth;
  switch (dictionary.huffmanDHSelector) {
    case 0:
    case 1:
      tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
      break;
    case 3:
      tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DH selector");
  }
  switch (dictionary.huffmanDWSelector) {
    case 0:
    case 1:
      tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
      break;
    case 3:
      tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DW selector");
  }
  let tableBitmapSize, tableAggregateInstances;
  if (dictionary.bitmapSizeSelector) {
    tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
    customIndex++;
  } else {
    tableBitmapSize = getStandardTable(1);
  }
  if (dictionary.aggregationInstancesSelector) {
    tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
  } else {
    tableAggregateInstances = getStandardTable(1);
  }
  return {
    tableDeltaHeight,
    tableDeltaWidth,
    tableBitmapSize,
    tableAggregateInstances
  };
}
function readUncompressedBitmap(reader, width, height) {
  const bitmap = [];
  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);
    for (let x = 0; x < width; x++) {
      row[x] = reader.readBit();
    }
    reader.byteAlign();
  }
  return bitmap;
}
function decodeMMRBitmap(input, width, height, endOfBlock) {
  const params = {
    K: -1,
    Columns: width,
    Rows: height,
    BlackIs1: true,
    EndOfBlock: endOfBlock
  };
  const decoder = new _ccitt.CCITTFaxDecoder(input, params);
  const bitmap = [];
  let currentByte,
    eof = false;
  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);
    let shift = -1;
    for (let x = 0; x < width; x++) {
      if (shift < 0) {
        currentByte = decoder.readNextChar();
        if (currentByte === -1) {
          currentByte = 0;
          eof = true;
        }
        shift = 7;
      }
      row[x] = currentByte >> shift & 1;
      shift--;
    }
  }
  if (endOfBlock && !eof) {
    const lookForEOFLimit = 5;
    for (let i = 0; i < lookForEOFLimit; i++) {
      if (decoder.readNextChar() === -1) {
        break;
      }
    }
  }
  return bitmap;
}
class Jbig2Image {
  parseChunks(chunks) {
    return parseJbig2Chunks(chunks);
  }
  parse(data) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
exports.Jbig2Image = Jbig2Image;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ArithmeticDecoder = void 0;
const QeTable = [{
  qe: 0x5601,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 0x3401,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x5101,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x3401,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2801,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x2201,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 0x1401,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 0x1201,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 0x1101,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 0x09c1,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x08a1,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 0x0441,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 0x02a1,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 0x0141,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 0x0111,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 0x0085,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 0x0049,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 0x0025,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 0x0015,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 0x0009,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 0x0005,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 0x0001,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];
class ArithmeticDecoder {
  constructor(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;
    this.chigh = data[start];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 0xffff | this.clow >> 9 & 0x7f;
    this.clow = this.clow << 7 & 0xffff;
    this.ct -= 7;
    this.a = 0x8000;
  }
  byteIn() {
    const data = this.data;
    let bp = this.bp;
    if (data[bp] === 0xff) {
      if (data[bp + 1] > 0x8f) {
        this.clow += 0xff00;
        this.ct = 8;
      } else {
        bp++;
        this.clow += data[bp] << 9;
        this.ct = 7;
        this.bp = bp;
      }
    } else {
      bp++;
      this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xff00;
      this.ct = 8;
      this.bp = bp;
    }
    if (this.clow > 0xffff) {
      this.chigh += this.clow >> 16;
      this.clow &= 0xffff;
    }
  }
  readBit(contexts, pos) {
    let cx_index = contexts[pos] >> 1,
      cx_mps = contexts[pos] & 1;
    const qeTableIcx = QeTable[cx_index];
    const qeIcx = qeTableIcx.qe;
    let d;
    let a = this.a - qeIcx;
    if (this.chigh < qeIcx) {
      if (a < qeIcx) {
        a = qeIcx;
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      } else {
        a = qeIcx;
        d = 1 ^ cx_mps;
        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      }
    } else {
      this.chigh -= qeIcx;
      if ((a & 0x8000) !== 0) {
        this.a = a;
        return cx_mps;
      }
      if (a < qeIcx) {
        d = 1 ^ cx_mps;
        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      } else {
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      }
    }
    do {
      if (this.ct === 0) {
        this.byteIn();
      }
      a <<= 1;
      this.chigh = this.chigh << 1 & 0xffff | this.clow >> 15 & 1;
      this.clow = this.clow << 1 & 0xffff;
      this.ct--;
    } while ((a & 0x8000) === 0);
    this.a = a;
    contexts[pos] = cx_index << 1 | cx_mps;
    return d;
  }
}
exports.ArithmeticDecoder = ArithmeticDecoder;

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _jpg = __w_pdfjs_require__(27);
var _util = __w_pdfjs_require__(2);
class JpegStream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === 0xff) {
        stream.skip(-1);
        break;
      }
    }
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {}
  readBlock() {
    if (this.eof) {
      return;
    }
    const jpegOptions = {
      decodeTransform: undefined,
      colorTransform: undefined
    };
    const decodeArr = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(decodeArr)) {
      const bitsPerComponent = this.dict.get("BPC", "BitsPerComponent") || 8;
      const decodeArrLength = decodeArr.length;
      const transform = new Int32Array(decodeArrLength);
      let transformNeeded = false;
      const maxValue = (1 << bitsPerComponent) - 1;
      for (let i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;
        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }
      if (transformNeeded) {
        jpegOptions.decodeTransform = transform;
      }
    }
    if (this.params instanceof _primitives.Dict) {
      const colorTransform = this.params.get("ColorTransform");
      if (Number.isInteger(colorTransform)) {
        jpegOptions.colorTransform = colorTransform;
      }
    }
    const jpegImage = new _jpg.JpegImage(jpegOptions);
    jpegImage.parse(this.bytes);
    const data = jpegImage.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGBA: this.forceRGBA,
      forceRGB: this.forceRGB,
      isSourcePDF: true
    });
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  }
}
exports.JpegStream = JpegStream;

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegImage = void 0;
var _util = __w_pdfjs_require__(2);
var _image_utils = __w_pdfjs_require__(28);
var _core_utils = __w_pdfjs_require__(3);
class JpegError extends _util.BaseException {
  constructor(msg) {
    super(`JPEG error: ${msg}`, "JpegError");
  }
}
class DNLMarkerError extends _util.BaseException {
  constructor(message, scanLines) {
    super(message, "DNLMarkerError");
    this.scanLines = scanLines;
  }
}
class EOIMarkerError extends _util.BaseException {
  constructor(msg) {
    super(msg, "EOIMarkerError");
  }
}
const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
const dctCos1 = 4017;
const dctSin1 = 799;
const dctCos3 = 3406;
const dctSin3 = 2276;
const dctCos6 = 1567;
const dctSin6 = 3784;
const dctSqrt2 = 5793;
const dctSqrt1d2 = 2896;
function buildHuffmanTable(codeLengths, values) {
  let k = 0,
    i,
    j,
    length = 16;
  while (length > 0 && !codeLengths[length - 1]) {
    length--;
  }
  const code = [{
    children: [],
    index: 0
  }];
  let p = code[0],
    q;
  for (i = 0; i < length; i++) {
    for (j = 0; j < codeLengths[i]; j++) {
      p = code.pop();
      p.children[p.index] = values[k];
      while (p.index > 0) {
        p = code.pop();
      }
      p.index++;
      code.push(p);
      while (code.length <= i) {
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }
      k++;
    }
    if (i + 1 < length) {
      code.push(q = {
        children: [],
        index: 0
      });
      p.children[p.index] = q.children;
      p = q;
    }
  }
  return code[0].children;
}
function getBlockBufferOffset(component, row, col) {
  return 64 * ((component.blocksPerLine + 1) * row + col);
}
function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
  const mcusPerLine = frame.mcusPerLine;
  const progressive = frame.progressive;
  const startOffset = offset;
  let bitsData = 0,
    bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }
    bitsData = data[offset++];
    if (bitsData === 0xff) {
      const nextByte = data[offset++];
      if (nextByte) {
        if (nextByte === 0xdc && parseDNLMarker) {
          offset += 2;
          const scanLines = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          if (scanLines > 0 && scanLines !== frame.scanLines) {
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
          }
        } else if (nextByte === 0xd9) {
          if (parseDNLMarker) {
            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 5) {
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, " + "possibly caused by incorrect `scanLines` parameter", maybeScanLines);
            }
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node = tree;
    while (true) {
      node = node[readBit()];
      switch (typeof node) {
        case "number":
          return node;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(length) {
    let n = 0;
    while (length > 0) {
      n = n << 1 | readBit();
      length--;
    }
    return n;
  }
  function receiveAndExtend(length) {
    if (length === 1) {
      return readBit() === 1 ? 1 : -1;
    }
    const n = receive(length);
    if (n >= 1 << length - 1) {
      return n;
    }
    return n + (-1 << length) + 1;
  }
  function decodeBaseline(component, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    component.blockData[blockOffset] = component.pred += diff;
    let k = 1;
    while (k < 64) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
        r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          break;
        }
        k += 16;
        continue;
      }
      k += r;
      const z = dctZigZag[k];
      component.blockData[blockOffset + z] = receiveAndExtend(s);
      k++;
    }
  }
  function decodeDCFirst(component, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
    component.blockData[blockOffset] = component.pred += diff;
  }
  function decodeDCSuccessive(component, blockOffset) {
    component.blockData[blockOffset] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component, blockOffset) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k = spectralStart;
    const e = spectralEnd;
    while (k <= e) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
        r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }
        k += 16;
        continue;
      }
      k += r;
      const z = dctZigZag[k];
      component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
      k++;
    }
  }
  let successiveACState = 0,
    successiveACNextValue;
  function decodeACSuccessive(component, blockOffset) {
    let k = spectralStart;
    const e = spectralEnd;
    let r = 0;
    let s;
    let rs;
    while (k <= e) {
      const offsetZ = blockOffset + dctZigZag[k];
      const sign = component.blockData[offsetZ] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0:
          rs = decodeHuffman(component.huffmanTableAC);
          s = rs & 15;
          r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1) {
              throw new JpegError("invalid ACn encoding");
            }
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            r--;
            if (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            component.blockData[offsetZ] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          }
          break;
      }
      k++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  let blockRow = 0;
  function decodeMcu(component, decode, mcu, row, col) {
    const mcuRow = mcu / mcusPerLine | 0;
    const mcuCol = mcu % mcusPerLine;
    blockRow = mcuRow * component.v + row;
    const blockCol = mcuCol * component.h + col;
    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
    decode(component, blockOffset);
  }
  function decodeBlock(component, decode, mcu) {
    blockRow = mcu / component.blocksPerLine | 0;
    const blockCol = mcu % component.blocksPerLine;
    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
    decode(component, blockOffset);
  }
  const componentsLength = components.length;
  let component, i, j, k, n;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }
  let mcu = 0,
    fileMarker;
  const mcuExpected = componentsLength === 1 ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn;
  let h, v;
  while (mcu <= mcuExpected) {
    const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
    if (mcuToRead > 0) {
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;
      if (componentsLength === 1) {
        component = components[0];
        for (n = 0; n < mcuToRead; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < mcuToRead; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }
    }
    bitsCount = 0;
    fileMarker = findNextFileMarker(data, offset);
    if (!fileMarker) {
      break;
    }
    if (fileMarker.invalid) {
      const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
      (0, _util.warn)(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);
      offset = fileMarker.offset;
    }
    if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
      offset += 2;
    } else {
      break;
    }
  }
  return offset - startOffset;
}
function quantizeAndInverse(component, blockBufferOffset, p) {
  const qt = component.quantizationTable,
    blockData = component.blockData;
  let v0, v1, v2, v3, v4, v5, v6, v7;
  let p0, p1, p2, p3, p4, p5, p6, p7;
  let t;
  if (!qt) {
    throw new JpegError("missing required Quantization Table.");
  }
  for (let row = 0; row < 64; row += 8) {
    p0 = blockData[blockBufferOffset + row];
    p1 = blockData[blockBufferOffset + row + 1];
    p2 = blockData[blockBufferOffset + row + 2];
    p3 = blockData[blockBufferOffset + row + 3];
    p4 = blockData[blockBufferOffset + row + 4];
    p5 = blockData[blockBufferOffset + row + 5];
    p6 = blockData[blockBufferOffset + row + 6];
    p7 = blockData[blockBufferOffset + row + 7];
    p0 *= qt[row];
    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 512 >> 10;
      p[row] = t;
      p[row + 1] = t;
      p[row + 2] = t;
      p[row + 3] = t;
      p[row + 4] = t;
      p[row + 5] = t;
      p[row + 6] = t;
      p[row + 7] = t;
      continue;
    }
    p1 *= qt[row + 1];
    p2 *= qt[row + 2];
    p3 *= qt[row + 3];
    p4 *= qt[row + 4];
    p5 *= qt[row + 5];
    p6 *= qt[row + 6];
    p7 *= qt[row + 7];
    v0 = dctSqrt2 * p0 + 128 >> 8;
    v1 = dctSqrt2 * p4 + 128 >> 8;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
    v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
    v5 = p3 << 4;
    v6 = p5 << 4;
    v0 = v0 + v1 + 1 >> 1;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p[row] = v0 + v7;
    p[row + 7] = v0 - v7;
    p[row + 1] = v1 + v6;
    p[row + 6] = v1 - v6;
    p[row + 2] = v2 + v5;
    p[row + 5] = v2 - v5;
    p[row + 3] = v3 + v4;
    p[row + 4] = v3 - v4;
  }
  for (let col = 0; col < 8; ++col) {
    p0 = p[col];
    p1 = p[col + 8];
    p2 = p[col + 16];
    p3 = p[col + 24];
    p4 = p[col + 32];
    p5 = p[col + 40];
    p6 = p[col + 48];
    p7 = p[col + 56];
    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 8192 >> 14;
      if (t < -2040) {
        t = 0;
      } else if (t >= 2024) {
        t = 255;
      } else {
        t = t + 2056 >> 4;
      }
      blockData[blockBufferOffset + col] = t;
      blockData[blockBufferOffset + col + 8] = t;
      blockData[blockBufferOffset + col + 16] = t;
      blockData[blockBufferOffset + col + 24] = t;
      blockData[blockBufferOffset + col + 32] = t;
      blockData[blockBufferOffset + col + 40] = t;
      blockData[blockBufferOffset + col + 48] = t;
      blockData[blockBufferOffset + col + 56] = t;
      continue;
    }
    v0 = dctSqrt2 * p0 + 2048 >> 12;
    v1 = dctSqrt2 * p4 + 2048 >> 12;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
    v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
    v5 = p3;
    v6 = p5;
    v0 = (v0 + v1 + 1 >> 1) + 4112;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p0 = v0 + v7;
    p7 = v0 - v7;
    p1 = v1 + v6;
    p6 = v1 - v6;
    p2 = v2 + v5;
    p5 = v2 - v5;
    p3 = v3 + v4;
    p4 = v3 - v4;
    if (p0 < 16) {
      p0 = 0;
    } else if (p0 >= 4080) {
      p0 = 255;
    } else {
      p0 >>= 4;
    }
    if (p1 < 16) {
      p1 = 0;
    } else if (p1 >= 4080) {
      p1 = 255;
    } else {
      p1 >>= 4;
    }
    if (p2 < 16) {
      p2 = 0;
    } else if (p2 >= 4080) {
      p2 = 255;
    } else {
      p2 >>= 4;
    }
    if (p3 < 16) {
      p3 = 0;
    } else if (p3 >= 4080) {
      p3 = 255;
    } else {
      p3 >>= 4;
    }
    if (p4 < 16) {
      p4 = 0;
    } else if (p4 >= 4080) {
      p4 = 255;
    } else {
      p4 >>= 4;
    }
    if (p5 < 16) {
      p5 = 0;
    } else if (p5 >= 4080) {
      p5 = 255;
    } else {
      p5 >>= 4;
    }
    if (p6 < 16) {
      p6 = 0;
    } else if (p6 >= 4080) {
      p6 = 255;
    } else {
      p6 >>= 4;
    }
    if (p7 < 16) {
      p7 = 0;
    } else if (p7 >= 4080) {
      p7 = 255;
    } else {
      p7 >>= 4;
    }
    blockData[blockBufferOffset + col] = p0;
    blockData[blockBufferOffset + col + 8] = p1;
    blockData[blockBufferOffset + col + 16] = p2;
    blockData[blockBufferOffset + col + 24] = p3;
    blockData[blockBufferOffset + col + 32] = p4;
    blockData[blockBufferOffset + col + 40] = p5;
    blockData[blockBufferOffset + col + 48] = p6;
    blockData[blockBufferOffset + col + 56] = p7;
  }
}
function buildComponentData(frame, component) {
  const blocksPerLine = component.blocksPerLine;
  const blocksPerColumn = component.blocksPerColumn;
  const computationBuffer = new Int16Array(64);
  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      const offset = getBlockBufferOffset(component, blockRow, blockCol);
      quantizeAndInverse(component, offset, computationBuffer);
    }
  }
  return component.blockData;
}
function findNextFileMarker(data, currentPos, startPos = currentPos) {
  const maxPos = data.length - 1;
  let newPos = startPos < currentPos ? startPos : currentPos;
  if (currentPos >= maxPos) {
    return null;
  }
  const currentMarker = (0, _core_utils.readUint16)(data, currentPos);
  if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
    return {
      invalid: null,
      marker: currentMarker,
      offset: currentPos
    };
  }
  let newMarker = (0, _core_utils.readUint16)(data, newPos);
  while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
    if (++newPos >= maxPos) {
      return null;
    }
    newMarker = (0, _core_utils.readUint16)(data, newPos);
  }
  return {
    invalid: currentMarker.toString(16),
    marker: newMarker,
    offset: newPos
  };
}
class JpegImage {
  constructor({
    decodeTransform = null,
    colorTransform = -1
  } = {}) {
    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }
  parse(data, {
    dnlScanLines = null
  } = {}) {
    function readDataBlock() {
      const length = (0, _core_utils.readUint16)(data, offset);
      offset += 2;
      let endOffset = offset + length - 2;
      const fileMarker = findNextFileMarker(data, endOffset, offset);
      if (fileMarker?.invalid) {
        (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker.invalid);
        endOffset = fileMarker.offset;
      }
      const array = data.subarray(offset, endOffset);
      offset += array.length;
      return array;
    }
    function prepareComponents(frame) {
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
      for (const component of frame.components) {
        const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
        const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
        const blocksPerLineForMcu = mcusPerLine * component.h;
        const blocksPerColumnForMcu = mcusPerColumn * component.v;
        const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
        component.blockData = new Int16Array(blocksBufferSize);
        component.blocksPerLine = blocksPerLine;
        component.blocksPerColumn = blocksPerColumn;
      }
      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }
    let offset = 0;
    let jfif = null;
    let adobe = null;
    let frame, resetInterval;
    let numSOSMarkers = 0;
    const quantizationTables = [];
    const huffmanTablesAC = [],
      huffmanTablesDC = [];
    let fileMarker = (0, _core_utils.readUint16)(data, offset);
    offset += 2;
    if (fileMarker !== 0xffd8) {
      throw new JpegError("SOI not found");
    }
    fileMarker = (0, _core_utils.readUint16)(data, offset);
    offset += 2;
    markerLoop: while (fileMarker !== 0xffd9) {
      let i, j, l;
      switch (fileMarker) {
        case 0xffe0:
        case 0xffe1:
        case 0xffe2:
        case 0xffe3:
        case 0xffe4:
        case 0xffe5:
        case 0xffe6:
        case 0xffe7:
        case 0xffe8:
        case 0xffe9:
        case 0xffea:
        case 0xffeb:
        case 0xffec:
        case 0xffed:
        case 0xffee:
        case 0xffef:
        case 0xfffe:
          const appData = readDataBlock();
          if (fileMarker === 0xffe0) {
            if (appData[0] === 0x4a && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
              jfif = {
                version: {
                  major: appData[5],
                  minor: appData[6]
                },
                densityUnits: appData[7],
                xDensity: appData[8] << 8 | appData[9],
                yDensity: appData[10] << 8 | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
              };
            }
          }
          if (fileMarker === 0xffee) {
            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6f && appData[3] === 0x62 && appData[4] === 0x65) {
              adobe = {
                version: appData[5] << 8 | appData[6],
                flags0: appData[7] << 8 | appData[8],
                flags1: appData[9] << 8 | appData[10],
                transformCode: appData[11]
              };
            }
          }
          break;
        case 0xffdb:
          const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
          let z;
          while (offset < quantizationTablesEnd) {
            const quantizationTableSpec = data[offset++];
            const tableData = new Uint16Array(64);
            if (quantizationTableSpec >> 4 === 0) {
              for (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = data[offset++];
              }
            } else if (quantizationTableSpec >> 4 === 1) {
              for (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = (0, _core_utils.readUint16)(data, offset);
                offset += 2;
              }
            } else {
              throw new JpegError("DQT - invalid table spec");
            }
            quantizationTables[quantizationTableSpec & 15] = tableData;
          }
          break;
        case 0xffc0:
        case 0xffc1:
        case 0xffc2:
          if (frame) {
            throw new JpegError("Only single frame JPEGs supported");
          }
          offset += 2;
          frame = {};
          frame.extended = fileMarker === 0xffc1;
          frame.progressive = fileMarker === 0xffc2;
          frame.precision = data[offset++];
          const sofScanLines = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          frame.scanLines = dnlScanLines || sofScanLines;
          frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          frame.components = [];
          frame.componentIds = {};
          const componentsCount = data[offset++];
          let maxH = 0,
            maxV = 0;
          for (i = 0; i < componentsCount; i++) {
            const componentId = data[offset];
            const h = data[offset + 1] >> 4;
            const v = data[offset + 1] & 15;
            if (maxH < h) {
              maxH = h;
            }
            if (maxV < v) {
              maxV = v;
            }
            const qId = data[offset + 2];
            l = frame.components.push({
              h,
              v,
              quantizationId: qId,
              quantizationTable: null
            });
            frame.componentIds[componentId] = l - 1;
            offset += 3;
          }
          frame.maxH = maxH;
          frame.maxV = maxV;
          prepareComponents(frame);
          break;
        case 0xffc4:
          const huffmanLength = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          for (i = 2; i < huffmanLength;) {
            const huffmanTableSpec = data[offset++];
            const codeLengths = new Uint8Array(16);
            let codeLengthSum = 0;
            for (j = 0; j < 16; j++, offset++) {
              codeLengthSum += codeLengths[j] = data[offset];
            }
            const huffmanValues = new Uint8Array(codeLengthSum);
            for (j = 0; j < codeLengthSum; j++, offset++) {
              huffmanValues[j] = data[offset];
            }
            i += 17 + codeLengthSum;
            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
          }
          break;
        case 0xffdd:
          offset += 2;
          resetInterval = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          break;
        case 0xffda:
          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
          offset += 2;
          const selectorsCount = data[offset++],
            components = [];
          for (i = 0; i < selectorsCount; i++) {
            const index = data[offset++];
            const componentIndex = frame.componentIds[index];
            const component = frame.components[componentIndex];
            component.index = index;
            const tableSpec = data[offset++];
            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
            components.push(component);
          }
          const spectralStart = data[offset++],
            spectralEnd = data[offset++],
            successiveApproximation = data[offset++];
          try {
            const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
            offset += processed;
          } catch (ex) {
            if (ex instanceof DNLMarkerError) {
              (0, _util.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
              return this.parse(data, {
                dnlScanLines: ex.scanLines
              });
            } else if (ex instanceof EOIMarkerError) {
              (0, _util.warn)(`${ex.message} -- ignoring the rest of the image data.`);
              break markerLoop;
            }
            throw ex;
          }
          break;
        case 0xffdc:
          offset += 4;
          break;
        case 0xffff:
          if (data[offset] !== 0xff) {
            offset--;
          }
          break;
        default:
          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);
          if (nextFileMarker?.invalid) {
            (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
            offset = nextFileMarker.offset;
            break;
          }
          if (!nextFileMarker || offset >= data.length - 1) {
            (0, _util.warn)("JpegImage.parse - reached the end of the image data " + "without finding an EOI marker (0xFFD9).");
            break markerLoop;
          }
          throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
      }
      fileMarker = (0, _core_utils.readUint16)(data, offset);
      offset += 2;
    }
    this.width = frame.samplesPerLine;
    this.height = frame.scanLines;
    this.jfif = jfif;
    this.adobe = adobe;
    this.components = [];
    for (const component of frame.components) {
      const quantizationTable = quantizationTables[component.quantizationId];
      if (quantizationTable) {
        component.quantizationTable = quantizationTable;
      }
      this.components.push({
        index: component.index,
        output: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV,
        blocksPerLine: component.blocksPerLine,
        blocksPerColumn: component.blocksPerColumn
      });
    }
    this.numComponents = this.components.length;
    return undefined;
  }
  _getLinearizedBlockData(width, height, isSourcePDF = false) {
    const scaleX = this.width / width,
      scaleY = this.height / height;
    let component, componentScaleX, componentScaleY, blocksPerScanline;
    let x, y, i, j, k;
    let index;
    let offset = 0;
    let output;
    const numComponents = this.components.length;
    const dataLength = width * height * numComponents;
    const data = new Uint8ClampedArray(dataLength);
    const xScaleBlockOffset = new Uint32Array(width);
    const mask3LSB = 0xfffffff8;
    let lastComponentScaleX;
    for (i = 0; i < numComponents; i++) {
      component = this.components[i];
      componentScaleX = component.scaleX * scaleX;
      componentScaleY = component.scaleY * scaleY;
      offset = i;
      output = component.output;
      blocksPerScanline = component.blocksPerLine + 1 << 3;
      if (componentScaleX !== lastComponentScaleX) {
        for (x = 0; x < width; x++) {
          j = 0 | x * componentScaleX;
          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
        }
        lastComponentScaleX = componentScaleX;
      }
      for (y = 0; y < height; y++) {
        j = 0 | y * componentScaleY;
        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
        for (x = 0; x < width; x++) {
          data[offset] = output[index + xScaleBlockOffset[x]];
          offset += numComponents;
        }
      }
    }
    let transform = this._decodeTransform;
    if (!isSourcePDF && numComponents === 4 && !transform) {
      transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
    }
    if (transform) {
      for (i = 0; i < dataLength;) {
        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
          data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
        }
      }
    }
    return data;
  }
  get _isColorConversionNeeded() {
    if (this.adobe) {
      return !!this.adobe.transformCode;
    }
    if (this.numComponents === 3) {
      if (this._colorTransform === 0) {
        return false;
      } else if (this.components[0].index === 0x52 && this.components[1].index === 0x47 && this.components[2].index === 0x42) {
        return false;
      }
      return true;
    }
    if (this._colorTransform === 1) {
      return true;
    }
    return false;
  }
  _convertYccToRgb(data) {
    let Y, Cb, Cr;
    for (let i = 0, length = data.length; i < length; i += 3) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = Y - 179.456 + 1.402 * Cr;
      data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
      data[i + 2] = Y - 226.816 + 1.772 * Cb;
    }
    return data;
  }
  _convertYccToRgba(data, out) {
    for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {
      const Y = data[i];
      const Cb = data[i + 1];
      const Cr = data[i + 2];
      out[j] = Y - 179.456 + 1.402 * Cr;
      out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
      out[j + 2] = Y - 226.816 + 1.772 * Cb;
      out[j + 3] = 255;
    }
    return out;
  }
  _convertYcckToRgb(data) {
    let Y, Cb, Cr, k;
    let offset = 0;
    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      k = data[i + 3];
      data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
      data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
      data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
    }
    return data.subarray(0, offset);
  }
  _convertYcckToRgba(data) {
    for (let i = 0, length = data.length; i < length; i += 4) {
      const Y = data[i];
      const Cb = data[i + 1];
      const Cr = data[i + 2];
      const k = data[i + 3];
      data[i] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
      data[i + 1] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
      data[i + 2] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
      data[i + 3] = 255;
    }
    return data;
  }
  _convertYcckToCmyk(data) {
    let Y, Cb, Cr;
    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = 434.456 - Y - 1.402 * Cr;
      data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
      data[i + 2] = 481.816 - Y - 1.772 * Cb;
    }
    return data;
  }
  _convertCmykToRgb(data) {
    let c, m, y, k;
    let offset = 0;
    for (let i = 0, length = data.length; i < length; i += 4) {
      c = data[i];
      m = data[i + 1];
      y = data[i + 2];
      k = data[i + 3];
      data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);
      data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);
      data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
    }
    return data.subarray(0, offset);
  }
  _convertCmykToRgba(data) {
    for (let i = 0, length = data.length; i < length; i += 4) {
      const c = data[i];
      const m = data[i + 1];
      const y = data[i + 2];
      const k = data[i + 3];
      data[i] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);
      data[i + 1] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);
      data[i + 2] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
      data[i + 3] = 255;
    }
    return data;
  }
  getData({
    width,
    height,
    forceRGBA = false,
    forceRGB = false,
    isSourcePDF = false
  }) {
    if (this.numComponents > 4) {
      throw new JpegError("Unsupported color mode");
    }
    const data = this._getLinearizedBlockData(width, height, isSourcePDF);
    if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
      const len = data.length * (forceRGBA ? 4 : 3);
      const rgbaData = new Uint8ClampedArray(len);
      let offset = 0;
      if (forceRGBA) {
        (0, _image_utils.grayToRGBA)(data, new Uint32Array(rgbaData.buffer));
      } else {
        for (const grayColor of data) {
          rgbaData[offset++] = grayColor;
          rgbaData[offset++] = grayColor;
          rgbaData[offset++] = grayColor;
        }
      }
      return rgbaData;
    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
      if (forceRGBA) {
        const rgbaData = new Uint8ClampedArray(data.length / 3 * 4);
        return this._convertYccToRgba(data, rgbaData);
      }
      return this._convertYccToRgb(data);
    } else if (this.numComponents === 4) {
      if (this._isColorConversionNeeded) {
        if (forceRGBA) {
          return this._convertYcckToRgba(data);
        }
        if (forceRGB) {
          return this._convertYcckToRgb(data);
        }
        return this._convertYcckToCmyk(data);
      } else if (forceRGBA) {
        return this._convertCmykToRgba(data);
      } else if (forceRGB) {
        return this._convertCmykToRgb(data);
      }
    }
    return data;
  }
}
exports.JpegImage = JpegImage;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
exports.convertToRGBA = convertToRGBA;
exports.grayToRGBA = grayToRGBA;
var _util = __w_pdfjs_require__(2);
function convertToRGBA(params) {
  switch (params.kind) {
    case _util.ImageKind.GRAYSCALE_1BPP:
      return convertBlackAndWhiteToRGBA(params);
    case _util.ImageKind.RGB_24BPP:
      return convertRGBToRGBA(params);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 0xffffffff,
  inverseDecode = false
}) {
  const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
function convertRGBToRGBA({
  src,
  srcPos = 0,
  dest,
  destPos = 0,
  width,
  height
}) {
  let i = 0;
  const len32 = src.length >> 2;
  const src32 = new Uint32Array(src.buffer, srcPos, len32);
  if (_util.FeatureTest.isLittleEndian) {
    for (; i < len32 - 2; i += 3, destPos += 4) {
      const s1 = src32[i];
      const s2 = src32[i + 1];
      const s3 = src32[i + 2];
      dest[destPos] = s1 | 0xff000000;
      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
      dest[destPos + 3] = s3 >>> 8 | 0xff000000;
    }
    for (let j = i * 4, jj = src.length; j < jj; j += 3) {
      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
    }
  } else {
    for (; i < len32 - 2; i += 3, destPos += 4) {
      const s1 = src32[i];
      const s2 = src32[i + 1];
      const s3 = src32[i + 2];
      dest[destPos] = s1 | 0xff;
      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;
      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;
      dest[destPos + 3] = s3 << 8 | 0xff;
    }
    for (let j = i * 4, jj = src.length; j < jj; j += 3) {
      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;
    }
  }
  return {
    srcPos,
    destPos
  };
}
function grayToRGBA(src, dest) {
  if (_util.FeatureTest.isLittleEndian) {
    for (let i = 0, ii = src.length; i < ii; i++) {
      dest[i] = src[i] * 0x10101 | 0xff000000;
    }
  } else {
    for (let i = 0, ii = src.length; i < ii; i++) {
      dest[i] = src[i] * 0x1010100 | 0x000000ff;
    }
  }
}

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _jpx = __w_pdfjs_require__(30);
var _util = __w_pdfjs_require__(2);
class JpxStream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {}
  readBlock() {
    if (this.eof) {
      return;
    }
    const jpxImage = new _jpx.JpxImage();
    jpxImage.parse(this.bytes);
    const width = jpxImage.width;
    const height = jpxImage.height;
    const componentsCount = jpxImage.componentsCount;
    const tileCount = jpxImage.tiles.length;
    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      const data = new Uint8ClampedArray(width * height * componentsCount);
      for (let k = 0; k < tileCount; k++) {
        const tileComponents = jpxImage.tiles[k];
        const tileWidth = tileComponents.width;
        const tileHeight = tileComponents.height;
        const tileLeft = tileComponents.left;
        const tileTop = tileComponents.top;
        const src = tileComponents.items;
        let srcPosition = 0;
        let dataPosition = (width * tileTop + tileLeft) * componentsCount;
        const imgRowSize = width * componentsCount;
        const tileRowSize = tileWidth * componentsCount;
        for (let j = 0; j < tileHeight; j++) {
          const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }
      this.buffer = data;
    }
    this.bufferLength = this.buffer.length;
    this.eof = true;
  }
}
exports.JpxStream = JpxStream;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxImage = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _arithmetic_decoder = __w_pdfjs_require__(25);
class JpxError extends _util.BaseException {
  constructor(msg) {
    super(`JPX error: ${msg}`, "JpxError");
  }
}
const SubbandsGainLog2 = {
  LL: 0,
  LH: 1,
  HL: 1,
  HH: 2
};
class JpxImage {
  constructor() {
    this.failOnCorruptedImage = false;
  }
  parse(data) {
    const head = (0, _core_utils.readUint16)(data, 0);
    if (head === 0xff4f) {
      this.parseCodestream(data, 0, data.length);
      return;
    }
    const length = data.length;
    let position = 0;
    while (position < length) {
      let headerSize = 8;
      let lbox = (0, _core_utils.readUint32)(data, position);
      const tbox = (0, _core_utils.readUint32)(data, position + 4);
      position += headerSize;
      if (lbox === 1) {
        lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
        position += 8;
        headerSize += 8;
      }
      if (lbox === 0) {
        lbox = length - position + headerSize;
      }
      if (lbox < headerSize) {
        throw new JpxError("Invalid box field size");
      }
      const dataLength = lbox - headerSize;
      let jumpDataLength = true;
      switch (tbox) {
        case 0x6a703268:
          jumpDataLength = false;
          break;
        case 0x636f6c72:
          const method = data[position];
          if (method === 1) {
            const colorspace = (0, _core_utils.readUint32)(data, position + 3);
            switch (colorspace) {
              case 16:
              case 17:
              case 18:
                break;
              default:
                (0, _util.warn)("Unknown colorspace " + colorspace);
                break;
            }
          } else if (method === 2) {
            (0, _util.info)("ICC profile not supported");
          }
          break;
        case 0x6a703263:
          this.parseCodestream(data, position, position + dataLength);
          break;
        case 0x6a502020:
          if ((0, _core_utils.readUint32)(data, position) !== 0x0d0a870a) {
            (0, _util.warn)("Invalid JP2 signature");
          }
          break;
        case 0x6a501a1a:
        case 0x66747970:
        case 0x72726571:
        case 0x72657320:
        case 0x69686472:
          break;
        default:
          const headerType = String.fromCharCode(tbox >> 24 & 0xff, tbox >> 16 & 0xff, tbox >> 8 & 0xff, tbox & 0xff);
          (0, _util.warn)(`Unsupported header type ${tbox} (${headerType}).`);
          break;
      }
      if (jumpDataLength) {
        position += dataLength;
      }
    }
  }
  parseImageProperties(stream) {
    let newByte = stream.getByte();
    while (newByte >= 0) {
      const oldByte = newByte;
      newByte = stream.getByte();
      const code = oldByte << 8 | newByte;
      if (code === 0xff51) {
        stream.skip(4);
        const Xsiz = stream.getInt32() >>> 0;
        const Ysiz = stream.getInt32() >>> 0;
        const XOsiz = stream.getInt32() >>> 0;
        const YOsiz = stream.getInt32() >>> 0;
        stream.skip(16);
        const Csiz = stream.getUint16();
        this.width = Xsiz - XOsiz;
        this.height = Ysiz - YOsiz;
        this.componentsCount = Csiz;
        this.bitsPerComponent = 8;
        return;
      }
    }
    throw new JpxError("No size marker found in JPX stream");
  }
  parseCodestream(data, start, end) {
    const context = {};
    let doNotRecover = false;
    try {
      let position = start;
      while (position + 1 < end) {
        const code = (0, _core_utils.readUint16)(data, position);
        position += 2;
        let length = 0,
          j,
          sqcd,
          spqcds,
          spqcdSize,
          scalarExpounded,
          tile;
        switch (code) {
          case 0xff4f:
            context.mainHeader = true;
            break;
          case 0xffd9:
            break;
          case 0xff51:
            length = (0, _core_utils.readUint16)(data, position);
            const siz = {};
            siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
            siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
            siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
            siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
            siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
            siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
            siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
            siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
            const componentsCount = (0, _core_utils.readUint16)(data, position + 36);
            siz.Csiz = componentsCount;
            const components = [];
            j = position + 38;
            for (let i = 0; i < componentsCount; i++) {
              const component = {
                precision: (data[j] & 0x7f) + 1,
                isSigned: !!(data[j] & 0x80),
                XRsiz: data[j + 1],
                YRsiz: data[j + 2]
              };
              j += 3;
              calculateComponentDimensions(component, siz);
              components.push(component);
            }
            context.SIZ = siz;
            context.components = components;
            calculateTileGrids(context, components);
            context.QCC = [];
            context.COC = [];
            break;
          case 0xff5c:
            length = (0, _core_utils.readUint16)(data, position);
            const qcd = {};
            j = position + 2;
            sqcd = data[j++];
            switch (sqcd & 0x1f) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;
              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;
              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;
              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }
            qcd.noQuantization = spqcdSize === 8;
            qcd.scalarExpounded = scalarExpounded;
            qcd.guardBits = sqcd >> 5;
            spqcds = [];
            while (j < length + position) {
              const spqcd = {};
              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcd.SPqcds = spqcds;
            if (context.mainHeader) {
              context.QCD = qcd;
            } else {
              context.currentTile.QCD = qcd;
              context.currentTile.QCC = [];
            }
            break;
          case 0xff5d:
            length = (0, _core_utils.readUint16)(data, position);
            const qcc = {};
            j = position + 2;
            let cqcc;
            if (context.SIZ.Csiz < 257) {
              cqcc = data[j++];
            } else {
              cqcc = (0, _core_utils.readUint16)(data, j);
              j += 2;
            }
            sqcd = data[j++];
            switch (sqcd & 0x1f) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;
              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;
              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;
              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }
            qcc.noQuantization = spqcdSize === 8;
            qcc.scalarExpounded = scalarExpounded;
            qcc.guardBits = sqcd >> 5;
            spqcds = [];
            while (j < length + position) {
              const spqcd = {};
              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcc.SPqcds = spqcds;
            if (context.mainHeader) {
              context.QCC[cqcc] = qcc;
            } else {
              context.currentTile.QCC[cqcc] = qcc;
            }
            break;
          case 0xff52:
            length = (0, _core_utils.readUint16)(data, position);
            const cod = {};
            j = position + 2;
            const scod = data[j++];
            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
            cod.sopMarkerUsed = !!(scod & 2);
            cod.ephMarkerUsed = !!(scod & 4);
            cod.progressionOrder = data[j++];
            cod.layersCount = (0, _core_utils.readUint16)(data, j);
            j += 2;
            cod.multipleComponentTransform = data[j++];
            cod.decompositionLevelsCount = data[j++];
            cod.xcb = (data[j++] & 0xf) + 2;
            cod.ycb = (data[j++] & 0xf) + 2;
            const blockStyle = data[j++];
            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
            cod.resetContextProbabilities = !!(blockStyle & 2);
            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
            cod.verticallyStripe = !!(blockStyle & 8);
            cod.predictableTermination = !!(blockStyle & 16);
            cod.segmentationSymbolUsed = !!(blockStyle & 32);
            cod.reversibleTransformation = data[j++];
            if (cod.entropyCoderWithCustomPrecincts) {
              const precinctsSizes = [];
              while (j < length + position) {
                const precinctsSize = data[j++];
                precinctsSizes.push({
                  PPx: precinctsSize & 0xf,
                  PPy: precinctsSize >> 4
                });
              }
              cod.precinctsSizes = precinctsSizes;
            }
            const unsupported = [];
            if (cod.selectiveArithmeticCodingBypass) {
              unsupported.push("selectiveArithmeticCodingBypass");
            }
            if (cod.terminationOnEachCodingPass) {
              unsupported.push("terminationOnEachCodingPass");
            }
            if (cod.verticallyStripe) {
              unsupported.push("verticallyStripe");
            }
            if (cod.predictableTermination) {
              unsupported.push("predictableTermination");
            }
            if (unsupported.length > 0) {
              doNotRecover = true;
              (0, _util.warn)(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
            }
            if (context.mainHeader) {
              context.COD = cod;
            } else {
              context.currentTile.COD = cod;
              context.currentTile.COC = [];
            }
            break;
          case 0xff90:
            length = (0, _core_utils.readUint16)(data, position);
            tile = {};
            tile.index = (0, _core_utils.readUint16)(data, position + 2);
            tile.length = (0, _core_utils.readUint32)(data, position + 4);
            tile.dataEnd = tile.length + position - 2;
            tile.partIndex = data[position + 8];
            tile.partsCount = data[position + 9];
            context.mainHeader = false;
            if (tile.partIndex === 0) {
              tile.COD = context.COD;
              tile.COC = context.COC.slice(0);
              tile.QCD = context.QCD;
              tile.QCC = context.QCC.slice(0);
            }
            context.currentTile = tile;
            break;
          case 0xff93:
            tile = context.currentTile;
            if (tile.partIndex === 0) {
              initializeTile(context, tile.index);
              buildPackets(context);
            }
            length = tile.dataEnd - position;
            parseTilePackets(context, data, position, length);
            break;
          case 0xff53:
            (0, _util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
          case 0xff55:
          case 0xff57:
          case 0xff58:
          case 0xff64:
            length = (0, _core_utils.readUint16)(data, position);
            break;
          default:
            throw new Error("Unknown codestream code: " + code.toString(16));
        }
        position += length;
      }
    } catch (e) {
      if (doNotRecover || this.failOnCorruptedImage) {
        throw new JpxError(e.message);
      } else {
        (0, _util.warn)(`JPX: Trying to recover from: "${e.message}".`);
      }
    }
    this.tiles = transformComponents(context);
    this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
    this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
    this.componentsCount = context.SIZ.Csiz;
  }
}
exports.JpxImage = JpxImage;
function calculateComponentDimensions(component, siz) {
  component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
  component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
  component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
  component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
  component.width = component.x1 - component.x0;
  component.height = component.y1 - component.y0;
}
function calculateTileGrids(context, components) {
  const siz = context.SIZ;
  const tiles = [];
  let tile;
  const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
  const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
  for (let q = 0; q < numYtiles; q++) {
    for (let p = 0; p < numXtiles; p++) {
      tile = {};
      tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
      tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
      tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
      tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
      tile.width = tile.tx1 - tile.tx0;
      tile.height = tile.ty1 - tile.ty0;
      tile.components = [];
      tiles.push(tile);
    }
  }
  context.tiles = tiles;
  const componentsCount = siz.Csiz;
  for (let i = 0, ii = componentsCount; i < ii; i++) {
    const component = components[i];
    for (let j = 0, jj = tiles.length; j < jj; j++) {
      const tileComponent = {};
      tile = tiles[j];
      tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
      tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
      tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
      tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
      tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
      tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
      tile.components[i] = tileComponent;
    }
  }
}
function getBlocksDimensions(context, component, r) {
  const codOrCoc = component.codingStyleParameters;
  const result = {};
  if (!codOrCoc.entropyCoderWithCustomPrecincts) {
    result.PPx = 15;
    result.PPy = 15;
  } else {
    result.PPx = codOrCoc.precinctsSizes[r].PPx;
    result.PPy = codOrCoc.precinctsSizes[r].PPy;
  }
  result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
  result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
  return result;
}
function buildPrecincts(context, resolution, dimensions) {
  const precinctWidth = 1 << dimensions.PPx;
  const precinctHeight = 1 << dimensions.PPy;
  const isZeroRes = resolution.resLevel === 0;
  const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
  const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
  const numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
  const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
  const numprecincts = numprecinctswide * numprecinctshigh;
  resolution.precinctParameters = {
    precinctWidth,
    precinctHeight,
    numprecinctswide,
    numprecinctshigh,
    numprecincts,
    precinctWidthInSubband,
    precinctHeightInSubband
  };
}
function buildCodeblocks(context, subband, dimensions) {
  const xcb_ = dimensions.xcb_;
  const ycb_ = dimensions.ycb_;
  const codeblockWidth = 1 << xcb_;
  const codeblockHeight = 1 << ycb_;
  const cbx0 = subband.tbx0 >> xcb_;
  const cby0 = subband.tby0 >> ycb_;
  const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
  const cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
  const precinctParameters = subband.resolution.precinctParameters;
  const codeblocks = [];
  const precincts = [];
  let i, j, codeblock, precinctNumber;
  for (j = cby0; j < cby1; j++) {
    for (i = cbx0; i < cbx1; i++) {
      codeblock = {
        cbx: i,
        cby: j,
        tbx0: codeblockWidth * i,
        tby0: codeblockHeight * j,
        tbx1: codeblockWidth * (i + 1),
        tby1: codeblockHeight * (j + 1)
      };
      codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
      codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
      codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
      codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
      const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
      const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
      precinctNumber = pi + pj * precinctParameters.numprecinctswide;
      codeblock.precinctNumber = precinctNumber;
      codeblock.subbandType = subband.type;
      codeblock.Lblock = 3;
      if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
        continue;
      }
      codeblocks.push(codeblock);
      let precinct = precincts[precinctNumber];
      if (precinct !== undefined) {
        if (i < precinct.cbxMin) {
          precinct.cbxMin = i;
        } else if (i > precinct.cbxMax) {
          precinct.cbxMax = i;
        }
        if (j < precinct.cbyMin) {
          precinct.cbxMin = j;
        } else if (j > precinct.cbyMax) {
          precinct.cbyMax = j;
        }
      } else {
        precincts[precinctNumber] = precinct = {
          cbxMin: i,
          cbyMin: j,
          cbxMax: i,
          cbyMax: j
        };
      }
      codeblock.precinct = precinct;
    }
  }
  subband.codeblockParameters = {
    codeblockWidth: xcb_,
    codeblockHeight: ycb_,
    numcodeblockwide: cbx1 - cbx0 + 1,
    numcodeblockhigh: cby1 - cby0 + 1
  };
  subband.codeblocks = codeblocks;
  subband.precincts = precincts;
}
function createPacket(resolution, precinctNumber, layerNumber) {
  const precinctCodeblocks = [];
  const subbands = resolution.subbands;
  for (let i = 0, ii = subbands.length; i < ii; i++) {
    const subband = subbands[i];
    const codeblocks = subband.codeblocks;
    for (let j = 0, jj = codeblocks.length; j < jj; j++) {
      const codeblock = codeblocks[j];
      if (codeblock.precinctNumber !== precinctNumber) {
        continue;
      }
      precinctCodeblocks.push(codeblock);
    }
  }
  return {
    layerNumber,
    codeblocks: precinctCodeblocks
  };
}
function LayerResolutionComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;
  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  let l = 0,
    r = 0,
    i = 0,
    k = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; l < layersCount; l++) {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          for (; k < numprecincts;) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }
          k = 0;
        }
        i = 0;
      }
      r = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ResolutionLayerComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;
  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  let r = 0,
    l = 0,
    i = 0,
    k = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; l < layersCount; l++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          for (; k < numprecincts;) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }
          k = 0;
        }
        i = 0;
      }
      l = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ResolutionPositionComponentLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let l, r, c, p;
  let maxDecompositionLevelsCount = 0;
  for (c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
  }
  const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
  for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
    let maxNumPrecincts = 0;
    for (c = 0; c < componentsCount; ++c) {
      const resolutions = tile.components[c].resolutions;
      if (r < resolutions.length) {
        maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
      }
    }
    maxNumPrecinctsInLevel[r] = maxNumPrecincts;
  }
  l = 0;
  r = 0;
  c = 0;
  p = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; p < maxNumPrecinctsInLevel[r]; p++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          if (p >= numprecincts) {
            continue;
          }
          for (; l < layersCount;) {
            const packet = createPacket(resolution, p, l);
            l++;
            return packet;
          }
          l = 0;
        }
        c = 0;
      }
      p = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function PositionComponentResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  const precinctsIterationSizes = precinctsSizes;
  let l = 0,
    r = 0,
    c = 0,
    px = 0,
    py = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
      for (; px < precinctsIterationSizes.maxNumWide; px++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];
          const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            if (k === null) {
              continue;
            }
            for (; l < layersCount;) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }
            l = 0;
          }
          r = 0;
        }
        c = 0;
      }
      px = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ComponentPositionResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  let l = 0,
    r = 0,
    c = 0,
    px = 0,
    py = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; c < componentsCount; ++c) {
      const component = tile.components[c];
      const precinctsIterationSizes = precinctsSizes.components[c];
      const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsIterationSizes.resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            if (k === null) {
              continue;
            }
            for (; l < layersCount;) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }
            l = 0;
          }
          r = 0;
        }
        px = 0;
      }
      py = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
  const posX = pxIndex * precinctIterationSizes.minWidth;
  const posY = pyIndex * precinctIterationSizes.minHeight;
  if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
    return null;
  }
  const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
  return posX / sizeInImageScale.height + startPrecinctRowIndex;
}
function getPrecinctSizesInImageScale(tile) {
  const componentsCount = tile.components.length;
  let minWidth = Number.MAX_VALUE;
  let minHeight = Number.MAX_VALUE;
  let maxNumWide = 0;
  let maxNumHigh = 0;
  const sizePerComponent = new Array(componentsCount);
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const sizePerResolution = new Array(decompositionLevelsCount + 1);
    let minWidthCurrentComponent = Number.MAX_VALUE;
    let minHeightCurrentComponent = Number.MAX_VALUE;
    let maxNumWideCurrentComponent = 0;
    let maxNumHighCurrentComponent = 0;
    let scale = 1;
    for (let r = decompositionLevelsCount; r >= 0; --r) {
      const resolution = component.resolutions[r];
      const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
      const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
      minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
      minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
      maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
      maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
      sizePerResolution[r] = {
        width: widthCurrentResolution,
        height: heightCurrentResolution
      };
      scale <<= 1;
    }
    minWidth = Math.min(minWidth, minWidthCurrentComponent);
    minHeight = Math.min(minHeight, minHeightCurrentComponent);
    maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
    maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
    sizePerComponent[c] = {
      resolutions: sizePerResolution,
      minWidth: minWidthCurrentComponent,
      minHeight: minHeightCurrentComponent,
      maxNumWide: maxNumWideCurrentComponent,
      maxNumHigh: maxNumHighCurrentComponent
    };
  }
  return {
    components: sizePerComponent,
    minWidth,
    minHeight,
    maxNumWide,
    maxNumHigh
  };
}
function buildPackets(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const componentsCount = siz.Csiz;
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const resolutions = [];
    const subbands = [];
    for (let r = 0; r <= decompositionLevelsCount; r++) {
      const blocksDimensions = getBlocksDimensions(context, component, r);
      const resolution = {};
      const scale = 1 << decompositionLevelsCount - r;
      resolution.trx0 = Math.ceil(component.tcx0 / scale);
      resolution.try0 = Math.ceil(component.tcy0 / scale);
      resolution.trx1 = Math.ceil(component.tcx1 / scale);
      resolution.try1 = Math.ceil(component.tcy1 / scale);
      resolution.resLevel = r;
      buildPrecincts(context, resolution, blocksDimensions);
      resolutions.push(resolution);
      let subband;
      if (r === 0) {
        subband = {};
        subband.type = "LL";
        subband.tbx0 = Math.ceil(component.tcx0 / scale);
        subband.tby0 = Math.ceil(component.tcy0 / scale);
        subband.tbx1 = Math.ceil(component.tcx1 / scale);
        subband.tby1 = Math.ceil(component.tcy1 / scale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolution.subbands = [subband];
      } else {
        const bscale = 1 << decompositionLevelsCount - r + 1;
        const resolutionSubbands = [];
        subband = {};
        subband.type = "HL";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "LH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "HH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        resolution.subbands = resolutionSubbands;
      }
    }
    component.resolutions = resolutions;
    component.subbands = subbands;
  }
  const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
  switch (progressionOrder) {
    case 0:
      tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
      break;
    case 1:
      tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
      break;
    case 2:
      tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
      break;
    case 3:
      tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
      break;
    case 4:
      tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
      break;
    default:
      throw new JpxError(`Unsupported progression order ${progressionOrder}`);
  }
}
function parseTilePackets(context, data, offset, dataLength) {
  let position = 0;
  let buffer,
    bufferSize = 0,
    skipNextBit = false;
  function readBits(count) {
    while (bufferSize < count) {
      const b = data[offset + position];
      position++;
      if (skipNextBit) {
        buffer = buffer << 7 | b;
        bufferSize += 7;
        skipNextBit = false;
      } else {
        buffer = buffer << 8 | b;
        bufferSize += 8;
      }
      if (b === 0xff) {
        skipNextBit = true;
      }
    }
    bufferSize -= count;
    return buffer >>> bufferSize & (1 << count) - 1;
  }
  function skipMarkerIfEqual(value) {
    if (data[offset + position - 1] === 0xff && data[offset + position] === value) {
      skipBytes(1);
      return true;
    } else if (data[offset + position] === 0xff && data[offset + position + 1] === value) {
      skipBytes(2);
      return true;
    }
    return false;
  }
  function skipBytes(count) {
    position += count;
  }
  function alignToByte() {
    bufferSize = 0;
    if (skipNextBit) {
      position++;
      skipNextBit = false;
    }
  }
  function readCodingpasses() {
    if (readBits(1) === 0) {
      return 1;
    }
    if (readBits(1) === 0) {
      return 2;
    }
    let value = readBits(2);
    if (value < 3) {
      return value + 3;
    }
    value = readBits(5);
    if (value < 31) {
      return value + 6;
    }
    value = readBits(7);
    return value + 37;
  }
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const sopMarkerUsed = context.COD.sopMarkerUsed;
  const ephMarkerUsed = context.COD.ephMarkerUsed;
  const packetsIterator = tile.packetsIterator;
  while (position < dataLength) {
    alignToByte();
    if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
      skipBytes(4);
    }
    const packet = packetsIterator.nextPacket();
    if (!readBits(1)) {
      continue;
    }
    const layerNumber = packet.layerNumber,
      queue = [];
    let codeblock;
    for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
      codeblock = packet.codeblocks[i];
      let precinct = codeblock.precinct;
      const codeblockColumn = codeblock.cbx - precinct.cbxMin;
      const codeblockRow = codeblock.cby - precinct.cbyMin;
      let codeblockIncluded = false;
      let firstTimeInclusion = false;
      let valueReady, zeroBitPlanesTree;
      if (codeblock.included !== undefined) {
        codeblockIncluded = !!readBits(1);
      } else {
        precinct = codeblock.precinct;
        let inclusionTree;
        if (precinct.inclusionTree !== undefined) {
          inclusionTree = precinct.inclusionTree;
        } else {
          const width = precinct.cbxMax - precinct.cbxMin + 1;
          const height = precinct.cbyMax - precinct.cbyMin + 1;
          inclusionTree = new InclusionTree(width, height, layerNumber);
          zeroBitPlanesTree = new TagTree(width, height);
          precinct.inclusionTree = inclusionTree;
          precinct.zeroBitPlanesTree = zeroBitPlanesTree;
          for (let l = 0; l < layerNumber; l++) {
            if (readBits(1) !== 0) {
              throw new JpxError("Invalid tag tree");
            }
          }
        }
        if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
          while (true) {
            if (readBits(1)) {
              valueReady = !inclusionTree.nextLevel();
              if (valueReady) {
                codeblock.included = true;
                codeblockIncluded = firstTimeInclusion = true;
                break;
              }
            } else {
              inclusionTree.incrementValue(layerNumber);
              break;
            }
          }
        }
      }
      if (!codeblockIncluded) {
        continue;
      }
      if (firstTimeInclusion) {
        zeroBitPlanesTree = precinct.zeroBitPlanesTree;
        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
        while (true) {
          if (readBits(1)) {
            valueReady = !zeroBitPlanesTree.nextLevel();
            if (valueReady) {
              break;
            }
          } else {
            zeroBitPlanesTree.incrementValue();
          }
        }
        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
      }
      const codingpasses = readCodingpasses();
      while (readBits(1)) {
        codeblock.Lblock++;
      }
      const codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
      const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
      const codedDataLength = readBits(bits);
      queue.push({
        codeblock,
        codingpasses,
        dataLength: codedDataLength
      });
    }
    alignToByte();
    if (ephMarkerUsed) {
      skipMarkerIfEqual(0x92);
    }
    while (queue.length > 0) {
      const packetItem = queue.shift();
      codeblock = packetItem.codeblock;
      if (codeblock.data === undefined) {
        codeblock.data = [];
      }
      codeblock.data.push({
        data,
        start: offset + position,
        end: offset + position + packetItem.dataLength,
        codingpasses: packetItem.codingpasses
      });
      position += packetItem.dataLength;
    }
  }
  return position;
}
function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities) {
  const x0 = subband.tbx0;
  const y0 = subband.tby0;
  const width = subband.tbx1 - subband.tbx0;
  const codeblocks = subband.codeblocks;
  const right = subband.type.charAt(0) === "H" ? 1 : 0;
  const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
  for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
    const codeblock = codeblocks[i];
    const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
    const blockHeight = codeblock.tby1_ - codeblock.tby0_;
    if (blockWidth === 0 || blockHeight === 0) {
      continue;
    }
    if (codeblock.data === undefined) {
      continue;
    }
    const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
    let currentCodingpassType = 2;
    const data = codeblock.data;
    let totalLength = 0,
      codingpasses = 0;
    let j, jj, dataItem;
    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      totalLength += dataItem.end - dataItem.start;
      codingpasses += dataItem.codingpasses;
    }
    const encodedData = new Uint8Array(totalLength);
    let position = 0;
    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
      encodedData.set(chunk, position);
      position += chunk.length;
    }
    const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
    bitModel.setDecoder(decoder);
    for (j = 0; j < codingpasses; j++) {
      switch (currentCodingpassType) {
        case 0:
          bitModel.runSignificancePropagationPass();
          break;
        case 1:
          bitModel.runMagnitudeRefinementPass();
          break;
        case 2:
          bitModel.runCleanupPass();
          if (segmentationSymbolUsed) {
            bitModel.checkSegmentationSymbol();
          }
          break;
      }
      if (resetContextProbabilities) {
        bitModel.reset();
      }
      currentCodingpassType = (currentCodingpassType + 1) % 3;
    }
    let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
    const sign = bitModel.coefficentsSign;
    const magnitude = bitModel.coefficentsMagnitude;
    const bitsDecoded = bitModel.bitsDecoded;
    const magnitudeCorrection = reversible ? 0 : 0.5;
    let k, n, nb;
    position = 0;
    const interleave = subband.type !== "LL";
    for (j = 0; j < blockHeight; j++) {
      const row = offset / width | 0;
      const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
      for (k = 0; k < blockWidth; k++) {
        n = magnitude[position];
        if (n !== 0) {
          n = (n + magnitudeCorrection) * delta;
          if (sign[position] !== 0) {
            n = -n;
          }
          nb = bitsDecoded[position];
          const pos = interleave ? levelOffset + (offset << 1) : offset;
          coefficients[pos] = reversible && nb >= mb ? n : n * (1 << mb - nb);
        }
        offset++;
        position++;
      }
      offset += width - blockWidth;
    }
  }
}
function transformTile(context, tile, c) {
  const component = tile.components[c];
  const codingStyleParameters = component.codingStyleParameters;
  const quantizationParameters = component.quantizationParameters;
  const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
  const spqcds = quantizationParameters.SPqcds;
  const scalarExpounded = quantizationParameters.scalarExpounded;
  const guardBits = quantizationParameters.guardBits;
  const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
  const resetContextProbabilities = codingStyleParameters.resetContextProbabilities;
  const precision = context.components[c].precision;
  const reversible = codingStyleParameters.reversibleTransformation;
  const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
  const subbandCoefficients = [];
  let b = 0;
  for (let i = 0; i <= decompositionLevelsCount; i++) {
    const resolution = component.resolutions[i];
    const width = resolution.trx1 - resolution.trx0;
    const height = resolution.try1 - resolution.try0;
    const coefficients = new Float32Array(width * height);
    for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
      let mu, epsilon;
      if (!scalarExpounded) {
        mu = spqcds[0].mu;
        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
      } else {
        mu = spqcds[b].mu;
        epsilon = spqcds[b].epsilon;
        b++;
      }
      const subband = resolution.subbands[j];
      const gainLog2 = SubbandsGainLog2[subband.type];
      const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
      const mb = guardBits + epsilon - 1;
      copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed, resetContextProbabilities);
    }
    subbandCoefficients.push({
      width,
      height,
      items: coefficients
    });
  }
  const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
  return {
    left: component.tcx0,
    top: component.tcy0,
    width: result.width,
    height: result.height,
    items: result.items
  };
}
function transformComponents(context) {
  const siz = context.SIZ;
  const components = context.components;
  const componentsCount = siz.Csiz;
  const resultImages = [];
  for (let i = 0, ii = context.tiles.length; i < ii; i++) {
    const tile = context.tiles[i];
    const transformedTiles = [];
    for (let c = 0; c < componentsCount; c++) {
      transformedTiles[c] = transformTile(context, tile, c);
    }
    const tile0 = transformedTiles[0];
    const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
    const result = {
      left: tile0.left,
      top: tile0.top,
      width: tile0.width,
      height: tile0.height,
      items: out
    };
    let shift, offset;
    let pos = 0,
      j,
      jj,
      y0,
      y1,
      y2;
    if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
      const fourComponents = componentsCount === 4;
      const y0items = transformedTiles[0].items;
      const y1items = transformedTiles[1].items;
      const y2items = transformedTiles[2].items;
      const y3items = fourComponents ? transformedTiles[3].items : null;
      shift = components[0].precision - 8;
      offset = (128 << shift) + 0.5;
      const component0 = tile.components[0];
      const alpha01 = componentsCount - 3;
      jj = y0items.length;
      if (!component0.codingStyleParameters.reversibleTransformation) {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          out[pos++] = y0 + 1.402 * y2 >> shift;
          out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
          out[pos++] = y0 + 1.772 * y1 >> shift;
        }
      } else {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          const g = y0 - (y2 + y1 >> 2);
          out[pos++] = g + y2 >> shift;
          out[pos++] = g >> shift;
          out[pos++] = g + y1 >> shift;
        }
      }
      if (fourComponents) {
        for (j = 0, pos = 3; j < jj; j++, pos += 4) {
          out[pos] = y3items[j] + offset >> shift;
        }
      }
    } else {
      for (let c = 0; c < componentsCount; c++) {
        const items = transformedTiles[c].items;
        shift = components[c].precision - 8;
        offset = (128 << shift) + 0.5;
        for (pos = c, j = 0, jj = items.length; j < jj; j++) {
          out[pos] = items[j] + offset >> shift;
          pos += componentsCount;
        }
      }
    }
    resultImages.push(result);
  }
  return resultImages;
}
function initializeTile(context, tileIndex) {
  const siz = context.SIZ;
  const componentsCount = siz.Csiz;
  const tile = context.tiles[tileIndex];
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;
    component.quantizationParameters = qcdOrQcc;
    const codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;
    component.codingStyleParameters = codOrCoc;
  }
  tile.codingStyleDefaultParameters = context.currentTile.COD;
}
class TagTree {
  constructor(width, height) {
    const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
    this.levels = [];
    for (let i = 0; i < levelsLength; i++) {
      const level = {
        width,
        height,
        items: []
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }
  reset(i, j) {
    let currentLevel = 0,
      value = 0,
      level;
    while (currentLevel < this.levels.length) {
      level = this.levels[currentLevel];
      const index = i + j * level.width;
      if (level.items[index] !== undefined) {
        value = level.items[index];
        break;
      }
      level.index = index;
      i >>= 1;
      j >>= 1;
      currentLevel++;
    }
    currentLevel--;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    this.currentLevel = currentLevel;
    delete this.value;
  }
  incrementValue() {
    const level = this.levels[this.currentLevel];
    level.items[level.index]++;
  }
  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    currentLevel--;
    if (currentLevel < 0) {
      this.value = value;
      return false;
    }
    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }
}
class InclusionTree {
  constructor(width, height, defaultValue) {
    const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
    this.levels = [];
    for (let i = 0; i < levelsLength; i++) {
      const items = new Uint8Array(width * height);
      for (let j = 0, jj = items.length; j < jj; j++) {
        items[j] = defaultValue;
      }
      const level = {
        width,
        height,
        items
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }
  reset(i, j, stopValue) {
    let currentLevel = 0;
    while (currentLevel < this.levels.length) {
      const level = this.levels[currentLevel];
      const index = i + j * level.width;
      level.index = index;
      const value = level.items[index];
      if (value === 0xff) {
        break;
      }
      if (value > stopValue) {
        this.currentLevel = currentLevel;
        this.propagateValues();
        return false;
      }
      i >>= 1;
      j >>= 1;
      currentLevel++;
    }
    this.currentLevel = currentLevel - 1;
    return true;
  }
  incrementValue(stopValue) {
    const level = this.levels[this.currentLevel];
    level.items[level.index] = stopValue + 1;
    this.propagateValues();
  }
  propagateValues() {
    let levelIndex = this.currentLevel;
    let level = this.levels[levelIndex];
    const currentValue = level.items[level.index];
    while (--levelIndex >= 0) {
      level = this.levels[levelIndex];
      level.items[level.index] = currentValue;
    }
  }
  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    level.items[level.index] = 0xff;
    currentLevel--;
    if (currentLevel < 0) {
      return false;
    }
    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }
}
class BitModel {
  static UNIFORM_CONTEXT = 17;
  static RUNLENGTH_CONTEXT = 18;
  static LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
  static HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
  static HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
  constructor(width, height, subband, zeroBitPlanes, mb) {
    this.width = width;
    this.height = height;
    let contextLabelTable;
    if (subband === "HH") {
      contextLabelTable = BitModel.HHContextLabel;
    } else if (subband === "HL") {
      contextLabelTable = BitModel.HLContextLabel;
    } else {
      contextLabelTable = BitModel.LLAndLHContextsLabel;
    }
    this.contextLabelTable = contextLabelTable;
    const coefficientCount = width * height;
    this.neighborsSignificance = new Uint8Array(coefficientCount);
    this.coefficentsSign = new Uint8Array(coefficientCount);
    let coefficentsMagnitude;
    if (mb > 14) {
      coefficentsMagnitude = new Uint32Array(coefficientCount);
    } else if (mb > 6) {
      coefficentsMagnitude = new Uint16Array(coefficientCount);
    } else {
      coefficentsMagnitude = new Uint8Array(coefficientCount);
    }
    this.coefficentsMagnitude = coefficentsMagnitude;
    this.processingFlags = new Uint8Array(coefficientCount);
    const bitsDecoded = new Uint8Array(coefficientCount);
    if (zeroBitPlanes !== 0) {
      for (let i = 0; i < coefficientCount; i++) {
        bitsDecoded[i] = zeroBitPlanes;
      }
    }
    this.bitsDecoded = bitsDecoded;
    this.reset();
  }
  setDecoder(decoder) {
    this.decoder = decoder;
  }
  reset() {
    this.contexts = new Int8Array(19);
    this.contexts[0] = 4 << 1 | 0;
    this.contexts[BitModel.UNIFORM_CONTEXT] = 46 << 1 | 0;
    this.contexts[BitModel.RUNLENGTH_CONTEXT] = 3 << 1 | 0;
  }
  setNeighborsSignificance(row, column, index) {
    const neighborsSignificance = this.neighborsSignificance;
    const width = this.width,
      height = this.height;
    const left = column > 0;
    const right = column + 1 < width;
    let i;
    if (row > 0) {
      i = index - width;
      if (left) {
        neighborsSignificance[i - 1] += 0x10;
      }
      if (right) {
        neighborsSignificance[i + 1] += 0x10;
      }
      neighborsSignificance[i] += 0x04;
    }
    if (row + 1 < height) {
      i = index + width;
      if (left) {
        neighborsSignificance[i - 1] += 0x10;
      }
      if (right) {
        neighborsSignificance[i + 1] += 0x10;
      }
      neighborsSignificance[i] += 0x04;
    }
    if (left) {
      neighborsSignificance[index - 1] += 0x01;
    }
    if (right) {
      neighborsSignificance[index + 1] += 0x01;
    }
    neighborsSignificance[index] |= 0x80;
  }
  runSignificancePropagationPass() {
    const decoder = this.decoder;
    const width = this.width,
      height = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    const neighborsSignificance = this.neighborsSignificance;
    const processingFlags = this.processingFlags;
    const contexts = this.contexts;
    const labels = this.contextLabelTable;
    const bitsDecoded = this.bitsDecoded;
    const processedInverseMask = ~1;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    for (let i0 = 0; i0 < height; i0 += 4) {
      for (let j = 0; j < width; j++) {
        let index = i0 * width + j;
        for (let i1 = 0; i1 < 4; i1++, index += width) {
          const i = i0 + i1;
          if (i >= height) {
            break;
          }
          processingFlags[index] &= processedInverseMask;
          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
            continue;
          }
          const contextLabel = labels[neighborsSignificance[index]];
          const decision = decoder.readBit(contexts, contextLabel);
          if (decision) {
            const sign = this.decodeSignBit(i, j, index);
            coefficentsSign[index] = sign;
            coefficentsMagnitude[index] = 1;
            this.setNeighborsSignificance(i, j, index);
            processingFlags[index] |= firstMagnitudeBitMask;
          }
          bitsDecoded[index]++;
          processingFlags[index] |= processedMask;
        }
      }
    }
  }
  decodeSignBit(row, column, index) {
    const width = this.width,
      height = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    let contribution, sign0, sign1, significance1;
    let contextLabel, decoded;
    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
      sign1 = coefficentsSign[index + 1];
      if (significance1) {
        sign0 = coefficentsSign[index - 1];
        contribution = 1 - sign1 - sign0;
      } else {
        contribution = 1 - sign1 - sign1;
      }
    } else if (significance1) {
      sign0 = coefficentsSign[index - 1];
      contribution = 1 - sign0 - sign0;
    } else {
      contribution = 0;
    }
    const horizontalContribution = 3 * contribution;
    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
      sign1 = coefficentsSign[index + width];
      if (significance1) {
        sign0 = coefficentsSign[index - width];
        contribution = 1 - sign1 - sign0 + horizontalContribution;
      } else {
        contribution = 1 - sign1 - sign1 + horizontalContribution;
      }
    } else if (significance1) {
      sign0 = coefficentsSign[index - width];
      contribution = 1 - sign0 - sign0 + horizontalContribution;
    } else {
      contribution = horizontalContribution;
    }
    if (contribution >= 0) {
      contextLabel = 9 + contribution;
      decoded = this.decoder.readBit(this.contexts, contextLabel);
    } else {
      contextLabel = 9 - contribution;
      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
    }
    return decoded;
  }
  runMagnitudeRefinementPass() {
    const decoder = this.decoder;
    const width = this.width,
      height = this.height;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const neighborsSignificance = this.neighborsSignificance;
    const contexts = this.contexts;
    const bitsDecoded = this.bitsDecoded;
    const processingFlags = this.processingFlags;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    const length = width * height;
    const width4 = width * 4;
    for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
      indexNext = Math.min(length, index0 + width4);
      for (let j = 0; j < width; j++) {
        for (let index = index0 + j; index < indexNext; index += width) {
          if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
            continue;
          }
          let contextLabel = 16;
          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
            processingFlags[index] ^= firstMagnitudeBitMask;
            const significance = neighborsSignificance[index] & 127;
            contextLabel = significance === 0 ? 15 : 14;
          }
          const bit = decoder.readBit(contexts, contextLabel);
          coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
          bitsDecoded[index]++;
          processingFlags[index] |= processedMask;
        }
      }
    }
  }
  runCleanupPass() {
    const decoder = this.decoder;
    const width = this.width,
      height = this.height;
    const neighborsSignificance = this.neighborsSignificance;
    const coefficentsMagnitude = this.coefficentsMagnitude;
    const coefficentsSign = this.coefficentsSign;
    const contexts = this.contexts;
    const labels = this.contextLabelTable;
    const bitsDecoded = this.bitsDecoded;
    const processingFlags = this.processingFlags;
    const processedMask = 1;
    const firstMagnitudeBitMask = 2;
    const oneRowDown = width;
    const twoRowsDown = width * 2;
    const threeRowsDown = width * 3;
    let iNext;
    for (let i0 = 0; i0 < height; i0 = iNext) {
      iNext = Math.min(i0 + 4, height);
      const indexBase = i0 * width;
      const checkAllEmpty = i0 + 3 < height;
      for (let j = 0; j < width; j++) {
        const index0 = indexBase + j;
        const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
        let i1 = 0,
          index = index0;
        let i = i0,
          sign;
        if (allEmpty) {
          const hasSignificantCoefficent = decoder.readBit(contexts, BitModel.RUNLENGTH_CONTEXT);
          if (!hasSignificantCoefficent) {
            bitsDecoded[index0]++;
            bitsDecoded[index0 + oneRowDown]++;
            bitsDecoded[index0 + twoRowsDown]++;
            bitsDecoded[index0 + threeRowsDown]++;
            continue;
          }
          i1 = decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
          if (i1 !== 0) {
            i = i0 + i1;
            index += i1 * width;
          }
          sign = this.decodeSignBit(i, j, index);
          coefficentsSign[index] = sign;
          coefficentsMagnitude[index] = 1;
          this.setNeighborsSignificance(i, j, index);
          processingFlags[index] |= firstMagnitudeBitMask;
          index = index0;
          for (let i2 = i0; i2 <= i; i2++, index += width) {
            bitsDecoded[index]++;
          }
          i1++;
        }
        for (i = i0 + i1; i < iNext; i++, index += width) {
          if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
            continue;
          }
          const contextLabel = labels[neighborsSignificance[index]];
          const decision = decoder.readBit(contexts, contextLabel);
          if (decision === 1) {
            sign = this.decodeSignBit(i, j, index);
            coefficentsSign[index] = sign;
            coefficentsMagnitude[index] = 1;
            this.setNeighborsSignificance(i, j, index);
            processingFlags[index] |= firstMagnitudeBitMask;
          }
          bitsDecoded[index]++;
        }
      }
    }
  }
  checkSegmentationSymbol() {
    const decoder = this.decoder;
    const contexts = this.contexts;
    const symbol = decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
    if (symbol !== 0xa) {
      throw new JpxError("Invalid segmentation symbol");
    }
  }
}
class Transform {
  constructor() {
    if (this.constructor === Transform) {
      (0, _util.unreachable)("Cannot initialize Transform.");
    }
  }
  calculate(subbands, u0, v0) {
    let ll = subbands[0];
    for (let i = 1, ii = subbands.length; i < ii; i++) {
      ll = this.iterate(ll, subbands[i], u0, v0);
    }
    return ll;
  }
  extend(buffer, offset, size) {
    let i1 = offset - 1,
      j1 = offset + 1;
    let i2 = offset + size - 2,
      j2 = offset + size;
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1] = buffer[j1];
    buffer[j2] = buffer[i2];
  }
  filter(x, offset, length) {
    (0, _util.unreachable)("Abstract method `filter` called");
  }
  iterate(ll, hl_lh_hh, u0, v0) {
    const llWidth = ll.width,
      llHeight = ll.height;
    let llItems = ll.items;
    const width = hl_lh_hh.width;
    const height = hl_lh_hh.height;
    const items = hl_lh_hh.items;
    let i, j, k, l, u, v;
    for (k = 0, i = 0; i < llHeight; i++) {
      l = i * 2 * width;
      for (j = 0; j < llWidth; j++, k++, l += 2) {
        items[l] = llItems[k];
      }
    }
    llItems = ll.items = null;
    const bufferPadding = 4;
    const rowBuffer = new Float32Array(width + 2 * bufferPadding);
    if (width === 1) {
      if ((u0 & 1) !== 0) {
        for (v = 0, k = 0; v < height; v++, k += width) {
          items[k] *= 0.5;
        }
      }
    } else {
      for (v = 0, k = 0; v < height; v++, k += width) {
        rowBuffer.set(items.subarray(k, k + width), bufferPadding);
        this.extend(rowBuffer, bufferPadding, width);
        this.filter(rowBuffer, bufferPadding, width);
        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
      }
    }
    let numBuffers = 16;
    const colBuffers = [];
    for (i = 0; i < numBuffers; i++) {
      colBuffers.push(new Float32Array(height + 2 * bufferPadding));
    }
    let b,
      currentBuffer = 0;
    ll = bufferPadding + height;
    if (height === 1) {
      if ((v0 & 1) !== 0) {
        for (u = 0; u < width; u++) {
          items[u] *= 0.5;
        }
      }
    } else {
      for (u = 0; u < width; u++) {
        if (currentBuffer === 0) {
          numBuffers = Math.min(width - u, numBuffers);
          for (k = u, l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              colBuffers[b][l] = items[k + b];
            }
          }
          currentBuffer = numBuffers;
        }
        currentBuffer--;
        const buffer = colBuffers[currentBuffer];
        this.extend(buffer, bufferPadding, height);
        this.filter(buffer, bufferPadding, height);
        if (currentBuffer === 0) {
          k = u - numBuffers + 1;
          for (l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              items[k + b] = colBuffers[b][l];
            }
          }
        }
      }
    }
    return {
      width,
      height,
      items
    };
  }
}
class IrreversibleTransform extends Transform {
  filter(x, offset, length) {
    const len = length >> 1;
    offset |= 0;
    let j, n, current, next;
    const alpha = -1.586134342059924;
    const beta = -0.052980118572961;
    const gamma = 0.882911075530934;
    const delta = 0.443506852043971;
    const K = 1.230174104914001;
    const K_ = 1 / K;
    j = offset - 3;
    for (n = len + 4; n--; j += 2) {
      x[j] *= K_;
    }
    j = offset - 2;
    current = delta * x[j - 1];
    for (n = len + 3; n--; j += 2) {
      next = delta * x[j + 1];
      x[j] = K * x[j] - current - next;
      if (n--) {
        j += 2;
        current = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
      } else {
        break;
      }
    }
    j = offset - 1;
    current = gamma * x[j - 1];
    for (n = len + 2; n--; j += 2) {
      next = gamma * x[j + 1];
      x[j] -= current + next;
      if (n--) {
        j += 2;
        current = gamma * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }
    j = offset;
    current = beta * x[j - 1];
    for (n = len + 1; n--; j += 2) {
      next = beta * x[j + 1];
      x[j] -= current + next;
      if (n--) {
        j += 2;
        current = beta * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }
    if (len !== 0) {
      j = offset + 1;
      current = alpha * x[j - 1];
      for (n = len; n--; j += 2) {
        next = alpha * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = alpha * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }
    }
  }
}
class ReversibleTransform extends Transform {
  filter(x, offset, length) {
    const len = length >> 1;
    offset |= 0;
    let j, n;
    for (j = offset, n = len + 1; n--; j += 2) {
      x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
    }
    for (j = offset + 1, n = len; n--; j += 2) {
      x[j] += x[j - 1] + x[j + 1] >> 1;
    }
  }
}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LZWStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
class LZWStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, earlyChange) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    const maxLzwDictionarySize = 4096;
    const lzwState = {
      earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };
    for (let i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }
    this.lzwState = lzwState;
  }
  readBits(n) {
    let bitsCached = this.bitsCached;
    let cachedData = this.cachedData;
    while (bitsCached < n) {
      const c = this.str.getByte();
      if (c === -1) {
        this.eof = true;
        return null;
      }
      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }
    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  }
  readBlock() {
    const blockSize = 512,
      decodedSizeDelta = blockSize;
    let estimatedDecodedSize = blockSize * 2;
    let i, j, q;
    const lzwState = this.lzwState;
    if (!lzwState) {
      return;
    }
    const earlyChange = lzwState.earlyChange;
    let nextCode = lzwState.nextCode;
    const dictionaryValues = lzwState.dictionaryValues;
    const dictionaryLengths = lzwState.dictionaryLengths;
    const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    let codeLength = lzwState.codeLength;
    let prevCode = lzwState.prevCode;
    const currentSequence = lzwState.currentSequence;
    let currentSequenceLength = lzwState.currentSequenceLength;
    let decodedLength = 0;
    let currentBufferLength = this.bufferLength;
    let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
    for (i = 0; i < blockSize; i++) {
      const code = this.readBits(codeLength);
      const hasPrev = currentSequenceLength > 0;
      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];
          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }
      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }
      prevCode = code;
      decodedLength += currentSequenceLength;
      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);
        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }
      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }
    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  }
}
exports.LZWStream = LZWStream;

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PredictorStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
class PredictorStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);
    if (!(params instanceof _primitives.Dict)) {
      return str;
    }
    const predictor = this.predictor = params.get("Predictor") || 1;
    if (predictor <= 1) {
      return str;
    }
    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
    }
    this.readBlock = predictor === 2 ? this.readBlockTiff : this.readBlockPng;
    this.str = str;
    this.dict = str.dict;
    const colors = this.colors = params.get("Colors") || 1;
    const bits = this.bits = params.get("BPC", "BitsPerComponent") || 8;
    const columns = this.columns = params.get("Columns") || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    return this;
  }
  readBlockTiff() {
    const rowBytes = this.rowBytes;
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    const bits = this.bits;
    const colors = this.colors;
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    let inbuf = 0,
      outbuf = 0;
    let inbits = 0,
      outbits = 0;
    let pos = bufferLength;
    let i;
    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        let c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else if (bits === 16) {
      const bytesPerPixel = colors * 2;
      for (i = 0; i < bytesPerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; i += 2) {
        const sum = ((rawBytes[i] & 0xff) << 8) + (rawBytes[i + 1] & 0xff) + ((buffer[pos - bytesPerPixel] & 0xff) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xff);
        buffer[pos++] = sum >> 8 & 0xff;
        buffer[pos++] = sum & 0xff;
      }
    } else {
      const compArray = new Uint8Array(colors + 1);
      const bitMask = (1 << bits) - 1;
      let j = 0,
        k = bufferLength;
      const columns = this.columns;
      for (i = 0; i < columns; ++i) {
        for (let kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xff;
            inbits += 8;
          }
          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;
          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xff;
            outbits -= 8;
          }
        }
      }
      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }
    this.bufferLength += rowBytes;
  }
  readBlockPng() {
    const rowBytes = this.rowBytes;
    const pixBytes = this.pixBytes;
    const predictor = this.str.getByte();
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }
    let i,
      j = bufferLength,
      up,
      c;
    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        break;
      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xff;
          j++;
        }
        break;
      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xff;
        }
        break;
      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xff;
          j++;
        }
        break;
      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }
        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          const upLeft = prevRow[i - pixBytes];
          const left = buffer[j - pixBytes];
          const p = left + up - upLeft;
          let pa = p - left;
          if (pa < 0) {
            pa = -pa;
          }
          let pb = p - up;
          if (pb < 0) {
            pb = -pb;
          }
          let pc = p - upLeft;
          if (pc < 0) {
            pc = -pc;
          }
          c = rawBytes[i];
          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }
        break;
      default:
        throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
    }
    this.bufferLength += rowBytes;
  }
}
exports.PredictorStream = PredictorStream;

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RunLengthStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
class RunLengthStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
  }
  readBlock() {
    const repeatHeader = this.str.getBytes(2);
    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }
    let buffer;
    let bufferLength = this.bufferLength;
    let n = repeatHeader[0];
    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];
      if (n > 0) {
        const source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      const b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);
      for (let i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }
    this.bufferLength = bufferLength;
  }
}
exports.RunLengthStream = RunLengthStream;

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Font = exports.ErrorFont = void 0;
var _util = __w_pdfjs_require__(2);
var _cff_parser = __w_pdfjs_require__(35);
var _fonts_utils = __w_pdfjs_require__(38);
var _unicode = __w_pdfjs_require__(40);
var _glyphlist = __w_pdfjs_require__(39);
var _encodings = __w_pdfjs_require__(37);
var _standard_fonts = __w_pdfjs_require__(41);
var _to_unicode_map = __w_pdfjs_require__(42);
var _cff_font = __w_pdfjs_require__(43);
var _font_renderer = __w_pdfjs_require__(44);
var _metrics = __w_pdfjs_require__(45);
var _glyf = __w_pdfjs_require__(46);
var _cmap = __w_pdfjs_require__(14);
var _opentype_file_builder = __w_pdfjs_require__(47);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _type1_font = __w_pdfjs_require__(48);
const PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]];
const PDF_GLYPH_SPACE_UNITS = 1000;
const EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"];
const EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function adjustWidths(properties) {
  if (!properties.fontMatrix) {
    return;
  }
  if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
    return;
  }
  const scale = 0.001 / properties.fontMatrix[0];
  const glyphsWidths = properties.widths;
  for (const glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }
  properties.defaultWidth *= scale;
}
function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
  if (properties.isInternalFont) {
    return;
  }
  if (properties.hasIncludedToUnicodeMap) {
    return;
  }
  if (properties.hasEncoding) {
    return;
  }
  if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
    return;
  }
  if (!isSymbolicFont) {
    return;
  }
  if (nameRecords.length === 0) {
    return;
  }
  if (properties.defaultEncoding === _encodings.WinAnsiEncoding) {
    return;
  }
  for (const r of nameRecords) {
    if (!isWinNameRecord(r)) {
      return;
    }
  }
  const encoding = _encodings.WinAnsiEncoding;
  const toUnicode = [],
    glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
  for (const charCode in encoding) {
    const glyphName = encoding[charCode];
    if (glyphName === "") {
      continue;
    }
    const unicode = glyphsUnicodeMap[glyphName];
    if (unicode === undefined) {
      continue;
    }
    toUnicode[charCode] = String.fromCharCode(unicode);
  }
  if (toUnicode.length > 0) {
    properties.toUnicode.amend(toUnicode);
  }
}
function adjustType1ToUnicode(properties, builtInEncoding) {
  if (properties.isInternalFont) {
    return;
  }
  if (properties.hasIncludedToUnicodeMap) {
    return;
  }
  if (builtInEncoding === properties.defaultEncoding) {
    return;
  }
  if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
    return;
  }
  const toUnicode = [],
    glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
  for (const charCode in builtInEncoding) {
    if (properties.hasEncoding) {
      if (properties.baseEncodingName || properties.differences[charCode] !== undefined) {
        continue;
      }
    }
    const glyphName = builtInEncoding[charCode];
    const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
    if (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }
  if (toUnicode.length > 0) {
    properties.toUnicode.amend(toUnicode);
  }
}
function amendFallbackToUnicode(properties) {
  if (!properties.fallbackToUnicode) {
    return;
  }
  if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
    return;
  }
  const toUnicode = [];
  for (const charCode in properties.fallbackToUnicode) {
    if (properties.toUnicode.has(charCode)) {
      continue;
    }
    toUnicode[charCode] = properties.fallbackToUnicode[charCode];
  }
  if (toUnicode.length > 0) {
    properties.toUnicode.amend(toUnicode);
  }
}
class Glyph {
  constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.originalCharCode = originalCharCode;
    this.fontChar = fontChar;
    this.unicode = unicode;
    this.accent = accent;
    this.width = width;
    this.vmetric = vmetric;
    this.operatorListId = operatorListId;
    this.isSpace = isSpace;
    this.isInFont = isInFont;
  }
  get category() {
    return (0, _util.shadow)(this, "category", (0, _unicode.getCharUnicodeCategory)(this.unicode), true);
  }
}
function int16(b0, b1) {
  return (b0 << 8) + b1;
}
function writeSignedInt16(bytes, index, value) {
  bytes[index + 1] = value;
  bytes[index] = value >>> 8;
}
function signedInt16(b0, b1) {
  const value = (b0 << 8) + b1;
  return value & 1 << 15 ? value - 0x10000 : value;
}
function int32(b0, b1, b2, b3) {
  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
}
function string16(value) {
  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
}
function safeString16(value) {
  if (value > 0x7fff) {
    value = 0x7fff;
  } else if (value < -0x8000) {
    value = -0x8000;
  }
  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
}
function isTrueTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _core_utils.readUint32)(header, 0) === 0x00010000 || (0, _util.bytesToString)(header) === "true";
}
function isTrueTypeCollectionFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(header) === "ttcf";
}
function isOpenTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(header) === "OTTO";
}
function isType1File(file) {
  const header = file.peekBytes(2);
  if (header[0] === 0x25 && header[1] === 0x21) {
    return true;
  }
  if (header[0] === 0x80 && header[1] === 0x01) {
    return true;
  }
  return false;
}
function isCFFFile(file) {
  const header = file.peekBytes(4);
  if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
    return true;
  }
  return false;
}
function getFontFileType(file, {
  type,
  subtype,
  composite
}) {
  let fileType, fileSubtype;
  if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
    fileType = composite ? "CIDFontType2" : "TrueType";
  } else if (isOpenTypeFile(file)) {
    fileType = composite ? "CIDFontType2" : "OpenType";
  } else if (isType1File(file)) {
    if (composite) {
      fileType = "CIDFontType0";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
    }
  } else if (isCFFFile(file)) {
    if (composite) {
      fileType = "CIDFontType0";
      fileSubtype = "CIDFontType0C";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
      fileSubtype = "Type1C";
    }
  } else {
    (0, _util.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
    fileType = type;
    fileSubtype = subtype;
  }
  return [fileType, fileSubtype];
}
function applyStandardFontGlyphMap(map, glyphMap) {
  for (const charCode in glyphMap) {
    map[+charCode] = glyphMap[charCode];
  }
}
function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
  const toFontChar = [];
  let unicode;
  for (let i = 0, ii = encoding.length; i < ii; i++) {
    unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
    if (unicode !== -1) {
      toFontChar[i] = unicode;
    }
  }
  for (const charCode in differences) {
    unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
    if (unicode !== -1) {
      toFontChar[+charCode] = unicode;
    }
  }
  return toFontChar;
}
function isMacNameRecord(r) {
  return r.platform === 1 && r.encoding === 0 && r.language === 0;
}
function isWinNameRecord(r) {
  return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
}
function convertCidString(charCode, cid, shouldThrow = false) {
  switch (cid.length) {
    case 1:
      return cid.charCodeAt(0);
    case 2:
      return cid.charCodeAt(0) << 8 | cid.charCodeAt(1);
  }
  const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
  if (shouldThrow) {
    throw new _util.FormatError(msg);
  }
  (0, _util.warn)(msg);
  return cid;
}
function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
  const newMap = Object.create(null);
  const toUnicodeExtraMap = new Map();
  const toFontChar = [];
  const usedGlyphIds = new Set();
  let privateUseAreaIndex = 0;
  const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
  let nextAvailableFontCharCode = privateUseOffetStart;
  let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
  const isInPrivateArea = code => PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1] || PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1];
  for (let originalCharCode in charCodeToGlyphId) {
    originalCharCode |= 0;
    let glyphId = charCodeToGlyphId[originalCharCode];
    if (!hasGlyph(glyphId)) {
      continue;
    }
    if (nextAvailableFontCharCode > privateUseOffetEnd) {
      privateUseAreaIndex++;
      if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
        (0, _util.warn)("Ran out of space in font private use area.");
        break;
      }
      nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
      privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
    }
    const fontCharCode = nextAvailableFontCharCode++;
    if (glyphId === 0) {
      glyphId = newGlyphZeroId;
    }
    let unicode = toUnicode.get(originalCharCode);
    if (typeof unicode === "string") {
      unicode = unicode.codePointAt(0);
    }
    if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
      toUnicodeExtraMap.set(unicode, glyphId);
      usedGlyphIds.add(glyphId);
    }
    newMap[fontCharCode] = glyphId;
    toFontChar[originalCharCode] = fontCharCode;
  }
  return {
    toFontChar,
    charCodeToGlyphId: newMap,
    toUnicodeExtraMap,
    nextAvailableFontCharCode
  };
}
function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
  const codes = [];
  for (const charCode in glyphs) {
    if (glyphs[charCode] >= numGlyphs) {
      continue;
    }
    codes.push({
      fontCharCode: charCode | 0,
      glyphId: glyphs[charCode]
    });
  }
  if (toUnicodeExtraMap) {
    for (const [unicode, glyphId] of toUnicodeExtraMap) {
      if (glyphId >= numGlyphs) {
        continue;
      }
      codes.push({
        fontCharCode: unicode,
        glyphId
      });
    }
  }
  if (codes.length === 0) {
    codes.push({
      fontCharCode: 0,
      glyphId: 0
    });
  }
  codes.sort(function fontGetRangesSort(a, b) {
    return a.fontCharCode - b.fontCharCode;
  });
  const ranges = [];
  const length = codes.length;
  for (let n = 0; n < length;) {
    const start = codes[n].fontCharCode;
    const codeIndices = [codes[n].glyphId];
    ++n;
    let end = start;
    while (n < length && end + 1 === codes[n].fontCharCode) {
      codeIndices.push(codes[n].glyphId);
      ++end;
      ++n;
      if (end === 0xffff) {
        break;
      }
    }
    ranges.push([start, end, codeIndices]);
  }
  return ranges;
}
function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
  const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
  const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
  let cmap = "\x00\x00" + string16(numTables) + "\x00\x03" + "\x00\x01" + (0, _util.string32)(4 + numTables * 8);
  let i, ii, j, jj;
  for (i = ranges.length - 1; i >= 0; --i) {
    if (ranges[i][0] <= 0xffff) {
      break;
    }
  }
  const bmpLength = i + 1;
  if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
    ranges[i][1] = 0xfffe;
  }
  const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
  const segCount = bmpLength + trailingRangesCount;
  const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2);
  let startCount = "";
  let endCount = "";
  let idDeltas = "";
  let idRangeOffsets = "";
  let glyphsIds = "";
  let bias = 0;
  let range, start, end, codes;
  for (i = 0, ii = bmpLength; i < ii; i++) {
    range = ranges[i];
    start = range[0];
    end = range[1];
    startCount += string16(start);
    endCount += string16(end);
    codes = range[2];
    let contiguous = true;
    for (j = 1, jj = codes.length; j < jj; ++j) {
      if (codes[j] !== codes[j - 1] + 1) {
        contiguous = false;
        break;
      }
    }
    if (!contiguous) {
      const offset = (segCount - i) * 2 + bias * 2;
      bias += end - start + 1;
      idDeltas += string16(0);
      idRangeOffsets += string16(offset);
      for (j = 0, jj = codes.length; j < jj; ++j) {
        glyphsIds += string16(codes[j]);
      }
    } else {
      const startCode = codes[0];
      idDeltas += string16(startCode - start & 0xffff);
      idRangeOffsets += string16(0);
    }
  }
  if (trailingRangesCount > 0) {
    endCount += "\xFF\xFF";
    startCount += "\xFF\xFF";
    idDeltas += "\x00\x01";
    idRangeOffsets += "\x00\x00";
  }
  const format314 = "\x00\x00" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\x00\x00" + startCount + idDeltas + idRangeOffsets + glyphsIds;
  let format31012 = "";
  let header31012 = "";
  if (numTables > 1) {
    cmap += "\x00\x03" + "\x00\x0A" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
    format31012 = "";
    for (i = 0, ii = ranges.length; i < ii; i++) {
      range = ranges[i];
      start = range[0];
      codes = range[2];
      let code = codes[0];
      for (j = 1, jj = codes.length; j < jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          end = range[0] + j - 1;
          format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
          start = end + 1;
          code = codes[j];
        }
      }
      format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
    }
    header31012 = "\x00\x0C" + "\x00\x00" + (0, _util.string32)(format31012.length + 16) + "\x00\x00\x00\x00" + (0, _util.string32)(format31012.length / 12);
  }
  return cmap + "\x00\x04" + string16(format314.length + 4) + format314 + header31012 + format31012;
}
function validateOS2Table(os2, file) {
  file.pos = (file.start || 0) + os2.offset;
  const version = file.getUint16();
  file.skip(60);
  const selection = file.getUint16();
  if (version < 4 && selection & 0x0300) {
    return false;
  }
  const firstChar = file.getUint16();
  const lastChar = file.getUint16();
  if (firstChar > lastChar) {
    return false;
  }
  file.skip(6);
  const usWinAscent = file.getUint16();
  if (usWinAscent === 0) {
    return false;
  }
  os2.data[8] = os2.data[9] = 0;
  return true;
}
function createOS2Table(properties, charstrings, override) {
  override ||= {
    unitsPerEm: 0,
    yMax: 0,
    yMin: 0,
    ascent: 0,
    descent: 0
  };
  let ulUnicodeRange1 = 0;
  let ulUnicodeRange2 = 0;
  let ulUnicodeRange3 = 0;
  let ulUnicodeRange4 = 0;
  let firstCharIndex = null;
  let lastCharIndex = 0;
  let position = -1;
  if (charstrings) {
    for (let code in charstrings) {
      code |= 0;
      if (firstCharIndex > code || !firstCharIndex) {
        firstCharIndex = code;
      }
      if (lastCharIndex < code) {
        lastCharIndex = code;
      }
      position = (0, _unicode.getUnicodeRangeFor)(code, position);
      if (position < 32) {
        ulUnicodeRange1 |= 1 << position;
      } else if (position < 64) {
        ulUnicodeRange2 |= 1 << position - 32;
      } else if (position < 96) {
        ulUnicodeRange3 |= 1 << position - 64;
      } else if (position < 123) {
        ulUnicodeRange4 |= 1 << position - 96;
      } else {
        throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
      }
    }
    if (lastCharIndex > 0xffff) {
      lastCharIndex = 0xffff;
    }
  } else {
    firstCharIndex = 0;
    lastCharIndex = 255;
  }
  const bbox = properties.bbox || [0, 0, 0, 0];
  const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
  const scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
  const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
  let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
  if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
    typoDescent = -typoDescent;
  }
  const winAscent = override.yMax || typoAscent;
  const winDescent = -override.yMin || -typoDescent;
  return "\x00\x03" + "\x02\x24" + "\x01\xF4" + "\x00\x05" + "\x00\x00" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x00\x8C" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x01\xDF" + "\x00\x31" + "\x01\x02" + "\x00\x00" + "\x00\x00\x06" + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + "\x00\x00\x00\x00\x00\x00" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "\x2A\x32\x31\x2A" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\x00\x64" + string16(winAscent) + string16(winDescent) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\x00\x03";
}
function createPostTable(properties) {
  const angle = Math.floor(properties.italicAngle * 2 ** 16);
  return "\x00\x03\x00\x00" + (0, _util.string32)(angle) + "\x00\x00" + "\x00\x00" + (0, _util.string32)(properties.fixedPitch ? 1 : 0) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00";
}
function createPostscriptName(name) {
  return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(name, proto) {
  if (!proto) {
    proto = [[], []];
  }
  const strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || createPostscriptName(name), proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
  const stringsUnicode = [];
  let i, ii, j, jj, str;
  for (i = 0, ii = strings.length; i < ii; i++) {
    str = proto[1][i] || strings[i];
    const strBufUnicode = [];
    for (j = 0, jj = str.length; j < jj; j++) {
      strBufUnicode.push(string16(str.charCodeAt(j)));
    }
    stringsUnicode.push(strBufUnicode.join(""));
  }
  const names = [strings, stringsUnicode];
  const platforms = ["\x00\x01", "\x00\x03"];
  const encodings = ["\x00\x00", "\x00\x01"];
  const languages = ["\x00\x00", "\x04\x09"];
  const namesRecordCount = strings.length * platforms.length;
  let nameTable = "\x00\x00" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
  let strOffset = 0;
  for (i = 0, ii = platforms.length; i < ii; i++) {
    const strs = names[i];
    for (j = 0, jj = strs.length; j < jj; j++) {
      str = strs[j];
      const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
      nameTable += nameRecord;
      strOffset += str.length;
    }
  }
  nameTable += strings.join("") + stringsUnicode.join("");
  return nameTable;
}
class Font {
  constructor(name, file, properties) {
    this.name = name;
    this.psName = null;
    this.mimetype = null;
    this.disableFontFace = false;
    this.loadedName = properties.loadedName;
    this.isType3Font = properties.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = properties.cssFontInfo;
    this._charsCache = Object.create(null);
    this._glyphCache = Object.create(null);
    let isSerifFont = !!(properties.flags & _fonts_utils.FontFlags.Serif);
    if (!isSerifFont && !properties.isSimulatedFlags) {
      const baseName = name.replaceAll(/[,_]/g, "-").split("-")[0],
        serifFonts = (0, _standard_fonts.getSerifFonts)();
      for (const namePart of baseName.split("+")) {
        if (serifFonts[namePart]) {
          isSerifFont = true;
          break;
        }
      }
    }
    this.isSerifFont = isSerifFont;
    this.isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & _fonts_utils.FontFlags.FixedPitch);
    let {
      type,
      subtype
    } = properties;
    this.type = type;
    this.subtype = subtype;
    this.systemFontInfo = properties.systemFontInfo;
    const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    this.isInvalidPDFjsFont = !!matches;
    if (this.isInvalidPDFjsFont) {
      this.fallbackName = matches[1];
    } else if (this.isMonospace) {
      this.fallbackName = "monospace";
    } else if (this.isSerifFont) {
      this.fallbackName = "serif";
    } else {
      this.fallbackName = "sans-serif";
    }
    if (this.systemFontInfo?.guessFallback) {
      this.systemFontInfo.guessFallback = false;
      this.systemFontInfo.css += `,${this.fallbackName}`;
    }
    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.cMap = properties.cMap;
    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.lineHeight = this.ascent - this.descent;
    this.fontMatrix = properties.fontMatrix;
    this.bbox = properties.bbox;
    this.defaultEncoding = properties.defaultEncoding;
    this.toUnicode = properties.toUnicode;
    this.toFontChar = [];
    if (properties.type === "Type3") {
      for (let charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }
      return;
    }
    this.cidEncoding = properties.cidEncoding || "";
    this.vertical = !!properties.vertical;
    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }
    if (!file || file.isEmpty) {
      if (file) {
        (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
      }
      this.fallbackToSystemFont(properties);
      return;
    }
    [type, subtype] = getFontFileType(file, properties);
    if (type !== this.type || subtype !== this.subtype) {
      (0, _util.info)("Inconsistent font file Type/SubType, expected: " + `${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
    }
    let data;
    try {
      switch (type) {
        case "MMType1":
          (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new _cff_font.CFFFont(file, properties) : new _type1_font.Type1Font(name, file, properties);
          adjustWidths(properties);
          data = this.convert(name, cff, properties);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          data = this.checkAndRepair(name, file, properties);
          if (this.isOpenType) {
            adjustWidths(properties);
            type = "OpenType";
          }
          break;
        default:
          throw new _util.FormatError(`Font ${type} is not supported`);
      }
    } catch (e) {
      (0, _util.warn)(e);
      this.fallbackToSystemFont(properties);
      return;
    }
    amendFallbackToUnicode(properties);
    this.data = data;
    this.type = type;
    this.subtype = subtype;
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.seacMap = properties.seacMap;
  }
  get renderer() {
    const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    return (0, _util.shadow)(this, "renderer", renderer);
  }
  exportData(extraProperties = false) {
    const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
    const data = Object.create(null);
    let property, value;
    for (property of exportDataProperties) {
      value = this[property];
      if (value !== undefined) {
        data[property] = value;
      }
    }
    return data;
  }
  fallbackToSystemFont(properties) {
    this.missingFile = true;
    const {
      name,
      type
    } = this;
    let fontName = (0, _fonts_utils.normalizeFontName)(name);
    const stdFontMap = (0, _standard_fonts.getStdFontMap)(),
      nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
    const isStandardFont = !!stdFontMap[fontName];
    const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
    const fontBasicMetricsMap = (0, _metrics.getFontBasicMetrics)();
    const metrics = fontBasicMetricsMap[fontName];
    if (metrics) {
      if (isNaN(this.ascent)) {
        this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
      }
      if (isNaN(this.descent)) {
        this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
      }
      if (isNaN(this.capHeight)) {
        this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
      }
    }
    this.bold = /bold/gi.test(fontName);
    this.italic = /oblique|italic/gi.test(fontName);
    this.black = /Black/g.test(name);
    const isNarrow = /Narrow/g.test(name);
    this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
    if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const cidToGidMap = properties.cidToGidMap;
      const map = [];
      applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
      if (/Arial-?Black/i.test(name)) {
        applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)());
      } else if (/Calibri/i.test(name)) {
        applyStandardFontGlyphMap(map, (0, _standard_fonts.getSupplementalGlyphMapForCalibri)());
      }
      if (cidToGidMap) {
        for (const charCode in map) {
          const cid = map[charCode];
          if (cidToGidMap[cid] !== undefined) {
            map[+charCode] = cidToGidMap[cid];
          }
        }
        if (cidToGidMap.length !== this.toUnicode.length && properties.hasIncludedToUnicodeMap && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
          this.toUnicode.forEach(function (charCode, unicodeCharCode) {
            const cid = map[charCode];
            if (cidToGidMap[cid] === undefined) {
              map[+charCode] = unicodeCharCode;
            }
          });
        }
      }
      if (!(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }
      this.toFontChar = map;
      this.toUnicode = new _to_unicode_map.ToUnicodeMap(map);
    } else if (/Symbol/i.test(fontName)) {
      this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
    } else if (/Dingbats/i.test(fontName)) {
      this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
    } else if (isStandardFont) {
      const map = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
      if (type === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }
      this.toFontChar = map;
    } else {
      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      const map = [];
      this.toUnicode.forEach((charCode, unicodeCharCode) => {
        if (!this.composite) {
          const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
          const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
          if (unicode !== -1) {
            unicodeCharCode = unicode;
          }
        }
        map[+charCode] = unicodeCharCode;
      });
      if (this.composite && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
        if (/Tahoma|Verdana/i.test(name)) {
          applyStandardFontGlyphMap(map, (0, _standard_fonts.getGlyphMapForStandardFonts)());
        }
      }
      this.toFontChar = map;
    }
    amendFallbackToUnicode(properties);
    this.loadedName = fontName.split("-")[0];
  }
  checkAndRepair(name, font, properties) {
    const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function readTables(file, numTables) {
      const tables = Object.create(null);
      tables["OS/2"] = null;
      tables.cmap = null;
      tables.head = null;
      tables.hhea = null;
      tables.hmtx = null;
      tables.maxp = null;
      tables.name = null;
      tables.post = null;
      for (let i = 0; i < numTables; i++) {
        const table = readTableEntry(file);
        if (!VALID_TABLES.includes(table.tag)) {
          continue;
        }
        if (table.length === 0) {
          continue;
        }
        tables[table.tag] = table;
      }
      return tables;
    }
    function readTableEntry(file) {
      const tag = file.getString(4);
      const checksum = file.getInt32() >>> 0;
      const offset = file.getInt32() >>> 0;
      const length = file.getInt32() >>> 0;
      const previousPosition = file.pos;
      file.pos = file.start || 0;
      file.skip(offset);
      const data = file.getBytes(length);
      file.pos = previousPosition;
      if (tag === "head") {
        data[8] = data[9] = data[10] = data[11] = 0;
        data[17] |= 0x20;
      }
      return {
        tag,
        checksum,
        length,
        offset,
        data
      };
    }
    function readOpenTypeHeader(ttf) {
      return {
        version: ttf.getString(4),
        numTables: ttf.getUint16(),
        searchRange: ttf.getUint16(),
        entrySelector: ttf.getUint16(),
        rangeShift: ttf.getUint16()
      };
    }
    function readTrueTypeCollectionHeader(ttc) {
      const ttcTag = ttc.getString(4);
      (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
      const majorVersion = ttc.getUint16();
      const minorVersion = ttc.getUint16();
      const numFonts = ttc.getInt32() >>> 0;
      const offsetTable = [];
      for (let i = 0; i < numFonts; i++) {
        offsetTable.push(ttc.getInt32() >>> 0);
      }
      const header = {
        ttcTag,
        majorVersion,
        minorVersion,
        numFonts,
        offsetTable
      };
      switch (majorVersion) {
        case 1:
          return header;
        case 2:
          header.dsigTag = ttc.getInt32() >>> 0;
          header.dsigLength = ttc.getInt32() >>> 0;
          header.dsigOffset = ttc.getInt32() >>> 0;
          return header;
      }
      throw new _util.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
    }
    function readTrueTypeCollectionData(ttc, fontName) {
      const {
        numFonts,
        offsetTable
      } = readTrueTypeCollectionHeader(ttc);
      const fontNameParts = fontName.split("+");
      let fallbackData;
      for (let i = 0; i < numFonts; i++) {
        ttc.pos = (ttc.start || 0) + offsetTable[i];
        const potentialHeader = readOpenTypeHeader(ttc);
        const potentialTables = readTables(ttc, potentialHeader.numTables);
        if (!potentialTables.name) {
          throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
        }
        const [nameTable] = readNameTable(potentialTables.name);
        for (let j = 0, jj = nameTable.length; j < jj; j++) {
          for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
            const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
            if (!nameEntry) {
              continue;
            }
            if (nameEntry === fontName) {
              return {
                header: potentialHeader,
                tables: potentialTables
              };
            }
            if (fontNameParts.length < 2) {
              continue;
            }
            for (const part of fontNameParts) {
              if (nameEntry === part) {
                fallbackData = {
                  name: part,
                  header: potentialHeader,
                  tables: potentialTables
                };
              }
            }
          }
        }
      }
      if (fallbackData) {
        (0, _util.warn)(`TrueType Collection does not contain "${fontName}" font, ` + `falling back to "${fallbackData.name}" font instead.`);
        return {
          header: fallbackData.header,
          tables: fallbackData.tables
        };
      }
      throw new _util.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
    }
    function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
      if (!cmap) {
        (0, _util.warn)("No cmap table available.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      let segment;
      let start = (file.start || 0) + cmap.offset;
      file.pos = start;
      file.skip(2);
      const numTables = file.getUint16();
      let potentialTable;
      let canBreak = false;
      for (let i = 0; i < numTables; i++) {
        const platformId = file.getUint16();
        const encodingId = file.getUint16();
        const offset = file.getInt32() >>> 0;
        let useTable = false;
        if (potentialTable?.platformId === platformId && potentialTable?.encodingId === encodingId) {
          continue;
        }
        if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
          useTable = true;
        } else if (platformId === 1 && encodingId === 0) {
          useTable = true;
        } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
          useTable = true;
          if (!isSymbolicFont) {
            canBreak = true;
          }
        } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
          useTable = true;
          let correctlySorted = true;
          if (i < numTables - 1) {
            const nextBytes = file.peekBytes(2),
              nextPlatformId = int16(nextBytes[0], nextBytes[1]);
            if (nextPlatformId < platformId) {
              correctlySorted = false;
            }
          }
          if (correctlySorted) {
            canBreak = true;
          }
        }
        if (useTable) {
          potentialTable = {
            platformId,
            encodingId,
            offset
          };
        }
        if (canBreak) {
          break;
        }
      }
      if (potentialTable) {
        file.pos = start + potentialTable.offset;
      }
      if (!potentialTable || file.peekByte() === -1) {
        (0, _util.warn)("Could not find a preferred cmap table.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      const format = file.getUint16();
      let hasShortCmap = false;
      const mappings = [];
      let j, glyphId;
      if (format === 0) {
        file.skip(2 + 2);
        for (j = 0; j < 256; j++) {
          const index = file.getByte();
          if (!index) {
            continue;
          }
          mappings.push({
            charCode: j,
            glyphId: index
          });
        }
        hasShortCmap = true;
      } else if (format === 2) {
        file.skip(2 + 2);
        const subHeaderKeys = [];
        let maxSubHeaderKey = 0;
        for (let i = 0; i < 256; i++) {
          const subHeaderKey = file.getUint16() >> 3;
          subHeaderKeys.push(subHeaderKey);
          maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
        }
        const subHeaders = [];
        for (let i = 0; i <= maxSubHeaderKey; i++) {
          subHeaders.push({
            firstCode: file.getUint16(),
            entryCount: file.getUint16(),
            idDelta: signedInt16(file.getByte(), file.getByte()),
            idRangePos: file.pos + file.getUint16()
          });
        }
        for (let i = 0; i < 256; i++) {
          if (subHeaderKeys[i] === 0) {
            file.pos = subHeaders[0].idRangePos + 2 * i;
            glyphId = file.getUint16();
            mappings.push({
              charCode: i,
              glyphId
            });
          } else {
            const s = subHeaders[subHeaderKeys[i]];
            for (j = 0; j < s.entryCount; j++) {
              const charCode = (i << 8) + j + s.firstCode;
              file.pos = s.idRangePos + 2 * j;
              glyphId = file.getUint16();
              if (glyphId !== 0) {
                glyphId = (glyphId + s.idDelta) % 65536;
              }
              mappings.push({
                charCode,
                glyphId
              });
            }
          }
        }
      } else if (format === 4) {
        file.skip(2 + 2);
        const segCount = file.getUint16() >> 1;
        file.skip(6);
        const segments = [];
        let segIndex;
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments.push({
            end: file.getUint16()
          });
        }
        file.skip(2);
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].start = file.getUint16();
        }
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].delta = file.getUint16();
        }
        let offsetsCount = 0,
          offsetIndex;
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          const rangeOffset = file.getUint16();
          if (!rangeOffset) {
            segment.offsetIndex = -1;
            continue;
          }
          offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
          segment.offsetIndex = offsetIndex;
          offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
        }
        const offsets = [];
        for (j = 0; j < offsetsCount; j++) {
          offsets.push(file.getUint16());
        }
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          start = segment.start;
          const end = segment.end;
          const delta = segment.delta;
          offsetIndex = segment.offsetIndex;
          for (j = start; j <= end; j++) {
            if (j === 0xffff) {
              continue;
            }
            glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
            glyphId = glyphId + delta & 0xffff;
            mappings.push({
              charCode: j,
              glyphId
            });
          }
        }
      } else if (format === 6) {
        file.skip(2 + 2);
        const firstCode = file.getUint16();
        const entryCount = file.getUint16();
        for (j = 0; j < entryCount; j++) {
          glyphId = file.getUint16();
          const charCode = firstCode + j;
          mappings.push({
            charCode,
            glyphId
          });
        }
      } else if (format === 12) {
        file.skip(2 + 4 + 4);
        const nGroups = file.getInt32() >>> 0;
        for (j = 0; j < nGroups; j++) {
          const startCharCode = file.getInt32() >>> 0;
          const endCharCode = file.getInt32() >>> 0;
          let glyphCode = file.getInt32() >>> 0;
          for (let charCode = startCharCode; charCode <= endCharCode; charCode++) {
            mappings.push({
              charCode,
              glyphId: glyphCode++
            });
          }
        }
      } else {
        (0, _util.warn)("cmap table has unsupported format: " + format);
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      mappings.sort(function (a, b) {
        return a.charCode - b.charCode;
      });
      for (let i = 1; i < mappings.length; i++) {
        if (mappings[i - 1].charCode === mappings[i].charCode) {
          mappings.splice(i, 1);
          i--;
        }
      }
      return {
        platformId: potentialTable.platformId,
        encodingId: potentialTable.encodingId,
        mappings,
        hasShortCmap
      };
    }
    function sanitizeMetrics(file, header, metrics, headTable, numGlyphs, dupFirstEntry) {
      if (!header) {
        if (metrics) {
          metrics.data = null;
        }
        return;
      }
      file.pos = (file.start || 0) + header.offset;
      file.pos += 4;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      const caretOffset = file.getUint16();
      file.pos += 8;
      file.pos += 2;
      let numOfMetrics = file.getUint16();
      if (caretOffset !== 0) {
        const macStyle = int16(headTable.data[44], headTable.data[45]);
        if (!(macStyle & 2)) {
          header.data[22] = 0;
          header.data[23] = 0;
        }
      }
      if (numOfMetrics > numGlyphs) {
        (0, _util.info)(`The numOfMetrics (${numOfMetrics}) should not be ` + `greater than the numGlyphs (${numGlyphs}).`);
        numOfMetrics = numGlyphs;
        header.data[34] = (numOfMetrics & 0xff00) >> 8;
        header.data[35] = numOfMetrics & 0x00ff;
      }
      const numOfSidebearings = numGlyphs - numOfMetrics;
      const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
      if (numMissing > 0) {
        const entries = new Uint8Array(metrics.length + numMissing * 2);
        entries.set(metrics.data);
        if (dupFirstEntry) {
          entries[metrics.length] = metrics.data[2];
          entries[metrics.length + 1] = metrics.data[3];
        }
        metrics.data = entries;
      }
    }
    function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {
      const glyphProfile = {
        length: 0,
        sizeOfInstructions: 0
      };
      if (sourceStart < 0 || sourceStart >= source.length || sourceEnd > source.length || sourceEnd - sourceStart <= 12) {
        return glyphProfile;
      }
      const glyf = source.subarray(sourceStart, sourceEnd);
      const xMin = signedInt16(glyf[2], glyf[3]);
      const yMin = signedInt16(glyf[4], glyf[5]);
      const xMax = signedInt16(glyf[6], glyf[7]);
      const yMax = signedInt16(glyf[8], glyf[9]);
      if (xMin > xMax) {
        writeSignedInt16(glyf, 2, xMax);
        writeSignedInt16(glyf, 6, xMin);
      }
      if (yMin > yMax) {
        writeSignedInt16(glyf, 4, yMax);
        writeSignedInt16(glyf, 8, yMin);
      }
      const contoursCount = signedInt16(glyf[0], glyf[1]);
      if (contoursCount < 0) {
        if (contoursCount < -1) {
          return glyphProfile;
        }
        dest.set(glyf, destStart);
        glyphProfile.length = glyf.length;
        return glyphProfile;
      }
      let i,
        j = 10,
        flagsCount = 0;
      for (i = 0; i < contoursCount; i++) {
        const endPoint = glyf[j] << 8 | glyf[j + 1];
        flagsCount = endPoint + 1;
        j += 2;
      }
      const instructionsStart = j;
      const instructionsLength = glyf[j] << 8 | glyf[j + 1];
      glyphProfile.sizeOfInstructions = instructionsLength;
      j += 2 + instructionsLength;
      const instructionsEnd = j;
      let coordinatesLength = 0;
      for (i = 0; i < flagsCount; i++) {
        const flag = glyf[j++];
        if (flag & 0xc0) {
          glyf[j - 1] = flag & 0x3f;
        }
        let xLength = 2;
        if (flag & 2) {
          xLength = 1;
        } else if (flag & 16) {
          xLength = 0;
        }
        let yLength = 2;
        if (flag & 4) {
          yLength = 1;
        } else if (flag & 32) {
          yLength = 0;
        }
        const xyLength = xLength + yLength;
        coordinatesLength += xyLength;
        if (flag & 8) {
          const repeat = glyf[j++];
          if (repeat === 0) {
            glyf[j - 1] ^= 8;
          }
          i += repeat;
          coordinatesLength += repeat * xyLength;
        }
      }
      if (coordinatesLength === 0) {
        return glyphProfile;
      }
      let glyphDataLength = j + coordinatesLength;
      if (glyphDataLength > glyf.length) {
        return glyphProfile;
      }
      if (!hintsValid && instructionsLength > 0) {
        dest.set(glyf.subarray(0, instructionsStart), destStart);
        dest.set([0, 0], destStart + instructionsStart);
        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
        glyphDataLength -= instructionsLength;
        if (glyf.length - glyphDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
        }
        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }
      if (glyf.length - glyphDataLength > 3) {
        glyphDataLength = glyphDataLength + 3 & ~3;
        dest.set(glyf.subarray(0, glyphDataLength), destStart);
        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }
      dest.set(glyf, destStart);
      glyphProfile.length = glyf.length;
      return glyphProfile;
    }
    function sanitizeHead(head, numGlyphs, locaLength) {
      const data = head.data;
      const version = int32(data[0], data[1], data[2], data[3]);
      if (version >> 16 !== 1) {
        (0, _util.info)("Attempting to fix invalid version in head table: " + version);
        data[0] = 0;
        data[1] = 1;
        data[2] = 0;
        data[3] = 0;
      }
      const indexToLocFormat = int16(data[50], data[51]);
      if (indexToLocFormat < 0 || indexToLocFormat > 1) {
        (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
        const numGlyphsPlusOne = numGlyphs + 1;
        if (locaLength === numGlyphsPlusOne << 1) {
          data[50] = 0;
          data[51] = 0;
        } else if (locaLength === numGlyphsPlusOne << 2) {
          data[50] = 0;
          data[51] = 1;
        } else {
          throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
        }
      }
    }
    function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) {
      let itemSize, itemDecode, itemEncode;
      if (isGlyphLocationsLong) {
        itemSize = 4;
        itemDecode = function fontItemDecodeLong(data, offset) {
          return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        };
        itemEncode = function fontItemEncodeLong(data, offset, value) {
          data[offset] = value >>> 24 & 0xff;
          data[offset + 1] = value >> 16 & 0xff;
          data[offset + 2] = value >> 8 & 0xff;
          data[offset + 3] = value & 0xff;
        };
      } else {
        itemSize = 2;
        itemDecode = function fontItemDecode(data, offset) {
          return data[offset] << 9 | data[offset + 1] << 1;
        };
        itemEncode = function fontItemEncode(data, offset, value) {
          data[offset] = value >> 9 & 0xff;
          data[offset + 1] = value >> 1 & 0xff;
        };
      }
      const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
      const locaDataSize = itemSize * (1 + numGlyphsOut);
      const locaData = new Uint8Array(locaDataSize);
      locaData.set(loca.data.subarray(0, locaDataSize));
      loca.data = locaData;
      const oldGlyfData = glyf.data;
      const oldGlyfDataLength = oldGlyfData.length;
      const newGlyfData = new Uint8Array(oldGlyfDataLength);
      let i, j;
      const locaEntries = [];
      for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
        let offset = itemDecode(locaData, j);
        if (offset > oldGlyfDataLength) {
          offset = oldGlyfDataLength;
        }
        locaEntries.push({
          index: i,
          offset,
          endOffset: 0
        });
      }
      locaEntries.sort((a, b) => {
        return a.offset - b.offset;
      });
      for (i = 0; i < numGlyphs; i++) {
        locaEntries[i].endOffset = locaEntries[i + 1].offset;
      }
      locaEntries.sort((a, b) => {
        return a.index - b.index;
      });
      for (i = 0; i < numGlyphs; i++) {
        const {
          offset,
          endOffset
        } = locaEntries[i];
        if (offset !== 0 || endOffset !== 0) {
          break;
        }
        const nextOffset = locaEntries[i + 1].offset;
        if (nextOffset === 0) {
          continue;
        }
        locaEntries[i].endOffset = nextOffset;
        break;
      }
      const missingGlyphs = Object.create(null);
      let writeOffset = 0;
      itemEncode(locaData, 0, writeOffset);
      for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
        const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid);
        const newLength = glyphProfile.length;
        if (newLength === 0) {
          missingGlyphs[i] = true;
        }
        if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
          maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
        }
        writeOffset += newLength;
        itemEncode(locaData, j, writeOffset);
      }
      if (writeOffset === 0) {
        const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
        for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
          itemEncode(locaData, j, simpleGlyph.length);
        }
        glyf.data = simpleGlyph;
      } else if (dupFirstEntry) {
        const firstEntryLength = itemDecode(locaData, itemSize);
        if (newGlyfData.length > firstEntryLength + writeOffset) {
          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
        } else {
          glyf.data = new Uint8Array(firstEntryLength + writeOffset);
          glyf.data.set(newGlyfData.subarray(0, writeOffset));
        }
        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
      } else {
        glyf.data = newGlyfData.subarray(0, writeOffset);
      }
      return {
        missingGlyphs,
        maxSizeOfInstructions
      };
    }
    function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
      const start = (font.start || 0) + post.offset;
      font.pos = start;
      const length = post.length,
        end = start + length;
      const version = font.getInt32();
      font.skip(28);
      let glyphNames;
      let valid = true;
      let i;
      switch (version) {
        case 0x00010000:
          glyphNames = _fonts_utils.MacStandardGlyphOrdering;
          break;
        case 0x00020000:
          const numGlyphs = font.getUint16();
          if (numGlyphs !== maxpNumGlyphs) {
            valid = false;
            break;
          }
          const glyphNameIndexes = [];
          for (i = 0; i < numGlyphs; ++i) {
            const index = font.getUint16();
            if (index >= 32768) {
              valid = false;
              break;
            }
            glyphNameIndexes.push(index);
          }
          if (!valid) {
            break;
          }
          const customNames = [],
            strBuf = [];
          while (font.pos < end) {
            const stringLength = font.getByte();
            strBuf.length = stringLength;
            for (i = 0; i < stringLength; ++i) {
              strBuf[i] = String.fromCharCode(font.getByte());
            }
            customNames.push(strBuf.join(""));
          }
          glyphNames = [];
          for (i = 0; i < numGlyphs; ++i) {
            const j = glyphNameIndexes[i];
            if (j < 258) {
              glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]);
              continue;
            }
            glyphNames.push(customNames[j - 258]);
          }
          break;
        case 0x00030000:
          break;
        default:
          (0, _util.warn)("Unknown/unsupported post table version " + version);
          valid = false;
          if (propertiesObj.defaultEncoding) {
            glyphNames = propertiesObj.defaultEncoding;
          }
          break;
      }
      propertiesObj.glyphNames = glyphNames;
      return valid;
    }
    function readNameTable(nameTable) {
      const start = (font.start || 0) + nameTable.offset;
      font.pos = start;
      const names = [[], []],
        records = [];
      const length = nameTable.length,
        end = start + length;
      const format = font.getUint16();
      const FORMAT_0_HEADER_LENGTH = 6;
      if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
        return [names, records];
      }
      const numRecords = font.getUint16();
      const stringsStart = font.getUint16();
      const NAME_RECORD_LENGTH = 12;
      let i, ii;
      for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
        const r = {
          platform: font.getUint16(),
          encoding: font.getUint16(),
          language: font.getUint16(),
          name: font.getUint16(),
          length: font.getUint16(),
          offset: font.getUint16()
        };
        if (isMacNameRecord(r) || isWinNameRecord(r)) {
          records.push(r);
        }
      }
      for (i = 0, ii = records.length; i < ii; i++) {
        const record = records[i];
        if (record.length <= 0) {
          continue;
        }
        const pos = start + stringsStart + record.offset;
        if (pos + record.length > end) {
          continue;
        }
        font.pos = pos;
        const nameIndex = record.name;
        if (record.encoding) {
          let str = "";
          for (let j = 0, jj = record.length; j < jj; j += 2) {
            str += String.fromCharCode(font.getUint16());
          }
          names[1][nameIndex] = str;
        } else {
          names[0][nameIndex] = font.getString(record.length);
        }
      }
      return [names, records];
    }
    const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function sanitizeTTProgram(table, ttContext) {
      let data = table.data;
      let i = 0,
        j,
        n,
        b,
        funcId,
        pc,
        lastEndf = 0,
        lastDeff = 0;
      const stack = [];
      const callstack = [];
      const functionsCalled = [];
      let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
      let inFDEF = false,
        ifLevel = 0,
        inELSE = 0;
      for (let ii = data.length; i < ii;) {
        const op = data[i++];
        if (op === 0x40) {
          n = data[i++];
          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if (op === 0x41) {
          n = data[i++];
          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if ((op & 0xf8) === 0xb0) {
          n = op - 0xb0 + 1;
          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if ((op & 0xf8) === 0xb8) {
          n = op - 0xb8 + 1;
          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if (op === 0x2b && !tooComplexToFollowFunctions) {
          if (!inFDEF && !inELSE) {
            funcId = stack.at(-1);
            if (isNaN(funcId)) {
              (0, _util.info)("TT: CALL empty stack (or invalid entry).");
            } else {
              ttContext.functionsUsed[funcId] = true;
              if (funcId in ttContext.functionsStackDeltas) {
                const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                if (newStackLength < 0) {
                  (0, _util.warn)("TT: CALL invalid functions stack delta.");
                  ttContext.hintsValid = false;
                  return;
                }
                stack.length = newStackLength;
              } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                callstack.push({
                  data,
                  i,
                  stackTop: stack.length - 1
                });
                functionsCalled.push(funcId);
                pc = ttContext.functionsDefined[funcId];
                if (!pc) {
                  (0, _util.warn)("TT: CALL non-existent function");
                  ttContext.hintsValid = false;
                  return;
                }
                data = pc.data;
                i = pc.i;
              }
            }
          }
        } else if (op === 0x2c && !tooComplexToFollowFunctions) {
          if (inFDEF || inELSE) {
            (0, _util.warn)("TT: nested FDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = true;
          lastDeff = i;
          funcId = stack.pop();
          ttContext.functionsDefined[funcId] = {
            data,
            i
          };
        } else if (op === 0x2d) {
          if (inFDEF) {
            inFDEF = false;
            lastEndf = i;
          } else {
            pc = callstack.pop();
            if (!pc) {
              (0, _util.warn)("TT: ENDF bad stack");
              ttContext.hintsValid = false;
              return;
            }
            funcId = functionsCalled.pop();
            data = pc.data;
            i = pc.i;
            ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
          }
        } else if (op === 0x89) {
          if (inFDEF || inELSE) {
            (0, _util.warn)("TT: nested IDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = true;
          lastDeff = i;
        } else if (op === 0x58) {
          ++ifLevel;
        } else if (op === 0x1b) {
          inELSE = ifLevel;
        } else if (op === 0x59) {
          if (inELSE === ifLevel) {
            inELSE = 0;
          }
          --ifLevel;
        } else if (op === 0x1c) {
          if (!inFDEF && !inELSE) {
            const offset = stack.at(-1);
            if (offset > 0) {
              i += offset - 1;
            }
          }
        }
        if (!inFDEF && !inELSE) {
          let stackDelta = 0;
          if (op <= 0x8e) {
            stackDelta = TTOpsStackDeltas[op];
          } else if (op >= 0xc0 && op <= 0xdf) {
            stackDelta = -1;
          } else if (op >= 0xe0) {
            stackDelta = -2;
          }
          if (op >= 0x71 && op <= 0x75) {
            n = stack.pop();
            if (!isNaN(n)) {
              stackDelta = -n * 2;
            }
          }
          while (stackDelta < 0 && stack.length > 0) {
            stack.pop();
            stackDelta++;
          }
          while (stackDelta > 0) {
            stack.push(NaN);
            stackDelta--;
          }
        }
      }
      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
      const content = [data];
      if (i > data.length) {
        content.push(new Uint8Array(i - data.length));
      }
      if (lastDeff > lastEndf) {
        (0, _util.warn)("TT: complementing a missing function tail");
        content.push(new Uint8Array([0x22, 0x2d]));
      }
      foldTTTable(table, content);
    }
    function checkInvalidFunctions(ttContext, maxFunctionDefs) {
      if (ttContext.tooComplexToFollowFunctions) {
        return;
      }
      if (ttContext.functionsDefined.length > maxFunctionDefs) {
        (0, _util.warn)("TT: more functions defined than expected");
        ttContext.hintsValid = false;
        return;
      }
      for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
        if (j > maxFunctionDefs) {
          (0, _util.warn)("TT: invalid function id: " + j);
          ttContext.hintsValid = false;
          return;
        }
        if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
          (0, _util.warn)("TT: undefined function: " + j);
          ttContext.hintsValid = false;
          return;
        }
      }
    }
    function foldTTTable(table, content) {
      if (content.length > 1) {
        let newLength = 0;
        let j, jj;
        for (j = 0, jj = content.length; j < jj; j++) {
          newLength += content[j].length;
        }
        newLength = newLength + 3 & ~3;
        const result = new Uint8Array(newLength);
        let pos = 0;
        for (j = 0, jj = content.length; j < jj; j++) {
          result.set(content[j], pos);
          pos += content[j].length;
        }
        table.data = result;
        table.length = newLength;
      }
    }
    function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
      const ttContext = {
        functionsDefined: [],
        functionsUsed: [],
        functionsStackDeltas: [],
        tooComplexToFollowFunctions: false,
        hintsValid: true
      };
      if (fpgm) {
        sanitizeTTProgram(fpgm, ttContext);
      }
      if (prep) {
        sanitizeTTProgram(prep, ttContext);
      }
      if (fpgm) {
        checkInvalidFunctions(ttContext, maxFunctionDefs);
      }
      if (cvt && cvt.length & 1) {
        const cvtData = new Uint8Array(cvt.length + 1);
        cvtData.set(cvt.data);
        cvt.data = cvtData;
      }
      return ttContext.hintsValid;
    }
    font = new _stream.Stream(new Uint8Array(font.getBytes()));
    let header, tables;
    if (isTrueTypeCollectionFile(font)) {
      const ttcData = readTrueTypeCollectionData(font, this.name);
      header = ttcData.header;
      tables = ttcData.tables;
    } else {
      header = readOpenTypeHeader(font);
      tables = readTables(font, header.numTables);
    }
    let cff, cffFile;
    const isTrueType = !tables["CFF "];
    if (!isTrueType) {
      const isComposite = properties.composite && (properties.cidToGidMap?.length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
      if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
        cffFile = new _stream.Stream(tables["CFF "].data);
        cff = new _cff_font.CFFFont(cffFile, properties);
        adjustWidths(properties);
        return this.convert(name, cff, properties);
      }
      delete tables.glyf;
      delete tables.loca;
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
      this.isOpenType = true;
    } else {
      if (!tables.loca) {
        throw new _util.FormatError('Required "loca" table is not found');
      }
      if (!tables.glyf) {
        (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
        tables.glyf = {
          tag: "glyf",
          data: new Uint8Array(0)
        };
      }
      this.isOpenType = false;
    }
    if (!tables.maxp) {
      throw new _util.FormatError('Required "maxp" table is not found');
    }
    font.pos = (font.start || 0) + tables.maxp.offset;
    const version = font.getInt32();
    const numGlyphs = font.getUint16();
    if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
      const {
        scaleFactors
      } = properties;
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphs = new _glyf.GlyfTable({
        glyfTable: tables.glyf.data,
        isGlyphLocationsLong,
        locaTable: tables.loca.data,
        numGlyphs
      });
      glyphs.scale(scaleFactors);
      const {
        glyf,
        loca,
        isLocationLong
      } = glyphs.write();
      tables.glyf.data = glyf;
      tables.loca.data = loca;
      if (isLocationLong !== !!isGlyphLocationsLong) {
        tables.head.data[50] = 0;
        tables.head.data[51] = isLocationLong ? 1 : 0;
      }
      const metrics = tables.hmtx.data;
      for (let i = 0; i < numGlyphs; i++) {
        const j = 4 * i;
        const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));
        metrics[j] = advanceWidth >> 8 & 0xff;
        metrics[j + 1] = advanceWidth & 0xff;
        const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));
        writeSignedInt16(metrics, j + 2, lsb);
      }
    }
    let numGlyphsOut = numGlyphs + 1;
    let dupFirstEntry = true;
    if (numGlyphsOut > 0xffff) {
      dupFirstEntry = false;
      numGlyphsOut = numGlyphs;
      (0, _util.warn)("Not enough space in glyfs to duplicate first glyph.");
    }
    let maxFunctionDefs = 0;
    let maxSizeOfInstructions = 0;
    if (version >= 0x00010000 && tables.maxp.length >= 22) {
      font.pos += 8;
      const maxZones = font.getUint16();
      if (maxZones > 2) {
        tables.maxp.data[14] = 0;
        tables.maxp.data[15] = 2;
      }
      font.pos += 4;
      maxFunctionDefs = font.getUint16();
      font.pos += 4;
      maxSizeOfInstructions = font.getUint16();
    }
    tables.maxp.data[4] = numGlyphsOut >> 8;
    tables.maxp.data[5] = numGlyphsOut & 255;
    const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);
    if (!hintsValid) {
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
    }
    sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);
    if (!tables.head) {
      throw new _util.FormatError('Required "head" table is not found');
    }
    sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
    let missingGlyphs = Object.create(null);
    if (isTrueType) {
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
      missingGlyphs = glyphsInfo.missingGlyphs;
      if (version >= 0x00010000 && tables.maxp.length >= 22) {
        tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
        tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
      }
    }
    if (!tables.hhea) {
      throw new _util.FormatError('Required "hhea" table is not found');
    }
    if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
      tables.hhea.data[10] = 0xff;
      tables.hhea.data[11] = 0xff;
    }
    const metricsOverride = {
      unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
      yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
      yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
      ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
      descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
      lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])
    };
    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
    this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
    if (this.cssFontInfo?.lineHeight) {
      this.lineHeight = this.cssFontInfo.metrics.lineHeight;
      this.lineGap = this.cssFontInfo.metrics.lineGap;
    } else {
      this.lineHeight = this.ascent - this.descent + this.lineGap;
    }
    if (tables.post) {
      readPostScriptTable(tables.post, properties, numGlyphs);
    }
    tables.post = {
      tag: "post",
      data: createPostTable(properties)
    };
    const charCodeToGlyphId = [];
    function hasGlyph(glyphId) {
      return !missingGlyphs[glyphId];
    }
    if (properties.composite) {
      const cidToGidMap = properties.cidToGidMap || [];
      const isCidToGidMapEmpty = cidToGidMap.length === 0;
      properties.cMap.forEach(function (charCode, cid) {
        if (typeof cid === "string") {
          cid = convertCidString(charCode, cid, true);
        }
        if (cid > 0xffff) {
          throw new _util.FormatError("Max size of CID is 65,535");
        }
        let glyphId = -1;
        if (isCidToGidMapEmpty) {
          glyphId = cid;
        } else if (cidToGidMap[cid] !== undefined) {
          glyphId = cidToGidMap[cid];
        }
        if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
          charCodeToGlyphId[charCode] = glyphId;
        }
      });
    } else {
      const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
      const cmapPlatformId = cmapTable.platformId;
      const cmapEncodingId = cmapTable.encodingId;
      const cmapMappings = cmapTable.mappings;
      let baseEncoding = [],
        forcePostTable = false;
      if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
        baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
      }
      if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
        const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        for (let charCode = 0; charCode < 256; charCode++) {
          let glyphName;
          if (this.differences[charCode] !== undefined) {
            glyphName = this.differences[charCode];
          } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
            glyphName = baseEncoding[charCode];
          } else {
            glyphName = _encodings.StandardEncoding[charCode];
          }
          if (!glyphName) {
            continue;
          }
          const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap);
          let unicodeOrCharCode;
          if (cmapPlatformId === 3 && cmapEncodingId === 1) {
            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
          } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
            unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
          }
          if (unicodeOrCharCode === undefined) {
            if (!properties.glyphNames && properties.hasIncludedToUnicodeMap && !(this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap)) {
              const unicode = this.toUnicode.get(charCode);
              if (unicode) {
                unicodeOrCharCode = unicode.codePointAt(0);
              }
            }
            if (unicodeOrCharCode === undefined) {
              continue;
            }
          }
          for (const mapping of cmapMappings) {
            if (mapping.charCode !== unicodeOrCharCode) {
              continue;
            }
            charCodeToGlyphId[charCode] = mapping.glyphId;
            break;
          }
        }
      } else if (cmapPlatformId === 0) {
        for (const mapping of cmapMappings) {
          charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
        }
        forcePostTable = true;
      } else {
        for (const mapping of cmapMappings) {
          let charCode = mapping.charCode;
          if (cmapPlatformId === 3 && charCode >= 0xf000 && charCode <= 0xf0ff) {
            charCode &= 0xff;
          }
          charCodeToGlyphId[charCode] = mapping.glyphId;
        }
      }
      if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {
        for (let i = 0; i < 256; ++i) {
          if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
            continue;
          }
          const glyphName = this.differences[i] || baseEncoding[i];
          if (!glyphName) {
            continue;
          }
          const glyphId = properties.glyphNames.indexOf(glyphName);
          if (glyphId > 0 && hasGlyph(glyphId)) {
            charCodeToGlyphId[i] = glyphId;
          }
        }
      }
    }
    if (charCodeToGlyphId.length === 0) {
      charCodeToGlyphId[0] = 0;
    }
    let glyphZeroId = numGlyphsOut - 1;
    if (!dupFirstEntry) {
      glyphZeroId = 0;
    }
    if (!properties.cssFontInfo) {
      const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId, this.toUnicode);
      this.toFontChar = newMapping.toFontChar;
      tables.cmap = {
        tag: "cmap",
        data: createCmapTable(newMapping.charCodeToGlyphId, newMapping.toUnicodeExtraMap, numGlyphsOut)
      };
      if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
        tables["OS/2"] = {
          tag: "OS/2",
          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }
    }
    if (!isTrueType) {
      try {
        cffFile = new _stream.Stream(tables["CFF "].data);
        const parser = new _cff_parser.CFFParser(cffFile, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
        cff = parser.parse();
        cff.duplicateFirstGlyph();
        const compiler = new _cff_parser.CFFCompiler(cff);
        tables["CFF "].data = compiler.compile();
      } catch {
        (0, _util.warn)("Failed to compile font " + properties.loadedName);
      }
    }
    if (!tables.name) {
      tables.name = {
        tag: "name",
        data: createNameTable(this.name)
      };
    } else {
      const [namePrototype, nameRecords] = readNameTable(tables.name);
      tables.name.data = createNameTable(name, namePrototype);
      this.psName = namePrototype[0][6] || null;
      if (!properties.composite) {
        adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
      }
    }
    const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version);
    for (const tableTag in tables) {
      builder.addTable(tableTag, tables[tableTag].data);
    }
    return builder.toArray();
  }
  convert(fontName, font, properties) {
    properties.fixedPitch = false;
    if (properties.builtInEncoding) {
      adjustType1ToUnicode(properties, properties.builtInEncoding);
    }
    let glyphZeroId = 1;
    if (font instanceof _cff_font.CFFFont) {
      glyphZeroId = font.numGlyphs - 1;
    }
    const mapping = font.getGlyphMapping(properties);
    let newMapping = null;
    let newCharCodeToGlyphId = mapping;
    let toUnicodeExtraMap = null;
    if (!properties.cssFontInfo) {
      newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId, this.toUnicode);
      this.toFontChar = newMapping.toFontChar;
      newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
      toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
    }
    const numGlyphs = font.numGlyphs;
    function getCharCodes(charCodeToGlyphId, glyphId) {
      let charCodes = null;
      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          (charCodes ||= []).push(charCode | 0);
        }
      }
      return charCodes;
    }
    function createCharCode(charCodeToGlyphId, glyphId) {
      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          return charCode | 0;
        }
      }
      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
      return newMapping.nextAvailableFontCharCode++;
    }
    const seacs = font.seacs;
    if (newMapping && _fonts_utils.SEAC_ANALYSIS_ENABLED && seacs?.length) {
      const matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      const charset = font.getCharset();
      const seacMap = Object.create(null);
      for (let glyphId in seacs) {
        glyphId |= 0;
        const seac = seacs[glyphId];
        const baseGlyphName = _encodings.StandardEncoding[seac[2]];
        const accentGlyphName = _encodings.StandardEncoding[seac[3]];
        const baseGlyphId = charset.indexOf(baseGlyphName);
        const accentGlyphId = charset.indexOf(accentGlyphName);
        if (baseGlyphId < 0 || accentGlyphId < 0) {
          continue;
        }
        const accentOffset = {
          x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
          y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
        };
        const charCodes = getCharCodes(mapping, glyphId);
        if (!charCodes) {
          continue;
        }
        for (const charCode of charCodes) {
          const charCodeToGlyphId = newMapping.charCodeToGlyphId;
          const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
          const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
          seacMap[charCode] = {
            baseFontCharCode,
            accentFontCharCode,
            accentOffset
          };
        }
      }
      properties.seacMap = seacMap;
    }
    const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
    const builder = new _opentype_file_builder.OpenTypeFileBuilder("\x4F\x54\x54\x4F");
    builder.addTable("CFF ", font.data);
    builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
    builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs));
    builder.addTable("head", "\x00\x01\x00\x00" + "\x00\x00\x10\x00" + "\x00\x00\x00\x00" + "\x5F\x0F\x3C\xF5" + "\x00\x00" + safeString16(unitsPerEm) + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00" + safeString16(properties.descent) + "\x0F\xFF" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\x00\x11" + "\x00\x00" + "\x00\x00" + "\x00\x00");
    builder.addTable("hhea", "\x00\x01\x00\x00" + safeString16(properties.ascent) + safeString16(properties.descent) + "\x00\x00" + "\xFF\xFF" + "\x00\x00" + "\x00\x00" + "\x00\x00" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + string16(numGlyphs));
    builder.addTable("hmtx", function fontFieldsHmtx() {
      const charstrings = font.charstrings;
      const cffWidths = font.cff ? font.cff.widths : null;
      let hmtx = "\x00\x00\x00\x00";
      for (let i = 1, ii = numGlyphs; i < ii; i++) {
        let width = 0;
        if (charstrings) {
          const charstring = charstrings[i - 1];
          width = "width" in charstring ? charstring.width : 0;
        } else if (cffWidths) {
          width = Math.ceil(cffWidths[i] || 0);
        }
        hmtx += string16(width) + string16(0);
      }
      return hmtx;
    }());
    builder.addTable("maxp", "\x00\x00\x50\x00" + string16(numGlyphs));
    builder.addTable("name", createNameTable(fontName));
    builder.addTable("post", createPostTable(properties));
    return builder.toArray();
  }
  get spaceWidth() {
    const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
    let width;
    for (const glyphName of possibleSpaceReplacements) {
      if (glyphName in this.widths) {
        width = this.widths[glyphName];
        break;
      }
      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      const glyphUnicode = glyphsUnicodeMap[glyphName];
      let charcode = 0;
      if (this.composite && this.cMap.contains(glyphUnicode)) {
        charcode = this.cMap.lookup(glyphUnicode);
        if (typeof charcode === "string") {
          charcode = convertCidString(glyphUnicode, charcode);
        }
      }
      if (!charcode && this.toUnicode) {
        charcode = this.toUnicode.charCodeOf(glyphUnicode);
      }
      if (charcode <= 0) {
        charcode = glyphUnicode;
      }
      width = this.widths[charcode];
      if (width) {
        break;
      }
    }
    return (0, _util.shadow)(this, "spaceWidth", width || this.defaultWidth);
  }
  _charToGlyph(charcode, isSpace = false) {
    let glyph = this._glyphCache[charcode];
    if (glyph?.isSpace === isSpace) {
      return glyph;
    }
    let fontCharCode, width, operatorListId;
    let widthCode = charcode;
    if (this.cMap?.contains(charcode)) {
      widthCode = this.cMap.lookup(charcode);
      if (typeof widthCode === "string") {
        widthCode = convertCidString(charcode, widthCode);
      }
    }
    width = this.widths[widthCode];
    if (typeof width !== "number") {
      width = this.defaultWidth;
    }
    const vmetric = this.vmetrics?.[widthCode];
    let unicode = this.toUnicode.get(charcode) || charcode;
    if (typeof unicode === "number") {
      unicode = String.fromCharCode(unicode);
    }
    let isInFont = this.toFontChar[charcode] !== undefined;
    fontCharCode = this.toFontChar[charcode] || charcode;
    if (this.missingFile) {
      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
      if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
        fontCharCode = 0x20;
      }
      fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
    }
    if (this.isType3Font) {
      operatorListId = fontCharCode;
    }
    let accent = null;
    if (this.seacMap?.[charcode]) {
      isInFont = true;
      const seac = this.seacMap[charcode];
      fontCharCode = seac.baseFontCharCode;
      accent = {
        fontChar: String.fromCodePoint(seac.accentFontCharCode),
        offset: seac.accentOffset
      };
    }
    let fontChar = "";
    if (typeof fontCharCode === "number") {
      if (fontCharCode <= 0x10ffff) {
        fontChar = String.fromCodePoint(fontCharCode);
      } else {
        (0, _util.warn)(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
      }
    }
    glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
    return this._glyphCache[charcode] = glyph;
  }
  charsToGlyphs(chars) {
    let glyphs = this._charsCache[chars];
    if (glyphs) {
      return glyphs;
    }
    glyphs = [];
    if (this.cMap) {
      const c = Object.create(null),
        ii = chars.length;
      let i = 0;
      while (i < ii) {
        this.cMap.readCharCode(chars, i, c);
        const {
          charcode,
          length
        } = c;
        i += length;
        const glyph = this._charToGlyph(charcode, length === 1 && chars.charCodeAt(i - 1) === 0x20);
        glyphs.push(glyph);
      }
    } else {
      for (let i = 0, ii = chars.length; i < ii; ++i) {
        const charcode = chars.charCodeAt(i);
        const glyph = this._charToGlyph(charcode, charcode === 0x20);
        glyphs.push(glyph);
      }
    }
    return this._charsCache[chars] = glyphs;
  }
  getCharPositions(chars) {
    const positions = [];
    if (this.cMap) {
      const c = Object.create(null);
      let i = 0;
      while (i < chars.length) {
        this.cMap.readCharCode(chars, i, c);
        const length = c.length;
        positions.push([i, i + length]);
        i += length;
      }
    } else {
      for (let i = 0, ii = chars.length; i < ii; ++i) {
        positions.push([i, i + 1]);
      }
    }
    return positions;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(str) {
    const buffers = [];
    const currentBuf = [];
    const hasCurrentBufErrors = () => buffers.length % 2 === 1;
    const getCharCode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap ? unicode => this.toUnicode.charCodeOf(unicode) : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
    for (let i = 0, ii = str.length; i < ii; i++) {
      const unicode = str.codePointAt(i);
      if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
        i++;
      }
      if (this.toUnicode) {
        const charCode = getCharCode(unicode);
        if (charCode !== -1) {
          if (hasCurrentBufErrors()) {
            buffers.push(currentBuf.join(""));
            currentBuf.length = 0;
          }
          const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;
          for (let j = charCodeLength - 1; j >= 0; j--) {
            currentBuf.push(String.fromCharCode(charCode >> 8 * j & 0xff));
          }
          continue;
        }
      }
      if (!hasCurrentBufErrors()) {
        buffers.push(currentBuf.join(""));
        currentBuf.length = 0;
      }
      currentBuf.push(String.fromCodePoint(unicode));
    }
    buffers.push(currentBuf.join(""));
    return buffers;
  }
}
exports.Font = Font;
class ErrorFont {
  constructor(error) {
    this.error = error;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(chars) {
    return [chars];
  }
  exportData(extraProperties = false) {
    return {
      error: this.error
    };
  }
}
exports.ErrorFont = ErrorFont;

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFTopDict = exports.CFFStrings = exports.CFFStandardStrings = exports.CFFPrivateDict = exports.CFFParser = exports.CFFIndex = exports.CFFHeader = exports.CFFFDSelect = exports.CFFCompiler = exports.CFFCharset = exports.CFF = void 0;
var _util = __w_pdfjs_require__(2);
var _charsets = __w_pdfjs_require__(36);
var _encodings = __w_pdfjs_require__(37);
const MAX_SUBR_NESTING = 10;
const CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
exports.CFFStandardStrings = CFFStandardStrings;
const NUM_STANDARD_CFF_STRINGS = 391;
const CharstringValidationData = [null, {
  id: "hstem",
  min: 2,
  stackClearing: true,
  stem: true
}, null, {
  id: "vstem",
  min: 2,
  stackClearing: true,
  stem: true
}, {
  id: "vmoveto",
  min: 1,
  stackClearing: true
}, {
  id: "rlineto",
  min: 2,
  resetStack: true
}, {
  id: "hlineto",
  min: 1,
  resetStack: true
}, {
  id: "vlineto",
  min: 1,
  resetStack: true
}, {
  id: "rrcurveto",
  min: 6,
  resetStack: true
}, null, {
  id: "callsubr",
  min: 1,
  undefStack: true
}, {
  id: "return",
  min: 0,
  undefStack: true
}, null, null, {
  id: "endchar",
  min: 0,
  stackClearing: true
}, null, null, null, {
  id: "hstemhm",
  min: 2,
  stackClearing: true,
  stem: true
}, {
  id: "hintmask",
  min: 0,
  stackClearing: true
}, {
  id: "cntrmask",
  min: 0,
  stackClearing: true
}, {
  id: "rmoveto",
  min: 2,
  stackClearing: true
}, {
  id: "hmoveto",
  min: 1,
  stackClearing: true
}, {
  id: "vstemhm",
  min: 2,
  stackClearing: true,
  stem: true
}, {
  id: "rcurveline",
  min: 8,
  resetStack: true
}, {
  id: "rlinecurve",
  min: 8,
  resetStack: true
}, {
  id: "vvcurveto",
  min: 4,
  resetStack: true
}, {
  id: "hhcurveto",
  min: 4,
  resetStack: true
}, null, {
  id: "callgsubr",
  min: 1,
  undefStack: true
}, {
  id: "vhcurveto",
  min: 4,
  resetStack: true
}, {
  id: "hvcurveto",
  min: 4,
  resetStack: true
}];
const CharstringValidationData12 = [null, null, null, {
  id: "and",
  min: 2,
  stackDelta: -1
}, {
  id: "or",
  min: 2,
  stackDelta: -1
}, {
  id: "not",
  min: 1,
  stackDelta: 0
}, null, null, null, {
  id: "abs",
  min: 1,
  stackDelta: 0
}, {
  id: "add",
  min: 2,
  stackDelta: -1,
  stackFn(stack, index) {
    stack[index - 2] = stack[index - 2] + stack[index - 1];
  }
}, {
  id: "sub",
  min: 2,
  stackDelta: -1,
  stackFn(stack, index) {
    stack[index - 2] = stack[index - 2] - stack[index - 1];
  }
}, {
  id: "div",
  min: 2,
  stackDelta: -1,
  stackFn(stack, index) {
    stack[index - 2] = stack[index - 2] / stack[index - 1];
  }
}, null, {
  id: "neg",
  min: 1,
  stackDelta: 0,
  stackFn(stack, index) {
    stack[index - 1] = -stack[index - 1];
  }
}, {
  id: "eq",
  min: 2,
  stackDelta: -1
}, null, null, {
  id: "drop",
  min: 1,
  stackDelta: -1
}, null, {
  id: "put",
  min: 2,
  stackDelta: -2
}, {
  id: "get",
  min: 1,
  stackDelta: 0
}, {
  id: "ifelse",
  min: 4,
  stackDelta: -3
}, {
  id: "random",
  min: 0,
  stackDelta: 1
}, {
  id: "mul",
  min: 2,
  stackDelta: -1,
  stackFn(stack, index) {
    stack[index - 2] = stack[index - 2] * stack[index - 1];
  }
}, null, {
  id: "sqrt",
  min: 1,
  stackDelta: 0
}, {
  id: "dup",
  min: 1,
  stackDelta: 1
}, {
  id: "exch",
  min: 2,
  stackDelta: 0
}, {
  id: "index",
  min: 2,
  stackDelta: 0
}, {
  id: "roll",
  min: 3,
  stackDelta: -2
}, null, null, null, {
  id: "hflex",
  min: 7,
  resetStack: true
}, {
  id: "flex",
  min: 13,
  resetStack: true
}, {
  id: "hflex1",
  min: 9,
  resetStack: true
}, {
  id: "flex1",
  min: 11,
  resetStack: true
}];
class CFFParser {
  constructor(file, properties, seacAnalysisEnabled) {
    this.bytes = file.getBytes();
    this.properties = properties;
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
  }
  parse() {
    const properties = this.properties;
    const cff = new CFF();
    this.cff = cff;
    const header = this.parseHeader();
    const nameIndex = this.parseIndex(header.endPos);
    const topDictIndex = this.parseIndex(nameIndex.endPos);
    const stringIndex = this.parseIndex(topDictIndex.endPos);
    const globalSubrIndex = this.parseIndex(stringIndex.endPos);
    const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
    const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
    cff.header = header.obj;
    cff.names = this.parseNameIndex(nameIndex.obj);
    cff.strings = this.parseStringIndex(stringIndex.obj);
    cff.topDict = topDict;
    cff.globalSubrIndex = globalSubrIndex.obj;
    this.parsePrivateDict(cff.topDict);
    cff.isCIDFont = topDict.hasName("ROS");
    const charStringOffset = topDict.getByName("CharStrings");
    const charStringIndex = this.parseIndex(charStringOffset).obj;
    const fontMatrix = topDict.getByName("FontMatrix");
    if (fontMatrix) {
      properties.fontMatrix = fontMatrix;
    }
    const fontBBox = topDict.getByName("FontBBox");
    if (fontBBox) {
      properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
      properties.descent = Math.min(fontBBox[1], fontBBox[3]);
      properties.ascentScaled = true;
    }
    let charset, encoding;
    if (cff.isCIDFont) {
      const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
      for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
        const dictRaw = fdArrayIndex.get(i);
        const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
        this.parsePrivateDict(fontDict);
        cff.fdArray.push(fontDict);
      }
      encoding = null;
      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
      cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
    } else {
      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
      encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
    }
    cff.charset = charset;
    cff.encoding = encoding;
    const charStringsAndSeacs = this.parseCharStrings({
      charStrings: charStringIndex,
      localSubrIndex: topDict.privateDict.subrsIndex,
      globalSubrIndex: globalSubrIndex.obj,
      fdSelect: cff.fdSelect,
      fdArray: cff.fdArray,
      privateDict: topDict.privateDict
    });
    cff.charStrings = charStringsAndSeacs.charStrings;
    cff.seacs = charStringsAndSeacs.seacs;
    cff.widths = charStringsAndSeacs.widths;
    return cff;
  }
  parseHeader() {
    let bytes = this.bytes;
    const bytesLength = bytes.length;
    let offset = 0;
    while (offset < bytesLength && bytes[offset] !== 1) {
      ++offset;
    }
    if (offset >= bytesLength) {
      throw new _util.FormatError("Invalid CFF header");
    }
    if (offset !== 0) {
      (0, _util.info)("cff data is shifted");
      bytes = bytes.subarray(offset);
      this.bytes = bytes;
    }
    const major = bytes[0];
    const minor = bytes[1];
    const hdrSize = bytes[2];
    const offSize = bytes[3];
    const header = new CFFHeader(major, minor, hdrSize, offSize);
    return {
      obj: header,
      endPos: hdrSize
    };
  }
  parseDict(dict) {
    let pos = 0;
    function parseOperand() {
      let value = dict[pos++];
      if (value === 30) {
        return parseFloatOperand();
      } else if (value === 28) {
        value = dict[pos++];
        value = (value << 24 | dict[pos++] << 16) >> 16;
        return value;
      } else if (value === 29) {
        value = dict[pos++];
        value = value << 8 | dict[pos++];
        value = value << 8 | dict[pos++];
        value = value << 8 | dict[pos++];
        return value;
      } else if (value >= 32 && value <= 246) {
        return value - 139;
      } else if (value >= 247 && value <= 250) {
        return (value - 247) * 256 + dict[pos++] + 108;
      } else if (value >= 251 && value <= 254) {
        return -((value - 251) * 256) - dict[pos++] - 108;
      }
      (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
      return NaN;
    }
    function parseFloatOperand() {
      let str = "";
      const eof = 15;
      const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
      const length = dict.length;
      while (pos < length) {
        const b = dict[pos++];
        const b1 = b >> 4;
        const b2 = b & 15;
        if (b1 === eof) {
          break;
        }
        str += lookup[b1];
        if (b2 === eof) {
          break;
        }
        str += lookup[b2];
      }
      return parseFloat(str);
    }
    let operands = [];
    const entries = [];
    pos = 0;
    const end = dict.length;
    while (pos < end) {
      let b = dict[pos];
      if (b <= 21) {
        if (b === 12) {
          b = b << 8 | dict[++pos];
        }
        entries.push([b, operands]);
        operands = [];
        ++pos;
      } else {
        operands.push(parseOperand());
      }
    }
    return entries;
  }
  parseIndex(pos) {
    const cffIndex = new CFFIndex();
    const bytes = this.bytes;
    const count = bytes[pos++] << 8 | bytes[pos++];
    const offsets = [];
    let end = pos;
    let i, ii;
    if (count !== 0) {
      const offsetSize = bytes[pos++];
      const startPos = pos + (count + 1) * offsetSize - 1;
      for (i = 0, ii = count + 1; i < ii; ++i) {
        let offset = 0;
        for (let j = 0; j < offsetSize; ++j) {
          offset <<= 8;
          offset += bytes[pos++];
        }
        offsets.push(startPos + offset);
      }
      end = offsets[count];
    }
    for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
      const offsetStart = offsets[i];
      const offsetEnd = offsets[i + 1];
      cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
    }
    return {
      obj: cffIndex,
      endPos: end
    };
  }
  parseNameIndex(index) {
    const names = [];
    for (let i = 0, ii = index.count; i < ii; ++i) {
      const name = index.get(i);
      names.push((0, _util.bytesToString)(name));
    }
    return names;
  }
  parseStringIndex(index) {
    const strings = new CFFStrings();
    for (let i = 0, ii = index.count; i < ii; ++i) {
      const data = index.get(i);
      strings.add((0, _util.bytesToString)(data));
    }
    return strings;
  }
  createDict(Type, dict, strings) {
    const cffDict = new Type(strings);
    for (const [key, value] of dict) {
      cffDict.setByKey(key, value);
    }
    return cffDict;
  }
  parseCharString(state, data, localSubrIndex, globalSubrIndex) {
    if (!data || state.callDepth > MAX_SUBR_NESTING) {
      return false;
    }
    let stackSize = state.stackSize;
    const stack = state.stack;
    let length = data.length;
    for (let j = 0; j < length;) {
      const value = data[j++];
      let validationCommand = null;
      if (value === 12) {
        const q = data[j++];
        if (q === 0) {
          data[j - 2] = 139;
          data[j - 1] = 22;
          stackSize = 0;
        } else {
          validationCommand = CharstringValidationData12[q];
        }
      } else if (value === 28) {
        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
        j += 2;
        stackSize++;
      } else if (value === 14) {
        if (stackSize >= 4) {
          stackSize -= 4;
          if (this.seacAnalysisEnabled) {
            state.seac = stack.slice(stackSize, stackSize + 4);
            return false;
          }
        }
        validationCommand = CharstringValidationData[value];
      } else if (value >= 32 && value <= 246) {
        stack[stackSize] = value - 139;
        stackSize++;
      } else if (value >= 247 && value <= 254) {
        stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
        j++;
        stackSize++;
      } else if (value === 255) {
        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
        j += 4;
        stackSize++;
      } else if (value === 19 || value === 20) {
        state.hints += stackSize >> 1;
        if (state.hints === 0) {
          data.copyWithin(j - 1, j, -1);
          j -= 1;
          length -= 1;
          continue;
        }
        j += state.hints + 7 >> 3;
        stackSize %= 2;
        validationCommand = CharstringValidationData[value];
      } else if (value === 10 || value === 29) {
        const subrsIndex = value === 10 ? localSubrIndex : globalSubrIndex;
        if (!subrsIndex) {
          validationCommand = CharstringValidationData[value];
          (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
          return false;
        }
        let bias = 32768;
        if (subrsIndex.count < 1240) {
          bias = 107;
        } else if (subrsIndex.count < 33900) {
          bias = 1131;
        }
        const subrNumber = stack[--stackSize] + bias;
        if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
          validationCommand = CharstringValidationData[value];
          (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
          return false;
        }
        state.stackSize = stackSize;
        state.callDepth++;
        const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
        if (!valid) {
          return false;
        }
        state.callDepth--;
        stackSize = state.stackSize;
        continue;
      } else if (value === 11) {
        state.stackSize = stackSize;
        return true;
      } else if (value === 0 && j === data.length) {
        data[j - 1] = 14;
        validationCommand = CharstringValidationData[14];
      } else if (value === 9) {
        data.copyWithin(j - 1, j, -1);
        j -= 1;
        length -= 1;
        continue;
      } else {
        validationCommand = CharstringValidationData[value];
      }
      if (validationCommand) {
        if (validationCommand.stem) {
          state.hints += stackSize >> 1;
          if (value === 3 || value === 23) {
            state.hasVStems = true;
          } else if (state.hasVStems && (value === 1 || value === 18)) {
            (0, _util.warn)("CFF stem hints are in wrong order");
            data[j - 1] = value === 1 ? 3 : 23;
          }
        }
        if ("min" in validationCommand) {
          if (!state.undefStack && stackSize < validationCommand.min) {
            (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
            if (stackSize === 0) {
              data[j - 1] = 14;
              return true;
            }
            return false;
          }
        }
        if (state.firstStackClearing && validationCommand.stackClearing) {
          state.firstStackClearing = false;
          stackSize -= validationCommand.min;
          if (stackSize >= 2 && validationCommand.stem) {
            stackSize %= 2;
          } else if (stackSize > 1) {
            (0, _util.warn)("Found too many parameters for stack-clearing command");
          }
          if (stackSize > 0) {
            state.width = stack[stackSize - 1];
          }
        }
        if ("stackDelta" in validationCommand) {
          if ("stackFn" in validationCommand) {
            validationCommand.stackFn(stack, stackSize);
          }
          stackSize += validationCommand.stackDelta;
        } else if (validationCommand.stackClearing) {
          stackSize = 0;
        } else if (validationCommand.resetStack) {
          stackSize = 0;
          state.undefStack = false;
        } else if (validationCommand.undefStack) {
          stackSize = 0;
          state.undefStack = true;
          state.firstStackClearing = false;
        }
      }
    }
    if (length < data.length) {
      data.fill(14, length);
    }
    state.stackSize = stackSize;
    return true;
  }
  parseCharStrings({
    charStrings,
    localSubrIndex,
    globalSubrIndex,
    fdSelect,
    fdArray,
    privateDict
  }) {
    const seacs = [];
    const widths = [];
    const count = charStrings.count;
    for (let i = 0; i < count; i++) {
      const charstring = charStrings.get(i);
      const state = {
        callDepth: 0,
        stackSize: 0,
        stack: [],
        undefStack: true,
        hints: 0,
        firstStackClearing: true,
        seac: null,
        width: null,
        hasVStems: false
      };
      let valid = true;
      let localSubrToUse = null;
      let privateDictToUse = privateDict;
      if (fdSelect && fdArray.length) {
        const fdIndex = fdSelect.getFDIndex(i);
        if (fdIndex === -1) {
          (0, _util.warn)("Glyph index is not in fd select.");
          valid = false;
        }
        if (fdIndex >= fdArray.length) {
          (0, _util.warn)("Invalid fd index for glyph index.");
          valid = false;
        }
        if (valid) {
          privateDictToUse = fdArray[fdIndex].privateDict;
          localSubrToUse = privateDictToUse.subrsIndex;
        }
      } else if (localSubrIndex) {
        localSubrToUse = localSubrIndex;
      }
      if (valid) {
        valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
      }
      if (state.width !== null) {
        const nominalWidth = privateDictToUse.getByName("nominalWidthX");
        widths[i] = nominalWidth + state.width;
      } else {
        const defaultWidth = privateDictToUse.getByName("defaultWidthX");
        widths[i] = defaultWidth;
      }
      if (state.seac !== null) {
        seacs[i] = state.seac;
      }
      if (!valid) {
        charStrings.set(i, new Uint8Array([14]));
      }
    }
    return {
      charStrings,
      seacs,
      widths
    };
  }
  emptyPrivateDictionary(parentDict) {
    const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
    parentDict.setByKey(18, [0, 0]);
    parentDict.privateDict = privateDict;
  }
  parsePrivateDict(parentDict) {
    if (!parentDict.hasName("Private")) {
      this.emptyPrivateDictionary(parentDict);
      return;
    }
    const privateOffset = parentDict.getByName("Private");
    if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
      parentDict.removeByName("Private");
      return;
    }
    const size = privateOffset[0];
    const offset = privateOffset[1];
    if (size === 0 || offset >= this.bytes.length) {
      this.emptyPrivateDictionary(parentDict);
      return;
    }
    const privateDictEnd = offset + size;
    const dictData = this.bytes.subarray(offset, privateDictEnd);
    const dict = this.parseDict(dictData);
    const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
    parentDict.privateDict = privateDict;
    if (privateDict.getByName("ExpansionFactor") === 0) {
      privateDict.setByName("ExpansionFactor", 0.06);
    }
    if (!privateDict.getByName("Subrs")) {
      return;
    }
    const subrsOffset = privateDict.getByName("Subrs");
    const relativeOffset = offset + subrsOffset;
    if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
      this.emptyPrivateDictionary(parentDict);
      return;
    }
    const subrsIndex = this.parseIndex(relativeOffset);
    privateDict.subrsIndex = subrsIndex.obj;
  }
  parseCharsets(pos, length, strings, cid) {
    if (pos === 0) {
      return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
    } else if (pos === 1) {
      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
    } else if (pos === 2) {
      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
    }
    const bytes = this.bytes;
    const start = pos;
    const format = bytes[pos++];
    const charset = [cid ? 0 : ".notdef"];
    let id, count, i;
    length -= 1;
    switch (format) {
      case 0:
        for (i = 0; i < length; i++) {
          id = bytes[pos++] << 8 | bytes[pos++];
          charset.push(cid ? id : strings.get(id));
        }
        break;
      case 1:
        while (charset.length <= length) {
          id = bytes[pos++] << 8 | bytes[pos++];
          count = bytes[pos++];
          for (i = 0; i <= count; i++) {
            charset.push(cid ? id++ : strings.get(id++));
          }
        }
        break;
      case 2:
        while (charset.length <= length) {
          id = bytes[pos++] << 8 | bytes[pos++];
          count = bytes[pos++] << 8 | bytes[pos++];
          for (i = 0; i <= count; i++) {
            charset.push(cid ? id++ : strings.get(id++));
          }
        }
        break;
      default:
        throw new _util.FormatError("Unknown charset format");
    }
    const end = pos;
    const raw = bytes.subarray(start, end);
    return new CFFCharset(false, format, charset, raw);
  }
  parseEncoding(pos, properties, strings, charset) {
    const encoding = Object.create(null);
    const bytes = this.bytes;
    let predefined = false;
    let format, i, ii;
    let raw = null;
    function readSupplement() {
      const supplementsCount = bytes[pos++];
      for (i = 0; i < supplementsCount; i++) {
        const code = bytes[pos++];
        const sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
        encoding[code] = charset.indexOf(strings.get(sid));
      }
    }
    if (pos === 0 || pos === 1) {
      predefined = true;
      format = pos;
      const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
      for (i = 0, ii = charset.length; i < ii; i++) {
        const index = baseEncoding.indexOf(charset[i]);
        if (index !== -1) {
          encoding[index] = i;
        }
      }
    } else {
      const dataStart = pos;
      format = bytes[pos++];
      switch (format & 0x7f) {
        case 0:
          const glyphsCount = bytes[pos++];
          for (i = 1; i <= glyphsCount; i++) {
            encoding[bytes[pos++]] = i;
          }
          break;
        case 1:
          const rangesCount = bytes[pos++];
          let gid = 1;
          for (i = 0; i < rangesCount; i++) {
            const start = bytes[pos++];
            const left = bytes[pos++];
            for (let j = start; j <= start + left; j++) {
              encoding[j] = gid++;
            }
          }
          break;
        default:
          throw new _util.FormatError(`Unknown encoding format: ${format} in CFF`);
      }
      const dataEnd = pos;
      if (format & 0x80) {
        bytes[dataStart] &= 0x7f;
        readSupplement();
      }
      raw = bytes.subarray(dataStart, dataEnd);
    }
    format &= 0x7f;
    return new CFFEncoding(predefined, format, encoding, raw);
  }
  parseFDSelect(pos, length) {
    const bytes = this.bytes;
    const format = bytes[pos++];
    const fdSelect = [];
    let i;
    switch (format) {
      case 0:
        for (i = 0; i < length; ++i) {
          const id = bytes[pos++];
          fdSelect.push(id);
        }
        break;
      case 3:
        const rangesCount = bytes[pos++] << 8 | bytes[pos++];
        for (i = 0; i < rangesCount; ++i) {
          let first = bytes[pos++] << 8 | bytes[pos++];
          if (i === 0 && first !== 0) {
            (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0" + " -- trying to recover.");
            first = 0;
          }
          const fdIndex = bytes[pos++];
          const next = bytes[pos] << 8 | bytes[pos + 1];
          for (let j = first; j < next; ++j) {
            fdSelect.push(fdIndex);
          }
        }
        pos += 2;
        break;
      default:
        throw new _util.FormatError(`parseFDSelect: Unknown format "${format}".`);
    }
    if (fdSelect.length !== length) {
      throw new _util.FormatError("parseFDSelect: Invalid font data.");
    }
    return new CFFFDSelect(format, fdSelect);
  }
}
exports.CFFParser = CFFParser;
class CFF {
  constructor() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      (0, _util.warn)("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const glyphZero = this.charStrings.get(0);
    this.charStrings.add(glyphZero);
    if (this.isCIDFont) {
      this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
  }
  hasGlyphId(id) {
    if (id < 0 || id >= this.charStrings.count) {
      return false;
    }
    const glyph = this.charStrings.get(id);
    return glyph.length > 0;
  }
}
exports.CFF = CFF;
class CFFHeader {
  constructor(major, minor, hdrSize, offSize) {
    this.major = major;
    this.minor = minor;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }
}
exports.CFFHeader = CFFHeader;
class CFFStrings {
  constructor() {
    this.strings = [];
  }
  get(index) {
    if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
      return CFFStandardStrings[index];
    }
    if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
      return this.strings[index - NUM_STANDARD_CFF_STRINGS];
    }
    return CFFStandardStrings[0];
  }
  getSID(str) {
    let index = CFFStandardStrings.indexOf(str);
    if (index !== -1) {
      return index;
    }
    index = this.strings.indexOf(str);
    if (index !== -1) {
      return index + NUM_STANDARD_CFF_STRINGS;
    }
    return -1;
  }
  add(value) {
    this.strings.push(value);
  }
  get count() {
    return this.strings.length;
  }
}
exports.CFFStrings = CFFStrings;
class CFFIndex {
  constructor() {
    this.objects = [];
    this.length = 0;
  }
  add(data) {
    this.length += data.length;
    this.objects.push(data);
  }
  set(index, data) {
    this.length += data.length - this.objects[index].length;
    this.objects[index] = data;
  }
  get(index) {
    return this.objects[index];
  }
  get count() {
    return this.objects.length;
  }
}
exports.CFFIndex = CFFIndex;
class CFFDict {
  constructor(tables, strings) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = Object.create(null);
  }
  setByKey(key, value) {
    if (!(key in this.keyToNameMap)) {
      return false;
    }
    if (value.length === 0) {
      return true;
    }
    for (const val of value) {
      if (isNaN(val)) {
        (0, _util.warn)(`Invalid CFFDict value: "${value}" for key "${key}".`);
        return true;
      }
    }
    const type = this.types[key];
    if (type === "num" || type === "sid" || type === "offset") {
      value = value[0];
    }
    this.values[key] = value;
    return true;
  }
  setByName(name, value) {
    if (!(name in this.nameToKeyMap)) {
      throw new _util.FormatError(`Invalid dictionary name "${name}"`);
    }
    this.values[this.nameToKeyMap[name]] = value;
  }
  hasName(name) {
    return this.nameToKeyMap[name] in this.values;
  }
  getByName(name) {
    if (!(name in this.nameToKeyMap)) {
      throw new _util.FormatError(`Invalid dictionary name ${name}"`);
    }
    const key = this.nameToKeyMap[name];
    if (!(key in this.values)) {
      return this.defaults[key];
    }
    return this.values[key];
  }
  removeByName(name) {
    delete this.values[this.nameToKeyMap[name]];
  }
  static createTables(layout) {
    const tables = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (const entry of layout) {
      const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[key] = entry[1];
      tables.nameToKeyMap[entry[1]] = key;
      tables.types[key] = entry[2];
      tables.defaults[key] = entry[3];
      tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
      tables.order.push(key);
    }
    return tables;
  }
}
const CFFTopDictLayout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [0.001, 0, 0, 0.001, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class CFFTopDict extends CFFDict {
  static get tables() {
    return (0, _util.shadow)(this, "tables", this.createTables(CFFTopDictLayout));
  }
  constructor(strings) {
    super(CFFTopDict.tables, strings);
    this.privateDict = null;
  }
}
exports.CFFTopDict = CFFTopDict;
const CFFPrivateDictLayout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class CFFPrivateDict extends CFFDict {
  static get tables() {
    return (0, _util.shadow)(this, "tables", this.createTables(CFFPrivateDictLayout));
  }
  constructor(strings) {
    super(CFFPrivateDict.tables, strings);
    this.subrsIndex = null;
  }
}
exports.CFFPrivateDict = CFFPrivateDict;
const CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
class CFFCharset {
  constructor(predefined, format, charset, raw) {
    this.predefined = predefined;
    this.format = format;
    this.charset = charset;
    this.raw = raw;
  }
}
exports.CFFCharset = CFFCharset;
class CFFEncoding {
  constructor(predefined, format, encoding, raw) {
    this.predefined = predefined;
    this.format = format;
    this.encoding = encoding;
    this.raw = raw;
  }
}
class CFFFDSelect {
  constructor(format, fdSelect) {
    this.format = format;
    this.fdSelect = fdSelect;
  }
  getFDIndex(glyphIndex) {
    if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
      return -1;
    }
    return this.fdSelect[glyphIndex];
  }
}
exports.CFFFDSelect = CFFFDSelect;
class CFFOffsetTracker {
  constructor() {
    this.offsets = Object.create(null);
  }
  isTracking(key) {
    return key in this.offsets;
  }
  track(key, location) {
    if (key in this.offsets) {
      throw new _util.FormatError(`Already tracking location of ${key}`);
    }
    this.offsets[key] = location;
  }
  offset(value) {
    for (const key in this.offsets) {
      this.offsets[key] += value;
    }
  }
  setEntryLocation(key, values, output) {
    if (!(key in this.offsets)) {
      throw new _util.FormatError(`Not tracking location of ${key}`);
    }
    const data = output.data;
    const dataOffset = this.offsets[key];
    const size = 5;
    for (let i = 0, ii = values.length; i < ii; ++i) {
      const offset0 = i * size + dataOffset;
      const offset1 = offset0 + 1;
      const offset2 = offset0 + 2;
      const offset3 = offset0 + 3;
      const offset4 = offset0 + 4;
      if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
        throw new _util.FormatError("writing to an offset that is not empty");
      }
      const value = values[i];
      data[offset0] = 0x1d;
      data[offset1] = value >> 24 & 0xff;
      data[offset2] = value >> 16 & 0xff;
      data[offset3] = value >> 8 & 0xff;
      data[offset4] = value & 0xff;
    }
  }
}
class CFFCompiler {
  constructor(cff) {
    this.cff = cff;
  }
  compile() {
    const cff = this.cff;
    const output = {
      data: [],
      length: 0,
      add(data) {
        try {
          this.data.push(...data);
        } catch {
          this.data = this.data.concat(data);
        }
        this.length = this.data.length;
      }
    };
    const header = this.compileHeader(cff.header);
    output.add(header);
    const nameIndex = this.compileNameIndex(cff.names);
    output.add(nameIndex);
    if (cff.isCIDFont) {
      if (cff.topDict.hasName("FontMatrix")) {
        const base = cff.topDict.getByName("FontMatrix");
        cff.topDict.removeByName("FontMatrix");
        for (const subDict of cff.fdArray) {
          let matrix = base.slice(0);
          if (subDict.hasName("FontMatrix")) {
            matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
          }
          subDict.setByName("FontMatrix", matrix);
        }
      }
    }
    const xuid = cff.topDict.getByName("XUID");
    if (xuid?.length > 16) {
      cff.topDict.removeByName("XUID");
    }
    cff.topDict.setByName("charset", 0);
    let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
    output.add(compiled.output);
    const topDictTracker = compiled.trackers[0];
    const stringIndex = this.compileStringIndex(cff.strings.strings);
    output.add(stringIndex);
    const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
    output.add(globalSubrIndex);
    if (cff.encoding && cff.topDict.hasName("Encoding")) {
      if (cff.encoding.predefined) {
        topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
      } else {
        const encoding = this.compileEncoding(cff.encoding);
        topDictTracker.setEntryLocation("Encoding", [output.length], output);
        output.add(encoding);
      }
    }
    const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
    topDictTracker.setEntryLocation("charset", [output.length], output);
    output.add(charset);
    const charStrings = this.compileCharStrings(cff.charStrings);
    topDictTracker.setEntryLocation("CharStrings", [output.length], output);
    output.add(charStrings);
    if (cff.isCIDFont) {
      topDictTracker.setEntryLocation("FDSelect", [output.length], output);
      const fdSelect = this.compileFDSelect(cff.fdSelect);
      output.add(fdSelect);
      compiled = this.compileTopDicts(cff.fdArray, output.length, true);
      topDictTracker.setEntryLocation("FDArray", [output.length], output);
      output.add(compiled.output);
      const fontDictTrackers = compiled.trackers;
      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
    }
    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
    output.add([0]);
    return output.data;
  }
  encodeNumber(value) {
    if (Number.isInteger(value)) {
      return this.encodeInteger(value);
    }
    return this.encodeFloat(value);
  }
  static get EncodeFloatRegExp() {
    return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(num) {
    let value = num.toString();
    const m = CFFCompiler.EncodeFloatRegExp.exec(value);
    if (m) {
      const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
      value = (Math.round(num * epsilon) / epsilon).toString();
    }
    let nibbles = "";
    let i, ii;
    for (i = 0, ii = value.length; i < ii; ++i) {
      const a = value[i];
      if (a === "e") {
        nibbles += value[++i] === "-" ? "c" : "b";
      } else if (a === ".") {
        nibbles += "a";
      } else if (a === "-") {
        nibbles += "e";
      } else {
        nibbles += a;
      }
    }
    nibbles += nibbles.length & 1 ? "f" : "ff";
    const out = [30];
    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
      out.push(parseInt(nibbles.substring(i, i + 2), 16));
    }
    return out;
  }
  encodeInteger(value) {
    let code;
    if (value >= -107 && value <= 107) {
      code = [value + 139];
    } else if (value >= 108 && value <= 1131) {
      value -= 108;
      code = [(value >> 8) + 247, value & 0xff];
    } else if (value >= -1131 && value <= -108) {
      value = -value - 108;
      code = [(value >> 8) + 251, value & 0xff];
    } else if (value >= -32768 && value <= 32767) {
      code = [0x1c, value >> 8 & 0xff, value & 0xff];
    } else {
      code = [0x1d, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff];
    }
    return code;
  }
  compileHeader(header) {
    return [header.major, header.minor, 4, header.offSize];
  }
  compileNameIndex(names) {
    const nameIndex = new CFFIndex();
    for (const name of names) {
      const length = Math.min(name.length, 127);
      let sanitizedName = new Array(length);
      for (let j = 0; j < length; j++) {
        let char = name[j];
        if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
          char = "_";
        }
        sanitizedName[j] = char;
      }
      sanitizedName = sanitizedName.join("");
      if (sanitizedName === "") {
        sanitizedName = "Bad_Font_Name";
      }
      nameIndex.add((0, _util.stringToBytes)(sanitizedName));
    }
    return this.compileIndex(nameIndex);
  }
  compileTopDicts(dicts, length, removeCidKeys) {
    const fontDictTrackers = [];
    let fdArrayIndex = new CFFIndex();
    for (const fontDict of dicts) {
      if (removeCidKeys) {
        fontDict.removeByName("CIDFontVersion");
        fontDict.removeByName("CIDFontRevision");
        fontDict.removeByName("CIDFontType");
        fontDict.removeByName("CIDCount");
        fontDict.removeByName("UIDBase");
      }
      const fontDictTracker = new CFFOffsetTracker();
      const fontDictData = this.compileDict(fontDict, fontDictTracker);
      fontDictTrackers.push(fontDictTracker);
      fdArrayIndex.add(fontDictData);
      fontDictTracker.offset(length);
    }
    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
    return {
      trackers: fontDictTrackers,
      output: fdArrayIndex
    };
  }
  compilePrivateDicts(dicts, trackers, output) {
    for (let i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];
      const privateDict = fontDict.privateDict;
      if (!privateDict || !fontDict.hasName("Private")) {
        throw new _util.FormatError("There must be a private dictionary.");
      }
      const privateDictTracker = new CFFOffsetTracker();
      const privateDictData = this.compileDict(privateDict, privateDictTracker);
      let outputLength = output.length;
      privateDictTracker.offset(outputLength);
      if (!privateDictData.length) {
        outputLength = 0;
      }
      trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
      output.add(privateDictData);
      if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
        const subrs = this.compileIndex(privateDict.subrsIndex);
        privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
        output.add(subrs);
      }
    }
  }
  compileDict(dict, offsetTracker) {
    const out = [];
    for (const key of dict.order) {
      if (!(key in dict.values)) {
        continue;
      }
      let values = dict.values[key];
      let types = dict.types[key];
      if (!Array.isArray(types)) {
        types = [types];
      }
      if (!Array.isArray(values)) {
        values = [values];
      }
      if (values.length === 0) {
        continue;
      }
      for (let j = 0, jj = types.length; j < jj; ++j) {
        const type = types[j];
        const value = values[j];
        switch (type) {
          case "num":
          case "sid":
            out.push(...this.encodeNumber(value));
            break;
          case "offset":
            const name = dict.keyToNameMap[key];
            if (!offsetTracker.isTracking(name)) {
              offsetTracker.track(name, out.length);
            }
            out.push(0x1d, 0, 0, 0, 0);
            break;
          case "array":
          case "delta":
            out.push(...this.encodeNumber(value));
            for (let k = 1, kk = values.length; k < kk; ++k) {
              out.push(...this.encodeNumber(values[k]));
            }
            break;
          default:
            throw new _util.FormatError(`Unknown data type of ${type}`);
        }
      }
      out.push(...dict.opcodes[key]);
    }
    return out;
  }
  compileStringIndex(strings) {
    const stringIndex = new CFFIndex();
    for (const string of strings) {
      stringIndex.add((0, _util.stringToBytes)(string));
    }
    return this.compileIndex(stringIndex);
  }
  compileCharStrings(charStrings) {
    const charStringsIndex = new CFFIndex();
    for (let i = 0; i < charStrings.count; i++) {
      const glyph = charStrings.get(i);
      if (glyph.length === 0) {
        charStringsIndex.add(new Uint8Array([0x8b, 0x0e]));
        continue;
      }
      charStringsIndex.add(glyph);
    }
    return this.compileIndex(charStringsIndex);
  }
  compileCharset(charset, numGlyphs, strings, isCIDFont) {
    let out;
    const numGlyphsLessNotDef = numGlyphs - 1;
    if (isCIDFont) {
      out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 0xff, numGlyphsLessNotDef & 0xff]);
    } else {
      const length = 1 + numGlyphsLessNotDef * 2;
      out = new Uint8Array(length);
      out[0] = 0;
      let charsetIndex = 0;
      const numCharsets = charset.charset.length;
      let warned = false;
      for (let i = 1; i < out.length; i += 2) {
        let sid = 0;
        if (charsetIndex < numCharsets) {
          const name = charset.charset[charsetIndex++];
          sid = strings.getSID(name);
          if (sid === -1) {
            sid = 0;
            if (!warned) {
              warned = true;
              (0, _util.warn)(`Couldn't find ${name} in CFF strings`);
            }
          }
        }
        out[i] = sid >> 8 & 0xff;
        out[i + 1] = sid & 0xff;
      }
    }
    return this.compileTypedArray(out);
  }
  compileEncoding(encoding) {
    return this.compileTypedArray(encoding.raw);
  }
  compileFDSelect(fdSelect) {
    const format = fdSelect.format;
    let out, i;
    switch (format) {
      case 0:
        out = new Uint8Array(1 + fdSelect.fdSelect.length);
        out[0] = format;
        for (i = 0; i < fdSelect.fdSelect.length; i++) {
          out[i + 1] = fdSelect.fdSelect[i];
        }
        break;
      case 3:
        const start = 0;
        let lastFD = fdSelect.fdSelect[0];
        const ranges = [format, 0, 0, start >> 8 & 0xff, start & 0xff, lastFD];
        for (i = 1; i < fdSelect.fdSelect.length; i++) {
          const currentFD = fdSelect.fdSelect[i];
          if (currentFD !== lastFD) {
            ranges.push(i >> 8 & 0xff, i & 0xff, currentFD);
            lastFD = currentFD;
          }
        }
        const numRanges = (ranges.length - 3) / 3;
        ranges[1] = numRanges >> 8 & 0xff;
        ranges[2] = numRanges & 0xff;
        ranges.push(i >> 8 & 0xff, i & 0xff);
        out = new Uint8Array(ranges);
        break;
    }
    return this.compileTypedArray(out);
  }
  compileTypedArray(data) {
    return Array.from(data);
  }
  compileIndex(index, trackers = []) {
    const objects = index.objects;
    const count = objects.length;
    if (count === 0) {
      return [0, 0];
    }
    const data = [count >> 8 & 0xff, count & 0xff];
    let lastOffset = 1,
      i;
    for (i = 0; i < count; ++i) {
      lastOffset += objects[i].length;
    }
    let offsetSize;
    if (lastOffset < 0x100) {
      offsetSize = 1;
    } else if (lastOffset < 0x10000) {
      offsetSize = 2;
    } else if (lastOffset < 0x1000000) {
      offsetSize = 3;
    } else {
      offsetSize = 4;
    }
    data.push(offsetSize);
    let relativeOffset = 1;
    for (i = 0; i < count + 1; i++) {
      if (offsetSize === 1) {
        data.push(relativeOffset & 0xff);
      } else if (offsetSize === 2) {
        data.push(relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      } else if (offsetSize === 3) {
        data.push(relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      } else {
        data.push(relativeOffset >>> 24 & 0xff, relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      }
      if (objects[i]) {
        relativeOffset += objects[i].length;
      }
    }
    for (i = 0; i < count; i++) {
      if (trackers[i]) {
        trackers[i].offset(data.length);
      }
      data.push(...objects[i]);
    }
    return data;
  }
}
exports.CFFCompiler = CFFCompiler;

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOAdobeCharset = exports.ExpertSubsetCharset = exports.ExpertCharset = void 0;
const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
exports.ISOAdobeCharset = ISOAdobeCharset;
const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertCharset = ExpertCharset;
const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
exports.ExpertSubsetCharset = ExpertSubsetCharset;

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ZapfDingbatsEncoding = exports.WinAnsiEncoding = exports.SymbolSetEncoding = exports.StandardEncoding = exports.MacRomanEncoding = exports.ExpertEncoding = void 0;
exports.getEncoding = getEncoding;
const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertEncoding = ExpertEncoding;
const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
exports.MacRomanEncoding = MacRomanEncoding;
const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
exports.StandardEncoding = StandardEncoding;
const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
exports.WinAnsiEncoding = WinAnsiEncoding;
const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
exports.SymbolSetEncoding = SymbolSetEncoding;
const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
function getEncoding(encodingName) {
  switch (encodingName) {
    case "WinAnsiEncoding":
      return WinAnsiEncoding;
    case "StandardEncoding":
      return StandardEncoding;
    case "MacRomanEncoding":
      return MacRomanEncoding;
    case "SymbolSetEncoding":
      return SymbolSetEncoding;
    case "ZapfDingbatsEncoding":
      return ZapfDingbatsEncoding;
    case "ExpertEncoding":
      return ExpertEncoding;
    case "MacExpertEncoding":
      return MacExpertEncoding;
    default:
      return null;
  }
}

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SEAC_ANALYSIS_ENABLED = exports.MacStandardGlyphOrdering = exports.FontFlags = void 0;
exports.normalizeFontName = normalizeFontName;
exports.recoverGlyphName = recoverGlyphName;
exports.type1FontGlyphMapping = type1FontGlyphMapping;
var _encodings = __w_pdfjs_require__(37);
var _glyphlist = __w_pdfjs_require__(39);
var _unicode = __w_pdfjs_require__(40);
var _util = __w_pdfjs_require__(2);
const SEAC_ANALYSIS_ENABLED = true;
exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
const FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
exports.FontFlags = FontFlags;
const MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
exports.MacStandardGlyphOrdering = MacStandardGlyphOrdering;
function recoverGlyphName(name, glyphsUnicodeMap) {
  if (glyphsUnicodeMap[name] !== undefined) {
    return name;
  }
  const unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
  if (unicode !== -1) {
    for (const key in glyphsUnicodeMap) {
      if (glyphsUnicodeMap[key] === unicode) {
        return key;
      }
    }
  }
  (0, _util.info)("Unable to recover a standard glyph name for: " + name);
  return name;
}
function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
  const charCodeToGlyphId = Object.create(null);
  let glyphId, charCode, baseEncoding;
  const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
  if (properties.isInternalFont) {
    baseEncoding = builtInEncoding;
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  } else if (properties.baseEncodingName) {
    baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  } else if (isSymbolicFont) {
    for (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } else {
    baseEncoding = _encodings.StandardEncoding;
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  }
  const differences = properties.differences;
  let glyphsUnicodeMap;
  if (differences) {
    for (charCode in differences) {
      const glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);
      if (glyphId === -1) {
        if (!glyphsUnicodeMap) {
          glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        }
        const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
        if (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }
      charCodeToGlyphId[charCode] = glyphId >= 0 ? glyphId : 0;
    }
  }
  return charCodeToGlyphId;
}
function normalizeFontName(name) {
  return name.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getGlyphsUnicode = exports.getDingbatsGlyphsUnicode = void 0;
var _core_utils = __w_pdfjs_require__(3);
const getGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.A = 0x0041;
  t.AE = 0x00c6;
  t.AEacute = 0x01fc;
  t.AEmacron = 0x01e2;
  t.AEsmall = 0xf7e6;
  t.Aacute = 0x00c1;
  t.Aacutesmall = 0xf7e1;
  t.Abreve = 0x0102;
  t.Abreveacute = 0x1eae;
  t.Abrevecyrillic = 0x04d0;
  t.Abrevedotbelow = 0x1eb6;
  t.Abrevegrave = 0x1eb0;
  t.Abrevehookabove = 0x1eb2;
  t.Abrevetilde = 0x1eb4;
  t.Acaron = 0x01cd;
  t.Acircle = 0x24b6;
  t.Acircumflex = 0x00c2;
  t.Acircumflexacute = 0x1ea4;
  t.Acircumflexdotbelow = 0x1eac;
  t.Acircumflexgrave = 0x1ea6;
  t.Acircumflexhookabove = 0x1ea8;
  t.Acircumflexsmall = 0xf7e2;
  t.Acircumflextilde = 0x1eaa;
  t.Acute = 0xf6c9;
  t.Acutesmall = 0xf7b4;
  t.Acyrillic = 0x0410;
  t.Adblgrave = 0x0200;
  t.Adieresis = 0x00c4;
  t.Adieresiscyrillic = 0x04d2;
  t.Adieresismacron = 0x01de;
  t.Adieresissmall = 0xf7e4;
  t.Adotbelow = 0x1ea0;
  t.Adotmacron = 0x01e0;
  t.Agrave = 0x00c0;
  t.Agravesmall = 0xf7e0;
  t.Ahookabove = 0x1ea2;
  t.Aiecyrillic = 0x04d4;
  t.Ainvertedbreve = 0x0202;
  t.Alpha = 0x0391;
  t.Alphatonos = 0x0386;
  t.Amacron = 0x0100;
  t.Amonospace = 0xff21;
  t.Aogonek = 0x0104;
  t.Aring = 0x00c5;
  t.Aringacute = 0x01fa;
  t.Aringbelow = 0x1e00;
  t.Aringsmall = 0xf7e5;
  t.Asmall = 0xf761;
  t.Atilde = 0x00c3;
  t.Atildesmall = 0xf7e3;
  t.Aybarmenian = 0x0531;
  t.B = 0x0042;
  t.Bcircle = 0x24b7;
  t.Bdotaccent = 0x1e02;
  t.Bdotbelow = 0x1e04;
  t.Becyrillic = 0x0411;
  t.Benarmenian = 0x0532;
  t.Beta = 0x0392;
  t.Bhook = 0x0181;
  t.Blinebelow = 0x1e06;
  t.Bmonospace = 0xff22;
  t.Brevesmall = 0xf6f4;
  t.Bsmall = 0xf762;
  t.Btopbar = 0x0182;
  t.C = 0x0043;
  t.Caarmenian = 0x053e;
  t.Cacute = 0x0106;
  t.Caron = 0xf6ca;
  t.Caronsmall = 0xf6f5;
  t.Ccaron = 0x010c;
  t.Ccedilla = 0x00c7;
  t.Ccedillaacute = 0x1e08;
  t.Ccedillasmall = 0xf7e7;
  t.Ccircle = 0x24b8;
  t.Ccircumflex = 0x0108;
  t.Cdot = 0x010a;
  t.Cdotaccent = 0x010a;
  t.Cedillasmall = 0xf7b8;
  t.Chaarmenian = 0x0549;
  t.Cheabkhasiancyrillic = 0x04bc;
  t.Checyrillic = 0x0427;
  t.Chedescenderabkhasiancyrillic = 0x04be;
  t.Chedescendercyrillic = 0x04b6;
  t.Chedieresiscyrillic = 0x04f4;
  t.Cheharmenian = 0x0543;
  t.Chekhakassiancyrillic = 0x04cb;
  t.Cheverticalstrokecyrillic = 0x04b8;
  t.Chi = 0x03a7;
  t.Chook = 0x0187;
  t.Circumflexsmall = 0xf6f6;
  t.Cmonospace = 0xff23;
  t.Coarmenian = 0x0551;
  t.Csmall = 0xf763;
  t.D = 0x0044;
  t.DZ = 0x01f1;
  t.DZcaron = 0x01c4;
  t.Daarmenian = 0x0534;
  t.Dafrican = 0x0189;
  t.Dcaron = 0x010e;
  t.Dcedilla = 0x1e10;
  t.Dcircle = 0x24b9;
  t.Dcircumflexbelow = 0x1e12;
  t.Dcroat = 0x0110;
  t.Ddotaccent = 0x1e0a;
  t.Ddotbelow = 0x1e0c;
  t.Decyrillic = 0x0414;
  t.Deicoptic = 0x03ee;
  t.Delta = 0x2206;
  t.Deltagreek = 0x0394;
  t.Dhook = 0x018a;
  t.Dieresis = 0xf6cb;
  t.DieresisAcute = 0xf6cc;
  t.DieresisGrave = 0xf6cd;
  t.Dieresissmall = 0xf7a8;
  t.Digammagreek = 0x03dc;
  t.Djecyrillic = 0x0402;
  t.Dlinebelow = 0x1e0e;
  t.Dmonospace = 0xff24;
  t.Dotaccentsmall = 0xf6f7;
  t.Dslash = 0x0110;
  t.Dsmall = 0xf764;
  t.Dtopbar = 0x018b;
  t.Dz = 0x01f2;
  t.Dzcaron = 0x01c5;
  t.Dzeabkhasiancyrillic = 0x04e0;
  t.Dzecyrillic = 0x0405;
  t.Dzhecyrillic = 0x040f;
  t.E = 0x0045;
  t.Eacute = 0x00c9;
  t.Eacutesmall = 0xf7e9;
  t.Ebreve = 0x0114;
  t.Ecaron = 0x011a;
  t.Ecedillabreve = 0x1e1c;
  t.Echarmenian = 0x0535;
  t.Ecircle = 0x24ba;
  t.Ecircumflex = 0x00ca;
  t.Ecircumflexacute = 0x1ebe;
  t.Ecircumflexbelow = 0x1e18;
  t.Ecircumflexdotbelow = 0x1ec6;
  t.Ecircumflexgrave = 0x1ec0;
  t.Ecircumflexhookabove = 0x1ec2;
  t.Ecircumflexsmall = 0xf7ea;
  t.Ecircumflextilde = 0x1ec4;
  t.Ecyrillic = 0x0404;
  t.Edblgrave = 0x0204;
  t.Edieresis = 0x00cb;
  t.Edieresissmall = 0xf7eb;
  t.Edot = 0x0116;
  t.Edotaccent = 0x0116;
  t.Edotbelow = 0x1eb8;
  t.Efcyrillic = 0x0424;
  t.Egrave = 0x00c8;
  t.Egravesmall = 0xf7e8;
  t.Eharmenian = 0x0537;
  t.Ehookabove = 0x1eba;
  t.Eightroman = 0x2167;
  t.Einvertedbreve = 0x0206;
  t.Eiotifiedcyrillic = 0x0464;
  t.Elcyrillic = 0x041b;
  t.Elevenroman = 0x216a;
  t.Emacron = 0x0112;
  t.Emacronacute = 0x1e16;
  t.Emacrongrave = 0x1e14;
  t.Emcyrillic = 0x041c;
  t.Emonospace = 0xff25;
  t.Encyrillic = 0x041d;
  t.Endescendercyrillic = 0x04a2;
  t.Eng = 0x014a;
  t.Enghecyrillic = 0x04a4;
  t.Enhookcyrillic = 0x04c7;
  t.Eogonek = 0x0118;
  t.Eopen = 0x0190;
  t.Epsilon = 0x0395;
  t.Epsilontonos = 0x0388;
  t.Ercyrillic = 0x0420;
  t.Ereversed = 0x018e;
  t.Ereversedcyrillic = 0x042d;
  t.Escyrillic = 0x0421;
  t.Esdescendercyrillic = 0x04aa;
  t.Esh = 0x01a9;
  t.Esmall = 0xf765;
  t.Eta = 0x0397;
  t.Etarmenian = 0x0538;
  t.Etatonos = 0x0389;
  t.Eth = 0x00d0;
  t.Ethsmall = 0xf7f0;
  t.Etilde = 0x1ebc;
  t.Etildebelow = 0x1e1a;
  t.Euro = 0x20ac;
  t.Ezh = 0x01b7;
  t.Ezhcaron = 0x01ee;
  t.Ezhreversed = 0x01b8;
  t.F = 0x0046;
  t.Fcircle = 0x24bb;
  t.Fdotaccent = 0x1e1e;
  t.Feharmenian = 0x0556;
  t.Feicoptic = 0x03e4;
  t.Fhook = 0x0191;
  t.Fitacyrillic = 0x0472;
  t.Fiveroman = 0x2164;
  t.Fmonospace = 0xff26;
  t.Fourroman = 0x2163;
  t.Fsmall = 0xf766;
  t.G = 0x0047;
  t.GBsquare = 0x3387;
  t.Gacute = 0x01f4;
  t.Gamma = 0x0393;
  t.Gammaafrican = 0x0194;
  t.Gangiacoptic = 0x03ea;
  t.Gbreve = 0x011e;
  t.Gcaron = 0x01e6;
  t.Gcedilla = 0x0122;
  t.Gcircle = 0x24bc;
  t.Gcircumflex = 0x011c;
  t.Gcommaaccent = 0x0122;
  t.Gdot = 0x0120;
  t.Gdotaccent = 0x0120;
  t.Gecyrillic = 0x0413;
  t.Ghadarmenian = 0x0542;
  t.Ghemiddlehookcyrillic = 0x0494;
  t.Ghestrokecyrillic = 0x0492;
  t.Gheupturncyrillic = 0x0490;
  t.Ghook = 0x0193;
  t.Gimarmenian = 0x0533;
  t.Gjecyrillic = 0x0403;
  t.Gmacron = 0x1e20;
  t.Gmonospace = 0xff27;
  t.Grave = 0xf6ce;
  t.Gravesmall = 0xf760;
  t.Gsmall = 0xf767;
  t.Gsmallhook = 0x029b;
  t.Gstroke = 0x01e4;
  t.H = 0x0048;
  t.H18533 = 0x25cf;
  t.H18543 = 0x25aa;
  t.H18551 = 0x25ab;
  t.H22073 = 0x25a1;
  t.HPsquare = 0x33cb;
  t.Haabkhasiancyrillic = 0x04a8;
  t.Hadescendercyrillic = 0x04b2;
  t.Hardsigncyrillic = 0x042a;
  t.Hbar = 0x0126;
  t.Hbrevebelow = 0x1e2a;
  t.Hcedilla = 0x1e28;
  t.Hcircle = 0x24bd;
  t.Hcircumflex = 0x0124;
  t.Hdieresis = 0x1e26;
  t.Hdotaccent = 0x1e22;
  t.Hdotbelow = 0x1e24;
  t.Hmonospace = 0xff28;
  t.Hoarmenian = 0x0540;
  t.Horicoptic = 0x03e8;
  t.Hsmall = 0xf768;
  t.Hungarumlaut = 0xf6cf;
  t.Hungarumlautsmall = 0xf6f8;
  t.Hzsquare = 0x3390;
  t.I = 0x0049;
  t.IAcyrillic = 0x042f;
  t.IJ = 0x0132;
  t.IUcyrillic = 0x042e;
  t.Iacute = 0x00cd;
  t.Iacutesmall = 0xf7ed;
  t.Ibreve = 0x012c;
  t.Icaron = 0x01cf;
  t.Icircle = 0x24be;
  t.Icircumflex = 0x00ce;
  t.Icircumflexsmall = 0xf7ee;
  t.Icyrillic = 0x0406;
  t.Idblgrave = 0x0208;
  t.Idieresis = 0x00cf;
  t.Idieresisacute = 0x1e2e;
  t.Idieresiscyrillic = 0x04e4;
  t.Idieresissmall = 0xf7ef;
  t.Idot = 0x0130;
  t.Idotaccent = 0x0130;
  t.Idotbelow = 0x1eca;
  t.Iebrevecyrillic = 0x04d6;
  t.Iecyrillic = 0x0415;
  t.Ifraktur = 0x2111;
  t.Igrave = 0x00cc;
  t.Igravesmall = 0xf7ec;
  t.Ihookabove = 0x1ec8;
  t.Iicyrillic = 0x0418;
  t.Iinvertedbreve = 0x020a;
  t.Iishortcyrillic = 0x0419;
  t.Imacron = 0x012a;
  t.Imacroncyrillic = 0x04e2;
  t.Imonospace = 0xff29;
  t.Iniarmenian = 0x053b;
  t.Iocyrillic = 0x0401;
  t.Iogonek = 0x012e;
  t.Iota = 0x0399;
  t.Iotaafrican = 0x0196;
  t.Iotadieresis = 0x03aa;
  t.Iotatonos = 0x038a;
  t.Ismall = 0xf769;
  t.Istroke = 0x0197;
  t.Itilde = 0x0128;
  t.Itildebelow = 0x1e2c;
  t.Izhitsacyrillic = 0x0474;
  t.Izhitsadblgravecyrillic = 0x0476;
  t.J = 0x004a;
  t.Jaarmenian = 0x0541;
  t.Jcircle = 0x24bf;
  t.Jcircumflex = 0x0134;
  t.Jecyrillic = 0x0408;
  t.Jheharmenian = 0x054b;
  t.Jmonospace = 0xff2a;
  t.Jsmall = 0xf76a;
  t.K = 0x004b;
  t.KBsquare = 0x3385;
  t.KKsquare = 0x33cd;
  t.Kabashkircyrillic = 0x04a0;
  t.Kacute = 0x1e30;
  t.Kacyrillic = 0x041a;
  t.Kadescendercyrillic = 0x049a;
  t.Kahookcyrillic = 0x04c3;
  t.Kappa = 0x039a;
  t.Kastrokecyrillic = 0x049e;
  t.Kaverticalstrokecyrillic = 0x049c;
  t.Kcaron = 0x01e8;
  t.Kcedilla = 0x0136;
  t.Kcircle = 0x24c0;
  t.Kcommaaccent = 0x0136;
  t.Kdotbelow = 0x1e32;
  t.Keharmenian = 0x0554;
  t.Kenarmenian = 0x053f;
  t.Khacyrillic = 0x0425;
  t.Kheicoptic = 0x03e6;
  t.Khook = 0x0198;
  t.Kjecyrillic = 0x040c;
  t.Klinebelow = 0x1e34;
  t.Kmonospace = 0xff2b;
  t.Koppacyrillic = 0x0480;
  t.Koppagreek = 0x03de;
  t.Ksicyrillic = 0x046e;
  t.Ksmall = 0xf76b;
  t.L = 0x004c;
  t.LJ = 0x01c7;
  t.LL = 0xf6bf;
  t.Lacute = 0x0139;
  t.Lambda = 0x039b;
  t.Lcaron = 0x013d;
  t.Lcedilla = 0x013b;
  t.Lcircle = 0x24c1;
  t.Lcircumflexbelow = 0x1e3c;
  t.Lcommaaccent = 0x013b;
  t.Ldot = 0x013f;
  t.Ldotaccent = 0x013f;
  t.Ldotbelow = 0x1e36;
  t.Ldotbelowmacron = 0x1e38;
  t.Liwnarmenian = 0x053c;
  t.Lj = 0x01c8;
  t.Ljecyrillic = 0x0409;
  t.Llinebelow = 0x1e3a;
  t.Lmonospace = 0xff2c;
  t.Lslash = 0x0141;
  t.Lslashsmall = 0xf6f9;
  t.Lsmall = 0xf76c;
  t.M = 0x004d;
  t.MBsquare = 0x3386;
  t.Macron = 0xf6d0;
  t.Macronsmall = 0xf7af;
  t.Macute = 0x1e3e;
  t.Mcircle = 0x24c2;
  t.Mdotaccent = 0x1e40;
  t.Mdotbelow = 0x1e42;
  t.Menarmenian = 0x0544;
  t.Mmonospace = 0xff2d;
  t.Msmall = 0xf76d;
  t.Mturned = 0x019c;
  t.Mu = 0x039c;
  t.N = 0x004e;
  t.NJ = 0x01ca;
  t.Nacute = 0x0143;
  t.Ncaron = 0x0147;
  t.Ncedilla = 0x0145;
  t.Ncircle = 0x24c3;
  t.Ncircumflexbelow = 0x1e4a;
  t.Ncommaaccent = 0x0145;
  t.Ndotaccent = 0x1e44;
  t.Ndotbelow = 0x1e46;
  t.Nhookleft = 0x019d;
  t.Nineroman = 0x2168;
  t.Nj = 0x01cb;
  t.Njecyrillic = 0x040a;
  t.Nlinebelow = 0x1e48;
  t.Nmonospace = 0xff2e;
  t.Nowarmenian = 0x0546;
  t.Nsmall = 0xf76e;
  t.Ntilde = 0x00d1;
  t.Ntildesmall = 0xf7f1;
  t.Nu = 0x039d;
  t.O = 0x004f;
  t.OE = 0x0152;
  t.OEsmall = 0xf6fa;
  t.Oacute = 0x00d3;
  t.Oacutesmall = 0xf7f3;
  t.Obarredcyrillic = 0x04e8;
  t.Obarreddieresiscyrillic = 0x04ea;
  t.Obreve = 0x014e;
  t.Ocaron = 0x01d1;
  t.Ocenteredtilde = 0x019f;
  t.Ocircle = 0x24c4;
  t.Ocircumflex = 0x00d4;
  t.Ocircumflexacute = 0x1ed0;
  t.Ocircumflexdotbelow = 0x1ed8;
  t.Ocircumflexgrave = 0x1ed2;
  t.Ocircumflexhookabove = 0x1ed4;
  t.Ocircumflexsmall = 0xf7f4;
  t.Ocircumflextilde = 0x1ed6;
  t.Ocyrillic = 0x041e;
  t.Odblacute = 0x0150;
  t.Odblgrave = 0x020c;
  t.Odieresis = 0x00d6;
  t.Odieresiscyrillic = 0x04e6;
  t.Odieresissmall = 0xf7f6;
  t.Odotbelow = 0x1ecc;
  t.Ogoneksmall = 0xf6fb;
  t.Ograve = 0x00d2;
  t.Ogravesmall = 0xf7f2;
  t.Oharmenian = 0x0555;
  t.Ohm = 0x2126;
  t.Ohookabove = 0x1ece;
  t.Ohorn = 0x01a0;
  t.Ohornacute = 0x1eda;
  t.Ohorndotbelow = 0x1ee2;
  t.Ohorngrave = 0x1edc;
  t.Ohornhookabove = 0x1ede;
  t.Ohorntilde = 0x1ee0;
  t.Ohungarumlaut = 0x0150;
  t.Oi = 0x01a2;
  t.Oinvertedbreve = 0x020e;
  t.Omacron = 0x014c;
  t.Omacronacute = 0x1e52;
  t.Omacrongrave = 0x1e50;
  t.Omega = 0x2126;
  t.Omegacyrillic = 0x0460;
  t.Omegagreek = 0x03a9;
  t.Omegaroundcyrillic = 0x047a;
  t.Omegatitlocyrillic = 0x047c;
  t.Omegatonos = 0x038f;
  t.Omicron = 0x039f;
  t.Omicrontonos = 0x038c;
  t.Omonospace = 0xff2f;
  t.Oneroman = 0x2160;
  t.Oogonek = 0x01ea;
  t.Oogonekmacron = 0x01ec;
  t.Oopen = 0x0186;
  t.Oslash = 0x00d8;
  t.Oslashacute = 0x01fe;
  t.Oslashsmall = 0xf7f8;
  t.Osmall = 0xf76f;
  t.Ostrokeacute = 0x01fe;
  t.Otcyrillic = 0x047e;
  t.Otilde = 0x00d5;
  t.Otildeacute = 0x1e4c;
  t.Otildedieresis = 0x1e4e;
  t.Otildesmall = 0xf7f5;
  t.P = 0x0050;
  t.Pacute = 0x1e54;
  t.Pcircle = 0x24c5;
  t.Pdotaccent = 0x1e56;
  t.Pecyrillic = 0x041f;
  t.Peharmenian = 0x054a;
  t.Pemiddlehookcyrillic = 0x04a6;
  t.Phi = 0x03a6;
  t.Phook = 0x01a4;
  t.Pi = 0x03a0;
  t.Piwrarmenian = 0x0553;
  t.Pmonospace = 0xff30;
  t.Psi = 0x03a8;
  t.Psicyrillic = 0x0470;
  t.Psmall = 0xf770;
  t.Q = 0x0051;
  t.Qcircle = 0x24c6;
  t.Qmonospace = 0xff31;
  t.Qsmall = 0xf771;
  t.R = 0x0052;
  t.Raarmenian = 0x054c;
  t.Racute = 0x0154;
  t.Rcaron = 0x0158;
  t.Rcedilla = 0x0156;
  t.Rcircle = 0x24c7;
  t.Rcommaaccent = 0x0156;
  t.Rdblgrave = 0x0210;
  t.Rdotaccent = 0x1e58;
  t.Rdotbelow = 0x1e5a;
  t.Rdotbelowmacron = 0x1e5c;
  t.Reharmenian = 0x0550;
  t.Rfraktur = 0x211c;
  t.Rho = 0x03a1;
  t.Ringsmall = 0xf6fc;
  t.Rinvertedbreve = 0x0212;
  t.Rlinebelow = 0x1e5e;
  t.Rmonospace = 0xff32;
  t.Rsmall = 0xf772;
  t.Rsmallinverted = 0x0281;
  t.Rsmallinvertedsuperior = 0x02b6;
  t.S = 0x0053;
  t.SF010000 = 0x250c;
  t.SF020000 = 0x2514;
  t.SF030000 = 0x2510;
  t.SF040000 = 0x2518;
  t.SF050000 = 0x253c;
  t.SF060000 = 0x252c;
  t.SF070000 = 0x2534;
  t.SF080000 = 0x251c;
  t.SF090000 = 0x2524;
  t.SF100000 = 0x2500;
  t.SF110000 = 0x2502;
  t.SF190000 = 0x2561;
  t.SF200000 = 0x2562;
  t.SF210000 = 0x2556;
  t.SF220000 = 0x2555;
  t.SF230000 = 0x2563;
  t.SF240000 = 0x2551;
  t.SF250000 = 0x2557;
  t.SF260000 = 0x255d;
  t.SF270000 = 0x255c;
  t.SF280000 = 0x255b;
  t.SF360000 = 0x255e;
  t.SF370000 = 0x255f;
  t.SF380000 = 0x255a;
  t.SF390000 = 0x2554;
  t.SF400000 = 0x2569;
  t.SF410000 = 0x2566;
  t.SF420000 = 0x2560;
  t.SF430000 = 0x2550;
  t.SF440000 = 0x256c;
  t.SF450000 = 0x2567;
  t.SF460000 = 0x2568;
  t.SF470000 = 0x2564;
  t.SF480000 = 0x2565;
  t.SF490000 = 0x2559;
  t.SF500000 = 0x2558;
  t.SF510000 = 0x2552;
  t.SF520000 = 0x2553;
  t.SF530000 = 0x256b;
  t.SF540000 = 0x256a;
  t.Sacute = 0x015a;
  t.Sacutedotaccent = 0x1e64;
  t.Sampigreek = 0x03e0;
  t.Scaron = 0x0160;
  t.Scarondotaccent = 0x1e66;
  t.Scaronsmall = 0xf6fd;
  t.Scedilla = 0x015e;
  t.Schwa = 0x018f;
  t.Schwacyrillic = 0x04d8;
  t.Schwadieresiscyrillic = 0x04da;
  t.Scircle = 0x24c8;
  t.Scircumflex = 0x015c;
  t.Scommaaccent = 0x0218;
  t.Sdotaccent = 0x1e60;
  t.Sdotbelow = 0x1e62;
  t.Sdotbelowdotaccent = 0x1e68;
  t.Seharmenian = 0x054d;
  t.Sevenroman = 0x2166;
  t.Shaarmenian = 0x0547;
  t.Shacyrillic = 0x0428;
  t.Shchacyrillic = 0x0429;
  t.Sheicoptic = 0x03e2;
  t.Shhacyrillic = 0x04ba;
  t.Shimacoptic = 0x03ec;
  t.Sigma = 0x03a3;
  t.Sixroman = 0x2165;
  t.Smonospace = 0xff33;
  t.Softsigncyrillic = 0x042c;
  t.Ssmall = 0xf773;
  t.Stigmagreek = 0x03da;
  t.T = 0x0054;
  t.Tau = 0x03a4;
  t.Tbar = 0x0166;
  t.Tcaron = 0x0164;
  t.Tcedilla = 0x0162;
  t.Tcircle = 0x24c9;
  t.Tcircumflexbelow = 0x1e70;
  t.Tcommaaccent = 0x0162;
  t.Tdotaccent = 0x1e6a;
  t.Tdotbelow = 0x1e6c;
  t.Tecyrillic = 0x0422;
  t.Tedescendercyrillic = 0x04ac;
  t.Tenroman = 0x2169;
  t.Tetsecyrillic = 0x04b4;
  t.Theta = 0x0398;
  t.Thook = 0x01ac;
  t.Thorn = 0x00de;
  t.Thornsmall = 0xf7fe;
  t.Threeroman = 0x2162;
  t.Tildesmall = 0xf6fe;
  t.Tiwnarmenian = 0x054f;
  t.Tlinebelow = 0x1e6e;
  t.Tmonospace = 0xff34;
  t.Toarmenian = 0x0539;
  t.Tonefive = 0x01bc;
  t.Tonesix = 0x0184;
  t.Tonetwo = 0x01a7;
  t.Tretroflexhook = 0x01ae;
  t.Tsecyrillic = 0x0426;
  t.Tshecyrillic = 0x040b;
  t.Tsmall = 0xf774;
  t.Twelveroman = 0x216b;
  t.Tworoman = 0x2161;
  t.U = 0x0055;
  t.Uacute = 0x00da;
  t.Uacutesmall = 0xf7fa;
  t.Ubreve = 0x016c;
  t.Ucaron = 0x01d3;
  t.Ucircle = 0x24ca;
  t.Ucircumflex = 0x00db;
  t.Ucircumflexbelow = 0x1e76;
  t.Ucircumflexsmall = 0xf7fb;
  t.Ucyrillic = 0x0423;
  t.Udblacute = 0x0170;
  t.Udblgrave = 0x0214;
  t.Udieresis = 0x00dc;
  t.Udieresisacute = 0x01d7;
  t.Udieresisbelow = 0x1e72;
  t.Udieresiscaron = 0x01d9;
  t.Udieresiscyrillic = 0x04f0;
  t.Udieresisgrave = 0x01db;
  t.Udieresismacron = 0x01d5;
  t.Udieresissmall = 0xf7fc;
  t.Udotbelow = 0x1ee4;
  t.Ugrave = 0x00d9;
  t.Ugravesmall = 0xf7f9;
  t.Uhookabove = 0x1ee6;
  t.Uhorn = 0x01af;
  t.Uhornacute = 0x1ee8;
  t.Uhorndotbelow = 0x1ef0;
  t.Uhorngrave = 0x1eea;
  t.Uhornhookabove = 0x1eec;
  t.Uhorntilde = 0x1eee;
  t.Uhungarumlaut = 0x0170;
  t.Uhungarumlautcyrillic = 0x04f2;
  t.Uinvertedbreve = 0x0216;
  t.Ukcyrillic = 0x0478;
  t.Umacron = 0x016a;
  t.Umacroncyrillic = 0x04ee;
  t.Umacrondieresis = 0x1e7a;
  t.Umonospace = 0xff35;
  t.Uogonek = 0x0172;
  t.Upsilon = 0x03a5;
  t.Upsilon1 = 0x03d2;
  t.Upsilonacutehooksymbolgreek = 0x03d3;
  t.Upsilonafrican = 0x01b1;
  t.Upsilondieresis = 0x03ab;
  t.Upsilondieresishooksymbolgreek = 0x03d4;
  t.Upsilonhooksymbol = 0x03d2;
  t.Upsilontonos = 0x038e;
  t.Uring = 0x016e;
  t.Ushortcyrillic = 0x040e;
  t.Usmall = 0xf775;
  t.Ustraightcyrillic = 0x04ae;
  t.Ustraightstrokecyrillic = 0x04b0;
  t.Utilde = 0x0168;
  t.Utildeacute = 0x1e78;
  t.Utildebelow = 0x1e74;
  t.V = 0x0056;
  t.Vcircle = 0x24cb;
  t.Vdotbelow = 0x1e7e;
  t.Vecyrillic = 0x0412;
  t.Vewarmenian = 0x054e;
  t.Vhook = 0x01b2;
  t.Vmonospace = 0xff36;
  t.Voarmenian = 0x0548;
  t.Vsmall = 0xf776;
  t.Vtilde = 0x1e7c;
  t.W = 0x0057;
  t.Wacute = 0x1e82;
  t.Wcircle = 0x24cc;
  t.Wcircumflex = 0x0174;
  t.Wdieresis = 0x1e84;
  t.Wdotaccent = 0x1e86;
  t.Wdotbelow = 0x1e88;
  t.Wgrave = 0x1e80;
  t.Wmonospace = 0xff37;
  t.Wsmall = 0xf777;
  t.X = 0x0058;
  t.Xcircle = 0x24cd;
  t.Xdieresis = 0x1e8c;
  t.Xdotaccent = 0x1e8a;
  t.Xeharmenian = 0x053d;
  t.Xi = 0x039e;
  t.Xmonospace = 0xff38;
  t.Xsmall = 0xf778;
  t.Y = 0x0059;
  t.Yacute = 0x00dd;
  t.Yacutesmall = 0xf7fd;
  t.Yatcyrillic = 0x0462;
  t.Ycircle = 0x24ce;
  t.Ycircumflex = 0x0176;
  t.Ydieresis = 0x0178;
  t.Ydieresissmall = 0xf7ff;
  t.Ydotaccent = 0x1e8e;
  t.Ydotbelow = 0x1ef4;
  t.Yericyrillic = 0x042b;
  t.Yerudieresiscyrillic = 0x04f8;
  t.Ygrave = 0x1ef2;
  t.Yhook = 0x01b3;
  t.Yhookabove = 0x1ef6;
  t.Yiarmenian = 0x0545;
  t.Yicyrillic = 0x0407;
  t.Yiwnarmenian = 0x0552;
  t.Ymonospace = 0xff39;
  t.Ysmall = 0xf779;
  t.Ytilde = 0x1ef8;
  t.Yusbigcyrillic = 0x046a;
  t.Yusbigiotifiedcyrillic = 0x046c;
  t.Yuslittlecyrillic = 0x0466;
  t.Yuslittleiotifiedcyrillic = 0x0468;
  t.Z = 0x005a;
  t.Zaarmenian = 0x0536;
  t.Zacute = 0x0179;
  t.Zcaron = 0x017d;
  t.Zcaronsmall = 0xf6ff;
  t.Zcircle = 0x24cf;
  t.Zcircumflex = 0x1e90;
  t.Zdot = 0x017b;
  t.Zdotaccent = 0x017b;
  t.Zdotbelow = 0x1e92;
  t.Zecyrillic = 0x0417;
  t.Zedescendercyrillic = 0x0498;
  t.Zedieresiscyrillic = 0x04de;
  t.Zeta = 0x0396;
  t.Zhearmenian = 0x053a;
  t.Zhebrevecyrillic = 0x04c1;
  t.Zhecyrillic = 0x0416;
  t.Zhedescendercyrillic = 0x0496;
  t.Zhedieresiscyrillic = 0x04dc;
  t.Zlinebelow = 0x1e94;
  t.Zmonospace = 0xff3a;
  t.Zsmall = 0xf77a;
  t.Zstroke = 0x01b5;
  t.a = 0x0061;
  t.aabengali = 0x0986;
  t.aacute = 0x00e1;
  t.aadeva = 0x0906;
  t.aagujarati = 0x0a86;
  t.aagurmukhi = 0x0a06;
  t.aamatragurmukhi = 0x0a3e;
  t.aarusquare = 0x3303;
  t.aavowelsignbengali = 0x09be;
  t.aavowelsigndeva = 0x093e;
  t.aavowelsigngujarati = 0x0abe;
  t.abbreviationmarkarmenian = 0x055f;
  t.abbreviationsigndeva = 0x0970;
  t.abengali = 0x0985;
  t.abopomofo = 0x311a;
  t.abreve = 0x0103;
  t.abreveacute = 0x1eaf;
  t.abrevecyrillic = 0x04d1;
  t.abrevedotbelow = 0x1eb7;
  t.abrevegrave = 0x1eb1;
  t.abrevehookabove = 0x1eb3;
  t.abrevetilde = 0x1eb5;
  t.acaron = 0x01ce;
  t.acircle = 0x24d0;
  t.acircumflex = 0x00e2;
  t.acircumflexacute = 0x1ea5;
  t.acircumflexdotbelow = 0x1ead;
  t.acircumflexgrave = 0x1ea7;
  t.acircumflexhookabove = 0x1ea9;
  t.acircumflextilde = 0x1eab;
  t.acute = 0x00b4;
  t.acutebelowcmb = 0x0317;
  t.acutecmb = 0x0301;
  t.acutecomb = 0x0301;
  t.acutedeva = 0x0954;
  t.acutelowmod = 0x02cf;
  t.acutetonecmb = 0x0341;
  t.acyrillic = 0x0430;
  t.adblgrave = 0x0201;
  t.addakgurmukhi = 0x0a71;
  t.adeva = 0x0905;
  t.adieresis = 0x00e4;
  t.adieresiscyrillic = 0x04d3;
  t.adieresismacron = 0x01df;
  t.adotbelow = 0x1ea1;
  t.adotmacron = 0x01e1;
  t.ae = 0x00e6;
  t.aeacute = 0x01fd;
  t.aekorean = 0x3150;
  t.aemacron = 0x01e3;
  t.afii00208 = 0x2015;
  t.afii08941 = 0x20a4;
  t.afii10017 = 0x0410;
  t.afii10018 = 0x0411;
  t.afii10019 = 0x0412;
  t.afii10020 = 0x0413;
  t.afii10021 = 0x0414;
  t.afii10022 = 0x0415;
  t.afii10023 = 0x0401;
  t.afii10024 = 0x0416;
  t.afii10025 = 0x0417;
  t.afii10026 = 0x0418;
  t.afii10027 = 0x0419;
  t.afii10028 = 0x041a;
  t.afii10029 = 0x041b;
  t.afii10030 = 0x041c;
  t.afii10031 = 0x041d;
  t.afii10032 = 0x041e;
  t.afii10033 = 0x041f;
  t.afii10034 = 0x0420;
  t.afii10035 = 0x0421;
  t.afii10036 = 0x0422;
  t.afii10037 = 0x0423;
  t.afii10038 = 0x0424;
  t.afii10039 = 0x0425;
  t.afii10040 = 0x0426;
  t.afii10041 = 0x0427;
  t.afii10042 = 0x0428;
  t.afii10043 = 0x0429;
  t.afii10044 = 0x042a;
  t.afii10045 = 0x042b;
  t.afii10046 = 0x042c;
  t.afii10047 = 0x042d;
  t.afii10048 = 0x042e;
  t.afii10049 = 0x042f;
  t.afii10050 = 0x0490;
  t.afii10051 = 0x0402;
  t.afii10052 = 0x0403;
  t.afii10053 = 0x0404;
  t.afii10054 = 0x0405;
  t.afii10055 = 0x0406;
  t.afii10056 = 0x0407;
  t.afii10057 = 0x0408;
  t.afii10058 = 0x0409;
  t.afii10059 = 0x040a;
  t.afii10060 = 0x040b;
  t.afii10061 = 0x040c;
  t.afii10062 = 0x040e;
  t.afii10063 = 0xf6c4;
  t.afii10064 = 0xf6c5;
  t.afii10065 = 0x0430;
  t.afii10066 = 0x0431;
  t.afii10067 = 0x0432;
  t.afii10068 = 0x0433;
  t.afii10069 = 0x0434;
  t.afii10070 = 0x0435;
  t.afii10071 = 0x0451;
  t.afii10072 = 0x0436;
  t.afii10073 = 0x0437;
  t.afii10074 = 0x0438;
  t.afii10075 = 0x0439;
  t.afii10076 = 0x043a;
  t.afii10077 = 0x043b;
  t.afii10078 = 0x043c;
  t.afii10079 = 0x043d;
  t.afii10080 = 0x043e;
  t.afii10081 = 0x043f;
  t.afii10082 = 0x0440;
  t.afii10083 = 0x0441;
  t.afii10084 = 0x0442;
  t.afii10085 = 0x0443;
  t.afii10086 = 0x0444;
  t.afii10087 = 0x0445;
  t.afii10088 = 0x0446;
  t.afii10089 = 0x0447;
  t.afii10090 = 0x0448;
  t.afii10091 = 0x0449;
  t.afii10092 = 0x044a;
  t.afii10093 = 0x044b;
  t.afii10094 = 0x044c;
  t.afii10095 = 0x044d;
  t.afii10096 = 0x044e;
  t.afii10097 = 0x044f;
  t.afii10098 = 0x0491;
  t.afii10099 = 0x0452;
  t.afii10100 = 0x0453;
  t.afii10101 = 0x0454;
  t.afii10102 = 0x0455;
  t.afii10103 = 0x0456;
  t.afii10104 = 0x0457;
  t.afii10105 = 0x0458;
  t.afii10106 = 0x0459;
  t.afii10107 = 0x045a;
  t.afii10108 = 0x045b;
  t.afii10109 = 0x045c;
  t.afii10110 = 0x045e;
  t.afii10145 = 0x040f;
  t.afii10146 = 0x0462;
  t.afii10147 = 0x0472;
  t.afii10148 = 0x0474;
  t.afii10192 = 0xf6c6;
  t.afii10193 = 0x045f;
  t.afii10194 = 0x0463;
  t.afii10195 = 0x0473;
  t.afii10196 = 0x0475;
  t.afii10831 = 0xf6c7;
  t.afii10832 = 0xf6c8;
  t.afii10846 = 0x04d9;
  t.afii299 = 0x200e;
  t.afii300 = 0x200f;
  t.afii301 = 0x200d;
  t.afii57381 = 0x066a;
  t.afii57388 = 0x060c;
  t.afii57392 = 0x0660;
  t.afii57393 = 0x0661;
  t.afii57394 = 0x0662;
  t.afii57395 = 0x0663;
  t.afii57396 = 0x0664;
  t.afii57397 = 0x0665;
  t.afii57398 = 0x0666;
  t.afii57399 = 0x0667;
  t.afii57400 = 0x0668;
  t.afii57401 = 0x0669;
  t.afii57403 = 0x061b;
  t.afii57407 = 0x061f;
  t.afii57409 = 0x0621;
  t.afii57410 = 0x0622;
  t.afii57411 = 0x0623;
  t.afii57412 = 0x0624;
  t.afii57413 = 0x0625;
  t.afii57414 = 0x0626;
  t.afii57415 = 0x0627;
  t.afii57416 = 0x0628;
  t.afii57417 = 0x0629;
  t.afii57418 = 0x062a;
  t.afii57419 = 0x062b;
  t.afii57420 = 0x062c;
  t.afii57421 = 0x062d;
  t.afii57422 = 0x062e;
  t.afii57423 = 0x062f;
  t.afii57424 = 0x0630;
  t.afii57425 = 0x0631;
  t.afii57426 = 0x0632;
  t.afii57427 = 0x0633;
  t.afii57428 = 0x0634;
  t.afii57429 = 0x0635;
  t.afii57430 = 0x0636;
  t.afii57431 = 0x0637;
  t.afii57432 = 0x0638;
  t.afii57433 = 0x0639;
  t.afii57434 = 0x063a;
  t.afii57440 = 0x0640;
  t.afii57441 = 0x0641;
  t.afii57442 = 0x0642;
  t.afii57443 = 0x0643;
  t.afii57444 = 0x0644;
  t.afii57445 = 0x0645;
  t.afii57446 = 0x0646;
  t.afii57448 = 0x0648;
  t.afii57449 = 0x0649;
  t.afii57450 = 0x064a;
  t.afii57451 = 0x064b;
  t.afii57452 = 0x064c;
  t.afii57453 = 0x064d;
  t.afii57454 = 0x064e;
  t.afii57455 = 0x064f;
  t.afii57456 = 0x0650;
  t.afii57457 = 0x0651;
  t.afii57458 = 0x0652;
  t.afii57470 = 0x0647;
  t.afii57505 = 0x06a4;
  t.afii57506 = 0x067e;
  t.afii57507 = 0x0686;
  t.afii57508 = 0x0698;
  t.afii57509 = 0x06af;
  t.afii57511 = 0x0679;
  t.afii57512 = 0x0688;
  t.afii57513 = 0x0691;
  t.afii57514 = 0x06ba;
  t.afii57519 = 0x06d2;
  t.afii57534 = 0x06d5;
  t.afii57636 = 0x20aa;
  t.afii57645 = 0x05be;
  t.afii57658 = 0x05c3;
  t.afii57664 = 0x05d0;
  t.afii57665 = 0x05d1;
  t.afii57666 = 0x05d2;
  t.afii57667 = 0x05d3;
  t.afii57668 = 0x05d4;
  t.afii57669 = 0x05d5;
  t.afii57670 = 0x05d6;
  t.afii57671 = 0x05d7;
  t.afii57672 = 0x05d8;
  t.afii57673 = 0x05d9;
  t.afii57674 = 0x05da;
  t.afii57675 = 0x05db;
  t.afii57676 = 0x05dc;
  t.afii57677 = 0x05dd;
  t.afii57678 = 0x05de;
  t.afii57679 = 0x05df;
  t.afii57680 = 0x05e0;
  t.afii57681 = 0x05e1;
  t.afii57682 = 0x05e2;
  t.afii57683 = 0x05e3;
  t.afii57684 = 0x05e4;
  t.afii57685 = 0x05e5;
  t.afii57686 = 0x05e6;
  t.afii57687 = 0x05e7;
  t.afii57688 = 0x05e8;
  t.afii57689 = 0x05e9;
  t.afii57690 = 0x05ea;
  t.afii57694 = 0xfb2a;
  t.afii57695 = 0xfb2b;
  t.afii57700 = 0xfb4b;
  t.afii57705 = 0xfb1f;
  t.afii57716 = 0x05f0;
  t.afii57717 = 0x05f1;
  t.afii57718 = 0x05f2;
  t.afii57723 = 0xfb35;
  t.afii57793 = 0x05b4;
  t.afii57794 = 0x05b5;
  t.afii57795 = 0x05b6;
  t.afii57796 = 0x05bb;
  t.afii57797 = 0x05b8;
  t.afii57798 = 0x05b7;
  t.afii57799 = 0x05b0;
  t.afii57800 = 0x05b2;
  t.afii57801 = 0x05b1;
  t.afii57802 = 0x05b3;
  t.afii57803 = 0x05c2;
  t.afii57804 = 0x05c1;
  t.afii57806 = 0x05b9;
  t.afii57807 = 0x05bc;
  t.afii57839 = 0x05bd;
  t.afii57841 = 0x05bf;
  t.afii57842 = 0x05c0;
  t.afii57929 = 0x02bc;
  t.afii61248 = 0x2105;
  t.afii61289 = 0x2113;
  t.afii61352 = 0x2116;
  t.afii61573 = 0x202c;
  t.afii61574 = 0x202d;
  t.afii61575 = 0x202e;
  t.afii61664 = 0x200c;
  t.afii63167 = 0x066d;
  t.afii64937 = 0x02bd;
  t.agrave = 0x00e0;
  t.agujarati = 0x0a85;
  t.agurmukhi = 0x0a05;
  t.ahiragana = 0x3042;
  t.ahookabove = 0x1ea3;
  t.aibengali = 0x0990;
  t.aibopomofo = 0x311e;
  t.aideva = 0x0910;
  t.aiecyrillic = 0x04d5;
  t.aigujarati = 0x0a90;
  t.aigurmukhi = 0x0a10;
  t.aimatragurmukhi = 0x0a48;
  t.ainarabic = 0x0639;
  t.ainfinalarabic = 0xfeca;
  t.aininitialarabic = 0xfecb;
  t.ainmedialarabic = 0xfecc;
  t.ainvertedbreve = 0x0203;
  t.aivowelsignbengali = 0x09c8;
  t.aivowelsigndeva = 0x0948;
  t.aivowelsigngujarati = 0x0ac8;
  t.akatakana = 0x30a2;
  t.akatakanahalfwidth = 0xff71;
  t.akorean = 0x314f;
  t.alef = 0x05d0;
  t.alefarabic = 0x0627;
  t.alefdageshhebrew = 0xfb30;
  t.aleffinalarabic = 0xfe8e;
  t.alefhamzaabovearabic = 0x0623;
  t.alefhamzaabovefinalarabic = 0xfe84;
  t.alefhamzabelowarabic = 0x0625;
  t.alefhamzabelowfinalarabic = 0xfe88;
  t.alefhebrew = 0x05d0;
  t.aleflamedhebrew = 0xfb4f;
  t.alefmaddaabovearabic = 0x0622;
  t.alefmaddaabovefinalarabic = 0xfe82;
  t.alefmaksuraarabic = 0x0649;
  t.alefmaksurafinalarabic = 0xfef0;
  t.alefmaksurainitialarabic = 0xfef3;
  t.alefmaksuramedialarabic = 0xfef4;
  t.alefpatahhebrew = 0xfb2e;
  t.alefqamatshebrew = 0xfb2f;
  t.aleph = 0x2135;
  t.allequal = 0x224c;
  t.alpha = 0x03b1;
  t.alphatonos = 0x03ac;
  t.amacron = 0x0101;
  t.amonospace = 0xff41;
  t.ampersand = 0x0026;
  t.ampersandmonospace = 0xff06;
  t.ampersandsmall = 0xf726;
  t.amsquare = 0x33c2;
  t.anbopomofo = 0x3122;
  t.angbopomofo = 0x3124;
  t.angbracketleft = 0x3008;
  t.angbracketright = 0x3009;
  t.angkhankhuthai = 0x0e5a;
  t.angle = 0x2220;
  t.anglebracketleft = 0x3008;
  t.anglebracketleftvertical = 0xfe3f;
  t.anglebracketright = 0x3009;
  t.anglebracketrightvertical = 0xfe40;
  t.angleleft = 0x2329;
  t.angleright = 0x232a;
  t.angstrom = 0x212b;
  t.anoteleia = 0x0387;
  t.anudattadeva = 0x0952;
  t.anusvarabengali = 0x0982;
  t.anusvaradeva = 0x0902;
  t.anusvaragujarati = 0x0a82;
  t.aogonek = 0x0105;
  t.apaatosquare = 0x3300;
  t.aparen = 0x249c;
  t.apostrophearmenian = 0x055a;
  t.apostrophemod = 0x02bc;
  t.apple = 0xf8ff;
  t.approaches = 0x2250;
  t.approxequal = 0x2248;
  t.approxequalorimage = 0x2252;
  t.approximatelyequal = 0x2245;
  t.araeaekorean = 0x318e;
  t.araeakorean = 0x318d;
  t.arc = 0x2312;
  t.arighthalfring = 0x1e9a;
  t.aring = 0x00e5;
  t.aringacute = 0x01fb;
  t.aringbelow = 0x1e01;
  t.arrowboth = 0x2194;
  t.arrowdashdown = 0x21e3;
  t.arrowdashleft = 0x21e0;
  t.arrowdashright = 0x21e2;
  t.arrowdashup = 0x21e1;
  t.arrowdblboth = 0x21d4;
  t.arrowdbldown = 0x21d3;
  t.arrowdblleft = 0x21d0;
  t.arrowdblright = 0x21d2;
  t.arrowdblup = 0x21d1;
  t.arrowdown = 0x2193;
  t.arrowdownleft = 0x2199;
  t.arrowdownright = 0x2198;
  t.arrowdownwhite = 0x21e9;
  t.arrowheaddownmod = 0x02c5;
  t.arrowheadleftmod = 0x02c2;
  t.arrowheadrightmod = 0x02c3;
  t.arrowheadupmod = 0x02c4;
  t.arrowhorizex = 0xf8e7;
  t.arrowleft = 0x2190;
  t.arrowleftdbl = 0x21d0;
  t.arrowleftdblstroke = 0x21cd;
  t.arrowleftoverright = 0x21c6;
  t.arrowleftwhite = 0x21e6;
  t.arrowright = 0x2192;
  t.arrowrightdblstroke = 0x21cf;
  t.arrowrightheavy = 0x279e;
  t.arrowrightoverleft = 0x21c4;
  t.arrowrightwhite = 0x21e8;
  t.arrowtableft = 0x21e4;
  t.arrowtabright = 0x21e5;
  t.arrowup = 0x2191;
  t.arrowupdn = 0x2195;
  t.arrowupdnbse = 0x21a8;
  t.arrowupdownbase = 0x21a8;
  t.arrowupleft = 0x2196;
  t.arrowupleftofdown = 0x21c5;
  t.arrowupright = 0x2197;
  t.arrowupwhite = 0x21e7;
  t.arrowvertex = 0xf8e6;
  t.asciicircum = 0x005e;
  t.asciicircummonospace = 0xff3e;
  t.asciitilde = 0x007e;
  t.asciitildemonospace = 0xff5e;
  t.ascript = 0x0251;
  t.ascriptturned = 0x0252;
  t.asmallhiragana = 0x3041;
  t.asmallkatakana = 0x30a1;
  t.asmallkatakanahalfwidth = 0xff67;
  t.asterisk = 0x002a;
  t.asteriskaltonearabic = 0x066d;
  t.asteriskarabic = 0x066d;
  t.asteriskmath = 0x2217;
  t.asteriskmonospace = 0xff0a;
  t.asterisksmall = 0xfe61;
  t.asterism = 0x2042;
  t.asuperior = 0xf6e9;
  t.asymptoticallyequal = 0x2243;
  t.at = 0x0040;
  t.atilde = 0x00e3;
  t.atmonospace = 0xff20;
  t.atsmall = 0xfe6b;
  t.aturned = 0x0250;
  t.aubengali = 0x0994;
  t.aubopomofo = 0x3120;
  t.audeva = 0x0914;
  t.augujarati = 0x0a94;
  t.augurmukhi = 0x0a14;
  t.aulengthmarkbengali = 0x09d7;
  t.aumatragurmukhi = 0x0a4c;
  t.auvowelsignbengali = 0x09cc;
  t.auvowelsigndeva = 0x094c;
  t.auvowelsigngujarati = 0x0acc;
  t.avagrahadeva = 0x093d;
  t.aybarmenian = 0x0561;
  t.ayin = 0x05e2;
  t.ayinaltonehebrew = 0xfb20;
  t.ayinhebrew = 0x05e2;
  t.b = 0x0062;
  t.babengali = 0x09ac;
  t.backslash = 0x005c;
  t.backslashmonospace = 0xff3c;
  t.badeva = 0x092c;
  t.bagujarati = 0x0aac;
  t.bagurmukhi = 0x0a2c;
  t.bahiragana = 0x3070;
  t.bahtthai = 0x0e3f;
  t.bakatakana = 0x30d0;
  t.bar = 0x007c;
  t.barmonospace = 0xff5c;
  t.bbopomofo = 0x3105;
  t.bcircle = 0x24d1;
  t.bdotaccent = 0x1e03;
  t.bdotbelow = 0x1e05;
  t.beamedsixteenthnotes = 0x266c;
  t.because = 0x2235;
  t.becyrillic = 0x0431;
  t.beharabic = 0x0628;
  t.behfinalarabic = 0xfe90;
  t.behinitialarabic = 0xfe91;
  t.behiragana = 0x3079;
  t.behmedialarabic = 0xfe92;
  t.behmeeminitialarabic = 0xfc9f;
  t.behmeemisolatedarabic = 0xfc08;
  t.behnoonfinalarabic = 0xfc6d;
  t.bekatakana = 0x30d9;
  t.benarmenian = 0x0562;
  t.bet = 0x05d1;
  t.beta = 0x03b2;
  t.betasymbolgreek = 0x03d0;
  t.betdagesh = 0xfb31;
  t.betdageshhebrew = 0xfb31;
  t.bethebrew = 0x05d1;
  t.betrafehebrew = 0xfb4c;
  t.bhabengali = 0x09ad;
  t.bhadeva = 0x092d;
  t.bhagujarati = 0x0aad;
  t.bhagurmukhi = 0x0a2d;
  t.bhook = 0x0253;
  t.bihiragana = 0x3073;
  t.bikatakana = 0x30d3;
  t.bilabialclick = 0x0298;
  t.bindigurmukhi = 0x0a02;
  t.birusquare = 0x3331;
  t.blackcircle = 0x25cf;
  t.blackdiamond = 0x25c6;
  t.blackdownpointingtriangle = 0x25bc;
  t.blackleftpointingpointer = 0x25c4;
  t.blackleftpointingtriangle = 0x25c0;
  t.blacklenticularbracketleft = 0x3010;
  t.blacklenticularbracketleftvertical = 0xfe3b;
  t.blacklenticularbracketright = 0x3011;
  t.blacklenticularbracketrightvertical = 0xfe3c;
  t.blacklowerlefttriangle = 0x25e3;
  t.blacklowerrighttriangle = 0x25e2;
  t.blackrectangle = 0x25ac;
  t.blackrightpointingpointer = 0x25ba;
  t.blackrightpointingtriangle = 0x25b6;
  t.blacksmallsquare = 0x25aa;
  t.blacksmilingface = 0x263b;
  t.blacksquare = 0x25a0;
  t.blackstar = 0x2605;
  t.blackupperlefttriangle = 0x25e4;
  t.blackupperrighttriangle = 0x25e5;
  t.blackuppointingsmalltriangle = 0x25b4;
  t.blackuppointingtriangle = 0x25b2;
  t.blank = 0x2423;
  t.blinebelow = 0x1e07;
  t.block = 0x2588;
  t.bmonospace = 0xff42;
  t.bobaimaithai = 0x0e1a;
  t.bohiragana = 0x307c;
  t.bokatakana = 0x30dc;
  t.bparen = 0x249d;
  t.bqsquare = 0x33c3;
  t.braceex = 0xf8f4;
  t.braceleft = 0x007b;
  t.braceleftbt = 0xf8f3;
  t.braceleftmid = 0xf8f2;
  t.braceleftmonospace = 0xff5b;
  t.braceleftsmall = 0xfe5b;
  t.bracelefttp = 0xf8f1;
  t.braceleftvertical = 0xfe37;
  t.braceright = 0x007d;
  t.bracerightbt = 0xf8fe;
  t.bracerightmid = 0xf8fd;
  t.bracerightmonospace = 0xff5d;
  t.bracerightsmall = 0xfe5c;
  t.bracerighttp = 0xf8fc;
  t.bracerightvertical = 0xfe38;
  t.bracketleft = 0x005b;
  t.bracketleftbt = 0xf8f0;
  t.bracketleftex = 0xf8ef;
  t.bracketleftmonospace = 0xff3b;
  t.bracketlefttp = 0xf8ee;
  t.bracketright = 0x005d;
  t.bracketrightbt = 0xf8fb;
  t.bracketrightex = 0xf8fa;
  t.bracketrightmonospace = 0xff3d;
  t.bracketrighttp = 0xf8f9;
  t.breve = 0x02d8;
  t.brevebelowcmb = 0x032e;
  t.brevecmb = 0x0306;
  t.breveinvertedbelowcmb = 0x032f;
  t.breveinvertedcmb = 0x0311;
  t.breveinverteddoublecmb = 0x0361;
  t.bridgebelowcmb = 0x032a;
  t.bridgeinvertedbelowcmb = 0x033a;
  t.brokenbar = 0x00a6;
  t.bstroke = 0x0180;
  t.bsuperior = 0xf6ea;
  t.btopbar = 0x0183;
  t.buhiragana = 0x3076;
  t.bukatakana = 0x30d6;
  t.bullet = 0x2022;
  t.bulletinverse = 0x25d8;
  t.bulletoperator = 0x2219;
  t.bullseye = 0x25ce;
  t.c = 0x0063;
  t.caarmenian = 0x056e;
  t.cabengali = 0x099a;
  t.cacute = 0x0107;
  t.cadeva = 0x091a;
  t.cagujarati = 0x0a9a;
  t.cagurmukhi = 0x0a1a;
  t.calsquare = 0x3388;
  t.candrabindubengali = 0x0981;
  t.candrabinducmb = 0x0310;
  t.candrabindudeva = 0x0901;
  t.candrabindugujarati = 0x0a81;
  t.capslock = 0x21ea;
  t.careof = 0x2105;
  t.caron = 0x02c7;
  t.caronbelowcmb = 0x032c;
  t.caroncmb = 0x030c;
  t.carriagereturn = 0x21b5;
  t.cbopomofo = 0x3118;
  t.ccaron = 0x010d;
  t.ccedilla = 0x00e7;
  t.ccedillaacute = 0x1e09;
  t.ccircle = 0x24d2;
  t.ccircumflex = 0x0109;
  t.ccurl = 0x0255;
  t.cdot = 0x010b;
  t.cdotaccent = 0x010b;
  t.cdsquare = 0x33c5;
  t.cedilla = 0x00b8;
  t.cedillacmb = 0x0327;
  t.cent = 0x00a2;
  t.centigrade = 0x2103;
  t.centinferior = 0xf6df;
  t.centmonospace = 0xffe0;
  t.centoldstyle = 0xf7a2;
  t.centsuperior = 0xf6e0;
  t.chaarmenian = 0x0579;
  t.chabengali = 0x099b;
  t.chadeva = 0x091b;
  t.chagujarati = 0x0a9b;
  t.chagurmukhi = 0x0a1b;
  t.chbopomofo = 0x3114;
  t.cheabkhasiancyrillic = 0x04bd;
  t.checkmark = 0x2713;
  t.checyrillic = 0x0447;
  t.chedescenderabkhasiancyrillic = 0x04bf;
  t.chedescendercyrillic = 0x04b7;
  t.chedieresiscyrillic = 0x04f5;
  t.cheharmenian = 0x0573;
  t.chekhakassiancyrillic = 0x04cc;
  t.cheverticalstrokecyrillic = 0x04b9;
  t.chi = 0x03c7;
  t.chieuchacirclekorean = 0x3277;
  t.chieuchaparenkorean = 0x3217;
  t.chieuchcirclekorean = 0x3269;
  t.chieuchkorean = 0x314a;
  t.chieuchparenkorean = 0x3209;
  t.chochangthai = 0x0e0a;
  t.chochanthai = 0x0e08;
  t.chochingthai = 0x0e09;
  t.chochoethai = 0x0e0c;
  t.chook = 0x0188;
  t.cieucacirclekorean = 0x3276;
  t.cieucaparenkorean = 0x3216;
  t.cieuccirclekorean = 0x3268;
  t.cieuckorean = 0x3148;
  t.cieucparenkorean = 0x3208;
  t.cieucuparenkorean = 0x321c;
  t.circle = 0x25cb;
  t.circlecopyrt = 0x00a9;
  t.circlemultiply = 0x2297;
  t.circleot = 0x2299;
  t.circleplus = 0x2295;
  t.circlepostalmark = 0x3036;
  t.circlewithlefthalfblack = 0x25d0;
  t.circlewithrighthalfblack = 0x25d1;
  t.circumflex = 0x02c6;
  t.circumflexbelowcmb = 0x032d;
  t.circumflexcmb = 0x0302;
  t.clear = 0x2327;
  t.clickalveolar = 0x01c2;
  t.clickdental = 0x01c0;
  t.clicklateral = 0x01c1;
  t.clickretroflex = 0x01c3;
  t.club = 0x2663;
  t.clubsuitblack = 0x2663;
  t.clubsuitwhite = 0x2667;
  t.cmcubedsquare = 0x33a4;
  t.cmonospace = 0xff43;
  t.cmsquaredsquare = 0x33a0;
  t.coarmenian = 0x0581;
  t.colon = 0x003a;
  t.colonmonetary = 0x20a1;
  t.colonmonospace = 0xff1a;
  t.colonsign = 0x20a1;
  t.colonsmall = 0xfe55;
  t.colontriangularhalfmod = 0x02d1;
  t.colontriangularmod = 0x02d0;
  t.comma = 0x002c;
  t.commaabovecmb = 0x0313;
  t.commaaboverightcmb = 0x0315;
  t.commaaccent = 0xf6c3;
  t.commaarabic = 0x060c;
  t.commaarmenian = 0x055d;
  t.commainferior = 0xf6e1;
  t.commamonospace = 0xff0c;
  t.commareversedabovecmb = 0x0314;
  t.commareversedmod = 0x02bd;
  t.commasmall = 0xfe50;
  t.commasuperior = 0xf6e2;
  t.commaturnedabovecmb = 0x0312;
  t.commaturnedmod = 0x02bb;
  t.compass = 0x263c;
  t.congruent = 0x2245;
  t.contourintegral = 0x222e;
  t.control = 0x2303;
  t.controlACK = 0x0006;
  t.controlBEL = 0x0007;
  t.controlBS = 0x0008;
  t.controlCAN = 0x0018;
  t.controlCR = 0x000d;
  t.controlDC1 = 0x0011;
  t.controlDC2 = 0x0012;
  t.controlDC3 = 0x0013;
  t.controlDC4 = 0x0014;
  t.controlDEL = 0x007f;
  t.controlDLE = 0x0010;
  t.controlEM = 0x0019;
  t.controlENQ = 0x0005;
  t.controlEOT = 0x0004;
  t.controlESC = 0x001b;
  t.controlETB = 0x0017;
  t.controlETX = 0x0003;
  t.controlFF = 0x000c;
  t.controlFS = 0x001c;
  t.controlGS = 0x001d;
  t.controlHT = 0x0009;
  t.controlLF = 0x000a;
  t.controlNAK = 0x0015;
  t.controlNULL = 0x0000;
  t.controlRS = 0x001e;
  t.controlSI = 0x000f;
  t.controlSO = 0x000e;
  t.controlSOT = 0x0002;
  t.controlSTX = 0x0001;
  t.controlSUB = 0x001a;
  t.controlSYN = 0x0016;
  t.controlUS = 0x001f;
  t.controlVT = 0x000b;
  t.copyright = 0x00a9;
  t.copyrightsans = 0xf8e9;
  t.copyrightserif = 0xf6d9;
  t.cornerbracketleft = 0x300c;
  t.cornerbracketlefthalfwidth = 0xff62;
  t.cornerbracketleftvertical = 0xfe41;
  t.cornerbracketright = 0x300d;
  t.cornerbracketrighthalfwidth = 0xff63;
  t.cornerbracketrightvertical = 0xfe42;
  t.corporationsquare = 0x337f;
  t.cosquare = 0x33c7;
  t.coverkgsquare = 0x33c6;
  t.cparen = 0x249e;
  t.cruzeiro = 0x20a2;
  t.cstretched = 0x0297;
  t.curlyand = 0x22cf;
  t.curlyor = 0x22ce;
  t.currency = 0x00a4;
  t.cyrBreve = 0xf6d1;
  t.cyrFlex = 0xf6d2;
  t.cyrbreve = 0xf6d4;
  t.cyrflex = 0xf6d5;
  t.d = 0x0064;
  t.daarmenian = 0x0564;
  t.dabengali = 0x09a6;
  t.dadarabic = 0x0636;
  t.dadeva = 0x0926;
  t.dadfinalarabic = 0xfebe;
  t.dadinitialarabic = 0xfebf;
  t.dadmedialarabic = 0xfec0;
  t.dagesh = 0x05bc;
  t.dageshhebrew = 0x05bc;
  t.dagger = 0x2020;
  t.daggerdbl = 0x2021;
  t.dagujarati = 0x0aa6;
  t.dagurmukhi = 0x0a26;
  t.dahiragana = 0x3060;
  t.dakatakana = 0x30c0;
  t.dalarabic = 0x062f;
  t.dalet = 0x05d3;
  t.daletdagesh = 0xfb33;
  t.daletdageshhebrew = 0xfb33;
  t.dalethebrew = 0x05d3;
  t.dalfinalarabic = 0xfeaa;
  t.dammaarabic = 0x064f;
  t.dammalowarabic = 0x064f;
  t.dammatanaltonearabic = 0x064c;
  t.dammatanarabic = 0x064c;
  t.danda = 0x0964;
  t.dargahebrew = 0x05a7;
  t.dargalefthebrew = 0x05a7;
  t.dasiapneumatacyrilliccmb = 0x0485;
  t.dblGrave = 0xf6d3;
  t.dblanglebracketleft = 0x300a;
  t.dblanglebracketleftvertical = 0xfe3d;
  t.dblanglebracketright = 0x300b;
  t.dblanglebracketrightvertical = 0xfe3e;
  t.dblarchinvertedbelowcmb = 0x032b;
  t.dblarrowleft = 0x21d4;
  t.dblarrowright = 0x21d2;
  t.dbldanda = 0x0965;
  t.dblgrave = 0xf6d6;
  t.dblgravecmb = 0x030f;
  t.dblintegral = 0x222c;
  t.dbllowline = 0x2017;
  t.dbllowlinecmb = 0x0333;
  t.dbloverlinecmb = 0x033f;
  t.dblprimemod = 0x02ba;
  t.dblverticalbar = 0x2016;
  t.dblverticallineabovecmb = 0x030e;
  t.dbopomofo = 0x3109;
  t.dbsquare = 0x33c8;
  t.dcaron = 0x010f;
  t.dcedilla = 0x1e11;
  t.dcircle = 0x24d3;
  t.dcircumflexbelow = 0x1e13;
  t.dcroat = 0x0111;
  t.ddabengali = 0x09a1;
  t.ddadeva = 0x0921;
  t.ddagujarati = 0x0aa1;
  t.ddagurmukhi = 0x0a21;
  t.ddalarabic = 0x0688;
  t.ddalfinalarabic = 0xfb89;
  t.dddhadeva = 0x095c;
  t.ddhabengali = 0x09a2;
  t.ddhadeva = 0x0922;
  t.ddhagujarati = 0x0aa2;
  t.ddhagurmukhi = 0x0a22;
  t.ddotaccent = 0x1e0b;
  t.ddotbelow = 0x1e0d;
  t.decimalseparatorarabic = 0x066b;
  t.decimalseparatorpersian = 0x066b;
  t.decyrillic = 0x0434;
  t.degree = 0x00b0;
  t.dehihebrew = 0x05ad;
  t.dehiragana = 0x3067;
  t.deicoptic = 0x03ef;
  t.dekatakana = 0x30c7;
  t.deleteleft = 0x232b;
  t.deleteright = 0x2326;
  t.delta = 0x03b4;
  t.deltaturned = 0x018d;
  t.denominatorminusonenumeratorbengali = 0x09f8;
  t.dezh = 0x02a4;
  t.dhabengali = 0x09a7;
  t.dhadeva = 0x0927;
  t.dhagujarati = 0x0aa7;
  t.dhagurmukhi = 0x0a27;
  t.dhook = 0x0257;
  t.dialytikatonos = 0x0385;
  t.dialytikatonoscmb = 0x0344;
  t.diamond = 0x2666;
  t.diamondsuitwhite = 0x2662;
  t.dieresis = 0x00a8;
  t.dieresisacute = 0xf6d7;
  t.dieresisbelowcmb = 0x0324;
  t.dieresiscmb = 0x0308;
  t.dieresisgrave = 0xf6d8;
  t.dieresistonos = 0x0385;
  t.dihiragana = 0x3062;
  t.dikatakana = 0x30c2;
  t.dittomark = 0x3003;
  t.divide = 0x00f7;
  t.divides = 0x2223;
  t.divisionslash = 0x2215;
  t.djecyrillic = 0x0452;
  t.dkshade = 0x2593;
  t.dlinebelow = 0x1e0f;
  t.dlsquare = 0x3397;
  t.dmacron = 0x0111;
  t.dmonospace = 0xff44;
  t.dnblock = 0x2584;
  t.dochadathai = 0x0e0e;
  t.dodekthai = 0x0e14;
  t.dohiragana = 0x3069;
  t.dokatakana = 0x30c9;
  t.dollar = 0x0024;
  t.dollarinferior = 0xf6e3;
  t.dollarmonospace = 0xff04;
  t.dollaroldstyle = 0xf724;
  t.dollarsmall = 0xfe69;
  t.dollarsuperior = 0xf6e4;
  t.dong = 0x20ab;
  t.dorusquare = 0x3326;
  t.dotaccent = 0x02d9;
  t.dotaccentcmb = 0x0307;
  t.dotbelowcmb = 0x0323;
  t.dotbelowcomb = 0x0323;
  t.dotkatakana = 0x30fb;
  t.dotlessi = 0x0131;
  t.dotlessj = 0xf6be;
  t.dotlessjstrokehook = 0x0284;
  t.dotmath = 0x22c5;
  t.dottedcircle = 0x25cc;
  t.doubleyodpatah = 0xfb1f;
  t.doubleyodpatahhebrew = 0xfb1f;
  t.downtackbelowcmb = 0x031e;
  t.downtackmod = 0x02d5;
  t.dparen = 0x249f;
  t.dsuperior = 0xf6eb;
  t.dtail = 0x0256;
  t.dtopbar = 0x018c;
  t.duhiragana = 0x3065;
  t.dukatakana = 0x30c5;
  t.dz = 0x01f3;
  t.dzaltone = 0x02a3;
  t.dzcaron = 0x01c6;
  t.dzcurl = 0x02a5;
  t.dzeabkhasiancyrillic = 0x04e1;
  t.dzecyrillic = 0x0455;
  t.dzhecyrillic = 0x045f;
  t.e = 0x0065;
  t.eacute = 0x00e9;
  t.earth = 0x2641;
  t.ebengali = 0x098f;
  t.ebopomofo = 0x311c;
  t.ebreve = 0x0115;
  t.ecandradeva = 0x090d;
  t.ecandragujarati = 0x0a8d;
  t.ecandravowelsigndeva = 0x0945;
  t.ecandravowelsigngujarati = 0x0ac5;
  t.ecaron = 0x011b;
  t.ecedillabreve = 0x1e1d;
  t.echarmenian = 0x0565;
  t.echyiwnarmenian = 0x0587;
  t.ecircle = 0x24d4;
  t.ecircumflex = 0x00ea;
  t.ecircumflexacute = 0x1ebf;
  t.ecircumflexbelow = 0x1e19;
  t.ecircumflexdotbelow = 0x1ec7;
  t.ecircumflexgrave = 0x1ec1;
  t.ecircumflexhookabove = 0x1ec3;
  t.ecircumflextilde = 0x1ec5;
  t.ecyrillic = 0x0454;
  t.edblgrave = 0x0205;
  t.edeva = 0x090f;
  t.edieresis = 0x00eb;
  t.edot = 0x0117;
  t.edotaccent = 0x0117;
  t.edotbelow = 0x1eb9;
  t.eegurmukhi = 0x0a0f;
  t.eematragurmukhi = 0x0a47;
  t.efcyrillic = 0x0444;
  t.egrave = 0x00e8;
  t.egujarati = 0x0a8f;
  t.eharmenian = 0x0567;
  t.ehbopomofo = 0x311d;
  t.ehiragana = 0x3048;
  t.ehookabove = 0x1ebb;
  t.eibopomofo = 0x311f;
  t.eight = 0x0038;
  t.eightarabic = 0x0668;
  t.eightbengali = 0x09ee;
  t.eightcircle = 0x2467;
  t.eightcircleinversesansserif = 0x2791;
  t.eightdeva = 0x096e;
  t.eighteencircle = 0x2471;
  t.eighteenparen = 0x2485;
  t.eighteenperiod = 0x2499;
  t.eightgujarati = 0x0aee;
  t.eightgurmukhi = 0x0a6e;
  t.eighthackarabic = 0x0668;
  t.eighthangzhou = 0x3028;
  t.eighthnotebeamed = 0x266b;
  t.eightideographicparen = 0x3227;
  t.eightinferior = 0x2088;
  t.eightmonospace = 0xff18;
  t.eightoldstyle = 0xf738;
  t.eightparen = 0x247b;
  t.eightperiod = 0x248f;
  t.eightpersian = 0x06f8;
  t.eightroman = 0x2177;
  t.eightsuperior = 0x2078;
  t.eightthai = 0x0e58;
  t.einvertedbreve = 0x0207;
  t.eiotifiedcyrillic = 0x0465;
  t.ekatakana = 0x30a8;
  t.ekatakanahalfwidth = 0xff74;
  t.ekonkargurmukhi = 0x0a74;
  t.ekorean = 0x3154;
  t.elcyrillic = 0x043b;
  t.element = 0x2208;
  t.elevencircle = 0x246a;
  t.elevenparen = 0x247e;
  t.elevenperiod = 0x2492;
  t.elevenroman = 0x217a;
  t.ellipsis = 0x2026;
  t.ellipsisvertical = 0x22ee;
  t.emacron = 0x0113;
  t.emacronacute = 0x1e17;
  t.emacrongrave = 0x1e15;
  t.emcyrillic = 0x043c;
  t.emdash = 0x2014;
  t.emdashvertical = 0xfe31;
  t.emonospace = 0xff45;
  t.emphasismarkarmenian = 0x055b;
  t.emptyset = 0x2205;
  t.enbopomofo = 0x3123;
  t.encyrillic = 0x043d;
  t.endash = 0x2013;
  t.endashvertical = 0xfe32;
  t.endescendercyrillic = 0x04a3;
  t.eng = 0x014b;
  t.engbopomofo = 0x3125;
  t.enghecyrillic = 0x04a5;
  t.enhookcyrillic = 0x04c8;
  t.enspace = 0x2002;
  t.eogonek = 0x0119;
  t.eokorean = 0x3153;
  t.eopen = 0x025b;
  t.eopenclosed = 0x029a;
  t.eopenreversed = 0x025c;
  t.eopenreversedclosed = 0x025e;
  t.eopenreversedhook = 0x025d;
  t.eparen = 0x24a0;
  t.epsilon = 0x03b5;
  t.epsilontonos = 0x03ad;
  t.equal = 0x003d;
  t.equalmonospace = 0xff1d;
  t.equalsmall = 0xfe66;
  t.equalsuperior = 0x207c;
  t.equivalence = 0x2261;
  t.erbopomofo = 0x3126;
  t.ercyrillic = 0x0440;
  t.ereversed = 0x0258;
  t.ereversedcyrillic = 0x044d;
  t.escyrillic = 0x0441;
  t.esdescendercyrillic = 0x04ab;
  t.esh = 0x0283;
  t.eshcurl = 0x0286;
  t.eshortdeva = 0x090e;
  t.eshortvowelsigndeva = 0x0946;
  t.eshreversedloop = 0x01aa;
  t.eshsquatreversed = 0x0285;
  t.esmallhiragana = 0x3047;
  t.esmallkatakana = 0x30a7;
  t.esmallkatakanahalfwidth = 0xff6a;
  t.estimated = 0x212e;
  t.esuperior = 0xf6ec;
  t.eta = 0x03b7;
  t.etarmenian = 0x0568;
  t.etatonos = 0x03ae;
  t.eth = 0x00f0;
  t.etilde = 0x1ebd;
  t.etildebelow = 0x1e1b;
  t.etnahtafoukhhebrew = 0x0591;
  t.etnahtafoukhlefthebrew = 0x0591;
  t.etnahtahebrew = 0x0591;
  t.etnahtalefthebrew = 0x0591;
  t.eturned = 0x01dd;
  t.eukorean = 0x3161;
  t.euro = 0x20ac;
  t.evowelsignbengali = 0x09c7;
  t.evowelsigndeva = 0x0947;
  t.evowelsigngujarati = 0x0ac7;
  t.exclam = 0x0021;
  t.exclamarmenian = 0x055c;
  t.exclamdbl = 0x203c;
  t.exclamdown = 0x00a1;
  t.exclamdownsmall = 0xf7a1;
  t.exclammonospace = 0xff01;
  t.exclamsmall = 0xf721;
  t.existential = 0x2203;
  t.ezh = 0x0292;
  t.ezhcaron = 0x01ef;
  t.ezhcurl = 0x0293;
  t.ezhreversed = 0x01b9;
  t.ezhtail = 0x01ba;
  t.f = 0x0066;
  t.fadeva = 0x095e;
  t.fagurmukhi = 0x0a5e;
  t.fahrenheit = 0x2109;
  t.fathaarabic = 0x064e;
  t.fathalowarabic = 0x064e;
  t.fathatanarabic = 0x064b;
  t.fbopomofo = 0x3108;
  t.fcircle = 0x24d5;
  t.fdotaccent = 0x1e1f;
  t.feharabic = 0x0641;
  t.feharmenian = 0x0586;
  t.fehfinalarabic = 0xfed2;
  t.fehinitialarabic = 0xfed3;
  t.fehmedialarabic = 0xfed4;
  t.feicoptic = 0x03e5;
  t.female = 0x2640;
  t.ff = 0xfb00;
  t.f_f = 0xfb00;
  t.ffi = 0xfb03;
  t.f_f_i = 0xfb03;
  t.ffl = 0xfb04;
  t.f_f_l = 0xfb04;
  t.fi = 0xfb01;
  t.f_i = 0xfb01;
  t.fifteencircle = 0x246e;
  t.fifteenparen = 0x2482;
  t.fifteenperiod = 0x2496;
  t.figuredash = 0x2012;
  t.filledbox = 0x25a0;
  t.filledrect = 0x25ac;
  t.finalkaf = 0x05da;
  t.finalkafdagesh = 0xfb3a;
  t.finalkafdageshhebrew = 0xfb3a;
  t.finalkafhebrew = 0x05da;
  t.finalmem = 0x05dd;
  t.finalmemhebrew = 0x05dd;
  t.finalnun = 0x05df;
  t.finalnunhebrew = 0x05df;
  t.finalpe = 0x05e3;
  t.finalpehebrew = 0x05e3;
  t.finaltsadi = 0x05e5;
  t.finaltsadihebrew = 0x05e5;
  t.firsttonechinese = 0x02c9;
  t.fisheye = 0x25c9;
  t.fitacyrillic = 0x0473;
  t.five = 0x0035;
  t.fivearabic = 0x0665;
  t.fivebengali = 0x09eb;
  t.fivecircle = 0x2464;
  t.fivecircleinversesansserif = 0x278e;
  t.fivedeva = 0x096b;
  t.fiveeighths = 0x215d;
  t.fivegujarati = 0x0aeb;
  t.fivegurmukhi = 0x0a6b;
  t.fivehackarabic = 0x0665;
  t.fivehangzhou = 0x3025;
  t.fiveideographicparen = 0x3224;
  t.fiveinferior = 0x2085;
  t.fivemonospace = 0xff15;
  t.fiveoldstyle = 0xf735;
  t.fiveparen = 0x2478;
  t.fiveperiod = 0x248c;
  t.fivepersian = 0x06f5;
  t.fiveroman = 0x2174;
  t.fivesuperior = 0x2075;
  t.fivethai = 0x0e55;
  t.fl = 0xfb02;
  t.f_l = 0xfb02;
  t.florin = 0x0192;
  t.fmonospace = 0xff46;
  t.fmsquare = 0x3399;
  t.fofanthai = 0x0e1f;
  t.fofathai = 0x0e1d;
  t.fongmanthai = 0x0e4f;
  t.forall = 0x2200;
  t.four = 0x0034;
  t.fourarabic = 0x0664;
  t.fourbengali = 0x09ea;
  t.fourcircle = 0x2463;
  t.fourcircleinversesansserif = 0x278d;
  t.fourdeva = 0x096a;
  t.fourgujarati = 0x0aea;
  t.fourgurmukhi = 0x0a6a;
  t.fourhackarabic = 0x0664;
  t.fourhangzhou = 0x3024;
  t.fourideographicparen = 0x3223;
  t.fourinferior = 0x2084;
  t.fourmonospace = 0xff14;
  t.fournumeratorbengali = 0x09f7;
  t.fouroldstyle = 0xf734;
  t.fourparen = 0x2477;
  t.fourperiod = 0x248b;
  t.fourpersian = 0x06f4;
  t.fourroman = 0x2173;
  t.foursuperior = 0x2074;
  t.fourteencircle = 0x246d;
  t.fourteenparen = 0x2481;
  t.fourteenperiod = 0x2495;
  t.fourthai = 0x0e54;
  t.fourthtonechinese = 0x02cb;
  t.fparen = 0x24a1;
  t.fraction = 0x2044;
  t.franc = 0x20a3;
  t.g = 0x0067;
  t.gabengali = 0x0997;
  t.gacute = 0x01f5;
  t.gadeva = 0x0917;
  t.gafarabic = 0x06af;
  t.gaffinalarabic = 0xfb93;
  t.gafinitialarabic = 0xfb94;
  t.gafmedialarabic = 0xfb95;
  t.gagujarati = 0x0a97;
  t.gagurmukhi = 0x0a17;
  t.gahiragana = 0x304c;
  t.gakatakana = 0x30ac;
  t.gamma = 0x03b3;
  t.gammalatinsmall = 0x0263;
  t.gammasuperior = 0x02e0;
  t.gangiacoptic = 0x03eb;
  t.gbopomofo = 0x310d;
  t.gbreve = 0x011f;
  t.gcaron = 0x01e7;
  t.gcedilla = 0x0123;
  t.gcircle = 0x24d6;
  t.gcircumflex = 0x011d;
  t.gcommaaccent = 0x0123;
  t.gdot = 0x0121;
  t.gdotaccent = 0x0121;
  t.gecyrillic = 0x0433;
  t.gehiragana = 0x3052;
  t.gekatakana = 0x30b2;
  t.geometricallyequal = 0x2251;
  t.gereshaccenthebrew = 0x059c;
  t.gereshhebrew = 0x05f3;
  t.gereshmuqdamhebrew = 0x059d;
  t.germandbls = 0x00df;
  t.gershayimaccenthebrew = 0x059e;
  t.gershayimhebrew = 0x05f4;
  t.getamark = 0x3013;
  t.ghabengali = 0x0998;
  t.ghadarmenian = 0x0572;
  t.ghadeva = 0x0918;
  t.ghagujarati = 0x0a98;
  t.ghagurmukhi = 0x0a18;
  t.ghainarabic = 0x063a;
  t.ghainfinalarabic = 0xfece;
  t.ghaininitialarabic = 0xfecf;
  t.ghainmedialarabic = 0xfed0;
  t.ghemiddlehookcyrillic = 0x0495;
  t.ghestrokecyrillic = 0x0493;
  t.gheupturncyrillic = 0x0491;
  t.ghhadeva = 0x095a;
  t.ghhagurmukhi = 0x0a5a;
  t.ghook = 0x0260;
  t.ghzsquare = 0x3393;
  t.gihiragana = 0x304e;
  t.gikatakana = 0x30ae;
  t.gimarmenian = 0x0563;
  t.gimel = 0x05d2;
  t.gimeldagesh = 0xfb32;
  t.gimeldageshhebrew = 0xfb32;
  t.gimelhebrew = 0x05d2;
  t.gjecyrillic = 0x0453;
  t.glottalinvertedstroke = 0x01be;
  t.glottalstop = 0x0294;
  t.glottalstopinverted = 0x0296;
  t.glottalstopmod = 0x02c0;
  t.glottalstopreversed = 0x0295;
  t.glottalstopreversedmod = 0x02c1;
  t.glottalstopreversedsuperior = 0x02e4;
  t.glottalstopstroke = 0x02a1;
  t.glottalstopstrokereversed = 0x02a2;
  t.gmacron = 0x1e21;
  t.gmonospace = 0xff47;
  t.gohiragana = 0x3054;
  t.gokatakana = 0x30b4;
  t.gparen = 0x24a2;
  t.gpasquare = 0x33ac;
  t.gradient = 0x2207;
  t.grave = 0x0060;
  t.gravebelowcmb = 0x0316;
  t.gravecmb = 0x0300;
  t.gravecomb = 0x0300;
  t.gravedeva = 0x0953;
  t.gravelowmod = 0x02ce;
  t.gravemonospace = 0xff40;
  t.gravetonecmb = 0x0340;
  t.greater = 0x003e;
  t.greaterequal = 0x2265;
  t.greaterequalorless = 0x22db;
  t.greatermonospace = 0xff1e;
  t.greaterorequivalent = 0x2273;
  t.greaterorless = 0x2277;
  t.greateroverequal = 0x2267;
  t.greatersmall = 0xfe65;
  t.gscript = 0x0261;
  t.gstroke = 0x01e5;
  t.guhiragana = 0x3050;
  t.guillemotleft = 0x00ab;
  t.guillemotright = 0x00bb;
  t.guilsinglleft = 0x2039;
  t.guilsinglright = 0x203a;
  t.gukatakana = 0x30b0;
  t.guramusquare = 0x3318;
  t.gysquare = 0x33c9;
  t.h = 0x0068;
  t.haabkhasiancyrillic = 0x04a9;
  t.haaltonearabic = 0x06c1;
  t.habengali = 0x09b9;
  t.hadescendercyrillic = 0x04b3;
  t.hadeva = 0x0939;
  t.hagujarati = 0x0ab9;
  t.hagurmukhi = 0x0a39;
  t.haharabic = 0x062d;
  t.hahfinalarabic = 0xfea2;
  t.hahinitialarabic = 0xfea3;
  t.hahiragana = 0x306f;
  t.hahmedialarabic = 0xfea4;
  t.haitusquare = 0x332a;
  t.hakatakana = 0x30cf;
  t.hakatakanahalfwidth = 0xff8a;
  t.halantgurmukhi = 0x0a4d;
  t.hamzaarabic = 0x0621;
  t.hamzalowarabic = 0x0621;
  t.hangulfiller = 0x3164;
  t.hardsigncyrillic = 0x044a;
  t.harpoonleftbarbup = 0x21bc;
  t.harpoonrightbarbup = 0x21c0;
  t.hasquare = 0x33ca;
  t.hatafpatah = 0x05b2;
  t.hatafpatah16 = 0x05b2;
  t.hatafpatah23 = 0x05b2;
  t.hatafpatah2f = 0x05b2;
  t.hatafpatahhebrew = 0x05b2;
  t.hatafpatahnarrowhebrew = 0x05b2;
  t.hatafpatahquarterhebrew = 0x05b2;
  t.hatafpatahwidehebrew = 0x05b2;
  t.hatafqamats = 0x05b3;
  t.hatafqamats1b = 0x05b3;
  t.hatafqamats28 = 0x05b3;
  t.hatafqamats34 = 0x05b3;
  t.hatafqamatshebrew = 0x05b3;
  t.hatafqamatsnarrowhebrew = 0x05b3;
  t.hatafqamatsquarterhebrew = 0x05b3;
  t.hatafqamatswidehebrew = 0x05b3;
  t.hatafsegol = 0x05b1;
  t.hatafsegol17 = 0x05b1;
  t.hatafsegol24 = 0x05b1;
  t.hatafsegol30 = 0x05b1;
  t.hatafsegolhebrew = 0x05b1;
  t.hatafsegolnarrowhebrew = 0x05b1;
  t.hatafsegolquarterhebrew = 0x05b1;
  t.hatafsegolwidehebrew = 0x05b1;
  t.hbar = 0x0127;
  t.hbopomofo = 0x310f;
  t.hbrevebelow = 0x1e2b;
  t.hcedilla = 0x1e29;
  t.hcircle = 0x24d7;
  t.hcircumflex = 0x0125;
  t.hdieresis = 0x1e27;
  t.hdotaccent = 0x1e23;
  t.hdotbelow = 0x1e25;
  t.he = 0x05d4;
  t.heart = 0x2665;
  t.heartsuitblack = 0x2665;
  t.heartsuitwhite = 0x2661;
  t.hedagesh = 0xfb34;
  t.hedageshhebrew = 0xfb34;
  t.hehaltonearabic = 0x06c1;
  t.heharabic = 0x0647;
  t.hehebrew = 0x05d4;
  t.hehfinalaltonearabic = 0xfba7;
  t.hehfinalalttwoarabic = 0xfeea;
  t.hehfinalarabic = 0xfeea;
  t.hehhamzaabovefinalarabic = 0xfba5;
  t.hehhamzaaboveisolatedarabic = 0xfba4;
  t.hehinitialaltonearabic = 0xfba8;
  t.hehinitialarabic = 0xfeeb;
  t.hehiragana = 0x3078;
  t.hehmedialaltonearabic = 0xfba9;
  t.hehmedialarabic = 0xfeec;
  t.heiseierasquare = 0x337b;
  t.hekatakana = 0x30d8;
  t.hekatakanahalfwidth = 0xff8d;
  t.hekutaarusquare = 0x3336;
  t.henghook = 0x0267;
  t.herutusquare = 0x3339;
  t.het = 0x05d7;
  t.hethebrew = 0x05d7;
  t.hhook = 0x0266;
  t.hhooksuperior = 0x02b1;
  t.hieuhacirclekorean = 0x327b;
  t.hieuhaparenkorean = 0x321b;
  t.hieuhcirclekorean = 0x326d;
  t.hieuhkorean = 0x314e;
  t.hieuhparenkorean = 0x320d;
  t.hihiragana = 0x3072;
  t.hikatakana = 0x30d2;
  t.hikatakanahalfwidth = 0xff8b;
  t.hiriq = 0x05b4;
  t.hiriq14 = 0x05b4;
  t.hiriq21 = 0x05b4;
  t.hiriq2d = 0x05b4;
  t.hiriqhebrew = 0x05b4;
  t.hiriqnarrowhebrew = 0x05b4;
  t.hiriqquarterhebrew = 0x05b4;
  t.hiriqwidehebrew = 0x05b4;
  t.hlinebelow = 0x1e96;
  t.hmonospace = 0xff48;
  t.hoarmenian = 0x0570;
  t.hohipthai = 0x0e2b;
  t.hohiragana = 0x307b;
  t.hokatakana = 0x30db;
  t.hokatakanahalfwidth = 0xff8e;
  t.holam = 0x05b9;
  t.holam19 = 0x05b9;
  t.holam26 = 0x05b9;
  t.holam32 = 0x05b9;
  t.holamhebrew = 0x05b9;
  t.holamnarrowhebrew = 0x05b9;
  t.holamquarterhebrew = 0x05b9;
  t.holamwidehebrew = 0x05b9;
  t.honokhukthai = 0x0e2e;
  t.hookabovecomb = 0x0309;
  t.hookcmb = 0x0309;
  t.hookpalatalizedbelowcmb = 0x0321;
  t.hookretroflexbelowcmb = 0x0322;
  t.hoonsquare = 0x3342;
  t.horicoptic = 0x03e9;
  t.horizontalbar = 0x2015;
  t.horncmb = 0x031b;
  t.hotsprings = 0x2668;
  t.house = 0x2302;
  t.hparen = 0x24a3;
  t.hsuperior = 0x02b0;
  t.hturned = 0x0265;
  t.huhiragana = 0x3075;
  t.huiitosquare = 0x3333;
  t.hukatakana = 0x30d5;
  t.hukatakanahalfwidth = 0xff8c;
  t.hungarumlaut = 0x02dd;
  t.hungarumlautcmb = 0x030b;
  t.hv = 0x0195;
  t.hyphen = 0x002d;
  t.hypheninferior = 0xf6e5;
  t.hyphenmonospace = 0xff0d;
  t.hyphensmall = 0xfe63;
  t.hyphensuperior = 0xf6e6;
  t.hyphentwo = 0x2010;
  t.i = 0x0069;
  t.iacute = 0x00ed;
  t.iacyrillic = 0x044f;
  t.ibengali = 0x0987;
  t.ibopomofo = 0x3127;
  t.ibreve = 0x012d;
  t.icaron = 0x01d0;
  t.icircle = 0x24d8;
  t.icircumflex = 0x00ee;
  t.icyrillic = 0x0456;
  t.idblgrave = 0x0209;
  t.ideographearthcircle = 0x328f;
  t.ideographfirecircle = 0x328b;
  t.ideographicallianceparen = 0x323f;
  t.ideographiccallparen = 0x323a;
  t.ideographiccentrecircle = 0x32a5;
  t.ideographicclose = 0x3006;
  t.ideographiccomma = 0x3001;
  t.ideographiccommaleft = 0xff64;
  t.ideographiccongratulationparen = 0x3237;
  t.ideographiccorrectcircle = 0x32a3;
  t.ideographicearthparen = 0x322f;
  t.ideographicenterpriseparen = 0x323d;
  t.ideographicexcellentcircle = 0x329d;
  t.ideographicfestivalparen = 0x3240;
  t.ideographicfinancialcircle = 0x3296;
  t.ideographicfinancialparen = 0x3236;
  t.ideographicfireparen = 0x322b;
  t.ideographichaveparen = 0x3232;
  t.ideographichighcircle = 0x32a4;
  t.ideographiciterationmark = 0x3005;
  t.ideographiclaborcircle = 0x3298;
  t.ideographiclaborparen = 0x3238;
  t.ideographicleftcircle = 0x32a7;
  t.ideographiclowcircle = 0x32a6;
  t.ideographicmedicinecircle = 0x32a9;
  t.ideographicmetalparen = 0x322e;
  t.ideographicmoonparen = 0x322a;
  t.ideographicnameparen = 0x3234;
  t.ideographicperiod = 0x3002;
  t.ideographicprintcircle = 0x329e;
  t.ideographicreachparen = 0x3243;
  t.ideographicrepresentparen = 0x3239;
  t.ideographicresourceparen = 0x323e;
  t.ideographicrightcircle = 0x32a8;
  t.ideographicsecretcircle = 0x3299;
  t.ideographicselfparen = 0x3242;
  t.ideographicsocietyparen = 0x3233;
  t.ideographicspace = 0x3000;
  t.ideographicspecialparen = 0x3235;
  t.ideographicstockparen = 0x3231;
  t.ideographicstudyparen = 0x323b;
  t.ideographicsunparen = 0x3230;
  t.ideographicsuperviseparen = 0x323c;
  t.ideographicwaterparen = 0x322c;
  t.ideographicwoodparen = 0x322d;
  t.ideographiczero = 0x3007;
  t.ideographmetalcircle = 0x328e;
  t.ideographmooncircle = 0x328a;
  t.ideographnamecircle = 0x3294;
  t.ideographsuncircle = 0x3290;
  t.ideographwatercircle = 0x328c;
  t.ideographwoodcircle = 0x328d;
  t.ideva = 0x0907;
  t.idieresis = 0x00ef;
  t.idieresisacute = 0x1e2f;
  t.idieresiscyrillic = 0x04e5;
  t.idotbelow = 0x1ecb;
  t.iebrevecyrillic = 0x04d7;
  t.iecyrillic = 0x0435;
  t.ieungacirclekorean = 0x3275;
  t.ieungaparenkorean = 0x3215;
  t.ieungcirclekorean = 0x3267;
  t.ieungkorean = 0x3147;
  t.ieungparenkorean = 0x3207;
  t.igrave = 0x00ec;
  t.igujarati = 0x0a87;
  t.igurmukhi = 0x0a07;
  t.ihiragana = 0x3044;
  t.ihookabove = 0x1ec9;
  t.iibengali = 0x0988;
  t.iicyrillic = 0x0438;
  t.iideva = 0x0908;
  t.iigujarati = 0x0a88;
  t.iigurmukhi = 0x0a08;
  t.iimatragurmukhi = 0x0a40;
  t.iinvertedbreve = 0x020b;
  t.iishortcyrillic = 0x0439;
  t.iivowelsignbengali = 0x09c0;
  t.iivowelsigndeva = 0x0940;
  t.iivowelsigngujarati = 0x0ac0;
  t.ij = 0x0133;
  t.ikatakana = 0x30a4;
  t.ikatakanahalfwidth = 0xff72;
  t.ikorean = 0x3163;
  t.ilde = 0x02dc;
  t.iluyhebrew = 0x05ac;
  t.imacron = 0x012b;
  t.imacroncyrillic = 0x04e3;
  t.imageorapproximatelyequal = 0x2253;
  t.imatragurmukhi = 0x0a3f;
  t.imonospace = 0xff49;
  t.increment = 0x2206;
  t.infinity = 0x221e;
  t.iniarmenian = 0x056b;
  t.integral = 0x222b;
  t.integralbottom = 0x2321;
  t.integralbt = 0x2321;
  t.integralex = 0xf8f5;
  t.integraltop = 0x2320;
  t.integraltp = 0x2320;
  t.intersection = 0x2229;
  t.intisquare = 0x3305;
  t.invbullet = 0x25d8;
  t.invcircle = 0x25d9;
  t.invsmileface = 0x263b;
  t.iocyrillic = 0x0451;
  t.iogonek = 0x012f;
  t.iota = 0x03b9;
  t.iotadieresis = 0x03ca;
  t.iotadieresistonos = 0x0390;
  t.iotalatin = 0x0269;
  t.iotatonos = 0x03af;
  t.iparen = 0x24a4;
  t.irigurmukhi = 0x0a72;
  t.ismallhiragana = 0x3043;
  t.ismallkatakana = 0x30a3;
  t.ismallkatakanahalfwidth = 0xff68;
  t.issharbengali = 0x09fa;
  t.istroke = 0x0268;
  t.isuperior = 0xf6ed;
  t.iterationhiragana = 0x309d;
  t.iterationkatakana = 0x30fd;
  t.itilde = 0x0129;
  t.itildebelow = 0x1e2d;
  t.iubopomofo = 0x3129;
  t.iucyrillic = 0x044e;
  t.ivowelsignbengali = 0x09bf;
  t.ivowelsigndeva = 0x093f;
  t.ivowelsigngujarati = 0x0abf;
  t.izhitsacyrillic = 0x0475;
  t.izhitsadblgravecyrillic = 0x0477;
  t.j = 0x006a;
  t.jaarmenian = 0x0571;
  t.jabengali = 0x099c;
  t.jadeva = 0x091c;
  t.jagujarati = 0x0a9c;
  t.jagurmukhi = 0x0a1c;
  t.jbopomofo = 0x3110;
  t.jcaron = 0x01f0;
  t.jcircle = 0x24d9;
  t.jcircumflex = 0x0135;
  t.jcrossedtail = 0x029d;
  t.jdotlessstroke = 0x025f;
  t.jecyrillic = 0x0458;
  t.jeemarabic = 0x062c;
  t.jeemfinalarabic = 0xfe9e;
  t.jeeminitialarabic = 0xfe9f;
  t.jeemmedialarabic = 0xfea0;
  t.jeharabic = 0x0698;
  t.jehfinalarabic = 0xfb8b;
  t.jhabengali = 0x099d;
  t.jhadeva = 0x091d;
  t.jhagujarati = 0x0a9d;
  t.jhagurmukhi = 0x0a1d;
  t.jheharmenian = 0x057b;
  t.jis = 0x3004;
  t.jmonospace = 0xff4a;
  t.jparen = 0x24a5;
  t.jsuperior = 0x02b2;
  t.k = 0x006b;
  t.kabashkircyrillic = 0x04a1;
  t.kabengali = 0x0995;
  t.kacute = 0x1e31;
  t.kacyrillic = 0x043a;
  t.kadescendercyrillic = 0x049b;
  t.kadeva = 0x0915;
  t.kaf = 0x05db;
  t.kafarabic = 0x0643;
  t.kafdagesh = 0xfb3b;
  t.kafdageshhebrew = 0xfb3b;
  t.kaffinalarabic = 0xfeda;
  t.kafhebrew = 0x05db;
  t.kafinitialarabic = 0xfedb;
  t.kafmedialarabic = 0xfedc;
  t.kafrafehebrew = 0xfb4d;
  t.kagujarati = 0x0a95;
  t.kagurmukhi = 0x0a15;
  t.kahiragana = 0x304b;
  t.kahookcyrillic = 0x04c4;
  t.kakatakana = 0x30ab;
  t.kakatakanahalfwidth = 0xff76;
  t.kappa = 0x03ba;
  t.kappasymbolgreek = 0x03f0;
  t.kapyeounmieumkorean = 0x3171;
  t.kapyeounphieuphkorean = 0x3184;
  t.kapyeounpieupkorean = 0x3178;
  t.kapyeounssangpieupkorean = 0x3179;
  t.karoriisquare = 0x330d;
  t.kashidaautoarabic = 0x0640;
  t.kashidaautonosidebearingarabic = 0x0640;
  t.kasmallkatakana = 0x30f5;
  t.kasquare = 0x3384;
  t.kasraarabic = 0x0650;
  t.kasratanarabic = 0x064d;
  t.kastrokecyrillic = 0x049f;
  t.katahiraprolongmarkhalfwidth = 0xff70;
  t.kaverticalstrokecyrillic = 0x049d;
  t.kbopomofo = 0x310e;
  t.kcalsquare = 0x3389;
  t.kcaron = 0x01e9;
  t.kcedilla = 0x0137;
  t.kcircle = 0x24da;
  t.kcommaaccent = 0x0137;
  t.kdotbelow = 0x1e33;
  t.keharmenian = 0x0584;
  t.kehiragana = 0x3051;
  t.kekatakana = 0x30b1;
  t.kekatakanahalfwidth = 0xff79;
  t.kenarmenian = 0x056f;
  t.kesmallkatakana = 0x30f6;
  t.kgreenlandic = 0x0138;
  t.khabengali = 0x0996;
  t.khacyrillic = 0x0445;
  t.khadeva = 0x0916;
  t.khagujarati = 0x0a96;
  t.khagurmukhi = 0x0a16;
  t.khaharabic = 0x062e;
  t.khahfinalarabic = 0xfea6;
  t.khahinitialarabic = 0xfea7;
  t.khahmedialarabic = 0xfea8;
  t.kheicoptic = 0x03e7;
  t.khhadeva = 0x0959;
  t.khhagurmukhi = 0x0a59;
  t.khieukhacirclekorean = 0x3278;
  t.khieukhaparenkorean = 0x3218;
  t.khieukhcirclekorean = 0x326a;
  t.khieukhkorean = 0x314b;
  t.khieukhparenkorean = 0x320a;
  t.khokhaithai = 0x0e02;
  t.khokhonthai = 0x0e05;
  t.khokhuatthai = 0x0e03;
  t.khokhwaithai = 0x0e04;
  t.khomutthai = 0x0e5b;
  t.khook = 0x0199;
  t.khorakhangthai = 0x0e06;
  t.khzsquare = 0x3391;
  t.kihiragana = 0x304d;
  t.kikatakana = 0x30ad;
  t.kikatakanahalfwidth = 0xff77;
  t.kiroguramusquare = 0x3315;
  t.kiromeetorusquare = 0x3316;
  t.kirosquare = 0x3314;
  t.kiyeokacirclekorean = 0x326e;
  t.kiyeokaparenkorean = 0x320e;
  t.kiyeokcirclekorean = 0x3260;
  t.kiyeokkorean = 0x3131;
  t.kiyeokparenkorean = 0x3200;
  t.kiyeoksioskorean = 0x3133;
  t.kjecyrillic = 0x045c;
  t.klinebelow = 0x1e35;
  t.klsquare = 0x3398;
  t.kmcubedsquare = 0x33a6;
  t.kmonospace = 0xff4b;
  t.kmsquaredsquare = 0x33a2;
  t.kohiragana = 0x3053;
  t.kohmsquare = 0x33c0;
  t.kokaithai = 0x0e01;
  t.kokatakana = 0x30b3;
  t.kokatakanahalfwidth = 0xff7a;
  t.kooposquare = 0x331e;
  t.koppacyrillic = 0x0481;
  t.koreanstandardsymbol = 0x327f;
  t.koroniscmb = 0x0343;
  t.kparen = 0x24a6;
  t.kpasquare = 0x33aa;
  t.ksicyrillic = 0x046f;
  t.ktsquare = 0x33cf;
  t.kturned = 0x029e;
  t.kuhiragana = 0x304f;
  t.kukatakana = 0x30af;
  t.kukatakanahalfwidth = 0xff78;
  t.kvsquare = 0x33b8;
  t.kwsquare = 0x33be;
  t.l = 0x006c;
  t.labengali = 0x09b2;
  t.lacute = 0x013a;
  t.ladeva = 0x0932;
  t.lagujarati = 0x0ab2;
  t.lagurmukhi = 0x0a32;
  t.lakkhangyaothai = 0x0e45;
  t.lamaleffinalarabic = 0xfefc;
  t.lamalefhamzaabovefinalarabic = 0xfef8;
  t.lamalefhamzaaboveisolatedarabic = 0xfef7;
  t.lamalefhamzabelowfinalarabic = 0xfefa;
  t.lamalefhamzabelowisolatedarabic = 0xfef9;
  t.lamalefisolatedarabic = 0xfefb;
  t.lamalefmaddaabovefinalarabic = 0xfef6;
  t.lamalefmaddaaboveisolatedarabic = 0xfef5;
  t.lamarabic = 0x0644;
  t.lambda = 0x03bb;
  t.lambdastroke = 0x019b;
  t.lamed = 0x05dc;
  t.lameddagesh = 0xfb3c;
  t.lameddageshhebrew = 0xfb3c;
  t.lamedhebrew = 0x05dc;
  t.lamfinalarabic = 0xfede;
  t.lamhahinitialarabic = 0xfcca;
  t.laminitialarabic = 0xfedf;
  t.lamjeeminitialarabic = 0xfcc9;
  t.lamkhahinitialarabic = 0xfccb;
  t.lamlamhehisolatedarabic = 0xfdf2;
  t.lammedialarabic = 0xfee0;
  t.lammeemhahinitialarabic = 0xfd88;
  t.lammeeminitialarabic = 0xfccc;
  t.largecircle = 0x25ef;
  t.lbar = 0x019a;
  t.lbelt = 0x026c;
  t.lbopomofo = 0x310c;
  t.lcaron = 0x013e;
  t.lcedilla = 0x013c;
  t.lcircle = 0x24db;
  t.lcircumflexbelow = 0x1e3d;
  t.lcommaaccent = 0x013c;
  t.ldot = 0x0140;
  t.ldotaccent = 0x0140;
  t.ldotbelow = 0x1e37;
  t.ldotbelowmacron = 0x1e39;
  t.leftangleabovecmb = 0x031a;
  t.lefttackbelowcmb = 0x0318;
  t.less = 0x003c;
  t.lessequal = 0x2264;
  t.lessequalorgreater = 0x22da;
  t.lessmonospace = 0xff1c;
  t.lessorequivalent = 0x2272;
  t.lessorgreater = 0x2276;
  t.lessoverequal = 0x2266;
  t.lesssmall = 0xfe64;
  t.lezh = 0x026e;
  t.lfblock = 0x258c;
  t.lhookretroflex = 0x026d;
  t.lira = 0x20a4;
  t.liwnarmenian = 0x056c;
  t.lj = 0x01c9;
  t.ljecyrillic = 0x0459;
  t.ll = 0xf6c0;
  t.lladeva = 0x0933;
  t.llagujarati = 0x0ab3;
  t.llinebelow = 0x1e3b;
  t.llladeva = 0x0934;
  t.llvocalicbengali = 0x09e1;
  t.llvocalicdeva = 0x0961;
  t.llvocalicvowelsignbengali = 0x09e3;
  t.llvocalicvowelsigndeva = 0x0963;
  t.lmiddletilde = 0x026b;
  t.lmonospace = 0xff4c;
  t.lmsquare = 0x33d0;
  t.lochulathai = 0x0e2c;
  t.logicaland = 0x2227;
  t.logicalnot = 0x00ac;
  t.logicalnotreversed = 0x2310;
  t.logicalor = 0x2228;
  t.lolingthai = 0x0e25;
  t.longs = 0x017f;
  t.lowlinecenterline = 0xfe4e;
  t.lowlinecmb = 0x0332;
  t.lowlinedashed = 0xfe4d;
  t.lozenge = 0x25ca;
  t.lparen = 0x24a7;
  t.lslash = 0x0142;
  t.lsquare = 0x2113;
  t.lsuperior = 0xf6ee;
  t.ltshade = 0x2591;
  t.luthai = 0x0e26;
  t.lvocalicbengali = 0x098c;
  t.lvocalicdeva = 0x090c;
  t.lvocalicvowelsignbengali = 0x09e2;
  t.lvocalicvowelsigndeva = 0x0962;
  t.lxsquare = 0x33d3;
  t.m = 0x006d;
  t.mabengali = 0x09ae;
  t.macron = 0x00af;
  t.macronbelowcmb = 0x0331;
  t.macroncmb = 0x0304;
  t.macronlowmod = 0x02cd;
  t.macronmonospace = 0xffe3;
  t.macute = 0x1e3f;
  t.madeva = 0x092e;
  t.magujarati = 0x0aae;
  t.magurmukhi = 0x0a2e;
  t.mahapakhhebrew = 0x05a4;
  t.mahapakhlefthebrew = 0x05a4;
  t.mahiragana = 0x307e;
  t.maichattawalowleftthai = 0xf895;
  t.maichattawalowrightthai = 0xf894;
  t.maichattawathai = 0x0e4b;
  t.maichattawaupperleftthai = 0xf893;
  t.maieklowleftthai = 0xf88c;
  t.maieklowrightthai = 0xf88b;
  t.maiekthai = 0x0e48;
  t.maiekupperleftthai = 0xf88a;
  t.maihanakatleftthai = 0xf884;
  t.maihanakatthai = 0x0e31;
  t.maitaikhuleftthai = 0xf889;
  t.maitaikhuthai = 0x0e47;
  t.maitholowleftthai = 0xf88f;
  t.maitholowrightthai = 0xf88e;
  t.maithothai = 0x0e49;
  t.maithoupperleftthai = 0xf88d;
  t.maitrilowleftthai = 0xf892;
  t.maitrilowrightthai = 0xf891;
  t.maitrithai = 0x0e4a;
  t.maitriupperleftthai = 0xf890;
  t.maiyamokthai = 0x0e46;
  t.makatakana = 0x30de;
  t.makatakanahalfwidth = 0xff8f;
  t.male = 0x2642;
  t.mansyonsquare = 0x3347;
  t.maqafhebrew = 0x05be;
  t.mars = 0x2642;
  t.masoracirclehebrew = 0x05af;
  t.masquare = 0x3383;
  t.mbopomofo = 0x3107;
  t.mbsquare = 0x33d4;
  t.mcircle = 0x24dc;
  t.mcubedsquare = 0x33a5;
  t.mdotaccent = 0x1e41;
  t.mdotbelow = 0x1e43;
  t.meemarabic = 0x0645;
  t.meemfinalarabic = 0xfee2;
  t.meeminitialarabic = 0xfee3;
  t.meemmedialarabic = 0xfee4;
  t.meemmeeminitialarabic = 0xfcd1;
  t.meemmeemisolatedarabic = 0xfc48;
  t.meetorusquare = 0x334d;
  t.mehiragana = 0x3081;
  t.meizierasquare = 0x337e;
  t.mekatakana = 0x30e1;
  t.mekatakanahalfwidth = 0xff92;
  t.mem = 0x05de;
  t.memdagesh = 0xfb3e;
  t.memdageshhebrew = 0xfb3e;
  t.memhebrew = 0x05de;
  t.menarmenian = 0x0574;
  t.merkhahebrew = 0x05a5;
  t.merkhakefulahebrew = 0x05a6;
  t.merkhakefulalefthebrew = 0x05a6;
  t.merkhalefthebrew = 0x05a5;
  t.mhook = 0x0271;
  t.mhzsquare = 0x3392;
  t.middledotkatakanahalfwidth = 0xff65;
  t.middot = 0x00b7;
  t.mieumacirclekorean = 0x3272;
  t.mieumaparenkorean = 0x3212;
  t.mieumcirclekorean = 0x3264;
  t.mieumkorean = 0x3141;
  t.mieumpansioskorean = 0x3170;
  t.mieumparenkorean = 0x3204;
  t.mieumpieupkorean = 0x316e;
  t.mieumsioskorean = 0x316f;
  t.mihiragana = 0x307f;
  t.mikatakana = 0x30df;
  t.mikatakanahalfwidth = 0xff90;
  t.minus = 0x2212;
  t.minusbelowcmb = 0x0320;
  t.minuscircle = 0x2296;
  t.minusmod = 0x02d7;
  t.minusplus = 0x2213;
  t.minute = 0x2032;
  t.miribaarusquare = 0x334a;
  t.mirisquare = 0x3349;
  t.mlonglegturned = 0x0270;
  t.mlsquare = 0x3396;
  t.mmcubedsquare = 0x33a3;
  t.mmonospace = 0xff4d;
  t.mmsquaredsquare = 0x339f;
  t.mohiragana = 0x3082;
  t.mohmsquare = 0x33c1;
  t.mokatakana = 0x30e2;
  t.mokatakanahalfwidth = 0xff93;
  t.molsquare = 0x33d6;
  t.momathai = 0x0e21;
  t.moverssquare = 0x33a7;
  t.moverssquaredsquare = 0x33a8;
  t.mparen = 0x24a8;
  t.mpasquare = 0x33ab;
  t.mssquare = 0x33b3;
  t.msuperior = 0xf6ef;
  t.mturned = 0x026f;
  t.mu = 0x00b5;
  t.mu1 = 0x00b5;
  t.muasquare = 0x3382;
  t.muchgreater = 0x226b;
  t.muchless = 0x226a;
  t.mufsquare = 0x338c;
  t.mugreek = 0x03bc;
  t.mugsquare = 0x338d;
  t.muhiragana = 0x3080;
  t.mukatakana = 0x30e0;
  t.mukatakanahalfwidth = 0xff91;
  t.mulsquare = 0x3395;
  t.multiply = 0x00d7;
  t.mumsquare = 0x339b;
  t.munahhebrew = 0x05a3;
  t.munahlefthebrew = 0x05a3;
  t.musicalnote = 0x266a;
  t.musicalnotedbl = 0x266b;
  t.musicflatsign = 0x266d;
  t.musicsharpsign = 0x266f;
  t.mussquare = 0x33b2;
  t.muvsquare = 0x33b6;
  t.muwsquare = 0x33bc;
  t.mvmegasquare = 0x33b9;
  t.mvsquare = 0x33b7;
  t.mwmegasquare = 0x33bf;
  t.mwsquare = 0x33bd;
  t.n = 0x006e;
  t.nabengali = 0x09a8;
  t.nabla = 0x2207;
  t.nacute = 0x0144;
  t.nadeva = 0x0928;
  t.nagujarati = 0x0aa8;
  t.nagurmukhi = 0x0a28;
  t.nahiragana = 0x306a;
  t.nakatakana = 0x30ca;
  t.nakatakanahalfwidth = 0xff85;
  t.napostrophe = 0x0149;
  t.nasquare = 0x3381;
  t.nbopomofo = 0x310b;
  t.nbspace = 0x00a0;
  t.ncaron = 0x0148;
  t.ncedilla = 0x0146;
  t.ncircle = 0x24dd;
  t.ncircumflexbelow = 0x1e4b;
  t.ncommaaccent = 0x0146;
  t.ndotaccent = 0x1e45;
  t.ndotbelow = 0x1e47;
  t.nehiragana = 0x306d;
  t.nekatakana = 0x30cd;
  t.nekatakanahalfwidth = 0xff88;
  t.newsheqelsign = 0x20aa;
  t.nfsquare = 0x338b;
  t.ngabengali = 0x0999;
  t.ngadeva = 0x0919;
  t.ngagujarati = 0x0a99;
  t.ngagurmukhi = 0x0a19;
  t.ngonguthai = 0x0e07;
  t.nhiragana = 0x3093;
  t.nhookleft = 0x0272;
  t.nhookretroflex = 0x0273;
  t.nieunacirclekorean = 0x326f;
  t.nieunaparenkorean = 0x320f;
  t.nieuncieuckorean = 0x3135;
  t.nieuncirclekorean = 0x3261;
  t.nieunhieuhkorean = 0x3136;
  t.nieunkorean = 0x3134;
  t.nieunpansioskorean = 0x3168;
  t.nieunparenkorean = 0x3201;
  t.nieunsioskorean = 0x3167;
  t.nieuntikeutkorean = 0x3166;
  t.nihiragana = 0x306b;
  t.nikatakana = 0x30cb;
  t.nikatakanahalfwidth = 0xff86;
  t.nikhahitleftthai = 0xf899;
  t.nikhahitthai = 0x0e4d;
  t.nine = 0x0039;
  t.ninearabic = 0x0669;
  t.ninebengali = 0x09ef;
  t.ninecircle = 0x2468;
  t.ninecircleinversesansserif = 0x2792;
  t.ninedeva = 0x096f;
  t.ninegujarati = 0x0aef;
  t.ninegurmukhi = 0x0a6f;
  t.ninehackarabic = 0x0669;
  t.ninehangzhou = 0x3029;
  t.nineideographicparen = 0x3228;
  t.nineinferior = 0x2089;
  t.ninemonospace = 0xff19;
  t.nineoldstyle = 0xf739;
  t.nineparen = 0x247c;
  t.nineperiod = 0x2490;
  t.ninepersian = 0x06f9;
  t.nineroman = 0x2178;
  t.ninesuperior = 0x2079;
  t.nineteencircle = 0x2472;
  t.nineteenparen = 0x2486;
  t.nineteenperiod = 0x249a;
  t.ninethai = 0x0e59;
  t.nj = 0x01cc;
  t.njecyrillic = 0x045a;
  t.nkatakana = 0x30f3;
  t.nkatakanahalfwidth = 0xff9d;
  t.nlegrightlong = 0x019e;
  t.nlinebelow = 0x1e49;
  t.nmonospace = 0xff4e;
  t.nmsquare = 0x339a;
  t.nnabengali = 0x09a3;
  t.nnadeva = 0x0923;
  t.nnagujarati = 0x0aa3;
  t.nnagurmukhi = 0x0a23;
  t.nnnadeva = 0x0929;
  t.nohiragana = 0x306e;
  t.nokatakana = 0x30ce;
  t.nokatakanahalfwidth = 0xff89;
  t.nonbreakingspace = 0x00a0;
  t.nonenthai = 0x0e13;
  t.nonuthai = 0x0e19;
  t.noonarabic = 0x0646;
  t.noonfinalarabic = 0xfee6;
  t.noonghunnaarabic = 0x06ba;
  t.noonghunnafinalarabic = 0xfb9f;
  t.nooninitialarabic = 0xfee7;
  t.noonjeeminitialarabic = 0xfcd2;
  t.noonjeemisolatedarabic = 0xfc4b;
  t.noonmedialarabic = 0xfee8;
  t.noonmeeminitialarabic = 0xfcd5;
  t.noonmeemisolatedarabic = 0xfc4e;
  t.noonnoonfinalarabic = 0xfc8d;
  t.notcontains = 0x220c;
  t.notelement = 0x2209;
  t.notelementof = 0x2209;
  t.notequal = 0x2260;
  t.notgreater = 0x226f;
  t.notgreaternorequal = 0x2271;
  t.notgreaternorless = 0x2279;
  t.notidentical = 0x2262;
  t.notless = 0x226e;
  t.notlessnorequal = 0x2270;
  t.notparallel = 0x2226;
  t.notprecedes = 0x2280;
  t.notsubset = 0x2284;
  t.notsucceeds = 0x2281;
  t.notsuperset = 0x2285;
  t.nowarmenian = 0x0576;
  t.nparen = 0x24a9;
  t.nssquare = 0x33b1;
  t.nsuperior = 0x207f;
  t.ntilde = 0x00f1;
  t.nu = 0x03bd;
  t.nuhiragana = 0x306c;
  t.nukatakana = 0x30cc;
  t.nukatakanahalfwidth = 0xff87;
  t.nuktabengali = 0x09bc;
  t.nuktadeva = 0x093c;
  t.nuktagujarati = 0x0abc;
  t.nuktagurmukhi = 0x0a3c;
  t.numbersign = 0x0023;
  t.numbersignmonospace = 0xff03;
  t.numbersignsmall = 0xfe5f;
  t.numeralsigngreek = 0x0374;
  t.numeralsignlowergreek = 0x0375;
  t.numero = 0x2116;
  t.nun = 0x05e0;
  t.nundagesh = 0xfb40;
  t.nundageshhebrew = 0xfb40;
  t.nunhebrew = 0x05e0;
  t.nvsquare = 0x33b5;
  t.nwsquare = 0x33bb;
  t.nyabengali = 0x099e;
  t.nyadeva = 0x091e;
  t.nyagujarati = 0x0a9e;
  t.nyagurmukhi = 0x0a1e;
  t.o = 0x006f;
  t.oacute = 0x00f3;
  t.oangthai = 0x0e2d;
  t.obarred = 0x0275;
  t.obarredcyrillic = 0x04e9;
  t.obarreddieresiscyrillic = 0x04eb;
  t.obengali = 0x0993;
  t.obopomofo = 0x311b;
  t.obreve = 0x014f;
  t.ocandradeva = 0x0911;
  t.ocandragujarati = 0x0a91;
  t.ocandravowelsigndeva = 0x0949;
  t.ocandravowelsigngujarati = 0x0ac9;
  t.ocaron = 0x01d2;
  t.ocircle = 0x24de;
  t.ocircumflex = 0x00f4;
  t.ocircumflexacute = 0x1ed1;
  t.ocircumflexdotbelow = 0x1ed9;
  t.ocircumflexgrave = 0x1ed3;
  t.ocircumflexhookabove = 0x1ed5;
  t.ocircumflextilde = 0x1ed7;
  t.ocyrillic = 0x043e;
  t.odblacute = 0x0151;
  t.odblgrave = 0x020d;
  t.odeva = 0x0913;
  t.odieresis = 0x00f6;
  t.odieresiscyrillic = 0x04e7;
  t.odotbelow = 0x1ecd;
  t.oe = 0x0153;
  t.oekorean = 0x315a;
  t.ogonek = 0x02db;
  t.ogonekcmb = 0x0328;
  t.ograve = 0x00f2;
  t.ogujarati = 0x0a93;
  t.oharmenian = 0x0585;
  t.ohiragana = 0x304a;
  t.ohookabove = 0x1ecf;
  t.ohorn = 0x01a1;
  t.ohornacute = 0x1edb;
  t.ohorndotbelow = 0x1ee3;
  t.ohorngrave = 0x1edd;
  t.ohornhookabove = 0x1edf;
  t.ohorntilde = 0x1ee1;
  t.ohungarumlaut = 0x0151;
  t.oi = 0x01a3;
  t.oinvertedbreve = 0x020f;
  t.okatakana = 0x30aa;
  t.okatakanahalfwidth = 0xff75;
  t.okorean = 0x3157;
  t.olehebrew = 0x05ab;
  t.omacron = 0x014d;
  t.omacronacute = 0x1e53;
  t.omacrongrave = 0x1e51;
  t.omdeva = 0x0950;
  t.omega = 0x03c9;
  t.omega1 = 0x03d6;
  t.omegacyrillic = 0x0461;
  t.omegalatinclosed = 0x0277;
  t.omegaroundcyrillic = 0x047b;
  t.omegatitlocyrillic = 0x047d;
  t.omegatonos = 0x03ce;
  t.omgujarati = 0x0ad0;
  t.omicron = 0x03bf;
  t.omicrontonos = 0x03cc;
  t.omonospace = 0xff4f;
  t.one = 0x0031;
  t.onearabic = 0x0661;
  t.onebengali = 0x09e7;
  t.onecircle = 0x2460;
  t.onecircleinversesansserif = 0x278a;
  t.onedeva = 0x0967;
  t.onedotenleader = 0x2024;
  t.oneeighth = 0x215b;
  t.onefitted = 0xf6dc;
  t.onegujarati = 0x0ae7;
  t.onegurmukhi = 0x0a67;
  t.onehackarabic = 0x0661;
  t.onehalf = 0x00bd;
  t.onehangzhou = 0x3021;
  t.oneideographicparen = 0x3220;
  t.oneinferior = 0x2081;
  t.onemonospace = 0xff11;
  t.onenumeratorbengali = 0x09f4;
  t.oneoldstyle = 0xf731;
  t.oneparen = 0x2474;
  t.oneperiod = 0x2488;
  t.onepersian = 0x06f1;
  t.onequarter = 0x00bc;
  t.oneroman = 0x2170;
  t.onesuperior = 0x00b9;
  t.onethai = 0x0e51;
  t.onethird = 0x2153;
  t.oogonek = 0x01eb;
  t.oogonekmacron = 0x01ed;
  t.oogurmukhi = 0x0a13;
  t.oomatragurmukhi = 0x0a4b;
  t.oopen = 0x0254;
  t.oparen = 0x24aa;
  t.openbullet = 0x25e6;
  t.option = 0x2325;
  t.ordfeminine = 0x00aa;
  t.ordmasculine = 0x00ba;
  t.orthogonal = 0x221f;
  t.oshortdeva = 0x0912;
  t.oshortvowelsigndeva = 0x094a;
  t.oslash = 0x00f8;
  t.oslashacute = 0x01ff;
  t.osmallhiragana = 0x3049;
  t.osmallkatakana = 0x30a9;
  t.osmallkatakanahalfwidth = 0xff6b;
  t.ostrokeacute = 0x01ff;
  t.osuperior = 0xf6f0;
  t.otcyrillic = 0x047f;
  t.otilde = 0x00f5;
  t.otildeacute = 0x1e4d;
  t.otildedieresis = 0x1e4f;
  t.oubopomofo = 0x3121;
  t.overline = 0x203e;
  t.overlinecenterline = 0xfe4a;
  t.overlinecmb = 0x0305;
  t.overlinedashed = 0xfe49;
  t.overlinedblwavy = 0xfe4c;
  t.overlinewavy = 0xfe4b;
  t.overscore = 0x00af;
  t.ovowelsignbengali = 0x09cb;
  t.ovowelsigndeva = 0x094b;
  t.ovowelsigngujarati = 0x0acb;
  t.p = 0x0070;
  t.paampssquare = 0x3380;
  t.paasentosquare = 0x332b;
  t.pabengali = 0x09aa;
  t.pacute = 0x1e55;
  t.padeva = 0x092a;
  t.pagedown = 0x21df;
  t.pageup = 0x21de;
  t.pagujarati = 0x0aaa;
  t.pagurmukhi = 0x0a2a;
  t.pahiragana = 0x3071;
  t.paiyannoithai = 0x0e2f;
  t.pakatakana = 0x30d1;
  t.palatalizationcyrilliccmb = 0x0484;
  t.palochkacyrillic = 0x04c0;
  t.pansioskorean = 0x317f;
  t.paragraph = 0x00b6;
  t.parallel = 0x2225;
  t.parenleft = 0x0028;
  t.parenleftaltonearabic = 0xfd3e;
  t.parenleftbt = 0xf8ed;
  t.parenleftex = 0xf8ec;
  t.parenleftinferior = 0x208d;
  t.parenleftmonospace = 0xff08;
  t.parenleftsmall = 0xfe59;
  t.parenleftsuperior = 0x207d;
  t.parenlefttp = 0xf8eb;
  t.parenleftvertical = 0xfe35;
  t.parenright = 0x0029;
  t.parenrightaltonearabic = 0xfd3f;
  t.parenrightbt = 0xf8f8;
  t.parenrightex = 0xf8f7;
  t.parenrightinferior = 0x208e;
  t.parenrightmonospace = 0xff09;
  t.parenrightsmall = 0xfe5a;
  t.parenrightsuperior = 0x207e;
  t.parenrighttp = 0xf8f6;
  t.parenrightvertical = 0xfe36;
  t.partialdiff = 0x2202;
  t.paseqhebrew = 0x05c0;
  t.pashtahebrew = 0x0599;
  t.pasquare = 0x33a9;
  t.patah = 0x05b7;
  t.patah11 = 0x05b7;
  t.patah1d = 0x05b7;
  t.patah2a = 0x05b7;
  t.patahhebrew = 0x05b7;
  t.patahnarrowhebrew = 0x05b7;
  t.patahquarterhebrew = 0x05b7;
  t.patahwidehebrew = 0x05b7;
  t.pazerhebrew = 0x05a1;
  t.pbopomofo = 0x3106;
  t.pcircle = 0x24df;
  t.pdotaccent = 0x1e57;
  t.pe = 0x05e4;
  t.pecyrillic = 0x043f;
  t.pedagesh = 0xfb44;
  t.pedageshhebrew = 0xfb44;
  t.peezisquare = 0x333b;
  t.pefinaldageshhebrew = 0xfb43;
  t.peharabic = 0x067e;
  t.peharmenian = 0x057a;
  t.pehebrew = 0x05e4;
  t.pehfinalarabic = 0xfb57;
  t.pehinitialarabic = 0xfb58;
  t.pehiragana = 0x307a;
  t.pehmedialarabic = 0xfb59;
  t.pekatakana = 0x30da;
  t.pemiddlehookcyrillic = 0x04a7;
  t.perafehebrew = 0xfb4e;
  t.percent = 0x0025;
  t.percentarabic = 0x066a;
  t.percentmonospace = 0xff05;
  t.percentsmall = 0xfe6a;
  t.period = 0x002e;
  t.periodarmenian = 0x0589;
  t.periodcentered = 0x00b7;
  t.periodhalfwidth = 0xff61;
  t.periodinferior = 0xf6e7;
  t.periodmonospace = 0xff0e;
  t.periodsmall = 0xfe52;
  t.periodsuperior = 0xf6e8;
  t.perispomenigreekcmb = 0x0342;
  t.perpendicular = 0x22a5;
  t.perthousand = 0x2030;
  t.peseta = 0x20a7;
  t.pfsquare = 0x338a;
  t.phabengali = 0x09ab;
  t.phadeva = 0x092b;
  t.phagujarati = 0x0aab;
  t.phagurmukhi = 0x0a2b;
  t.phi = 0x03c6;
  t.phi1 = 0x03d5;
  t.phieuphacirclekorean = 0x327a;
  t.phieuphaparenkorean = 0x321a;
  t.phieuphcirclekorean = 0x326c;
  t.phieuphkorean = 0x314d;
  t.phieuphparenkorean = 0x320c;
  t.philatin = 0x0278;
  t.phinthuthai = 0x0e3a;
  t.phisymbolgreek = 0x03d5;
  t.phook = 0x01a5;
  t.phophanthai = 0x0e1e;
  t.phophungthai = 0x0e1c;
  t.phosamphaothai = 0x0e20;
  t.pi = 0x03c0;
  t.pieupacirclekorean = 0x3273;
  t.pieupaparenkorean = 0x3213;
  t.pieupcieuckorean = 0x3176;
  t.pieupcirclekorean = 0x3265;
  t.pieupkiyeokkorean = 0x3172;
  t.pieupkorean = 0x3142;
  t.pieupparenkorean = 0x3205;
  t.pieupsioskiyeokkorean = 0x3174;
  t.pieupsioskorean = 0x3144;
  t.pieupsiostikeutkorean = 0x3175;
  t.pieupthieuthkorean = 0x3177;
  t.pieuptikeutkorean = 0x3173;
  t.pihiragana = 0x3074;
  t.pikatakana = 0x30d4;
  t.pisymbolgreek = 0x03d6;
  t.piwrarmenian = 0x0583;
  t.planckover2pi = 0x210f;
  t.planckover2pi1 = 0x210f;
  t.plus = 0x002b;
  t.plusbelowcmb = 0x031f;
  t.pluscircle = 0x2295;
  t.plusminus = 0x00b1;
  t.plusmod = 0x02d6;
  t.plusmonospace = 0xff0b;
  t.plussmall = 0xfe62;
  t.plussuperior = 0x207a;
  t.pmonospace = 0xff50;
  t.pmsquare = 0x33d8;
  t.pohiragana = 0x307d;
  t.pointingindexdownwhite = 0x261f;
  t.pointingindexleftwhite = 0x261c;
  t.pointingindexrightwhite = 0x261e;
  t.pointingindexupwhite = 0x261d;
  t.pokatakana = 0x30dd;
  t.poplathai = 0x0e1b;
  t.postalmark = 0x3012;
  t.postalmarkface = 0x3020;
  t.pparen = 0x24ab;
  t.precedes = 0x227a;
  t.prescription = 0x211e;
  t.primemod = 0x02b9;
  t.primereversed = 0x2035;
  t.product = 0x220f;
  t.projective = 0x2305;
  t.prolongedkana = 0x30fc;
  t.propellor = 0x2318;
  t.propersubset = 0x2282;
  t.propersuperset = 0x2283;
  t.proportion = 0x2237;
  t.proportional = 0x221d;
  t.psi = 0x03c8;
  t.psicyrillic = 0x0471;
  t.psilipneumatacyrilliccmb = 0x0486;
  t.pssquare = 0x33b0;
  t.puhiragana = 0x3077;
  t.pukatakana = 0x30d7;
  t.pvsquare = 0x33b4;
  t.pwsquare = 0x33ba;
  t.q = 0x0071;
  t.qadeva = 0x0958;
  t.qadmahebrew = 0x05a8;
  t.qafarabic = 0x0642;
  t.qaffinalarabic = 0xfed6;
  t.qafinitialarabic = 0xfed7;
  t.qafmedialarabic = 0xfed8;
  t.qamats = 0x05b8;
  t.qamats10 = 0x05b8;
  t.qamats1a = 0x05b8;
  t.qamats1c = 0x05b8;
  t.qamats27 = 0x05b8;
  t.qamats29 = 0x05b8;
  t.qamats33 = 0x05b8;
  t.qamatsde = 0x05b8;
  t.qamatshebrew = 0x05b8;
  t.qamatsnarrowhebrew = 0x05b8;
  t.qamatsqatanhebrew = 0x05b8;
  t.qamatsqatannarrowhebrew = 0x05b8;
  t.qamatsqatanquarterhebrew = 0x05b8;
  t.qamatsqatanwidehebrew = 0x05b8;
  t.qamatsquarterhebrew = 0x05b8;
  t.qamatswidehebrew = 0x05b8;
  t.qarneyparahebrew = 0x059f;
  t.qbopomofo = 0x3111;
  t.qcircle = 0x24e0;
  t.qhook = 0x02a0;
  t.qmonospace = 0xff51;
  t.qof = 0x05e7;
  t.qofdagesh = 0xfb47;
  t.qofdageshhebrew = 0xfb47;
  t.qofhebrew = 0x05e7;
  t.qparen = 0x24ac;
  t.quarternote = 0x2669;
  t.qubuts = 0x05bb;
  t.qubuts18 = 0x05bb;
  t.qubuts25 = 0x05bb;
  t.qubuts31 = 0x05bb;
  t.qubutshebrew = 0x05bb;
  t.qubutsnarrowhebrew = 0x05bb;
  t.qubutsquarterhebrew = 0x05bb;
  t.qubutswidehebrew = 0x05bb;
  t.question = 0x003f;
  t.questionarabic = 0x061f;
  t.questionarmenian = 0x055e;
  t.questiondown = 0x00bf;
  t.questiondownsmall = 0xf7bf;
  t.questiongreek = 0x037e;
  t.questionmonospace = 0xff1f;
  t.questionsmall = 0xf73f;
  t.quotedbl = 0x0022;
  t.quotedblbase = 0x201e;
  t.quotedblleft = 0x201c;
  t.quotedblmonospace = 0xff02;
  t.quotedblprime = 0x301e;
  t.quotedblprimereversed = 0x301d;
  t.quotedblright = 0x201d;
  t.quoteleft = 0x2018;
  t.quoteleftreversed = 0x201b;
  t.quotereversed = 0x201b;
  t.quoteright = 0x2019;
  t.quoterightn = 0x0149;
  t.quotesinglbase = 0x201a;
  t.quotesingle = 0x0027;
  t.quotesinglemonospace = 0xff07;
  t.r = 0x0072;
  t.raarmenian = 0x057c;
  t.rabengali = 0x09b0;
  t.racute = 0x0155;
  t.radeva = 0x0930;
  t.radical = 0x221a;
  t.radicalex = 0xf8e5;
  t.radoverssquare = 0x33ae;
  t.radoverssquaredsquare = 0x33af;
  t.radsquare = 0x33ad;
  t.rafe = 0x05bf;
  t.rafehebrew = 0x05bf;
  t.ragujarati = 0x0ab0;
  t.ragurmukhi = 0x0a30;
  t.rahiragana = 0x3089;
  t.rakatakana = 0x30e9;
  t.rakatakanahalfwidth = 0xff97;
  t.ralowerdiagonalbengali = 0x09f1;
  t.ramiddlediagonalbengali = 0x09f0;
  t.ramshorn = 0x0264;
  t.ratio = 0x2236;
  t.rbopomofo = 0x3116;
  t.rcaron = 0x0159;
  t.rcedilla = 0x0157;
  t.rcircle = 0x24e1;
  t.rcommaaccent = 0x0157;
  t.rdblgrave = 0x0211;
  t.rdotaccent = 0x1e59;
  t.rdotbelow = 0x1e5b;
  t.rdotbelowmacron = 0x1e5d;
  t.referencemark = 0x203b;
  t.reflexsubset = 0x2286;
  t.reflexsuperset = 0x2287;
  t.registered = 0x00ae;
  t.registersans = 0xf8e8;
  t.registerserif = 0xf6da;
  t.reharabic = 0x0631;
  t.reharmenian = 0x0580;
  t.rehfinalarabic = 0xfeae;
  t.rehiragana = 0x308c;
  t.rekatakana = 0x30ec;
  t.rekatakanahalfwidth = 0xff9a;
  t.resh = 0x05e8;
  t.reshdageshhebrew = 0xfb48;
  t.reshhebrew = 0x05e8;
  t.reversedtilde = 0x223d;
  t.reviahebrew = 0x0597;
  t.reviamugrashhebrew = 0x0597;
  t.revlogicalnot = 0x2310;
  t.rfishhook = 0x027e;
  t.rfishhookreversed = 0x027f;
  t.rhabengali = 0x09dd;
  t.rhadeva = 0x095d;
  t.rho = 0x03c1;
  t.rhook = 0x027d;
  t.rhookturned = 0x027b;
  t.rhookturnedsuperior = 0x02b5;
  t.rhosymbolgreek = 0x03f1;
  t.rhotichookmod = 0x02de;
  t.rieulacirclekorean = 0x3271;
  t.rieulaparenkorean = 0x3211;
  t.rieulcirclekorean = 0x3263;
  t.rieulhieuhkorean = 0x3140;
  t.rieulkiyeokkorean = 0x313a;
  t.rieulkiyeoksioskorean = 0x3169;
  t.rieulkorean = 0x3139;
  t.rieulmieumkorean = 0x313b;
  t.rieulpansioskorean = 0x316c;
  t.rieulparenkorean = 0x3203;
  t.rieulphieuphkorean = 0x313f;
  t.rieulpieupkorean = 0x313c;
  t.rieulpieupsioskorean = 0x316b;
  t.rieulsioskorean = 0x313d;
  t.rieulthieuthkorean = 0x313e;
  t.rieultikeutkorean = 0x316a;
  t.rieulyeorinhieuhkorean = 0x316d;
  t.rightangle = 0x221f;
  t.righttackbelowcmb = 0x0319;
  t.righttriangle = 0x22bf;
  t.rihiragana = 0x308a;
  t.rikatakana = 0x30ea;
  t.rikatakanahalfwidth = 0xff98;
  t.ring = 0x02da;
  t.ringbelowcmb = 0x0325;
  t.ringcmb = 0x030a;
  t.ringhalfleft = 0x02bf;
  t.ringhalfleftarmenian = 0x0559;
  t.ringhalfleftbelowcmb = 0x031c;
  t.ringhalfleftcentered = 0x02d3;
  t.ringhalfright = 0x02be;
  t.ringhalfrightbelowcmb = 0x0339;
  t.ringhalfrightcentered = 0x02d2;
  t.rinvertedbreve = 0x0213;
  t.rittorusquare = 0x3351;
  t.rlinebelow = 0x1e5f;
  t.rlongleg = 0x027c;
  t.rlonglegturned = 0x027a;
  t.rmonospace = 0xff52;
  t.rohiragana = 0x308d;
  t.rokatakana = 0x30ed;
  t.rokatakanahalfwidth = 0xff9b;
  t.roruathai = 0x0e23;
  t.rparen = 0x24ad;
  t.rrabengali = 0x09dc;
  t.rradeva = 0x0931;
  t.rragurmukhi = 0x0a5c;
  t.rreharabic = 0x0691;
  t.rrehfinalarabic = 0xfb8d;
  t.rrvocalicbengali = 0x09e0;
  t.rrvocalicdeva = 0x0960;
  t.rrvocalicgujarati = 0x0ae0;
  t.rrvocalicvowelsignbengali = 0x09c4;
  t.rrvocalicvowelsigndeva = 0x0944;
  t.rrvocalicvowelsigngujarati = 0x0ac4;
  t.rsuperior = 0xf6f1;
  t.rtblock = 0x2590;
  t.rturned = 0x0279;
  t.rturnedsuperior = 0x02b4;
  t.ruhiragana = 0x308b;
  t.rukatakana = 0x30eb;
  t.rukatakanahalfwidth = 0xff99;
  t.rupeemarkbengali = 0x09f2;
  t.rupeesignbengali = 0x09f3;
  t.rupiah = 0xf6dd;
  t.ruthai = 0x0e24;
  t.rvocalicbengali = 0x098b;
  t.rvocalicdeva = 0x090b;
  t.rvocalicgujarati = 0x0a8b;
  t.rvocalicvowelsignbengali = 0x09c3;
  t.rvocalicvowelsigndeva = 0x0943;
  t.rvocalicvowelsigngujarati = 0x0ac3;
  t.s = 0x0073;
  t.sabengali = 0x09b8;
  t.sacute = 0x015b;
  t.sacutedotaccent = 0x1e65;
  t.sadarabic = 0x0635;
  t.sadeva = 0x0938;
  t.sadfinalarabic = 0xfeba;
  t.sadinitialarabic = 0xfebb;
  t.sadmedialarabic = 0xfebc;
  t.sagujarati = 0x0ab8;
  t.sagurmukhi = 0x0a38;
  t.sahiragana = 0x3055;
  t.sakatakana = 0x30b5;
  t.sakatakanahalfwidth = 0xff7b;
  t.sallallahoualayhewasallamarabic = 0xfdfa;
  t.samekh = 0x05e1;
  t.samekhdagesh = 0xfb41;
  t.samekhdageshhebrew = 0xfb41;
  t.samekhhebrew = 0x05e1;
  t.saraaathai = 0x0e32;
  t.saraaethai = 0x0e41;
  t.saraaimaimalaithai = 0x0e44;
  t.saraaimaimuanthai = 0x0e43;
  t.saraamthai = 0x0e33;
  t.saraathai = 0x0e30;
  t.saraethai = 0x0e40;
  t.saraiileftthai = 0xf886;
  t.saraiithai = 0x0e35;
  t.saraileftthai = 0xf885;
  t.saraithai = 0x0e34;
  t.saraothai = 0x0e42;
  t.saraueeleftthai = 0xf888;
  t.saraueethai = 0x0e37;
  t.saraueleftthai = 0xf887;
  t.sarauethai = 0x0e36;
  t.sarauthai = 0x0e38;
  t.sarauuthai = 0x0e39;
  t.sbopomofo = 0x3119;
  t.scaron = 0x0161;
  t.scarondotaccent = 0x1e67;
  t.scedilla = 0x015f;
  t.schwa = 0x0259;
  t.schwacyrillic = 0x04d9;
  t.schwadieresiscyrillic = 0x04db;
  t.schwahook = 0x025a;
  t.scircle = 0x24e2;
  t.scircumflex = 0x015d;
  t.scommaaccent = 0x0219;
  t.sdotaccent = 0x1e61;
  t.sdotbelow = 0x1e63;
  t.sdotbelowdotaccent = 0x1e69;
  t.seagullbelowcmb = 0x033c;
  t.second = 0x2033;
  t.secondtonechinese = 0x02ca;
  t.section = 0x00a7;
  t.seenarabic = 0x0633;
  t.seenfinalarabic = 0xfeb2;
  t.seeninitialarabic = 0xfeb3;
  t.seenmedialarabic = 0xfeb4;
  t.segol = 0x05b6;
  t.segol13 = 0x05b6;
  t.segol1f = 0x05b6;
  t.segol2c = 0x05b6;
  t.segolhebrew = 0x05b6;
  t.segolnarrowhebrew = 0x05b6;
  t.segolquarterhebrew = 0x05b6;
  t.segoltahebrew = 0x0592;
  t.segolwidehebrew = 0x05b6;
  t.seharmenian = 0x057d;
  t.sehiragana = 0x305b;
  t.sekatakana = 0x30bb;
  t.sekatakanahalfwidth = 0xff7e;
  t.semicolon = 0x003b;
  t.semicolonarabic = 0x061b;
  t.semicolonmonospace = 0xff1b;
  t.semicolonsmall = 0xfe54;
  t.semivoicedmarkkana = 0x309c;
  t.semivoicedmarkkanahalfwidth = 0xff9f;
  t.sentisquare = 0x3322;
  t.sentosquare = 0x3323;
  t.seven = 0x0037;
  t.sevenarabic = 0x0667;
  t.sevenbengali = 0x09ed;
  t.sevencircle = 0x2466;
  t.sevencircleinversesansserif = 0x2790;
  t.sevendeva = 0x096d;
  t.seveneighths = 0x215e;
  t.sevengujarati = 0x0aed;
  t.sevengurmukhi = 0x0a6d;
  t.sevenhackarabic = 0x0667;
  t.sevenhangzhou = 0x3027;
  t.sevenideographicparen = 0x3226;
  t.seveninferior = 0x2087;
  t.sevenmonospace = 0xff17;
  t.sevenoldstyle = 0xf737;
  t.sevenparen = 0x247a;
  t.sevenperiod = 0x248e;
  t.sevenpersian = 0x06f7;
  t.sevenroman = 0x2176;
  t.sevensuperior = 0x2077;
  t.seventeencircle = 0x2470;
  t.seventeenparen = 0x2484;
  t.seventeenperiod = 0x2498;
  t.seventhai = 0x0e57;
  t.sfthyphen = 0x00ad;
  t.shaarmenian = 0x0577;
  t.shabengali = 0x09b6;
  t.shacyrillic = 0x0448;
  t.shaddaarabic = 0x0651;
  t.shaddadammaarabic = 0xfc61;
  t.shaddadammatanarabic = 0xfc5e;
  t.shaddafathaarabic = 0xfc60;
  t.shaddakasraarabic = 0xfc62;
  t.shaddakasratanarabic = 0xfc5f;
  t.shade = 0x2592;
  t.shadedark = 0x2593;
  t.shadelight = 0x2591;
  t.shademedium = 0x2592;
  t.shadeva = 0x0936;
  t.shagujarati = 0x0ab6;
  t.shagurmukhi = 0x0a36;
  t.shalshelethebrew = 0x0593;
  t.shbopomofo = 0x3115;
  t.shchacyrillic = 0x0449;
  t.sheenarabic = 0x0634;
  t.sheenfinalarabic = 0xfeb6;
  t.sheeninitialarabic = 0xfeb7;
  t.sheenmedialarabic = 0xfeb8;
  t.sheicoptic = 0x03e3;
  t.sheqel = 0x20aa;
  t.sheqelhebrew = 0x20aa;
  t.sheva = 0x05b0;
  t.sheva115 = 0x05b0;
  t.sheva15 = 0x05b0;
  t.sheva22 = 0x05b0;
  t.sheva2e = 0x05b0;
  t.shevahebrew = 0x05b0;
  t.shevanarrowhebrew = 0x05b0;
  t.shevaquarterhebrew = 0x05b0;
  t.shevawidehebrew = 0x05b0;
  t.shhacyrillic = 0x04bb;
  t.shimacoptic = 0x03ed;
  t.shin = 0x05e9;
  t.shindagesh = 0xfb49;
  t.shindageshhebrew = 0xfb49;
  t.shindageshshindot = 0xfb2c;
  t.shindageshshindothebrew = 0xfb2c;
  t.shindageshsindot = 0xfb2d;
  t.shindageshsindothebrew = 0xfb2d;
  t.shindothebrew = 0x05c1;
  t.shinhebrew = 0x05e9;
  t.shinshindot = 0xfb2a;
  t.shinshindothebrew = 0xfb2a;
  t.shinsindot = 0xfb2b;
  t.shinsindothebrew = 0xfb2b;
  t.shook = 0x0282;
  t.sigma = 0x03c3;
  t.sigma1 = 0x03c2;
  t.sigmafinal = 0x03c2;
  t.sigmalunatesymbolgreek = 0x03f2;
  t.sihiragana = 0x3057;
  t.sikatakana = 0x30b7;
  t.sikatakanahalfwidth = 0xff7c;
  t.siluqhebrew = 0x05bd;
  t.siluqlefthebrew = 0x05bd;
  t.similar = 0x223c;
  t.sindothebrew = 0x05c2;
  t.siosacirclekorean = 0x3274;
  t.siosaparenkorean = 0x3214;
  t.sioscieuckorean = 0x317e;
  t.sioscirclekorean = 0x3266;
  t.sioskiyeokkorean = 0x317a;
  t.sioskorean = 0x3145;
  t.siosnieunkorean = 0x317b;
  t.siosparenkorean = 0x3206;
  t.siospieupkorean = 0x317d;
  t.siostikeutkorean = 0x317c;
  t.six = 0x0036;
  t.sixarabic = 0x0666;
  t.sixbengali = 0x09ec;
  t.sixcircle = 0x2465;
  t.sixcircleinversesansserif = 0x278f;
  t.sixdeva = 0x096c;
  t.sixgujarati = 0x0aec;
  t.sixgurmukhi = 0x0a6c;
  t.sixhackarabic = 0x0666;
  t.sixhangzhou = 0x3026;
  t.sixideographicparen = 0x3225;
  t.sixinferior = 0x2086;
  t.sixmonospace = 0xff16;
  t.sixoldstyle = 0xf736;
  t.sixparen = 0x2479;
  t.sixperiod = 0x248d;
  t.sixpersian = 0x06f6;
  t.sixroman = 0x2175;
  t.sixsuperior = 0x2076;
  t.sixteencircle = 0x246f;
  t.sixteencurrencydenominatorbengali = 0x09f9;
  t.sixteenparen = 0x2483;
  t.sixteenperiod = 0x2497;
  t.sixthai = 0x0e56;
  t.slash = 0x002f;
  t.slashmonospace = 0xff0f;
  t.slong = 0x017f;
  t.slongdotaccent = 0x1e9b;
  t.smileface = 0x263a;
  t.smonospace = 0xff53;
  t.sofpasuqhebrew = 0x05c3;
  t.softhyphen = 0x00ad;
  t.softsigncyrillic = 0x044c;
  t.sohiragana = 0x305d;
  t.sokatakana = 0x30bd;
  t.sokatakanahalfwidth = 0xff7f;
  t.soliduslongoverlaycmb = 0x0338;
  t.solidusshortoverlaycmb = 0x0337;
  t.sorusithai = 0x0e29;
  t.sosalathai = 0x0e28;
  t.sosothai = 0x0e0b;
  t.sosuathai = 0x0e2a;
  t.space = 0x0020;
  t.spacehackarabic = 0x0020;
  t.spade = 0x2660;
  t.spadesuitblack = 0x2660;
  t.spadesuitwhite = 0x2664;
  t.sparen = 0x24ae;
  t.squarebelowcmb = 0x033b;
  t.squarecc = 0x33c4;
  t.squarecm = 0x339d;
  t.squarediagonalcrosshatchfill = 0x25a9;
  t.squarehorizontalfill = 0x25a4;
  t.squarekg = 0x338f;
  t.squarekm = 0x339e;
  t.squarekmcapital = 0x33ce;
  t.squareln = 0x33d1;
  t.squarelog = 0x33d2;
  t.squaremg = 0x338e;
  t.squaremil = 0x33d5;
  t.squaremm = 0x339c;
  t.squaremsquared = 0x33a1;
  t.squareorthogonalcrosshatchfill = 0x25a6;
  t.squareupperlefttolowerrightfill = 0x25a7;
  t.squareupperrighttolowerleftfill = 0x25a8;
  t.squareverticalfill = 0x25a5;
  t.squarewhitewithsmallblack = 0x25a3;
  t.srsquare = 0x33db;
  t.ssabengali = 0x09b7;
  t.ssadeva = 0x0937;
  t.ssagujarati = 0x0ab7;
  t.ssangcieuckorean = 0x3149;
  t.ssanghieuhkorean = 0x3185;
  t.ssangieungkorean = 0x3180;
  t.ssangkiyeokkorean = 0x3132;
  t.ssangnieunkorean = 0x3165;
  t.ssangpieupkorean = 0x3143;
  t.ssangsioskorean = 0x3146;
  t.ssangtikeutkorean = 0x3138;
  t.ssuperior = 0xf6f2;
  t.sterling = 0x00a3;
  t.sterlingmonospace = 0xffe1;
  t.strokelongoverlaycmb = 0x0336;
  t.strokeshortoverlaycmb = 0x0335;
  t.subset = 0x2282;
  t.subsetnotequal = 0x228a;
  t.subsetorequal = 0x2286;
  t.succeeds = 0x227b;
  t.suchthat = 0x220b;
  t.suhiragana = 0x3059;
  t.sukatakana = 0x30b9;
  t.sukatakanahalfwidth = 0xff7d;
  t.sukunarabic = 0x0652;
  t.summation = 0x2211;
  t.sun = 0x263c;
  t.superset = 0x2283;
  t.supersetnotequal = 0x228b;
  t.supersetorequal = 0x2287;
  t.svsquare = 0x33dc;
  t.syouwaerasquare = 0x337c;
  t.t = 0x0074;
  t.tabengali = 0x09a4;
  t.tackdown = 0x22a4;
  t.tackleft = 0x22a3;
  t.tadeva = 0x0924;
  t.tagujarati = 0x0aa4;
  t.tagurmukhi = 0x0a24;
  t.taharabic = 0x0637;
  t.tahfinalarabic = 0xfec2;
  t.tahinitialarabic = 0xfec3;
  t.tahiragana = 0x305f;
  t.tahmedialarabic = 0xfec4;
  t.taisyouerasquare = 0x337d;
  t.takatakana = 0x30bf;
  t.takatakanahalfwidth = 0xff80;
  t.tatweelarabic = 0x0640;
  t.tau = 0x03c4;
  t.tav = 0x05ea;
  t.tavdages = 0xfb4a;
  t.tavdagesh = 0xfb4a;
  t.tavdageshhebrew = 0xfb4a;
  t.tavhebrew = 0x05ea;
  t.tbar = 0x0167;
  t.tbopomofo = 0x310a;
  t.tcaron = 0x0165;
  t.tccurl = 0x02a8;
  t.tcedilla = 0x0163;
  t.tcheharabic = 0x0686;
  t.tchehfinalarabic = 0xfb7b;
  t.tchehinitialarabic = 0xfb7c;
  t.tchehmedialarabic = 0xfb7d;
  t.tcircle = 0x24e3;
  t.tcircumflexbelow = 0x1e71;
  t.tcommaaccent = 0x0163;
  t.tdieresis = 0x1e97;
  t.tdotaccent = 0x1e6b;
  t.tdotbelow = 0x1e6d;
  t.tecyrillic = 0x0442;
  t.tedescendercyrillic = 0x04ad;
  t.teharabic = 0x062a;
  t.tehfinalarabic = 0xfe96;
  t.tehhahinitialarabic = 0xfca2;
  t.tehhahisolatedarabic = 0xfc0c;
  t.tehinitialarabic = 0xfe97;
  t.tehiragana = 0x3066;
  t.tehjeeminitialarabic = 0xfca1;
  t.tehjeemisolatedarabic = 0xfc0b;
  t.tehmarbutaarabic = 0x0629;
  t.tehmarbutafinalarabic = 0xfe94;
  t.tehmedialarabic = 0xfe98;
  t.tehmeeminitialarabic = 0xfca4;
  t.tehmeemisolatedarabic = 0xfc0e;
  t.tehnoonfinalarabic = 0xfc73;
  t.tekatakana = 0x30c6;
  t.tekatakanahalfwidth = 0xff83;
  t.telephone = 0x2121;
  t.telephoneblack = 0x260e;
  t.telishagedolahebrew = 0x05a0;
  t.telishaqetanahebrew = 0x05a9;
  t.tencircle = 0x2469;
  t.tenideographicparen = 0x3229;
  t.tenparen = 0x247d;
  t.tenperiod = 0x2491;
  t.tenroman = 0x2179;
  t.tesh = 0x02a7;
  t.tet = 0x05d8;
  t.tetdagesh = 0xfb38;
  t.tetdageshhebrew = 0xfb38;
  t.tethebrew = 0x05d8;
  t.tetsecyrillic = 0x04b5;
  t.tevirhebrew = 0x059b;
  t.tevirlefthebrew = 0x059b;
  t.thabengali = 0x09a5;
  t.thadeva = 0x0925;
  t.thagujarati = 0x0aa5;
  t.thagurmukhi = 0x0a25;
  t.thalarabic = 0x0630;
  t.thalfinalarabic = 0xfeac;
  t.thanthakhatlowleftthai = 0xf898;
  t.thanthakhatlowrightthai = 0xf897;
  t.thanthakhatthai = 0x0e4c;
  t.thanthakhatupperleftthai = 0xf896;
  t.theharabic = 0x062b;
  t.thehfinalarabic = 0xfe9a;
  t.thehinitialarabic = 0xfe9b;
  t.thehmedialarabic = 0xfe9c;
  t.thereexists = 0x2203;
  t.therefore = 0x2234;
  t.theta = 0x03b8;
  t.theta1 = 0x03d1;
  t.thetasymbolgreek = 0x03d1;
  t.thieuthacirclekorean = 0x3279;
  t.thieuthaparenkorean = 0x3219;
  t.thieuthcirclekorean = 0x326b;
  t.thieuthkorean = 0x314c;
  t.thieuthparenkorean = 0x320b;
  t.thirteencircle = 0x246c;
  t.thirteenparen = 0x2480;
  t.thirteenperiod = 0x2494;
  t.thonangmonthothai = 0x0e11;
  t.thook = 0x01ad;
  t.thophuthaothai = 0x0e12;
  t.thorn = 0x00fe;
  t.thothahanthai = 0x0e17;
  t.thothanthai = 0x0e10;
  t.thothongthai = 0x0e18;
  t.thothungthai = 0x0e16;
  t.thousandcyrillic = 0x0482;
  t.thousandsseparatorarabic = 0x066c;
  t.thousandsseparatorpersian = 0x066c;
  t.three = 0x0033;
  t.threearabic = 0x0663;
  t.threebengali = 0x09e9;
  t.threecircle = 0x2462;
  t.threecircleinversesansserif = 0x278c;
  t.threedeva = 0x0969;
  t.threeeighths = 0x215c;
  t.threegujarati = 0x0ae9;
  t.threegurmukhi = 0x0a69;
  t.threehackarabic = 0x0663;
  t.threehangzhou = 0x3023;
  t.threeideographicparen = 0x3222;
  t.threeinferior = 0x2083;
  t.threemonospace = 0xff13;
  t.threenumeratorbengali = 0x09f6;
  t.threeoldstyle = 0xf733;
  t.threeparen = 0x2476;
  t.threeperiod = 0x248a;
  t.threepersian = 0x06f3;
  t.threequarters = 0x00be;
  t.threequartersemdash = 0xf6de;
  t.threeroman = 0x2172;
  t.threesuperior = 0x00b3;
  t.threethai = 0x0e53;
  t.thzsquare = 0x3394;
  t.tihiragana = 0x3061;
  t.tikatakana = 0x30c1;
  t.tikatakanahalfwidth = 0xff81;
  t.tikeutacirclekorean = 0x3270;
  t.tikeutaparenkorean = 0x3210;
  t.tikeutcirclekorean = 0x3262;
  t.tikeutkorean = 0x3137;
  t.tikeutparenkorean = 0x3202;
  t.tilde = 0x02dc;
  t.tildebelowcmb = 0x0330;
  t.tildecmb = 0x0303;
  t.tildecomb = 0x0303;
  t.tildedoublecmb = 0x0360;
  t.tildeoperator = 0x223c;
  t.tildeoverlaycmb = 0x0334;
  t.tildeverticalcmb = 0x033e;
  t.timescircle = 0x2297;
  t.tipehahebrew = 0x0596;
  t.tipehalefthebrew = 0x0596;
  t.tippigurmukhi = 0x0a70;
  t.titlocyrilliccmb = 0x0483;
  t.tiwnarmenian = 0x057f;
  t.tlinebelow = 0x1e6f;
  t.tmonospace = 0xff54;
  t.toarmenian = 0x0569;
  t.tohiragana = 0x3068;
  t.tokatakana = 0x30c8;
  t.tokatakanahalfwidth = 0xff84;
  t.tonebarextrahighmod = 0x02e5;
  t.tonebarextralowmod = 0x02e9;
  t.tonebarhighmod = 0x02e6;
  t.tonebarlowmod = 0x02e8;
  t.tonebarmidmod = 0x02e7;
  t.tonefive = 0x01bd;
  t.tonesix = 0x0185;
  t.tonetwo = 0x01a8;
  t.tonos = 0x0384;
  t.tonsquare = 0x3327;
  t.topatakthai = 0x0e0f;
  t.tortoiseshellbracketleft = 0x3014;
  t.tortoiseshellbracketleftsmall = 0xfe5d;
  t.tortoiseshellbracketleftvertical = 0xfe39;
  t.tortoiseshellbracketright = 0x3015;
  t.tortoiseshellbracketrightsmall = 0xfe5e;
  t.tortoiseshellbracketrightvertical = 0xfe3a;
  t.totaothai = 0x0e15;
  t.tpalatalhook = 0x01ab;
  t.tparen = 0x24af;
  t.trademark = 0x2122;
  t.trademarksans = 0xf8ea;
  t.trademarkserif = 0xf6db;
  t.tretroflexhook = 0x0288;
  t.triagdn = 0x25bc;
  t.triaglf = 0x25c4;
  t.triagrt = 0x25ba;
  t.triagup = 0x25b2;
  t.ts = 0x02a6;
  t.tsadi = 0x05e6;
  t.tsadidagesh = 0xfb46;
  t.tsadidageshhebrew = 0xfb46;
  t.tsadihebrew = 0x05e6;
  t.tsecyrillic = 0x0446;
  t.tsere = 0x05b5;
  t.tsere12 = 0x05b5;
  t.tsere1e = 0x05b5;
  t.tsere2b = 0x05b5;
  t.tserehebrew = 0x05b5;
  t.tserenarrowhebrew = 0x05b5;
  t.tserequarterhebrew = 0x05b5;
  t.tserewidehebrew = 0x05b5;
  t.tshecyrillic = 0x045b;
  t.tsuperior = 0xf6f3;
  t.ttabengali = 0x099f;
  t.ttadeva = 0x091f;
  t.ttagujarati = 0x0a9f;
  t.ttagurmukhi = 0x0a1f;
  t.tteharabic = 0x0679;
  t.ttehfinalarabic = 0xfb67;
  t.ttehinitialarabic = 0xfb68;
  t.ttehmedialarabic = 0xfb69;
  t.tthabengali = 0x09a0;
  t.tthadeva = 0x0920;
  t.tthagujarati = 0x0aa0;
  t.tthagurmukhi = 0x0a20;
  t.tturned = 0x0287;
  t.tuhiragana = 0x3064;
  t.tukatakana = 0x30c4;
  t.tukatakanahalfwidth = 0xff82;
  t.tusmallhiragana = 0x3063;
  t.tusmallkatakana = 0x30c3;
  t.tusmallkatakanahalfwidth = 0xff6f;
  t.twelvecircle = 0x246b;
  t.twelveparen = 0x247f;
  t.twelveperiod = 0x2493;
  t.twelveroman = 0x217b;
  t.twentycircle = 0x2473;
  t.twentyhangzhou = 0x5344;
  t.twentyparen = 0x2487;
  t.twentyperiod = 0x249b;
  t.two = 0x0032;
  t.twoarabic = 0x0662;
  t.twobengali = 0x09e8;
  t.twocircle = 0x2461;
  t.twocircleinversesansserif = 0x278b;
  t.twodeva = 0x0968;
  t.twodotenleader = 0x2025;
  t.twodotleader = 0x2025;
  t.twodotleadervertical = 0xfe30;
  t.twogujarati = 0x0ae8;
  t.twogurmukhi = 0x0a68;
  t.twohackarabic = 0x0662;
  t.twohangzhou = 0x3022;
  t.twoideographicparen = 0x3221;
  t.twoinferior = 0x2082;
  t.twomonospace = 0xff12;
  t.twonumeratorbengali = 0x09f5;
  t.twooldstyle = 0xf732;
  t.twoparen = 0x2475;
  t.twoperiod = 0x2489;
  t.twopersian = 0x06f2;
  t.tworoman = 0x2171;
  t.twostroke = 0x01bb;
  t.twosuperior = 0x00b2;
  t.twothai = 0x0e52;
  t.twothirds = 0x2154;
  t.u = 0x0075;
  t.uacute = 0x00fa;
  t.ubar = 0x0289;
  t.ubengali = 0x0989;
  t.ubopomofo = 0x3128;
  t.ubreve = 0x016d;
  t.ucaron = 0x01d4;
  t.ucircle = 0x24e4;
  t.ucircumflex = 0x00fb;
  t.ucircumflexbelow = 0x1e77;
  t.ucyrillic = 0x0443;
  t.udattadeva = 0x0951;
  t.udblacute = 0x0171;
  t.udblgrave = 0x0215;
  t.udeva = 0x0909;
  t.udieresis = 0x00fc;
  t.udieresisacute = 0x01d8;
  t.udieresisbelow = 0x1e73;
  t.udieresiscaron = 0x01da;
  t.udieresiscyrillic = 0x04f1;
  t.udieresisgrave = 0x01dc;
  t.udieresismacron = 0x01d6;
  t.udotbelow = 0x1ee5;
  t.ugrave = 0x00f9;
  t.ugujarati = 0x0a89;
  t.ugurmukhi = 0x0a09;
  t.uhiragana = 0x3046;
  t.uhookabove = 0x1ee7;
  t.uhorn = 0x01b0;
  t.uhornacute = 0x1ee9;
  t.uhorndotbelow = 0x1ef1;
  t.uhorngrave = 0x1eeb;
  t.uhornhookabove = 0x1eed;
  t.uhorntilde = 0x1eef;
  t.uhungarumlaut = 0x0171;
  t.uhungarumlautcyrillic = 0x04f3;
  t.uinvertedbreve = 0x0217;
  t.ukatakana = 0x30a6;
  t.ukatakanahalfwidth = 0xff73;
  t.ukcyrillic = 0x0479;
  t.ukorean = 0x315c;
  t.umacron = 0x016b;
  t.umacroncyrillic = 0x04ef;
  t.umacrondieresis = 0x1e7b;
  t.umatragurmukhi = 0x0a41;
  t.umonospace = 0xff55;
  t.underscore = 0x005f;
  t.underscoredbl = 0x2017;
  t.underscoremonospace = 0xff3f;
  t.underscorevertical = 0xfe33;
  t.underscorewavy = 0xfe4f;
  t.union = 0x222a;
  t.universal = 0x2200;
  t.uogonek = 0x0173;
  t.uparen = 0x24b0;
  t.upblock = 0x2580;
  t.upperdothebrew = 0x05c4;
  t.upsilon = 0x03c5;
  t.upsilondieresis = 0x03cb;
  t.upsilondieresistonos = 0x03b0;
  t.upsilonlatin = 0x028a;
  t.upsilontonos = 0x03cd;
  t.uptackbelowcmb = 0x031d;
  t.uptackmod = 0x02d4;
  t.uragurmukhi = 0x0a73;
  t.uring = 0x016f;
  t.ushortcyrillic = 0x045e;
  t.usmallhiragana = 0x3045;
  t.usmallkatakana = 0x30a5;
  t.usmallkatakanahalfwidth = 0xff69;
  t.ustraightcyrillic = 0x04af;
  t.ustraightstrokecyrillic = 0x04b1;
  t.utilde = 0x0169;
  t.utildeacute = 0x1e79;
  t.utildebelow = 0x1e75;
  t.uubengali = 0x098a;
  t.uudeva = 0x090a;
  t.uugujarati = 0x0a8a;
  t.uugurmukhi = 0x0a0a;
  t.uumatragurmukhi = 0x0a42;
  t.uuvowelsignbengali = 0x09c2;
  t.uuvowelsigndeva = 0x0942;
  t.uuvowelsigngujarati = 0x0ac2;
  t.uvowelsignbengali = 0x09c1;
  t.uvowelsigndeva = 0x0941;
  t.uvowelsigngujarati = 0x0ac1;
  t.v = 0x0076;
  t.vadeva = 0x0935;
  t.vagujarati = 0x0ab5;
  t.vagurmukhi = 0x0a35;
  t.vakatakana = 0x30f7;
  t.vav = 0x05d5;
  t.vavdagesh = 0xfb35;
  t.vavdagesh65 = 0xfb35;
  t.vavdageshhebrew = 0xfb35;
  t.vavhebrew = 0x05d5;
  t.vavholam = 0xfb4b;
  t.vavholamhebrew = 0xfb4b;
  t.vavvavhebrew = 0x05f0;
  t.vavyodhebrew = 0x05f1;
  t.vcircle = 0x24e5;
  t.vdotbelow = 0x1e7f;
  t.vecyrillic = 0x0432;
  t.veharabic = 0x06a4;
  t.vehfinalarabic = 0xfb6b;
  t.vehinitialarabic = 0xfb6c;
  t.vehmedialarabic = 0xfb6d;
  t.vekatakana = 0x30f9;
  t.venus = 0x2640;
  t.verticalbar = 0x007c;
  t.verticallineabovecmb = 0x030d;
  t.verticallinebelowcmb = 0x0329;
  t.verticallinelowmod = 0x02cc;
  t.verticallinemod = 0x02c8;
  t.vewarmenian = 0x057e;
  t.vhook = 0x028b;
  t.vikatakana = 0x30f8;
  t.viramabengali = 0x09cd;
  t.viramadeva = 0x094d;
  t.viramagujarati = 0x0acd;
  t.visargabengali = 0x0983;
  t.visargadeva = 0x0903;
  t.visargagujarati = 0x0a83;
  t.vmonospace = 0xff56;
  t.voarmenian = 0x0578;
  t.voicediterationhiragana = 0x309e;
  t.voicediterationkatakana = 0x30fe;
  t.voicedmarkkana = 0x309b;
  t.voicedmarkkanahalfwidth = 0xff9e;
  t.vokatakana = 0x30fa;
  t.vparen = 0x24b1;
  t.vtilde = 0x1e7d;
  t.vturned = 0x028c;
  t.vuhiragana = 0x3094;
  t.vukatakana = 0x30f4;
  t.w = 0x0077;
  t.wacute = 0x1e83;
  t.waekorean = 0x3159;
  t.wahiragana = 0x308f;
  t.wakatakana = 0x30ef;
  t.wakatakanahalfwidth = 0xff9c;
  t.wakorean = 0x3158;
  t.wasmallhiragana = 0x308e;
  t.wasmallkatakana = 0x30ee;
  t.wattosquare = 0x3357;
  t.wavedash = 0x301c;
  t.wavyunderscorevertical = 0xfe34;
  t.wawarabic = 0x0648;
  t.wawfinalarabic = 0xfeee;
  t.wawhamzaabovearabic = 0x0624;
  t.wawhamzaabovefinalarabic = 0xfe86;
  t.wbsquare = 0x33dd;
  t.wcircle = 0x24e6;
  t.wcircumflex = 0x0175;
  t.wdieresis = 0x1e85;
  t.wdotaccent = 0x1e87;
  t.wdotbelow = 0x1e89;
  t.wehiragana = 0x3091;
  t.weierstrass = 0x2118;
  t.wekatakana = 0x30f1;
  t.wekorean = 0x315e;
  t.weokorean = 0x315d;
  t.wgrave = 0x1e81;
  t.whitebullet = 0x25e6;
  t.whitecircle = 0x25cb;
  t.whitecircleinverse = 0x25d9;
  t.whitecornerbracketleft = 0x300e;
  t.whitecornerbracketleftvertical = 0xfe43;
  t.whitecornerbracketright = 0x300f;
  t.whitecornerbracketrightvertical = 0xfe44;
  t.whitediamond = 0x25c7;
  t.whitediamondcontainingblacksmalldiamond = 0x25c8;
  t.whitedownpointingsmalltriangle = 0x25bf;
  t.whitedownpointingtriangle = 0x25bd;
  t.whiteleftpointingsmalltriangle = 0x25c3;
  t.whiteleftpointingtriangle = 0x25c1;
  t.whitelenticularbracketleft = 0x3016;
  t.whitelenticularbracketright = 0x3017;
  t.whiterightpointingsmalltriangle = 0x25b9;
  t.whiterightpointingtriangle = 0x25b7;
  t.whitesmallsquare = 0x25ab;
  t.whitesmilingface = 0x263a;
  t.whitesquare = 0x25a1;
  t.whitestar = 0x2606;
  t.whitetelephone = 0x260f;
  t.whitetortoiseshellbracketleft = 0x3018;
  t.whitetortoiseshellbracketright = 0x3019;
  t.whiteuppointingsmalltriangle = 0x25b5;
  t.whiteuppointingtriangle = 0x25b3;
  t.wihiragana = 0x3090;
  t.wikatakana = 0x30f0;
  t.wikorean = 0x315f;
  t.wmonospace = 0xff57;
  t.wohiragana = 0x3092;
  t.wokatakana = 0x30f2;
  t.wokatakanahalfwidth = 0xff66;
  t.won = 0x20a9;
  t.wonmonospace = 0xffe6;
  t.wowaenthai = 0x0e27;
  t.wparen = 0x24b2;
  t.wring = 0x1e98;
  t.wsuperior = 0x02b7;
  t.wturned = 0x028d;
  t.wynn = 0x01bf;
  t.x = 0x0078;
  t.xabovecmb = 0x033d;
  t.xbopomofo = 0x3112;
  t.xcircle = 0x24e7;
  t.xdieresis = 0x1e8d;
  t.xdotaccent = 0x1e8b;
  t.xeharmenian = 0x056d;
  t.xi = 0x03be;
  t.xmonospace = 0xff58;
  t.xparen = 0x24b3;
  t.xsuperior = 0x02e3;
  t.y = 0x0079;
  t.yaadosquare = 0x334e;
  t.yabengali = 0x09af;
  t.yacute = 0x00fd;
  t.yadeva = 0x092f;
  t.yaekorean = 0x3152;
  t.yagujarati = 0x0aaf;
  t.yagurmukhi = 0x0a2f;
  t.yahiragana = 0x3084;
  t.yakatakana = 0x30e4;
  t.yakatakanahalfwidth = 0xff94;
  t.yakorean = 0x3151;
  t.yamakkanthai = 0x0e4e;
  t.yasmallhiragana = 0x3083;
  t.yasmallkatakana = 0x30e3;
  t.yasmallkatakanahalfwidth = 0xff6c;
  t.yatcyrillic = 0x0463;
  t.ycircle = 0x24e8;
  t.ycircumflex = 0x0177;
  t.ydieresis = 0x00ff;
  t.ydotaccent = 0x1e8f;
  t.ydotbelow = 0x1ef5;
  t.yeharabic = 0x064a;
  t.yehbarreearabic = 0x06d2;
  t.yehbarreefinalarabic = 0xfbaf;
  t.yehfinalarabic = 0xfef2;
  t.yehhamzaabovearabic = 0x0626;
  t.yehhamzaabovefinalarabic = 0xfe8a;
  t.yehhamzaaboveinitialarabic = 0xfe8b;
  t.yehhamzaabovemedialarabic = 0xfe8c;
  t.yehinitialarabic = 0xfef3;
  t.yehmedialarabic = 0xfef4;
  t.yehmeeminitialarabic = 0xfcdd;
  t.yehmeemisolatedarabic = 0xfc58;
  t.yehnoonfinalarabic = 0xfc94;
  t.yehthreedotsbelowarabic = 0x06d1;
  t.yekorean = 0x3156;
  t.yen = 0x00a5;
  t.yenmonospace = 0xffe5;
  t.yeokorean = 0x3155;
  t.yeorinhieuhkorean = 0x3186;
  t.yerahbenyomohebrew = 0x05aa;
  t.yerahbenyomolefthebrew = 0x05aa;
  t.yericyrillic = 0x044b;
  t.yerudieresiscyrillic = 0x04f9;
  t.yesieungkorean = 0x3181;
  t.yesieungpansioskorean = 0x3183;
  t.yesieungsioskorean = 0x3182;
  t.yetivhebrew = 0x059a;
  t.ygrave = 0x1ef3;
  t.yhook = 0x01b4;
  t.yhookabove = 0x1ef7;
  t.yiarmenian = 0x0575;
  t.yicyrillic = 0x0457;
  t.yikorean = 0x3162;
  t.yinyang = 0x262f;
  t.yiwnarmenian = 0x0582;
  t.ymonospace = 0xff59;
  t.yod = 0x05d9;
  t.yoddagesh = 0xfb39;
  t.yoddageshhebrew = 0xfb39;
  t.yodhebrew = 0x05d9;
  t.yodyodhebrew = 0x05f2;
  t.yodyodpatahhebrew = 0xfb1f;
  t.yohiragana = 0x3088;
  t.yoikorean = 0x3189;
  t.yokatakana = 0x30e8;
  t.yokatakanahalfwidth = 0xff96;
  t.yokorean = 0x315b;
  t.yosmallhiragana = 0x3087;
  t.yosmallkatakana = 0x30e7;
  t.yosmallkatakanahalfwidth = 0xff6e;
  t.yotgreek = 0x03f3;
  t.yoyaekorean = 0x3188;
  t.yoyakorean = 0x3187;
  t.yoyakthai = 0x0e22;
  t.yoyingthai = 0x0e0d;
  t.yparen = 0x24b4;
  t.ypogegrammeni = 0x037a;
  t.ypogegrammenigreekcmb = 0x0345;
  t.yr = 0x01a6;
  t.yring = 0x1e99;
  t.ysuperior = 0x02b8;
  t.ytilde = 0x1ef9;
  t.yturned = 0x028e;
  t.yuhiragana = 0x3086;
  t.yuikorean = 0x318c;
  t.yukatakana = 0x30e6;
  t.yukatakanahalfwidth = 0xff95;
  t.yukorean = 0x3160;
  t.yusbigcyrillic = 0x046b;
  t.yusbigiotifiedcyrillic = 0x046d;
  t.yuslittlecyrillic = 0x0467;
  t.yuslittleiotifiedcyrillic = 0x0469;
  t.yusmallhiragana = 0x3085;
  t.yusmallkatakana = 0x30e5;
  t.yusmallkatakanahalfwidth = 0xff6d;
  t.yuyekorean = 0x318b;
  t.yuyeokorean = 0x318a;
  t.yyabengali = 0x09df;
  t.yyadeva = 0x095f;
  t.z = 0x007a;
  t.zaarmenian = 0x0566;
  t.zacute = 0x017a;
  t.zadeva = 0x095b;
  t.zagurmukhi = 0x0a5b;
  t.zaharabic = 0x0638;
  t.zahfinalarabic = 0xfec6;
  t.zahinitialarabic = 0xfec7;
  t.zahiragana = 0x3056;
  t.zahmedialarabic = 0xfec8;
  t.zainarabic = 0x0632;
  t.zainfinalarabic = 0xfeb0;
  t.zakatakana = 0x30b6;
  t.zaqefgadolhebrew = 0x0595;
  t.zaqefqatanhebrew = 0x0594;
  t.zarqahebrew = 0x0598;
  t.zayin = 0x05d6;
  t.zayindagesh = 0xfb36;
  t.zayindageshhebrew = 0xfb36;
  t.zayinhebrew = 0x05d6;
  t.zbopomofo = 0x3117;
  t.zcaron = 0x017e;
  t.zcircle = 0x24e9;
  t.zcircumflex = 0x1e91;
  t.zcurl = 0x0291;
  t.zdot = 0x017c;
  t.zdotaccent = 0x017c;
  t.zdotbelow = 0x1e93;
  t.zecyrillic = 0x0437;
  t.zedescendercyrillic = 0x0499;
  t.zedieresiscyrillic = 0x04df;
  t.zehiragana = 0x305c;
  t.zekatakana = 0x30bc;
  t.zero = 0x0030;
  t.zeroarabic = 0x0660;
  t.zerobengali = 0x09e6;
  t.zerodeva = 0x0966;
  t.zerogujarati = 0x0ae6;
  t.zerogurmukhi = 0x0a66;
  t.zerohackarabic = 0x0660;
  t.zeroinferior = 0x2080;
  t.zeromonospace = 0xff10;
  t.zerooldstyle = 0xf730;
  t.zeropersian = 0x06f0;
  t.zerosuperior = 0x2070;
  t.zerothai = 0x0e50;
  t.zerowidthjoiner = 0xfeff;
  t.zerowidthnonjoiner = 0x200c;
  t.zerowidthspace = 0x200b;
  t.zeta = 0x03b6;
  t.zhbopomofo = 0x3113;
  t.zhearmenian = 0x056a;
  t.zhebrevecyrillic = 0x04c2;
  t.zhecyrillic = 0x0436;
  t.zhedescendercyrillic = 0x0497;
  t.zhedieresiscyrillic = 0x04dd;
  t.zihiragana = 0x3058;
  t.zikatakana = 0x30b8;
  t.zinorhebrew = 0x05ae;
  t.zlinebelow = 0x1e95;
  t.zmonospace = 0xff5a;
  t.zohiragana = 0x305e;
  t.zokatakana = 0x30be;
  t.zparen = 0x24b5;
  t.zretroflexhook = 0x0290;
  t.zstroke = 0x01b6;
  t.zuhiragana = 0x305a;
  t.zukatakana = 0x30ba;
  t[".notdef"] = 0x0000;
  t.angbracketleftbig = 0x2329;
  t.angbracketleftBig = 0x2329;
  t.angbracketleftbigg = 0x2329;
  t.angbracketleftBigg = 0x2329;
  t.angbracketrightBig = 0x232a;
  t.angbracketrightbig = 0x232a;
  t.angbracketrightBigg = 0x232a;
  t.angbracketrightbigg = 0x232a;
  t.arrowhookleft = 0x21aa;
  t.arrowhookright = 0x21a9;
  t.arrowlefttophalf = 0x21bc;
  t.arrowleftbothalf = 0x21bd;
  t.arrownortheast = 0x2197;
  t.arrownorthwest = 0x2196;
  t.arrowrighttophalf = 0x21c0;
  t.arrowrightbothalf = 0x21c1;
  t.arrowsoutheast = 0x2198;
  t.arrowsouthwest = 0x2199;
  t.backslashbig = 0x2216;
  t.backslashBig = 0x2216;
  t.backslashBigg = 0x2216;
  t.backslashbigg = 0x2216;
  t.bardbl = 0x2016;
  t.bracehtipdownleft = 0xfe37;
  t.bracehtipdownright = 0xfe37;
  t.bracehtipupleft = 0xfe38;
  t.bracehtipupright = 0xfe38;
  t.braceleftBig = 0x007b;
  t.braceleftbig = 0x007b;
  t.braceleftbigg = 0x007b;
  t.braceleftBigg = 0x007b;
  t.bracerightBig = 0x007d;
  t.bracerightbig = 0x007d;
  t.bracerightbigg = 0x007d;
  t.bracerightBigg = 0x007d;
  t.bracketleftbig = 0x005b;
  t.bracketleftBig = 0x005b;
  t.bracketleftbigg = 0x005b;
  t.bracketleftBigg = 0x005b;
  t.bracketrightBig = 0x005d;
  t.bracketrightbig = 0x005d;
  t.bracketrightbigg = 0x005d;
  t.bracketrightBigg = 0x005d;
  t.ceilingleftbig = 0x2308;
  t.ceilingleftBig = 0x2308;
  t.ceilingleftBigg = 0x2308;
  t.ceilingleftbigg = 0x2308;
  t.ceilingrightbig = 0x2309;
  t.ceilingrightBig = 0x2309;
  t.ceilingrightbigg = 0x2309;
  t.ceilingrightBigg = 0x2309;
  t.circledotdisplay = 0x2299;
  t.circledottext = 0x2299;
  t.circlemultiplydisplay = 0x2297;
  t.circlemultiplytext = 0x2297;
  t.circleplusdisplay = 0x2295;
  t.circleplustext = 0x2295;
  t.contintegraldisplay = 0x222e;
  t.contintegraltext = 0x222e;
  t.coproductdisplay = 0x2210;
  t.coproducttext = 0x2210;
  t.floorleftBig = 0x230a;
  t.floorleftbig = 0x230a;
  t.floorleftbigg = 0x230a;
  t.floorleftBigg = 0x230a;
  t.floorrightbig = 0x230b;
  t.floorrightBig = 0x230b;
  t.floorrightBigg = 0x230b;
  t.floorrightbigg = 0x230b;
  t.hatwide = 0x0302;
  t.hatwider = 0x0302;
  t.hatwidest = 0x0302;
  t.intercal = 0x1d40;
  t.integraldisplay = 0x222b;
  t.integraltext = 0x222b;
  t.intersectiondisplay = 0x22c2;
  t.intersectiontext = 0x22c2;
  t.logicalanddisplay = 0x2227;
  t.logicalandtext = 0x2227;
  t.logicalordisplay = 0x2228;
  t.logicalortext = 0x2228;
  t.parenleftBig = 0x0028;
  t.parenleftbig = 0x0028;
  t.parenleftBigg = 0x0028;
  t.parenleftbigg = 0x0028;
  t.parenrightBig = 0x0029;
  t.parenrightbig = 0x0029;
  t.parenrightBigg = 0x0029;
  t.parenrightbigg = 0x0029;
  t.prime = 0x2032;
  t.productdisplay = 0x220f;
  t.producttext = 0x220f;
  t.radicalbig = 0x221a;
  t.radicalBig = 0x221a;
  t.radicalBigg = 0x221a;
  t.radicalbigg = 0x221a;
  t.radicalbt = 0x221a;
  t.radicaltp = 0x221a;
  t.radicalvertex = 0x221a;
  t.slashbig = 0x002f;
  t.slashBig = 0x002f;
  t.slashBigg = 0x002f;
  t.slashbigg = 0x002f;
  t.summationdisplay = 0x2211;
  t.summationtext = 0x2211;
  t.tildewide = 0x02dc;
  t.tildewider = 0x02dc;
  t.tildewidest = 0x02dc;
  t.uniondisplay = 0x22c3;
  t.unionmultidisplay = 0x228e;
  t.unionmultitext = 0x228e;
  t.unionsqdisplay = 0x2294;
  t.unionsqtext = 0x2294;
  t.uniontext = 0x22c3;
  t.vextenddouble = 0x2225;
  t.vextendsingle = 0x2223;
});
exports.getGlyphsUnicode = getGlyphsUnicode;
const getDingbatsGlyphsUnicode = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.space = 0x0020;
  t.a1 = 0x2701;
  t.a2 = 0x2702;
  t.a202 = 0x2703;
  t.a3 = 0x2704;
  t.a4 = 0x260e;
  t.a5 = 0x2706;
  t.a119 = 0x2707;
  t.a118 = 0x2708;
  t.a117 = 0x2709;
  t.a11 = 0x261b;
  t.a12 = 0x261e;
  t.a13 = 0x270c;
  t.a14 = 0x270d;
  t.a15 = 0x270e;
  t.a16 = 0x270f;
  t.a105 = 0x2710;
  t.a17 = 0x2711;
  t.a18 = 0x2712;
  t.a19 = 0x2713;
  t.a20 = 0x2714;
  t.a21 = 0x2715;
  t.a22 = 0x2716;
  t.a23 = 0x2717;
  t.a24 = 0x2718;
  t.a25 = 0x2719;
  t.a26 = 0x271a;
  t.a27 = 0x271b;
  t.a28 = 0x271c;
  t.a6 = 0x271d;
  t.a7 = 0x271e;
  t.a8 = 0x271f;
  t.a9 = 0x2720;
  t.a10 = 0x2721;
  t.a29 = 0x2722;
  t.a30 = 0x2723;
  t.a31 = 0x2724;
  t.a32 = 0x2725;
  t.a33 = 0x2726;
  t.a34 = 0x2727;
  t.a35 = 0x2605;
  t.a36 = 0x2729;
  t.a37 = 0x272a;
  t.a38 = 0x272b;
  t.a39 = 0x272c;
  t.a40 = 0x272d;
  t.a41 = 0x272e;
  t.a42 = 0x272f;
  t.a43 = 0x2730;
  t.a44 = 0x2731;
  t.a45 = 0x2732;
  t.a46 = 0x2733;
  t.a47 = 0x2734;
  t.a48 = 0x2735;
  t.a49 = 0x2736;
  t.a50 = 0x2737;
  t.a51 = 0x2738;
  t.a52 = 0x2739;
  t.a53 = 0x273a;
  t.a54 = 0x273b;
  t.a55 = 0x273c;
  t.a56 = 0x273d;
  t.a57 = 0x273e;
  t.a58 = 0x273f;
  t.a59 = 0x2740;
  t.a60 = 0x2741;
  t.a61 = 0x2742;
  t.a62 = 0x2743;
  t.a63 = 0x2744;
  t.a64 = 0x2745;
  t.a65 = 0x2746;
  t.a66 = 0x2747;
  t.a67 = 0x2748;
  t.a68 = 0x2749;
  t.a69 = 0x274a;
  t.a70 = 0x274b;
  t.a71 = 0x25cf;
  t.a72 = 0x274d;
  t.a73 = 0x25a0;
  t.a74 = 0x274f;
  t.a203 = 0x2750;
  t.a75 = 0x2751;
  t.a204 = 0x2752;
  t.a76 = 0x25b2;
  t.a77 = 0x25bc;
  t.a78 = 0x25c6;
  t.a79 = 0x2756;
  t.a81 = 0x25d7;
  t.a82 = 0x2758;
  t.a83 = 0x2759;
  t.a84 = 0x275a;
  t.a97 = 0x275b;
  t.a98 = 0x275c;
  t.a99 = 0x275d;
  t.a100 = 0x275e;
  t.a101 = 0x2761;
  t.a102 = 0x2762;
  t.a103 = 0x2763;
  t.a104 = 0x2764;
  t.a106 = 0x2765;
  t.a107 = 0x2766;
  t.a108 = 0x2767;
  t.a112 = 0x2663;
  t.a111 = 0x2666;
  t.a110 = 0x2665;
  t.a109 = 0x2660;
  t.a120 = 0x2460;
  t.a121 = 0x2461;
  t.a122 = 0x2462;
  t.a123 = 0x2463;
  t.a124 = 0x2464;
  t.a125 = 0x2465;
  t.a126 = 0x2466;
  t.a127 = 0x2467;
  t.a128 = 0x2468;
  t.a129 = 0x2469;
  t.a130 = 0x2776;
  t.a131 = 0x2777;
  t.a132 = 0x2778;
  t.a133 = 0x2779;
  t.a134 = 0x277a;
  t.a135 = 0x277b;
  t.a136 = 0x277c;
  t.a137 = 0x277d;
  t.a138 = 0x277e;
  t.a139 = 0x277f;
  t.a140 = 0x2780;
  t.a141 = 0x2781;
  t.a142 = 0x2782;
  t.a143 = 0x2783;
  t.a144 = 0x2784;
  t.a145 = 0x2785;
  t.a146 = 0x2786;
  t.a147 = 0x2787;
  t.a148 = 0x2788;
  t.a149 = 0x2789;
  t.a150 = 0x278a;
  t.a151 = 0x278b;
  t.a152 = 0x278c;
  t.a153 = 0x278d;
  t.a154 = 0x278e;
  t.a155 = 0x278f;
  t.a156 = 0x2790;
  t.a157 = 0x2791;
  t.a158 = 0x2792;
  t.a159 = 0x2793;
  t.a160 = 0x2794;
  t.a161 = 0x2192;
  t.a163 = 0x2194;
  t.a164 = 0x2195;
  t.a196 = 0x2798;
  t.a165 = 0x2799;
  t.a192 = 0x279a;
  t.a166 = 0x279b;
  t.a167 = 0x279c;
  t.a168 = 0x279d;
  t.a169 = 0x279e;
  t.a170 = 0x279f;
  t.a171 = 0x27a0;
  t.a172 = 0x27a1;
  t.a173 = 0x27a2;
  t.a162 = 0x27a3;
  t.a174 = 0x27a4;
  t.a175 = 0x27a5;
  t.a176 = 0x27a6;
  t.a177 = 0x27a7;
  t.a178 = 0x27a8;
  t.a179 = 0x27a9;
  t.a193 = 0x27aa;
  t.a180 = 0x27ab;
  t.a199 = 0x27ac;
  t.a181 = 0x27ad;
  t.a200 = 0x27ae;
  t.a182 = 0x27af;
  t.a201 = 0x27b1;
  t.a183 = 0x27b2;
  t.a184 = 0x27b3;
  t.a197 = 0x27b4;
  t.a185 = 0x27b5;
  t.a194 = 0x27b6;
  t.a198 = 0x27b7;
  t.a186 = 0x27b8;
  t.a195 = 0x27b9;
  t.a187 = 0x27ba;
  t.a188 = 0x27bb;
  t.a189 = 0x27bc;
  t.a190 = 0x27bd;
  t.a191 = 0x27be;
  t.a89 = 0x2768;
  t.a90 = 0x2769;
  t.a93 = 0x276a;
  t.a94 = 0x276b;
  t.a91 = 0x276c;
  t.a92 = 0x276d;
  t.a205 = 0x276e;
  t.a85 = 0x276f;
  t.a206 = 0x2770;
  t.a86 = 0x2771;
  t.a87 = 0x2772;
  t.a88 = 0x2773;
  t.a95 = 0x2774;
  t.a96 = 0x2775;
  t[".notdef"] = 0x0000;
});
exports.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearUnicodeCaches = clearUnicodeCaches;
exports.getCharUnicodeCategory = getCharUnicodeCategory;
exports.getUnicodeForGlyph = getUnicodeForGlyph;
exports.getUnicodeRangeFor = getUnicodeRangeFor;
exports.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
var _core_utils = __w_pdfjs_require__(3);
const getSpecialPUASymbols = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[63721] = 0x00a9;
  t[63193] = 0x00a9;
  t[63720] = 0x00ae;
  t[63194] = 0x00ae;
  t[63722] = 0x2122;
  t[63195] = 0x2122;
  t[63729] = 0x23a7;
  t[63730] = 0x23a8;
  t[63731] = 0x23a9;
  t[63740] = 0x23ab;
  t[63741] = 0x23ac;
  t[63742] = 0x23ad;
  t[63726] = 0x23a1;
  t[63727] = 0x23a2;
  t[63728] = 0x23a3;
  t[63737] = 0x23a4;
  t[63738] = 0x23a5;
  t[63739] = 0x23a6;
  t[63723] = 0x239b;
  t[63724] = 0x239c;
  t[63725] = 0x239d;
  t[63734] = 0x239e;
  t[63735] = 0x239f;
  t[63736] = 0x23a0;
});
function mapSpecialUnicodeValues(code) {
  if (code >= 0xfff0 && code <= 0xffff) {
    return 0;
  } else if (code >= 0xf600 && code <= 0xf8ff) {
    return getSpecialPUASymbols()[code] || code;
  } else if (code === 0x00ad) {
    return 0x002d;
  }
  return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
  let unicode = glyphsUnicodeMap[name];
  if (unicode !== undefined) {
    return unicode;
  }
  if (!name) {
    return -1;
  }
  if (name[0] === "u") {
    const nameLen = name.length;
    let hexStr;
    if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
      hexStr = name.substring(3);
    } else if (nameLen >= 5 && nameLen <= 7) {
      hexStr = name.substring(1);
    } else {
      return -1;
    }
    if (hexStr === hexStr.toUpperCase()) {
      unicode = parseInt(hexStr, 16);
      if (unicode >= 0) {
        return unicode;
      }
    }
  }
  return -1;
}
const UnicodeRanges = [[0x0000, 0x007f], [0x0080, 0x00ff], [0x0100, 0x017f], [0x0180, 0x024f], [0x0250, 0x02af, 0x1d00, 0x1d7f, 0x1d80, 0x1dbf], [0x02b0, 0x02ff, 0xa700, 0xa71f], [0x0300, 0x036f, 0x1dc0, 0x1dff], [0x0370, 0x03ff], [0x2c80, 0x2cff], [0x0400, 0x04ff, 0x0500, 0x052f, 0x2de0, 0x2dff, 0xa640, 0xa69f], [0x0530, 0x058f], [0x0590, 0x05ff], [0xa500, 0xa63f], [0x0600, 0x06ff, 0x0750, 0x077f], [0x07c0, 0x07ff], [0x0900, 0x097f], [0x0980, 0x09ff], [0x0a00, 0x0a7f], [0x0a80, 0x0aff], [0x0b00, 0x0b7f], [0x0b80, 0x0bff], [0x0c00, 0x0c7f], [0x0c80, 0x0cff], [0x0d00, 0x0d7f], [0x0e00, 0x0e7f], [0x0e80, 0x0eff], [0x10a0, 0x10ff, 0x2d00, 0x2d2f], [0x1b00, 0x1b7f], [0x1100, 0x11ff], [0x1e00, 0x1eff, 0x2c60, 0x2c7f, 0xa720, 0xa7ff], [0x1f00, 0x1fff], [0x2000, 0x206f, 0x2e00, 0x2e7f], [0x2070, 0x209f], [0x20a0, 0x20cf], [0x20d0, 0x20ff], [0x2100, 0x214f], [0x2150, 0x218f], [0x2190, 0x21ff, 0x27f0, 0x27ff, 0x2900, 0x297f, 0x2b00, 0x2bff], [0x2200, 0x22ff, 0x2a00, 0x2aff, 0x27c0, 0x27ef, 0x2980, 0x29ff], [0x2300, 0x23ff], [0x2400, 0x243f], [0x2440, 0x245f], [0x2460, 0x24ff], [0x2500, 0x257f], [0x2580, 0x259f], [0x25a0, 0x25ff], [0x2600, 0x26ff], [0x2700, 0x27bf], [0x3000, 0x303f], [0x3040, 0x309f], [0x30a0, 0x30ff, 0x31f0, 0x31ff], [0x3100, 0x312f, 0x31a0, 0x31bf], [0x3130, 0x318f], [0xa840, 0xa87f], [0x3200, 0x32ff], [0x3300, 0x33ff], [0xac00, 0xd7af], [0xd800, 0xdfff], [0x10900, 0x1091f], [0x4e00, 0x9fff, 0x2e80, 0x2eff, 0x2f00, 0x2fdf, 0x2ff0, 0x2fff, 0x3400, 0x4dbf, 0x20000, 0x2a6df, 0x3190, 0x319f], [0xe000, 0xf8ff], [0x31c0, 0x31ef, 0xf900, 0xfaff, 0x2f800, 0x2fa1f], [0xfb00, 0xfb4f], [0xfb50, 0xfdff], [0xfe20, 0xfe2f], [0xfe10, 0xfe1f], [0xfe50, 0xfe6f], [0xfe70, 0xfeff], [0xff00, 0xffef], [0xfff0, 0xffff], [0x0f00, 0x0fff], [0x0700, 0x074f], [0x0780, 0x07bf], [0x0d80, 0x0dff], [0x1000, 0x109f], [0x1200, 0x137f, 0x1380, 0x139f, 0x2d80, 0x2ddf], [0x13a0, 0x13ff], [0x1400, 0x167f], [0x1680, 0x169f], [0x16a0, 0x16ff], [0x1780, 0x17ff], [0x1800, 0x18af], [0x2800, 0x28ff], [0xa000, 0xa48f], [0x1700, 0x171f, 0x1720, 0x173f, 0x1740, 0x175f, 0x1760, 0x177f], [0x10300, 0x1032f], [0x10330, 0x1034f], [0x10400, 0x1044f], [0x1d000, 0x1d0ff, 0x1d100, 0x1d1ff, 0x1d200, 0x1d24f], [0x1d400, 0x1d7ff], [0xff000, 0xffffd], [0xfe00, 0xfe0f, 0xe0100, 0xe01ef], [0xe0000, 0xe007f], [0x1900, 0x194f], [0x1950, 0x197f], [0x1980, 0x19df], [0x1a00, 0x1a1f], [0x2c00, 0x2c5f], [0x2d30, 0x2d7f], [0x4dc0, 0x4dff], [0xa800, 0xa82f], [0x10000, 0x1007f, 0x10080, 0x100ff, 0x10100, 0x1013f], [0x10140, 0x1018f], [0x10380, 0x1039f], [0x103a0, 0x103df], [0x10450, 0x1047f], [0x10480, 0x104af], [0x10800, 0x1083f], [0x10a00, 0x10a5f], [0x1d300, 0x1d35f], [0x12000, 0x123ff, 0x12400, 0x1247f], [0x1d360, 0x1d37f], [0x1b80, 0x1bbf], [0x1c00, 0x1c4f], [0x1c50, 0x1c7f], [0xa880, 0xa8df], [0xa900, 0xa92f], [0xa930, 0xa95f], [0xaa00, 0xaa5f], [0x10190, 0x101cf], [0x101d0, 0x101ff], [0x102a0, 0x102df, 0x10280, 0x1029f, 0x10920, 0x1093f], [0x1f030, 0x1f09f, 0x1f000, 0x1f02f]];
function getUnicodeRangeFor(value, lastPosition = -1) {
  if (lastPosition !== -1) {
    const range = UnicodeRanges[lastPosition];
    for (let i = 0, ii = range.length; i < ii; i += 2) {
      if (value >= range[i] && value <= range[i + 1]) {
        return lastPosition;
      }
    }
  }
  for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
    const range = UnicodeRanges[i];
    for (let j = 0, jj = range.length; j < jj; j += 2) {
      if (value >= range[j] && value <= range[j + 1]) {
        return i;
      }
    }
  }
  return -1;
}
const SpecialCharRegExp = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
const CategoryCache = new Map();
function getCharUnicodeCategory(char) {
  const cachedCategory = CategoryCache.get(char);
  if (cachedCategory) {
    return cachedCategory;
  }
  const groups = char.match(SpecialCharRegExp);
  const category = {
    isWhitespace: !!groups?.[1],
    isZeroWidthDiacritic: !!groups?.[2],
    isInvisibleFormatMark: !!groups?.[3]
  };
  CategoryCache.set(char, category);
  return category;
}
function clearUnicodeCaches() {
  CategoryCache.clear();
}

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSerifFonts = exports.getNonStdFontMap = exports.getGlyphMapForStandardFonts = exports.getFontNameToFileMap = void 0;
exports.getStandardFontName = getStandardFontName;
exports.getSymbolsFonts = exports.getSupplementalGlyphMapForCalibri = exports.getSupplementalGlyphMapForArialBlack = exports.getStdFontMap = void 0;
exports.isKnownFontName = isKnownFontName;
var _core_utils = __w_pdfjs_require__(3);
var _fonts_utils = __w_pdfjs_require__(38);
const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Times-Roman"] = "Times-Roman";
  t.Helvetica = "Helvetica";
  t.Courier = "Courier";
  t.Symbol = "Symbol";
  t["Times-Bold"] = "Times-Bold";
  t["Helvetica-Bold"] = "Helvetica-Bold";
  t["Courier-Bold"] = "Courier-Bold";
  t.ZapfDingbats = "ZapfDingbats";
  t["Times-Italic"] = "Times-Italic";
  t["Helvetica-Oblique"] = "Helvetica-Oblique";
  t["Courier-Oblique"] = "Courier-Oblique";
  t["Times-BoldItalic"] = "Times-BoldItalic";
  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  t["Courier-BoldOblique"] = "Courier-BoldOblique";
  t.ArialNarrow = "Helvetica";
  t["ArialNarrow-Bold"] = "Helvetica-Bold";
  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
  t.ArialBlack = "Helvetica";
  t["ArialBlack-Bold"] = "Helvetica-Bold";
  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialBlack-Italic"] = "Helvetica-Oblique";
  t["Arial-Black"] = "Helvetica";
  t["Arial-Black-Bold"] = "Helvetica-Bold";
  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Black-Italic"] = "Helvetica-Oblique";
  t.Arial = "Helvetica";
  t["Arial-Bold"] = "Helvetica-Bold";
  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Italic"] = "Helvetica-Oblique";
  t.ArialMT = "Helvetica";
  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT"] = "Helvetica-Bold";
  t["Arial-ItalicMT"] = "Helvetica-Oblique";
  t["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT-Bold"] = "Helvetica-Bold";
  t["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
  t.ArialUnicodeMS = "Helvetica";
  t["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
  t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
  t["Courier-BoldItalic"] = "Courier-BoldOblique";
  t["Courier-Italic"] = "Courier-Oblique";
  t.CourierNew = "Courier";
  t["CourierNew-Bold"] = "Courier-Bold";
  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  t["CourierNew-Italic"] = "Courier-Oblique";
  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  t["CourierNewPS-BoldMT"] = "Courier-Bold";
  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  t.CourierNewPSMT = "Courier";
  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  t["Helvetica-Italic"] = "Helvetica-Oblique";
  t["Symbol-Bold"] = "Symbol";
  t["Symbol-BoldItalic"] = "Symbol";
  t["Symbol-Italic"] = "Symbol";
  t.TimesNewRoman = "Times-Roman";
  t["TimesNewRoman-Bold"] = "Times-Bold";
  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRoman-Italic"] = "Times-Italic";
  t.TimesNewRomanPS = "Times-Roman";
  t["TimesNewRomanPS-Bold"] = "Times-Bold";
  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  t["TimesNewRomanPS-Italic"] = "Times-Italic";
  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  t.TimesNewRomanPSMT = "Times-Roman";
  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
exports.getStdFontMap = getStdFontMap;
const getFontNameToFileMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = "FoxitFixed.pfb";
  t["Courier-Bold"] = "FoxitFixedBold.pfb";
  t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
  t["Courier-Oblique"] = "FoxitFixedItalic.pfb";
  t.Helvetica = "LiberationSans-Regular.ttf";
  t["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
  t["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
  t["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
  t["Times-Roman"] = "FoxitSerif.pfb";
  t["Times-Bold"] = "FoxitSerifBold.pfb";
  t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
  t["Times-Italic"] = "FoxitSerifItalic.pfb";
  t.Symbol = "FoxitSymbol.pfb";
  t.ZapfDingbats = "FoxitDingbats.pfb";
  t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
  t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
  t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
  t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
});
exports.getFontNameToFileMap = getFontNameToFileMap;
const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Calibri = "Helvetica";
  t["Calibri-Bold"] = "Helvetica-Bold";
  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  t["Calibri-Italic"] = "Helvetica-Oblique";
  t.CenturyGothic = "Helvetica";
  t["CenturyGothic-Bold"] = "Helvetica-Bold";
  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
  t.ComicSansMS = "Comic Sans MS";
  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  t.Impact = "Helvetica";
  t["ItcSymbol-Bold"] = "Helvetica-Bold";
  t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
  t["ItcSymbol-Book"] = "Helvetica";
  t["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
  t["ItcSymbol-Medium"] = "Helvetica";
  t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
  t.LucidaConsole = "Courier";
  t["LucidaConsole-Bold"] = "Courier-Bold";
  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  t["LucidaConsole-Italic"] = "Courier-Oblique";
  t["LucidaSans-Demi"] = "Helvetica-Bold";
  t["MS-Gothic"] = "MS Gothic";
  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
  t["MS-Mincho"] = "MS Mincho";
  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
  t["MS-PGothic"] = "MS PGothic";
  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
  t["MS-PMincho"] = "MS PMincho";
  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
  t.NuptialScript = "Times-Italic";
  t.SegoeUISymbol = "Helvetica";
});
exports.getNonStdFontMap = getNonStdFontMap;
const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Adobe Jenson"] = true;
  t["Adobe Text"] = true;
  t.Albertus = true;
  t.Aldus = true;
  t.Alexandria = true;
  t.Algerian = true;
  t["American Typewriter"] = true;
  t.Antiqua = true;
  t.Apex = true;
  t.Arno = true;
  t.Aster = true;
  t.Aurora = true;
  t.Baskerville = true;
  t.Bell = true;
  t.Bembo = true;
  t["Bembo Schoolbook"] = true;
  t.Benguiat = true;
  t["Berkeley Old Style"] = true;
  t["Bernhard Modern"] = true;
  t["Berthold City"] = true;
  t.Bodoni = true;
  t["Bauer Bodoni"] = true;
  t["Book Antiqua"] = true;
  t.Bookman = true;
  t["Bordeaux Roman"] = true;
  t["Californian FB"] = true;
  t.Calisto = true;
  t.Calvert = true;
  t.Capitals = true;
  t.Cambria = true;
  t.Cartier = true;
  t.Caslon = true;
  t.Catull = true;
  t.Centaur = true;
  t["Century Old Style"] = true;
  t["Century Schoolbook"] = true;
  t.Chaparral = true;
  t["Charis SIL"] = true;
  t.Cheltenham = true;
  t["Cholla Slab"] = true;
  t.Clarendon = true;
  t.Clearface = true;
  t.Cochin = true;
  t.Colonna = true;
  t["Computer Modern"] = true;
  t["Concrete Roman"] = true;
  t.Constantia = true;
  t["Cooper Black"] = true;
  t.Corona = true;
  t.Ecotype = true;
  t.Egyptienne = true;
  t.Elephant = true;
  t.Excelsior = true;
  t.Fairfield = true;
  t["FF Scala"] = true;
  t.Folkard = true;
  t.Footlight = true;
  t.FreeSerif = true;
  t["Friz Quadrata"] = true;
  t.Garamond = true;
  t.Gentium = true;
  t.Georgia = true;
  t.Gloucester = true;
  t["Goudy Old Style"] = true;
  t["Goudy Schoolbook"] = true;
  t["Goudy Pro Font"] = true;
  t.Granjon = true;
  t["Guardian Egyptian"] = true;
  t.Heather = true;
  t.Hercules = true;
  t["High Tower Text"] = true;
  t.Hiroshige = true;
  t["Hoefler Text"] = true;
  t["Humana Serif"] = true;
  t.Imprint = true;
  t["Ionic No. 5"] = true;
  t.Janson = true;
  t.Joanna = true;
  t.Korinna = true;
  t.Lexicon = true;
  t.LiberationSerif = true;
  t["Liberation Serif"] = true;
  t["Linux Libertine"] = true;
  t.Literaturnaya = true;
  t.Lucida = true;
  t["Lucida Bright"] = true;
  t.Melior = true;
  t.Memphis = true;
  t.Miller = true;
  t.Minion = true;
  t.Modern = true;
  t["Mona Lisa"] = true;
  t["Mrs Eaves"] = true;
  t["MS Serif"] = true;
  t["Museo Slab"] = true;
  t["New York"] = true;
  t["Nimbus Roman"] = true;
  t["NPS Rawlinson Roadway"] = true;
  t.NuptialScript = true;
  t.Palatino = true;
  t.Perpetua = true;
  t.Plantin = true;
  t["Plantin Schoolbook"] = true;
  t.Playbill = true;
  t["Poor Richard"] = true;
  t["Rawlinson Roadway"] = true;
  t.Renault = true;
  t.Requiem = true;
  t.Rockwell = true;
  t.Roman = true;
  t["Rotis Serif"] = true;
  t.Sabon = true;
  t.Scala = true;
  t.Seagull = true;
  t.Sistina = true;
  t.Souvenir = true;
  t.STIX = true;
  t["Stone Informal"] = true;
  t["Stone Serif"] = true;
  t.Sylfaen = true;
  t.Times = true;
  t.Trajan = true;
  t["Trinité"] = true;
  t["Trump Mediaeval"] = true;
  t.Utopia = true;
  t["Vale Type"] = true;
  t["Bitstream Vera"] = true;
  t["Vera Serif"] = true;
  t.Versailles = true;
  t.Wanted = true;
  t.Weiss = true;
  t["Wide Latin"] = true;
  t.Windsor = true;
  t.XITS = true;
});
exports.getSerifFonts = getSerifFonts;
const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Dingbats = true;
  t.Symbol = true;
  t.ZapfDingbats = true;
  t.Wingdings = true;
  t["Wingdings-Bold"] = true;
  t["Wingdings-Regular"] = true;
});
exports.getSymbolsFonts = getSymbolsFonts;
const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[179] = 8220;
  t[180] = 8221;
  t[181] = 8216;
  t[182] = 8217;
  t[200] = 193;
  t[203] = 205;
  t[207] = 211;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[226] = 352;
  t[227] = 353;
  t[228] = 381;
  t[229] = 382;
  t[233] = 221;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[267] = 282;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[283] = 344;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[672] = 1488;
  t[673] = 1489;
  t[674] = 1490;
  t[675] = 1491;
  t[676] = 1492;
  t[677] = 1493;
  t[678] = 1494;
  t[679] = 1495;
  t[680] = 1496;
  t[681] = 1497;
  t[682] = 1498;
  t[683] = 1499;
  t[684] = 1500;
  t[685] = 1501;
  t[686] = 1502;
  t[687] = 1503;
  t[688] = 1504;
  t[689] = 1505;
  t[690] = 1506;
  t[691] = 1507;
  t[692] = 1508;
  t[693] = 1509;
  t[694] = 1510;
  t[695] = 1511;
  t[696] = 1512;
  t[697] = 1513;
  t[698] = 1514;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[1] = 32;
  t[4] = 65;
  t[5] = 192;
  t[6] = 193;
  t[9] = 196;
  t[17] = 66;
  t[18] = 67;
  t[21] = 268;
  t[24] = 68;
  t[28] = 69;
  t[29] = 200;
  t[30] = 201;
  t[32] = 282;
  t[38] = 70;
  t[39] = 71;
  t[44] = 72;
  t[47] = 73;
  t[48] = 204;
  t[49] = 205;
  t[58] = 74;
  t[60] = 75;
  t[62] = 76;
  t[68] = 77;
  t[69] = 78;
  t[75] = 79;
  t[76] = 210;
  t[80] = 214;
  t[87] = 80;
  t[89] = 81;
  t[90] = 82;
  t[92] = 344;
  t[94] = 83;
  t[97] = 352;
  t[100] = 84;
  t[104] = 85;
  t[109] = 220;
  t[115] = 86;
  t[116] = 87;
  t[121] = 88;
  t[122] = 89;
  t[124] = 221;
  t[127] = 90;
  t[129] = 381;
  t[258] = 97;
  t[259] = 224;
  t[260] = 225;
  t[263] = 228;
  t[268] = 261;
  t[271] = 98;
  t[272] = 99;
  t[273] = 263;
  t[275] = 269;
  t[282] = 100;
  t[286] = 101;
  t[287] = 232;
  t[288] = 233;
  t[290] = 283;
  t[295] = 281;
  t[296] = 102;
  t[336] = 103;
  t[346] = 104;
  t[349] = 105;
  t[350] = 236;
  t[351] = 237;
  t[361] = 106;
  t[364] = 107;
  t[367] = 108;
  t[371] = 322;
  t[373] = 109;
  t[374] = 110;
  t[381] = 111;
  t[382] = 242;
  t[383] = 243;
  t[386] = 246;
  t[393] = 112;
  t[395] = 113;
  t[396] = 114;
  t[398] = 345;
  t[400] = 115;
  t[401] = 347;
  t[403] = 353;
  t[410] = 116;
  t[437] = 117;
  t[442] = 252;
  t[448] = 118;
  t[449] = 119;
  t[454] = 120;
  t[455] = 121;
  t[457] = 253;
  t[460] = 122;
  t[462] = 382;
  t[463] = 380;
  t[853] = 44;
  t[855] = 58;
  t[856] = 46;
  t[876] = 47;
  t[878] = 45;
  t[882] = 45;
  t[894] = 40;
  t[895] = 41;
  t[896] = 91;
  t[897] = 93;
  t[923] = 64;
  t[1004] = 48;
  t[1005] = 49;
  t[1006] = 50;
  t[1007] = 51;
  t[1008] = 52;
  t[1009] = 53;
  t[1010] = 54;
  t[1011] = 55;
  t[1012] = 56;
  t[1013] = 57;
  t[1081] = 37;
  t[1085] = 43;
  t[1086] = 45;
});
exports.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
function getStandardFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  const stdFontMap = getStdFontMap();
  return stdFontMap[fontName];
}
function isKnownFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  return !!(getStdFontMap()[fontName] || getNonStdFontMap()[fontName] || getSerifFonts()[fontName] || getSymbolsFonts()[fontName]);
}

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ToUnicodeMap = exports.IdentityToUnicodeMap = void 0;
var _util = __w_pdfjs_require__(2);
class ToUnicodeMap {
  constructor(cmap = []) {
    this._map = cmap;
  }
  get length() {
    return this._map.length;
  }
  forEach(callback) {
    for (const charCode in this._map) {
      callback(charCode, this._map[charCode].charCodeAt(0));
    }
  }
  has(i) {
    return this._map[i] !== undefined;
  }
  get(i) {
    return this._map[i];
  }
  charCodeOf(value) {
    const map = this._map;
    if (map.length <= 0x10000) {
      return map.indexOf(value);
    }
    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }
    return -1;
  }
  amend(map) {
    for (const charCode in map) {
      this._map[charCode] = map[charCode];
    }
  }
}
exports.ToUnicodeMap = ToUnicodeMap;
class IdentityToUnicodeMap {
  constructor(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(callback) {
    for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
      callback(i, i);
    }
  }
  has(i) {
    return this.firstChar <= i && i <= this.lastChar;
  }
  get(i) {
    if (this.firstChar <= i && i <= this.lastChar) {
      return String.fromCharCode(i);
    }
    return undefined;
  }
  charCodeOf(v) {
    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
  }
  amend(map) {
    (0, _util.unreachable)("Should not call amend()");
  }
}
exports.IdentityToUnicodeMap = IdentityToUnicodeMap;

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFFont = void 0;
var _cff_parser = __w_pdfjs_require__(35);
var _fonts_utils = __w_pdfjs_require__(38);
var _util = __w_pdfjs_require__(2);
class CFFFont {
  constructor(file, properties) {
    this.properties = properties;
    const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    this.cff.duplicateFirstGlyph();
    const compiler = new _cff_parser.CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = compiler.compile();
    } catch {
      (0, _util.warn)("Failed to compile font " + properties.loadedName);
      this.data = file;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const cff = this.cff;
    const properties = this.properties;
    const {
      cidToGidMap,
      cMap
    } = properties;
    const charsets = cff.charset.charset;
    let charCodeToGlyphId;
    let glyphId;
    if (properties.composite) {
      let invCidToGidMap;
      if (cidToGidMap?.length > 0) {
        invCidToGidMap = Object.create(null);
        for (let i = 0, ii = cidToGidMap.length; i < ii; i++) {
          const gid = cidToGidMap[i];
          if (gid !== undefined) {
            invCidToGidMap[gid] = i;
          }
        }
      }
      charCodeToGlyphId = Object.create(null);
      let charCode;
      if (cff.isCIDFont) {
        for (glyphId = 0; glyphId < charsets.length; glyphId++) {
          const cid = charsets[glyphId];
          charCode = cMap.charCodeOf(cid);
          if (invCidToGidMap?.[charCode] !== undefined) {
            charCode = invCidToGidMap[charCode];
          }
          charCodeToGlyphId[charCode] = glyphId;
        }
      } else {
        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
          charCode = cMap.charCodeOf(glyphId);
          charCodeToGlyphId[charCode] = glyphId;
        }
      }
      return charCodeToGlyphId;
    }
    let encoding = cff.encoding ? cff.encoding.encoding : null;
    if (properties.isInternalFont) {
      encoding = properties.defaultEncoding;
    }
    charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets);
    return charCodeToGlyphId;
  }
  hasGlyphId(id) {
    return this.cff.hasGlyphId(id);
  }
  _createBuiltInEncoding() {
    const {
      charset,
      encoding
    } = this.cff;
    if (!charset || !encoding) {
      return;
    }
    const charsets = charset.charset,
      encodings = encoding.encoding;
    const map = [];
    for (const charCode in encodings) {
      const glyphId = encodings[charCode];
      if (glyphId >= 0) {
        const glyphName = charsets[glyphId];
        if (glyphName) {
          map[charCode] = glyphName;
        }
      }
    }
    if (map.length > 0) {
      this.properties.builtInEncoding = map;
    }
  }
}
exports.CFFFont = CFFFont;

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontRendererFactory = void 0;
var _util = __w_pdfjs_require__(2);
var _cff_parser = __w_pdfjs_require__(35);
var _glyphlist = __w_pdfjs_require__(39);
var _encodings = __w_pdfjs_require__(37);
var _stream = __w_pdfjs_require__(8);
function getUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function getUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function getInt16(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16) >> 16;
}
function getInt8(data, offset) {
  return data[offset] << 24 >> 24;
}
function getFloat214(data, offset) {
  return getInt16(data, offset) / 16384;
}
function getSubroutineBias(subrs) {
  const numSubrs = subrs.length;
  let bias = 32768;
  if (numSubrs < 1240) {
    bias = 107;
  } else if (numSubrs < 33900) {
    bias = 1131;
  }
  return bias;
}
function parseCmap(data, start, end) {
  const offset = getUint16(data, start + 2) === 1 ? getUint32(data, start + 8) : getUint32(data, start + 16);
  const format = getUint16(data, start + offset);
  let ranges, p, i;
  if (format === 4) {
    getUint16(data, start + offset + 2);
    const segCount = getUint16(data, start + offset + 6) >> 1;
    p = start + offset + 14;
    ranges = [];
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i] = {
        end: getUint16(data, p)
      };
    }
    p += 2;
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].start = getUint16(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].idDelta = getUint16(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      let idOffset = getUint16(data, p);
      if (idOffset === 0) {
        continue;
      }
      ranges[i].ids = [];
      for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
        ranges[i].ids[j] = getUint16(data, p + idOffset);
        idOffset += 2;
      }
    }
    return ranges;
  } else if (format === 12) {
    const groups = getUint32(data, start + offset + 12);
    p = start + offset + 16;
    ranges = [];
    for (i = 0; i < groups; i++) {
      start = getUint32(data, p);
      ranges.push({
        start,
        end: getUint32(data, p + 4),
        idDelta: getUint32(data, p + 8) - start
      });
      p += 12;
    }
    return ranges;
  }
  throw new _util.FormatError(`unsupported cmap: ${format}`);
}
function parseCff(data, start, end, seacAnalysisEnabled) {
  const properties = {};
  const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
  const cff = parser.parse();
  return {
    glyphs: cff.charStrings.objects,
    subrs: cff.topDict.privateDict?.subrsIndex?.objects,
    gsubrs: cff.globalSubrIndex?.objects,
    isCFFCIDFont: cff.isCIDFont,
    fdSelect: cff.fdSelect,
    fdArray: cff.fdArray
  };
}
function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
  let itemSize, itemDecode;
  if (isGlyphLocationsLong) {
    itemSize = 4;
    itemDecode = getUint32;
  } else {
    itemSize = 2;
    itemDecode = (data, offset) => 2 * getUint16(data, offset);
  }
  const glyphs = [];
  let startOffset = itemDecode(loca, 0);
  for (let j = itemSize; j < loca.length; j += itemSize) {
    const endOffset = itemDecode(loca, j);
    glyphs.push(glyf.subarray(startOffset, endOffset));
    startOffset = endOffset;
  }
  return glyphs;
}
function lookupCmap(ranges, unicode) {
  const code = unicode.codePointAt(0);
  let gid = 0,
    l = 0,
    r = ranges.length - 1;
  while (l < r) {
    const c = l + r + 1 >> 1;
    if (code < ranges[c].start) {
      r = c - 1;
    } else {
      l = c;
    }
  }
  if (ranges[l].start <= code && code <= ranges[l].end) {
    gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xffff;
  }
  return {
    charCode: code,
    glyphId: gid
  };
}
function compileGlyf(code, cmds, font) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }
  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }
  function quadraticCurveTo(xa, ya, x, y) {
    cmds.push({
      cmd: "quadraticCurveTo",
      args: [xa, ya, x, y]
    });
  }
  let i = 0;
  const numberOfContours = getInt16(code, i);
  let flags;
  let x = 0,
    y = 0;
  i += 10;
  if (numberOfContours < 0) {
    do {
      flags = getUint16(code, i);
      const glyphIndex = getUint16(code, i + 2);
      i += 4;
      let arg1, arg2;
      if (flags & 0x01) {
        if (flags & 0x02) {
          arg1 = getInt16(code, i);
          arg2 = getInt16(code, i + 2);
        } else {
          arg1 = getUint16(code, i);
          arg2 = getUint16(code, i + 2);
        }
        i += 4;
      } else if (flags & 0x02) {
        arg1 = getInt8(code, i++);
        arg2 = getInt8(code, i++);
      } else {
        arg1 = code[i++];
        arg2 = code[i++];
      }
      if (flags & 0x02) {
        x = arg1;
        y = arg2;
      } else {
        x = 0;
        y = 0;
      }
      let scaleX = 1,
        scaleY = 1,
        scale01 = 0,
        scale10 = 0;
      if (flags & 0x08) {
        scaleX = scaleY = getFloat214(code, i);
        i += 2;
      } else if (flags & 0x40) {
        scaleX = getFloat214(code, i);
        scaleY = getFloat214(code, i + 2);
        i += 4;
      } else if (flags & 0x80) {
        scaleX = getFloat214(code, i);
        scale01 = getFloat214(code, i + 2);
        scale10 = getFloat214(code, i + 4);
        scaleY = getFloat214(code, i + 6);
        i += 8;
      }
      const subglyph = font.glyphs[glyphIndex];
      if (subglyph) {
        cmds.push({
          cmd: "save"
        }, {
          cmd: "transform",
          args: [scaleX, scale01, scale10, scaleY, x, y]
        });
        if (!(flags & 0x02)) {}
        compileGlyf(subglyph, cmds, font);
        cmds.push({
          cmd: "restore"
        });
      }
    } while (flags & 0x20);
  } else {
    const endPtsOfContours = [];
    let j, jj;
    for (j = 0; j < numberOfContours; j++) {
      endPtsOfContours.push(getUint16(code, i));
      i += 2;
    }
    const instructionLength = getUint16(code, i);
    i += 2 + instructionLength;
    const numberOfPoints = endPtsOfContours.at(-1) + 1;
    const points = [];
    while (points.length < numberOfPoints) {
      flags = code[i++];
      let repeat = 1;
      if (flags & 0x08) {
        repeat += code[i++];
      }
      while (repeat-- > 0) {
        points.push({
          flags
        });
      }
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x12) {
        case 0x00:
          x += getInt16(code, i);
          i += 2;
          break;
        case 0x02:
          x -= code[i++];
          break;
        case 0x12:
          x += code[i++];
          break;
      }
      points[j].x = x;
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x24) {
        case 0x00:
          y += getInt16(code, i);
          i += 2;
          break;
        case 0x04:
          y -= code[i++];
          break;
        case 0x24:
          y += code[i++];
          break;
      }
      points[j].y = y;
    }
    let startPoint = 0;
    for (i = 0; i < numberOfContours; i++) {
      const endPoint = endPtsOfContours[i];
      const contour = points.slice(startPoint, endPoint + 1);
      if (contour[0].flags & 1) {
        contour.push(contour[0]);
      } else if (contour.at(-1).flags & 1) {
        contour.unshift(contour.at(-1));
      } else {
        const p = {
          flags: 1,
          x: (contour[0].x + contour.at(-1).x) / 2,
          y: (contour[0].y + contour.at(-1).y) / 2
        };
        contour.unshift(p);
        contour.push(p);
      }
      moveTo(contour[0].x, contour[0].y);
      for (j = 1, jj = contour.length; j < jj; j++) {
        if (contour[j].flags & 1) {
          lineTo(contour[j].x, contour[j].y);
        } else if (contour[j + 1].flags & 1) {
          quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
          j++;
        } else {
          quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
        }
      }
      startPoint = endPoint + 1;
    }
  }
}
function compileCharString(charStringCode, cmds, font, glyphId) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }
  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }
  function bezierCurveTo(x1, y1, x2, y2, x, y) {
    cmds.push({
      cmd: "bezierCurveTo",
      args: [x1, y1, x2, y2, x, y]
    });
  }
  const stack = [];
  let x = 0,
    y = 0;
  let stems = 0;
  function parse(code) {
    let i = 0;
    while (i < code.length) {
      let stackClean = false;
      let v = code[i++];
      let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
      switch (v) {
        case 1:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 3:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 4:
          y += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 10:
          n = stack.pop();
          subrCode = null;
          if (font.isCFFCIDFont) {
            const fdIndex = font.fdSelect.getFDIndex(glyphId);
            if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
              const fontDict = font.fdArray[fdIndex];
              let subrs;
              if (fontDict.privateDict?.subrsIndex) {
                subrs = fontDict.privateDict.subrsIndex.objects;
              }
              if (subrs) {
                n += getSubroutineBias(subrs);
                subrCode = subrs[n];
              }
            } else {
              (0, _util.warn)("Invalid fd index for glyph index.");
            }
          } else {
            subrCode = font.subrs[n + font.subrsBias];
          }
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code[i++];
          switch (v) {
            case 34:
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y1 = y + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y, xb, y1, x, y1);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y, x, y);
              break;
            case 35:
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              stack.pop();
              break;
            case 36:
              xa = x + stack.shift();
              y1 = y + stack.shift();
              xb = xa + stack.shift();
              y2 = y1 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y2, x, y2);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y3 = y2 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y2, xb, y3, x, y);
              break;
            case 37:
              const x0 = x,
                y0 = y;
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb;
              if (Math.abs(x - x0) > Math.abs(y - y0)) {
                x += stack.shift();
              } else {
                y += stack.shift();
              }
              bezierCurveTo(xa, ya, xb, yb, x, y);
              break;
            default:
              throw new _util.FormatError(`unknown operator: 12 ${v}`);
          }
          break;
        case 14:
          if (stack.length >= 4) {
            const achar = stack.pop();
            const bchar = stack.pop();
            y = stack.pop();
            x = stack.pop();
            cmds.push({
              cmd: "save"
            }, {
              cmd: "translate",
              args: [x, y]
            });
            let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
            cmds.push({
              cmd: "restore"
            });
            cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
          }
          return;
        case 18:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 19:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 20:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 21:
          y += stack.pop();
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 22:
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 23:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 24:
          while (stack.length > 2) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          xa = x + stack.shift();
          ya = y + stack.shift();
          xb = xa + stack.shift();
          yb = ya + stack.shift();
          x = xb + stack.shift();
          y = yb + stack.shift();
          bezierCurveTo(xa, ya, xb, yb, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb;
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb;
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 28:
          stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
          i += 2;
          break;
        case 29:
          n = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[n];
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        default:
          if (v < 32) {
            throw new _util.FormatError(`unknown operator: ${v}`);
          }
          if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            stack.push((v - 247) * 256 + code[i++] + 108);
          } else if (v < 255) {
            stack.push(-(v - 251) * 256 - code[i++] - 108);
          } else {
            stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
            i += 4;
          }
          break;
      }
      if (stackClean) {
        stack.length = 0;
      }
    }
  }
  parse(charStringCode);
}
const NOOP = [];
class CompiledFont {
  constructor(fontMatrix) {
    if (this.constructor === CompiledFont) {
      (0, _util.unreachable)("Cannot initialize CompiledFont.");
    }
    this.fontMatrix = fontMatrix;
    this.compiledGlyphs = Object.create(null);
    this.compiledCharCodeToGlyphId = Object.create(null);
  }
  getPathJs(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    let fn = this.compiledGlyphs[glyphId];
    if (!fn) {
      try {
        fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
        this.compiledGlyphs[glyphId] = fn;
      } catch (ex) {
        this.compiledGlyphs[glyphId] = NOOP;
        if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
          this.compiledCharCodeToGlyphId[charCode] = glyphId;
        }
        throw ex;
      }
    }
    if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
      this.compiledCharCodeToGlyphId[charCode] = glyphId;
    }
    return fn;
  }
  compileGlyph(code, glyphId) {
    if (!code || code.length === 0 || code[0] === 14) {
      return NOOP;
    }
    let fontMatrix = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const fdIndex = this.fdSelect.getFDIndex(glyphId);
      if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
        const fontDict = this.fdArray[fdIndex];
        fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
      } else {
        (0, _util.warn)("Invalid fd index for glyph index.");
      }
    }
    const cmds = [{
      cmd: "save"
    }, {
      cmd: "transform",
      args: fontMatrix.slice()
    }, {
      cmd: "scale",
      args: ["size", "-size"]
    }];
    this.compileGlyphImpl(code, cmds, glyphId);
    cmds.push({
      cmd: "restore"
    });
    return cmds;
  }
  compileGlyphImpl() {
    (0, _util.unreachable)("Children classes should implement this.");
  }
  hasBuiltPath(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    return this.compiledGlyphs[glyphId] !== undefined && this.compiledCharCodeToGlyphId[charCode] !== undefined;
  }
}
class TrueTypeCompiled extends CompiledFont {
  constructor(glyphs, cmap, fontMatrix) {
    super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);
    this.glyphs = glyphs;
    this.cmap = cmap;
  }
  compileGlyphImpl(code, cmds) {
    compileGlyf(code, cmds, this);
  }
}
class Type2Compiled extends CompiledFont {
  constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
    super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);
    this.glyphs = cffInfo.glyphs;
    this.gsubrs = cffInfo.gsubrs || [];
    this.subrs = cffInfo.subrs || [];
    this.cmap = cmap;
    this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = cffInfo.isCFFCIDFont;
    this.fdSelect = cffInfo.fdSelect;
    this.fdArray = cffInfo.fdArray;
  }
  compileGlyphImpl(code, cmds, glyphId) {
    compileCharString(code, cmds, this, glyphId);
  }
}
class FontRendererFactory {
  static create(font, seacAnalysisEnabled) {
    const data = new Uint8Array(font.data);
    let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
    const numTables = getUint16(data, 4);
    for (let i = 0, p = 12; i < numTables; i++, p += 16) {
      const tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
      const offset = getUint32(data, p + 8);
      const length = getUint32(data, p + 12);
      switch (tag) {
        case "cmap":
          cmap = parseCmap(data, offset, offset + length);
          break;
        case "glyf":
          glyf = data.subarray(offset, offset + length);
          break;
        case "loca":
          loca = data.subarray(offset, offset + length);
          break;
        case "head":
          unitsPerEm = getUint16(data, offset + 18);
          indexToLocFormat = getUint16(data, offset + 50);
          break;
        case "CFF ":
          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
          break;
      }
    }
    if (glyf) {
      const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
    }
    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
  }
}
exports.FontRendererFactory = FontRendererFactory;

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMetrics = exports.getFontBasicMetrics = void 0;
var _core_utils = __w_pdfjs_require__(3);
const getMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = 600;
  t["Courier-Bold"] = 600;
  t["Courier-BoldOblique"] = 600;
  t["Courier-Oblique"] = 600;
  t.Helvetica = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t.Symbol = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.universal = 713;
    t.numbersign = 500;
    t.existential = 549;
    t.percent = 833;
    t.ampersand = 778;
    t.suchthat = 439;
    t.parenleft = 333;
    t.parenright = 333;
    t.asteriskmath = 500;
    t.plus = 549;
    t.comma = 250;
    t.minus = 549;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 549;
    t.equal = 549;
    t.greater = 549;
    t.question = 444;
    t.congruent = 549;
    t.Alpha = 722;
    t.Beta = 667;
    t.Chi = 722;
    t.Delta = 612;
    t.Epsilon = 611;
    t.Phi = 763;
    t.Gamma = 603;
    t.Eta = 722;
    t.Iota = 333;
    t.theta1 = 631;
    t.Kappa = 722;
    t.Lambda = 686;
    t.Mu = 889;
    t.Nu = 722;
    t.Omicron = 722;
    t.Pi = 768;
    t.Theta = 741;
    t.Rho = 556;
    t.Sigma = 592;
    t.Tau = 611;
    t.Upsilon = 690;
    t.sigma1 = 439;
    t.Omega = 768;
    t.Xi = 645;
    t.Psi = 795;
    t.Zeta = 611;
    t.bracketleft = 333;
    t.therefore = 863;
    t.bracketright = 333;
    t.perpendicular = 658;
    t.underscore = 500;
    t.radicalex = 500;
    t.alpha = 631;
    t.beta = 549;
    t.chi = 549;
    t.delta = 494;
    t.epsilon = 439;
    t.phi = 521;
    t.gamma = 411;
    t.eta = 603;
    t.iota = 329;
    t.phi1 = 603;
    t.kappa = 549;
    t.lambda = 549;
    t.mu = 576;
    t.nu = 521;
    t.omicron = 549;
    t.pi = 549;
    t.theta = 521;
    t.rho = 549;
    t.sigma = 603;
    t.tau = 439;
    t.upsilon = 576;
    t.omega1 = 713;
    t.omega = 686;
    t.xi = 493;
    t.psi = 686;
    t.zeta = 494;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.similar = 549;
    t.Euro = 750;
    t.Upsilon1 = 620;
    t.minute = 247;
    t.lessequal = 549;
    t.fraction = 167;
    t.infinity = 713;
    t.florin = 500;
    t.club = 753;
    t.diamond = 753;
    t.heart = 753;
    t.spade = 753;
    t.arrowboth = 1042;
    t.arrowleft = 987;
    t.arrowup = 603;
    t.arrowright = 987;
    t.arrowdown = 603;
    t.degree = 400;
    t.plusminus = 549;
    t.second = 411;
    t.greaterequal = 549;
    t.multiply = 549;
    t.proportional = 713;
    t.partialdiff = 494;
    t.bullet = 460;
    t.divide = 549;
    t.notequal = 549;
    t.equivalence = 549;
    t.approxequal = 549;
    t.ellipsis = 1000;
    t.arrowvertex = 603;
    t.arrowhorizex = 1000;
    t.carriagereturn = 658;
    t.aleph = 823;
    t.Ifraktur = 686;
    t.Rfraktur = 795;
    t.weierstrass = 987;
    t.circlemultiply = 768;
    t.circleplus = 768;
    t.emptyset = 823;
    t.intersection = 768;
    t.union = 768;
    t.propersuperset = 713;
    t.reflexsuperset = 713;
    t.notsubset = 713;
    t.propersubset = 713;
    t.reflexsubset = 713;
    t.element = 713;
    t.notelement = 713;
    t.angle = 768;
    t.gradient = 713;
    t.registerserif = 790;
    t.copyrightserif = 790;
    t.trademarkserif = 890;
    t.product = 823;
    t.radical = 549;
    t.dotmath = 250;
    t.logicalnot = 713;
    t.logicaland = 603;
    t.logicalor = 603;
    t.arrowdblboth = 1042;
    t.arrowdblleft = 987;
    t.arrowdblup = 603;
    t.arrowdblright = 987;
    t.arrowdbldown = 603;
    t.lozenge = 494;
    t.angleleft = 329;
    t.registersans = 790;
    t.copyrightsans = 790;
    t.trademarksans = 786;
    t.summation = 713;
    t.parenlefttp = 384;
    t.parenleftex = 384;
    t.parenleftbt = 384;
    t.bracketlefttp = 384;
    t.bracketleftex = 384;
    t.bracketleftbt = 384;
    t.bracelefttp = 494;
    t.braceleftmid = 494;
    t.braceleftbt = 494;
    t.braceex = 494;
    t.angleright = 329;
    t.integral = 274;
    t.integraltp = 686;
    t.integralex = 686;
    t.integralbt = 686;
    t.parenrighttp = 384;
    t.parenrightex = 384;
    t.parenrightbt = 384;
    t.bracketrighttp = 384;
    t.bracketrightex = 384;
    t.bracketrightbt = 384;
    t.bracerighttp = 494;
    t.bracerightmid = 494;
    t.bracerightbt = 494;
    t.apple = 790;
  });
  t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 408;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 564;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 564;
    t.equal = 564;
    t.greater = 564;
    t.question = 444;
    t.at = 921;
    t.A = 722;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 556;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 389;
    t.K = 722;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 556;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 722;
    t.W = 944;
    t.X = 722;
    t.Y = 722;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 469;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 444;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 333;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.asciitilde = 541;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 180;
    t.quotedblleft = 444;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 453;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 444;
    t.quotedblright = 444;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 444;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 889;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 444;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 564;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 444;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 444;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 444;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 444;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 444;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 444;
    t.Amacron = 722;
    t.rcaron = 333;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 556;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 588;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 564;
    t.uacute = 500;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 444;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 722;
    t.Iacute = 333;
    t.plusminus = 564;
    t.brokenbar = 200;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 333;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 326;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 444;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 344;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 722;
    t.zdotaccent = 444;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 500;
    t.minus = 564;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 564;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 1000;
    t.ampersand = 833;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 930;
    t.A = 722;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 778;
    t.L = 667;
    t.M = 944;
    t.N = 722;
    t.O = 778;
    t.P = 611;
    t.Q = 778;
    t.R = 722;
    t.S = 556;
    t.T = 667;
    t.U = 722;
    t.V = 722;
    t.W = 1000;
    t.X = 722;
    t.Y = 722;
    t.Z = 667;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 581;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 556;
    t.c = 444;
    t.d = 556;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 333;
    t.k = 556;
    t.l = 278;
    t.m = 833;
    t.n = 556;
    t.o = 500;
    t.p = 556;
    t.q = 556;
    t.r = 444;
    t.s = 389;
    t.t = 333;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 394;
    t.bar = 220;
    t.braceright = 394;
    t.asciitilde = 520;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 540;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 300;
    t.Lslash = 667;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 330;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 556;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 570;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 667;
    t.Cacute = 722;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 722;
    t.rcaron = 444;
    t.ccedilla = 444;
    t.Zdotaccent = 667;
    t.Thorn = 611;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 556;
    t.dcaron = 672;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 667;
    t.partialdiff = 494;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 778;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 444;
    t.omacron = 500;
    t.Zacute = 667;
    t.Zcaron = 667;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 416;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 300;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 394;
    t.Kcommaaccent = 778;
    t.Lacute = 667;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 667;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 444;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 667;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 444;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 556;
    t.minus = 570;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 333;
    t.logicalnot = 570;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 389;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 832;
    t.A = 667;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 667;
    t.F = 667;
    t.G = 722;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 667;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 889;
    t.X = 667;
    t.Y = 611;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 570;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 556;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 556;
    t.v = 444;
    t.w = 667;
    t.x = 500;
    t.y = 444;
    t.z = 389;
    t.braceleft = 348;
    t.bar = 220;
    t.braceright = 348;
    t.asciitilde = 570;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 500;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 944;
    t.ordfeminine = 266;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 300;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 611;
    t.divide = 570;
    t.Yacute = 611;
    t.Acircumflex = 667;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 667;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 608;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 444;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 722;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 366;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 576;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 382;
    t.Kcommaaccent = 667;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 500;
    t.minus = 606;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 606;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 420;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 675;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 675;
    t.equal = 675;
    t.greater = 675;
    t.question = 500;
    t.at = 920;
    t.A = 611;
    t.B = 611;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 611;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 444;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 667;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 611;
    t.S = 500;
    t.T = 556;
    t.U = 722;
    t.V = 611;
    t.W = 833;
    t.X = 611;
    t.Y = 556;
    t.Z = 556;
    t.bracketleft = 389;
    t.backslash = 278;
    t.bracketright = 389;
    t.asciicircum = 422;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 278;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 444;
    t.l = 278;
    t.m = 722;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 444;
    t.w = 667;
    t.x = 444;
    t.y = 444;
    t.z = 389;
    t.braceleft = 400;
    t.bar = 275;
    t.braceright = 400;
    t.asciitilde = 541;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 214;
    t.quotedblleft = 556;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 523;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 556;
    t.quotedblright = 556;
    t.guillemotright = 500;
    t.ellipsis = 889;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 889;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 556;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 667;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 556;
    t.divide = 675;
    t.Yacute = 556;
    t.Acircumflex = 611;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 667;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 556;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 611;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 500;
    t.Amacron = 611;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 556;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 611;
    t.Sacute = 500;
    t.dcaron = 544;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 611;
    t.Abreve = 611;
    t.multiply = 675;
    t.uacute = 500;
    t.Tcaron = 556;
    t.partialdiff = 476;
    t.ydieresis = 444;
    t.Nacute = 667;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 667;
    t.Iacute = 333;
    t.plusminus = 675;
    t.brokenbar = 275;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 556;
    t.Zcaron = 556;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 300;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 611;
    t.Adieresis = 611;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 500;
    t.lcaron = 300;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 500;
    t.Scommaaccent = 500;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 667;
    t.otilde = 500;
    t.Rcommaaccent = 611;
    t.Lcommaaccent = 556;
    t.Atilde = 611;
    t.Aogonek = 611;
    t.Aring = 611;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 444;
    t.minus = 675;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 675;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.a1 = 974;
    t.a2 = 961;
    t.a202 = 974;
    t.a3 = 980;
    t.a4 = 719;
    t.a5 = 789;
    t.a119 = 790;
    t.a118 = 791;
    t.a117 = 690;
    t.a11 = 960;
    t.a12 = 939;
    t.a13 = 549;
    t.a14 = 855;
    t.a15 = 911;
    t.a16 = 933;
    t.a105 = 911;
    t.a17 = 945;
    t.a18 = 974;
    t.a19 = 755;
    t.a20 = 846;
    t.a21 = 762;
    t.a22 = 761;
    t.a23 = 571;
    t.a24 = 677;
    t.a25 = 763;
    t.a26 = 760;
    t.a27 = 759;
    t.a28 = 754;
    t.a6 = 494;
    t.a7 = 552;
    t.a8 = 537;
    t.a9 = 577;
    t.a10 = 692;
    t.a29 = 786;
    t.a30 = 788;
    t.a31 = 788;
    t.a32 = 790;
    t.a33 = 793;
    t.a34 = 794;
    t.a35 = 816;
    t.a36 = 823;
    t.a37 = 789;
    t.a38 = 841;
    t.a39 = 823;
    t.a40 = 833;
    t.a41 = 816;
    t.a42 = 831;
    t.a43 = 923;
    t.a44 = 744;
    t.a45 = 723;
    t.a46 = 749;
    t.a47 = 790;
    t.a48 = 792;
    t.a49 = 695;
    t.a50 = 776;
    t.a51 = 768;
    t.a52 = 792;
    t.a53 = 759;
    t.a54 = 707;
    t.a55 = 708;
    t.a56 = 682;
    t.a57 = 701;
    t.a58 = 826;
    t.a59 = 815;
    t.a60 = 789;
    t.a61 = 789;
    t.a62 = 707;
    t.a63 = 687;
    t.a64 = 696;
    t.a65 = 689;
    t.a66 = 786;
    t.a67 = 787;
    t.a68 = 713;
    t.a69 = 791;
    t.a70 = 785;
    t.a71 = 791;
    t.a72 = 873;
    t.a73 = 761;
    t.a74 = 762;
    t.a203 = 762;
    t.a75 = 759;
    t.a204 = 759;
    t.a76 = 892;
    t.a77 = 892;
    t.a78 = 788;
    t.a79 = 784;
    t.a81 = 438;
    t.a82 = 138;
    t.a83 = 277;
    t.a84 = 415;
    t.a97 = 392;
    t.a98 = 392;
    t.a99 = 668;
    t.a100 = 668;
    t.a89 = 390;
    t.a90 = 390;
    t.a93 = 317;
    t.a94 = 317;
    t.a91 = 276;
    t.a92 = 276;
    t.a205 = 509;
    t.a85 = 509;
    t.a206 = 410;
    t.a86 = 410;
    t.a87 = 234;
    t.a88 = 234;
    t.a95 = 334;
    t.a96 = 334;
    t.a101 = 732;
    t.a102 = 544;
    t.a103 = 544;
    t.a104 = 910;
    t.a106 = 667;
    t.a107 = 760;
    t.a108 = 760;
    t.a112 = 776;
    t.a111 = 595;
    t.a110 = 694;
    t.a109 = 626;
    t.a120 = 788;
    t.a121 = 788;
    t.a122 = 788;
    t.a123 = 788;
    t.a124 = 788;
    t.a125 = 788;
    t.a126 = 788;
    t.a127 = 788;
    t.a128 = 788;
    t.a129 = 788;
    t.a130 = 788;
    t.a131 = 788;
    t.a132 = 788;
    t.a133 = 788;
    t.a134 = 788;
    t.a135 = 788;
    t.a136 = 788;
    t.a137 = 788;
    t.a138 = 788;
    t.a139 = 788;
    t.a140 = 788;
    t.a141 = 788;
    t.a142 = 788;
    t.a143 = 788;
    t.a144 = 788;
    t.a145 = 788;
    t.a146 = 788;
    t.a147 = 788;
    t.a148 = 788;
    t.a149 = 788;
    t.a150 = 788;
    t.a151 = 788;
    t.a152 = 788;
    t.a153 = 788;
    t.a154 = 788;
    t.a155 = 788;
    t.a156 = 788;
    t.a157 = 788;
    t.a158 = 788;
    t.a159 = 788;
    t.a160 = 894;
    t.a161 = 838;
    t.a163 = 1016;
    t.a164 = 458;
    t.a196 = 748;
    t.a165 = 924;
    t.a192 = 748;
    t.a166 = 918;
    t.a167 = 927;
    t.a168 = 928;
    t.a169 = 928;
    t.a170 = 834;
    t.a171 = 873;
    t.a172 = 828;
    t.a173 = 924;
    t.a162 = 924;
    t.a174 = 917;
    t.a175 = 930;
    t.a176 = 931;
    t.a177 = 463;
    t.a178 = 883;
    t.a179 = 836;
    t.a193 = 836;
    t.a180 = 867;
    t.a199 = 867;
    t.a181 = 696;
    t.a200 = 696;
    t.a182 = 874;
    t.a201 = 874;
    t.a183 = 760;
    t.a184 = 946;
    t.a197 = 771;
    t.a185 = 865;
    t.a194 = 771;
    t.a198 = 888;
    t.a186 = 967;
    t.a195 = 888;
    t.a187 = 831;
    t.a188 = 873;
    t.a189 = 927;
    t.a190 = 970;
    t.a191 = 918;
  });
});
exports.getMetrics = getMetrics;
const getFontBasicMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: -426
  };
  t["Courier-Bold"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 439
  };
  t["Courier-Oblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  };
  t["Courier-BoldOblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  };
  t.Helvetica = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  };
  t["Helvetica-Bold"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  };
  t["Helvetica-Oblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  };
  t["Helvetica-BoldOblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  };
  t["Times-Roman"] = {
    ascent: 683,
    descent: -217,
    capHeight: 662,
    xHeight: 450
  };
  t["Times-Bold"] = {
    ascent: 683,
    descent: -217,
    capHeight: 676,
    xHeight: 461
  };
  t["Times-Italic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 653,
    xHeight: 441
  };
  t["Times-BoldItalic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 669,
    xHeight: 462
  };
  t.Symbol = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
  t.ZapfDingbats = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
});
exports.getFontBasicMetrics = getFontBasicMetrics;

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlyfTable = void 0;
const ON_CURVE_POINT = 1 << 0;
const X_SHORT_VECTOR = 1 << 1;
const Y_SHORT_VECTOR = 1 << 2;
const REPEAT_FLAG = 1 << 3;
const X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;
const Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;
const OVERLAP_SIMPLE = 1 << 6;
const ARG_1_AND_2_ARE_WORDS = 1 << 0;
const ARGS_ARE_XY_VALUES = 1 << 1;
const WE_HAVE_A_SCALE = 1 << 3;
const MORE_COMPONENTS = 1 << 5;
const WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
const WE_HAVE_A_TWO_BY_TWO = 1 << 7;
const WE_HAVE_INSTRUCTIONS = 1 << 8;
class GlyfTable {
  constructor({
    glyfTable,
    isGlyphLocationsLong,
    locaTable,
    numGlyphs
  }) {
    this.glyphs = [];
    const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);
    const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);
    const offsetSize = isGlyphLocationsLong ? 4 : 2;
    let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);
    let pos = 0;
    for (let i = 0; i < numGlyphs; i++) {
      pos += offsetSize;
      const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);
      if (next === prev) {
        this.glyphs.push(new Glyph({}));
        continue;
      }
      const glyph = Glyph.parse(prev, glyf);
      this.glyphs.push(glyph);
      prev = next;
    }
  }
  getSize() {
    return this.glyphs.reduce((a, g) => {
      const size = g.getSize();
      return a + (size + 3 & ~3);
    }, 0);
  }
  write() {
    const totalSize = this.getSize();
    const glyfTable = new DataView(new ArrayBuffer(totalSize));
    const isLocationLong = totalSize > 0x1fffe;
    const offsetSize = isLocationLong ? 4 : 2;
    const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));
    if (isLocationLong) {
      locaTable.setUint32(0, 0);
    } else {
      locaTable.setUint16(0, 0);
    }
    let pos = 0;
    let locaIndex = 0;
    for (const glyph of this.glyphs) {
      pos += glyph.write(pos, glyfTable);
      pos = pos + 3 & ~3;
      locaIndex += offsetSize;
      if (isLocationLong) {
        locaTable.setUint32(locaIndex, pos);
      } else {
        locaTable.setUint16(locaIndex, pos >> 1);
      }
    }
    return {
      isLocationLong,
      loca: new Uint8Array(locaTable.buffer),
      glyf: new Uint8Array(glyfTable.buffer)
    };
  }
  scale(factors) {
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      this.glyphs[i].scale(factors[i]);
    }
  }
}
exports.GlyfTable = GlyfTable;
class Glyph {
  constructor({
    header = null,
    simple = null,
    composites = null
  }) {
    this.header = header;
    this.simple = simple;
    this.composites = composites;
  }
  static parse(pos, glyf) {
    const [read, header] = GlyphHeader.parse(pos, glyf);
    pos += read;
    if (header.numberOfContours < 0) {
      const composites = [];
      while (true) {
        const [n, composite] = CompositeGlyph.parse(pos, glyf);
        pos += n;
        composites.push(composite);
        if (!(composite.flags & MORE_COMPONENTS)) {
          break;
        }
      }
      return new Glyph({
        header,
        composites
      });
    }
    const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);
    return new Glyph({
      header,
      simple
    });
  }
  getSize() {
    if (!this.header) {
      return 0;
    }
    const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);
    return this.header.getSize() + size;
  }
  write(pos, buf) {
    if (!this.header) {
      return 0;
    }
    const spos = pos;
    pos += this.header.write(pos, buf);
    if (this.simple) {
      pos += this.simple.write(pos, buf);
    } else {
      for (const composite of this.composites) {
        pos += composite.write(pos, buf);
      }
    }
    return pos - spos;
  }
  scale(factor) {
    if (!this.header) {
      return;
    }
    const xMiddle = (this.header.xMin + this.header.xMax) / 2;
    this.header.scale(xMiddle, factor);
    if (this.simple) {
      this.simple.scale(xMiddle, factor);
    } else {
      for (const composite of this.composites) {
        composite.scale(xMiddle, factor);
      }
    }
  }
}
class GlyphHeader {
  constructor({
    numberOfContours,
    xMin,
    yMin,
    xMax,
    yMax
  }) {
    this.numberOfContours = numberOfContours;
    this.xMin = xMin;
    this.yMin = yMin;
    this.xMax = xMax;
    this.yMax = yMax;
  }
  static parse(pos, glyf) {
    return [10, new GlyphHeader({
      numberOfContours: glyf.getInt16(pos),
      xMin: glyf.getInt16(pos + 2),
      yMin: glyf.getInt16(pos + 4),
      xMax: glyf.getInt16(pos + 6),
      yMax: glyf.getInt16(pos + 8)
    })];
  }
  getSize() {
    return 10;
  }
  write(pos, buf) {
    buf.setInt16(pos, this.numberOfContours);
    buf.setInt16(pos + 2, this.xMin);
    buf.setInt16(pos + 4, this.yMin);
    buf.setInt16(pos + 6, this.xMax);
    buf.setInt16(pos + 8, this.yMax);
    return 10;
  }
  scale(x, factor) {
    this.xMin = Math.round(x + (this.xMin - x) * factor);
    this.xMax = Math.round(x + (this.xMax - x) * factor);
  }
}
class Contour {
  constructor({
    flags,
    xCoordinates,
    yCoordinates
  }) {
    this.xCoordinates = xCoordinates;
    this.yCoordinates = yCoordinates;
    this.flags = flags;
  }
}
class SimpleGlyph {
  constructor({
    contours,
    instructions
  }) {
    this.contours = contours;
    this.instructions = instructions;
  }
  static parse(pos, glyf, numberOfContours) {
    const endPtsOfContours = [];
    for (let i = 0; i < numberOfContours; i++) {
      const endPt = glyf.getUint16(pos);
      pos += 2;
      endPtsOfContours.push(endPt);
    }
    const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;
    const instructionLength = glyf.getUint16(pos);
    pos += 2;
    const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
    pos += instructionLength;
    const flags = [];
    for (let i = 0; i < numberOfPt; pos++, i++) {
      let flag = glyf.getUint8(pos);
      flags.push(flag);
      if (flag & REPEAT_FLAG) {
        const count = glyf.getUint8(++pos);
        flag ^= REPEAT_FLAG;
        for (let m = 0; m < count; m++) {
          flags.push(flag);
        }
        i += count;
      }
    }
    const allXCoordinates = [];
    let xCoordinates = [];
    let yCoordinates = [];
    let pointFlags = [];
    const contours = [];
    let endPtsOfContoursIndex = 0;
    let lastCoordinate = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        const x = glyf.getUint8(pos++);
        lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;
        xCoordinates.push(lastCoordinate);
      } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {
        xCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        xCoordinates.push(lastCoordinate);
      }
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        endPtsOfContoursIndex++;
        allXCoordinates.push(xCoordinates);
        xCoordinates = [];
      }
    }
    lastCoordinate = 0;
    endPtsOfContoursIndex = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        const y = glyf.getUint8(pos++);
        lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;
        yCoordinates.push(lastCoordinate);
      } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {
        yCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        yCoordinates.push(lastCoordinate);
      }
      pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        xCoordinates = allXCoordinates[endPtsOfContoursIndex];
        endPtsOfContoursIndex++;
        contours.push(new Contour({
          flags: pointFlags,
          xCoordinates,
          yCoordinates
        }));
        yCoordinates = [];
        pointFlags = [];
      }
    }
    return new SimpleGlyph({
      contours,
      instructions
    });
  }
  getSize() {
    let size = this.contours.length * 2 + 2 + this.instructions.length;
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      size += contour.flags.length;
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        const x = contour.xCoordinates[i];
        const y = contour.yCoordinates[i];
        let abs = Math.abs(x - lastX);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastX = x;
        abs = Math.abs(y - lastY);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastY = y;
      }
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    const xCoordinates = [];
    const yCoordinates = [];
    const flags = [];
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        let flag = contour.flags[i];
        const x = contour.xCoordinates[i];
        let delta = x - lastX;
        if (delta === 0) {
          flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;
          xCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;
            xCoordinates.push(abs);
          } else {
            xCoordinates.push(delta);
          }
        }
        lastX = x;
        const y = contour.yCoordinates[i];
        delta = y - lastY;
        if (delta === 0) {
          flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;
          yCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;
            yCoordinates.push(abs);
          } else {
            yCoordinates.push(delta);
          }
        }
        lastY = y;
        flags.push(flag);
      }
      buf.setUint16(pos, xCoordinates.length - 1);
      pos += 2;
    }
    buf.setUint16(pos, this.instructions.length);
    pos += 2;
    if (this.instructions.length) {
      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
      pos += this.instructions.length;
    }
    for (const flag of flags) {
      buf.setUint8(pos++, flag);
    }
    for (let i = 0, ii = xCoordinates.length; i < ii; i++) {
      const x = xCoordinates[i];
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        buf.setUint8(pos++, x);
      } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {
        buf.setInt16(pos, x);
        pos += 2;
      }
    }
    for (let i = 0, ii = yCoordinates.length; i < ii; i++) {
      const y = yCoordinates[i];
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        buf.setUint8(pos++, y);
      } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {
        buf.setInt16(pos, y);
        pos += 2;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {
    for (const contour of this.contours) {
      if (contour.xCoordinates.length === 0) {
        continue;
      }
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);
      }
    }
  }
}
class CompositeGlyph {
  constructor({
    flags,
    glyphIndex,
    argument1,
    argument2,
    transf,
    instructions
  }) {
    this.flags = flags;
    this.glyphIndex = glyphIndex;
    this.argument1 = argument1;
    this.argument2 = argument2;
    this.transf = transf;
    this.instructions = instructions;
  }
  static parse(pos, glyf) {
    const spos = pos;
    const transf = [];
    let flags = glyf.getUint16(pos);
    const glyphIndex = glyf.getUint16(pos + 2);
    pos += 4;
    let argument1, argument2;
    if (flags & ARG_1_AND_2_ARE_WORDS) {
      if (flags & ARGS_ARE_XY_VALUES) {
        argument1 = glyf.getInt16(pos);
        argument2 = glyf.getInt16(pos + 2);
      } else {
        argument1 = glyf.getUint16(pos);
        argument2 = glyf.getUint16(pos + 2);
      }
      pos += 4;
      flags ^= ARG_1_AND_2_ARE_WORDS;
    } else {
      if (flags & ARGS_ARE_XY_VALUES) {
        argument1 = glyf.getInt8(pos);
        argument2 = glyf.getInt8(pos + 1);
      } else {
        argument1 = glyf.getUint8(pos);
        argument2 = glyf.getUint8(pos + 1);
      }
      pos += 2;
    }
    if (flags & WE_HAVE_A_SCALE) {
      transf.push(glyf.getUint16(pos));
      pos += 2;
    } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));
      pos += 4;
    } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));
      pos += 8;
    }
    let instructions = null;
    if (flags & WE_HAVE_INSTRUCTIONS) {
      const instructionLength = glyf.getUint16(pos);
      pos += 2;
      instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
      pos += instructionLength;
    }
    return [pos - spos, new CompositeGlyph({
      flags,
      glyphIndex,
      argument1,
      argument2,
      transf,
      instructions
    })];
  }
  getSize() {
    let size = 2 + 2 + this.transf.length * 2;
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      size += 2 + this.instructions.length;
    }
    size += 2;
    if (this.flags & 2) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        size += 2;
      }
    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
      size += 2;
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    if (this.flags & ARGS_ARE_XY_VALUES) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        this.flags |= ARG_1_AND_2_ARE_WORDS;
      }
    } else if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
      this.flags |= ARG_1_AND_2_ARE_WORDS;
    }
    buf.setUint16(pos, this.flags);
    buf.setUint16(pos + 2, this.glyphIndex);
    pos += 4;
    if (this.flags & ARG_1_AND_2_ARE_WORDS) {
      if (this.flags & ARGS_ARE_XY_VALUES) {
        buf.setInt16(pos, this.argument1);
        buf.setInt16(pos + 2, this.argument2);
      } else {
        buf.setUint16(pos, this.argument1);
        buf.setUint16(pos + 2, this.argument2);
      }
      pos += 4;
    } else {
      buf.setUint8(pos, this.argument1);
      buf.setUint8(pos + 1, this.argument2);
      pos += 2;
    }
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      buf.setUint16(pos, this.instructions.length);
      pos += 2;
      if (this.instructions.length) {
        new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
        pos += this.instructions.length;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {}
}

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OpenTypeFileBuilder = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
function writeInt16(dest, offset, num) {
  dest[offset] = num >> 8 & 0xff;
  dest[offset + 1] = num & 0xff;
}
function writeInt32(dest, offset, num) {
  dest[offset] = num >> 24 & 0xff;
  dest[offset + 1] = num >> 16 & 0xff;
  dest[offset + 2] = num >> 8 & 0xff;
  dest[offset + 3] = num & 0xff;
}
function writeData(dest, offset, data) {
  if (data instanceof Uint8Array) {
    dest.set(data, offset);
  } else if (typeof data === "string") {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data.charCodeAt(i) & 0xff;
    }
  } else {
    for (const num of data) {
      dest[offset++] = num & 0xff;
    }
  }
}
const OTF_HEADER_SIZE = 12;
const OTF_TABLE_ENTRY_SIZE = 16;
class OpenTypeFileBuilder {
  constructor(sfnt) {
    this.sfnt = sfnt;
    this.tables = Object.create(null);
  }
  static getSearchParams(entriesCount, entrySize) {
    let maxPower2 = 1,
      log2 = 0;
    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log2++;
    }
    const searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log2,
      rangeShift: entrySize * entriesCount - searchRange
    };
  }
  toArray() {
    let sfnt = this.sfnt;
    const tables = this.tables;
    const tablesNames = Object.keys(tables);
    tablesNames.sort();
    const numTables = tablesNames.length;
    let i, j, jj, table, tableName;
    let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
    const tableOffsets = [offset];
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      const paddedLength = (table.length + 3 & ~3) >>> 0;
      offset += paddedLength;
      tableOffsets.push(offset);
    }
    const file = new Uint8Array(offset);
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      writeData(file, tableOffsets[i], table);
    }
    if (sfnt === "true") {
      sfnt = (0, _util.string32)(0x00010000);
    }
    file[0] = sfnt.charCodeAt(0) & 0xff;
    file[1] = sfnt.charCodeAt(1) & 0xff;
    file[2] = sfnt.charCodeAt(2) & 0xff;
    file[3] = sfnt.charCodeAt(3) & 0xff;
    writeInt16(file, 4, numTables);
    const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
    writeInt16(file, 6, searchParams.range);
    writeInt16(file, 8, searchParams.entry);
    writeInt16(file, 10, searchParams.rangeShift);
    offset = OTF_HEADER_SIZE;
    for (i = 0; i < numTables; i++) {
      tableName = tablesNames[i];
      file[offset] = tableName.charCodeAt(0) & 0xff;
      file[offset + 1] = tableName.charCodeAt(1) & 0xff;
      file[offset + 2] = tableName.charCodeAt(2) & 0xff;
      file[offset + 3] = tableName.charCodeAt(3) & 0xff;
      let checksum = 0;
      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
        const quad = (0, _core_utils.readUint32)(file, j);
        checksum = checksum + quad >>> 0;
      }
      writeInt32(file, offset + 4, checksum);
      writeInt32(file, offset + 8, tableOffsets[i]);
      writeInt32(file, offset + 12, tables[tableName].length);
      offset += OTF_TABLE_ENTRY_SIZE;
    }
    return file;
  }
  addTable(tag, data) {
    if (tag in this.tables) {
      throw new Error("Table " + tag + " already exists");
    }
    this.tables[tag] = data;
  }
}
exports.OpenTypeFileBuilder = OpenTypeFileBuilder;

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Font = void 0;
var _cff_parser = __w_pdfjs_require__(35);
var _util = __w_pdfjs_require__(2);
var _fonts_utils = __w_pdfjs_require__(38);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _type1_parser = __w_pdfjs_require__(49);
function findBlock(streamBytes, signature, startIndex) {
  const streamBytesLength = streamBytes.length;
  const signatureLength = signature.length;
  const scanLength = streamBytesLength - signatureLength;
  let i = startIndex,
    found = false;
  while (i < scanLength) {
    let j = 0;
    while (j < signatureLength && streamBytes[i + j] === signature[j]) {
      j++;
    }
    if (j >= signatureLength) {
      i += j;
      while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
        i++;
      }
      found = true;
      break;
    }
    i++;
  }
  return {
    found,
    length: i
  };
}
function getHeaderBlock(stream, suggestedLength) {
  const EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];
  const streamStartPos = stream.pos;
  let headerBytes, headerBytesLength, block;
  try {
    headerBytes = stream.getBytes(suggestedLength);
    headerBytesLength = headerBytes.length;
  } catch {}
  if (headerBytesLength === suggestedLength) {
    block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
    if (block.found && block.length === suggestedLength) {
      return {
        stream: new _stream.Stream(headerBytes),
        length: suggestedLength
      };
    }
  }
  (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
  stream.pos = streamStartPos;
  const SCAN_BLOCK_LENGTH = 2048;
  let actualLength;
  while (true) {
    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
    block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
    if (block.length === 0) {
      break;
    }
    stream.pos += block.length;
    if (block.found) {
      actualLength = stream.pos - streamStartPos;
      break;
    }
  }
  stream.pos = streamStartPos;
  if (actualLength) {
    return {
      stream: new _stream.Stream(stream.getBytes(actualLength)),
      length: actualLength
    };
  }
  (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
  return {
    stream: new _stream.Stream(stream.getBytes(suggestedLength)),
    length: suggestedLength
  };
}
function getEexecBlock(stream, suggestedLength) {
  const eexecBytes = stream.getBytes();
  if (eexecBytes.length === 0) {
    throw new _util.FormatError("getEexecBlock - no font program found.");
  }
  return {
    stream: new _stream.Stream(eexecBytes),
    length: eexecBytes.length
  };
}
class Type1Font {
  constructor(name, file, properties) {
    const PFB_HEADER_SIZE = 6;
    let headerBlockLength = properties.length1;
    let eexecBlockLength = properties.length2;
    let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    const pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;
    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const headerBlock = getHeaderBlock(file, headerBlockLength);
    const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);
    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const eexecBlock = getEexecBlock(file, eexecBlockLength);
    const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    const data = eexecBlockParser.extractFontProgram(properties);
    for (const key in data.properties) {
      properties[key] = data.properties[key];
    }
    const charstrings = data.charstrings;
    const type2Charstrings = this.getType2Charstrings(charstrings);
    const subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const charset = [".notdef"];
    for (const {
      glyphName
    } of this.charstrings) {
      charset.push(glyphName);
    }
    return charset;
  }
  getGlyphMapping(properties) {
    const charstrings = this.charstrings;
    if (properties.composite) {
      const charCodeToGlyphId = Object.create(null);
      for (let glyphId = 0, charstringsLen = charstrings.length; glyphId < charstringsLen; glyphId++) {
        const charCode = properties.cMap.charCodeOf(glyphId);
        charCodeToGlyphId[charCode] = glyphId + 1;
      }
      return charCodeToGlyphId;
    }
    const glyphNames = [".notdef"];
    let builtInEncoding, glyphId;
    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
      glyphNames.push(charstrings[glyphId].glyphName);
    }
    const encoding = properties.builtInEncoding;
    if (encoding) {
      builtInEncoding = Object.create(null);
      for (const charCode in encoding) {
        glyphId = glyphNames.indexOf(encoding[charCode]);
        if (glyphId >= 0) {
          builtInEncoding[charCode] = glyphId;
        }
      }
    }
    return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames);
  }
  hasGlyphId(id) {
    if (id < 0 || id >= this.numGlyphs) {
      return false;
    }
    if (id === 0) {
      return true;
    }
    const glyph = this.charstrings[id - 1];
    return glyph.charstring.length > 0;
  }
  getSeacs(charstrings) {
    const seacMap = [];
    for (let i = 0, ii = charstrings.length; i < ii; i++) {
      const charstring = charstrings[i];
      if (charstring.seac) {
        seacMap[i + 1] = charstring.seac;
      }
    }
    return seacMap;
  }
  getType2Charstrings(type1Charstrings) {
    const type2Charstrings = [];
    for (const type1Charstring of type1Charstrings) {
      type2Charstrings.push(type1Charstring.charstring);
    }
    return type2Charstrings;
  }
  getType2Subrs(type1Subrs) {
    let bias = 0;
    const count = type1Subrs.length;
    if (count < 1133) {
      bias = 107;
    } else if (count < 33769) {
      bias = 1131;
    } else {
      bias = 32768;
    }
    const type2Subrs = [];
    let i;
    for (i = 0; i < bias; i++) {
      type2Subrs.push([0x0b]);
    }
    for (i = 0; i < count; i++) {
      type2Subrs.push(type1Subrs[i]);
    }
    return type2Subrs;
  }
  wrap(name, glyphs, charstrings, subrs, properties) {
    const cff = new _cff_parser.CFF();
    cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
    cff.names = [name];
    const topDict = new _cff_parser.CFFTopDict();
    topDict.setByName("version", 391);
    topDict.setByName("Notice", 392);
    topDict.setByName("FullName", 393);
    topDict.setByName("FamilyName", 394);
    topDict.setByName("Weight", 395);
    topDict.setByName("Encoding", null);
    topDict.setByName("FontMatrix", properties.fontMatrix);
    topDict.setByName("FontBBox", properties.bbox);
    topDict.setByName("charset", null);
    topDict.setByName("CharStrings", null);
    topDict.setByName("Private", null);
    cff.topDict = topDict;
    const strings = new _cff_parser.CFFStrings();
    strings.add("Version 0.11");
    strings.add("See original notice");
    strings.add(name);
    strings.add(name);
    strings.add("Medium");
    cff.strings = strings;
    cff.globalSubrIndex = new _cff_parser.CFFIndex();
    const count = glyphs.length;
    const charsetArray = [".notdef"];
    let i, ii;
    for (i = 0; i < count; i++) {
      const glyphName = charstrings[i].glyphName;
      const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
      if (index === -1) {
        strings.add(glyphName);
      }
      charsetArray.push(glyphName);
    }
    cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
    const charStringsIndex = new _cff_parser.CFFIndex();
    charStringsIndex.add([0x8b, 0x0e]);
    for (i = 0; i < count; i++) {
      charStringsIndex.add(glyphs[i]);
    }
    cff.charStrings = charStringsIndex;
    const privateDict = new _cff_parser.CFFPrivateDict();
    privateDict.setByName("Subrs", null);
    const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (i = 0, ii = fields.length; i < ii; i++) {
      const field = fields[i];
      if (!(field in properties.privateData)) {
        continue;
      }
      const value = properties.privateData[field];
      if (Array.isArray(value)) {
        for (let j = value.length - 1; j > 0; j--) {
          value[j] -= value[j - 1];
        }
      }
      privateDict.setByName(field, value);
    }
    cff.topDict.privateDict = privateDict;
    const subrIndex = new _cff_parser.CFFIndex();
    for (i = 0, ii = subrs.length; i < ii; i++) {
      subrIndex.add(subrs[i]);
    }
    privateDict.subrsIndex = subrIndex;
    const compiler = new _cff_parser.CFFCompiler(cff);
    return compiler.compile();
  }
}
exports.Type1Font = Type1Font;

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Parser = void 0;
var _encodings = __w_pdfjs_require__(37);
var _core_utils = __w_pdfjs_require__(3);
var _stream = __w_pdfjs_require__(8);
var _util = __w_pdfjs_require__(2);
const HINTING_ENABLED = false;
const COMMAND_MAP = {
  hstem: [1],
  vstem: [3],
  vmoveto: [4],
  rlineto: [5],
  hlineto: [6],
  vlineto: [7],
  rrcurveto: [8],
  callsubr: [10],
  flex: [12, 35],
  drop: [12, 18],
  endchar: [14],
  rmoveto: [21],
  hmoveto: [22],
  vhcurveto: [30],
  hvcurveto: [31]
};
class Type1CharString {
  constructor() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }
  convert(encoded, subrs, seacAnalysisEnabled) {
    const count = encoded.length;
    let error = false;
    let wx, sbx, subrNumber;
    for (let i = 0; i < count; i++) {
      let value = encoded[i];
      if (value < 32) {
        if (value === 12) {
          value = (value << 8) + encoded[++i];
        }
        switch (value) {
          case 1:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.hstem);
            break;
          case 3:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.vstem);
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                error = true;
                break;
              }
              const dy = this.stack.pop();
              this.stack.push(0, dy);
              break;
            }
            error = this.executeCommand(1, COMMAND_MAP.vmoveto);
            break;
          case 5:
            error = this.executeCommand(2, COMMAND_MAP.rlineto);
            break;
          case 6:
            error = this.executeCommand(1, COMMAND_MAP.hlineto);
            break;
          case 7:
            error = this.executeCommand(1, COMMAND_MAP.vlineto);
            break;
          case 8:
            error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
            break;
          case 9:
            this.stack = [];
            break;
          case 10:
            if (this.stack.length < 1) {
              error = true;
              break;
            }
            subrNumber = this.stack.pop();
            if (!subrs[subrNumber]) {
              error = true;
              break;
            }
            error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
            break;
          case 11:
            return error;
          case 13:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            wx = this.stack.pop();
            sbx = this.stack.pop();
            this.lsb = sbx;
            this.width = wx;
            this.stack.push(wx, sbx);
            error = this.executeCommand(2, COMMAND_MAP.hmoveto);
            break;
          case 14:
            this.output.push(COMMAND_MAP.endchar[0]);
            break;
          case 21:
            if (this.flexing) {
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.rmoveto);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            error = this.executeCommand(1, COMMAND_MAP.hmoveto);
            break;
          case 30:
            error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
            break;
          case 31:
            error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
            break;
          case (12 << 8) + 0:
            this.stack = [];
            break;
          case (12 << 8) + 1:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.vstem);
            break;
          case (12 << 8) + 2:
            if (!HINTING_ENABLED) {
              this.stack = [];
              break;
            }
            error = this.executeCommand(2, COMMAND_MAP.hstem);
            break;
          case (12 << 8) + 6:
            if (seacAnalysisEnabled) {
              const asb = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4);
              this.seac[0] += this.lsb - asb;
              error = this.executeCommand(0, COMMAND_MAP.endchar);
            } else {
              error = this.executeCommand(4, COMMAND_MAP.endchar);
            }
            break;
          case (12 << 8) + 7:
            if (this.stack.length < 4) {
              error = true;
              break;
            }
            this.stack.pop();
            wx = this.stack.pop();
            const sby = this.stack.pop();
            sbx = this.stack.pop();
            this.lsb = sbx;
            this.width = wx;
            this.stack.push(wx, sbx, sby);
            error = this.executeCommand(3, COMMAND_MAP.rmoveto);
            break;
          case (12 << 8) + 12:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            const num2 = this.stack.pop();
            const num1 = this.stack.pop();
            this.stack.push(num1 / num2);
            break;
          case (12 << 8) + 16:
            if (this.stack.length < 2) {
              error = true;
              break;
            }
            subrNumber = this.stack.pop();
            const numArgs = this.stack.pop();
            if (subrNumber === 0 && numArgs === 3) {
              const flexArgs = this.stack.splice(-17, 17);
              this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
              error = this.executeCommand(13, COMMAND_MAP.flex, true);
              this.flexing = false;
              this.stack.push(flexArgs[15], flexArgs[16]);
            } else if (subrNumber === 1 && numArgs === 0) {
              this.flexing = true;
            }
            break;
          case (12 << 8) + 17:
            break;
          case (12 << 8) + 33:
            this.stack = [];
            break;
          default:
            (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
            break;
        }
        if (error) {
          break;
        }
        continue;
      } else if (value <= 246) {
        value -= 139;
      } else if (value <= 250) {
        value = (value - 247) * 256 + encoded[++i] + 108;
      } else if (value <= 254) {
        value = -((value - 251) * 256) - encoded[++i] - 108;
      } else {
        value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
      }
      this.stack.push(value);
    }
    return error;
  }
  executeCommand(howManyArgs, command, keepStack) {
    const stackLength = this.stack.length;
    if (howManyArgs > stackLength) {
      return true;
    }
    const start = stackLength - howManyArgs;
    for (let i = start; i < stackLength; i++) {
      let value = this.stack[i];
      if (Number.isInteger(value)) {
        this.output.push(28, value >> 8 & 0xff, value & 0xff);
      } else {
        value = 65536 * value | 0;
        this.output.push(255, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
      }
    }
    this.output.push(...command);
    if (keepStack) {
      this.stack.splice(start, howManyArgs);
    } else {
      this.stack.length = 0;
    }
    return false;
  }
}
const EEXEC_ENCRYPT_KEY = 55665;
const CHAR_STRS_ENCRYPT_KEY = 4330;
function isHexDigit(code) {
  return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
}
function decrypt(data, key, discardNumber) {
  if (discardNumber >= data.length) {
    return new Uint8Array(0);
  }
  const c1 = 52845,
    c2 = 22719;
  let r = key | 0,
    i,
    j;
  for (i = 0; i < discardNumber; i++) {
    r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
  }
  const count = data.length - discardNumber;
  const decrypted = new Uint8Array(count);
  for (i = discardNumber, j = 0; j < count; i++, j++) {
    const value = data[i];
    decrypted[j] = value ^ r >> 8;
    r = (value + r) * c1 + c2 & (1 << 16) - 1;
  }
  return decrypted;
}
function decryptAscii(data, key, discardNumber) {
  const c1 = 52845,
    c2 = 22719;
  let r = key | 0;
  const count = data.length,
    maybeLength = count >>> 1;
  const decrypted = new Uint8Array(maybeLength);
  let i, j;
  for (i = 0, j = 0; i < count; i++) {
    const digit1 = data[i];
    if (!isHexDigit(digit1)) {
      continue;
    }
    i++;
    let digit2;
    while (i < count && !isHexDigit(digit2 = data[i])) {
      i++;
    }
    if (i < count) {
      const value = parseInt(String.fromCharCode(digit1, digit2), 16);
      decrypted[j++] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }
  }
  return decrypted.slice(discardNumber, j);
}
function isSpecial(c) {
  return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29;
}
class Type1Parser {
  constructor(stream, encrypted, seacAnalysisEnabled) {
    if (encrypted) {
      const data = stream.getBytes();
      const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
      stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
    }
    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    this.stream = stream;
    this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const array = [];
    while (true) {
      const token = this.getToken();
      if (token === null || token === "]" || token === "}") {
        break;
      }
      array.push(parseFloat(token || 0));
    }
    return array;
  }
  readNumber() {
    const token = this.getToken();
    return parseFloat(token || 0);
  }
  readInt() {
    const token = this.getToken();
    return parseInt(token || 0, 10) | 0;
  }
  readBoolean() {
    const token = this.getToken();
    return token === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    this.stream.skip(-2);
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch === -1) {
        return null;
      }
      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
        break;
      }
      ch = this.nextChar();
    }
    if (isSpecial(ch)) {
      this.nextChar();
      return String.fromCharCode(ch);
    }
    let token = "";
    do {
      token += String.fromCharCode(ch);
      ch = this.nextChar();
    } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
    return token;
  }
  readCharStrings(bytes, lenIV) {
    if (lenIV === -1) {
      return bytes;
    }
    return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
  }
  extractFontProgram(properties) {
    const stream = this.stream;
    const subrs = [],
      charstrings = [];
    const privateData = Object.create(null);
    privateData.lenIV = 4;
    const program = {
      subrs: [],
      charstrings: [],
      properties: {
        privateData
      }
    };
    let token, length, data, lenIV;
    while ((token = this.getToken()) !== null) {
      if (token !== "/") {
        continue;
      }
      token = this.getToken();
      switch (token) {
        case "CharStrings":
          this.getToken();
          this.getToken();
          this.getToken();
          this.getToken();
          while (true) {
            token = this.getToken();
            if (token === null || token === "end") {
              break;
            }
            if (token !== "/") {
              continue;
            }
            const glyph = this.getToken();
            length = this.readInt();
            this.getToken();
            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
            lenIV = program.properties.privateData.lenIV;
            const encoded = this.readCharStrings(data, lenIV);
            this.nextChar();
            token = this.getToken();
            if (token === "noaccess") {
              this.getToken();
            } else if (token === "/") {
              this.prevChar();
            }
            charstrings.push({
              glyph,
              encoded
            });
          }
          break;
        case "Subrs":
          this.readInt();
          this.getToken();
          while (this.getToken() === "dup") {
            const index = this.readInt();
            length = this.readInt();
            this.getToken();
            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
            lenIV = program.properties.privateData.lenIV;
            const encoded = this.readCharStrings(data, lenIV);
            this.nextChar();
            token = this.getToken();
            if (token === "noaccess") {
              this.getToken();
            }
            subrs[index] = encoded;
          }
          break;
        case "BlueValues":
        case "OtherBlues":
        case "FamilyBlues":
        case "FamilyOtherBlues":
          const blueArray = this.readNumberArray();
          if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
            program.properties.privateData[token] = blueArray;
          }
          break;
        case "StemSnapH":
        case "StemSnapV":
          program.properties.privateData[token] = this.readNumberArray();
          break;
        case "StdHW":
        case "StdVW":
          program.properties.privateData[token] = this.readNumberArray()[0];
          break;
        case "BlueShift":
        case "lenIV":
        case "BlueFuzz":
        case "BlueScale":
        case "LanguageGroup":
          program.properties.privateData[token] = this.readNumber();
          break;
        case "ExpansionFactor":
          program.properties.privateData[token] = this.readNumber() || 0.06;
          break;
        case "ForceBold":
          program.properties.privateData[token] = this.readBoolean();
          break;
      }
    }
    for (const {
      encoded,
      glyph
    } of charstrings) {
      const charString = new Type1CharString();
      const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
      let output = charString.output;
      if (error) {
        output = [14];
      }
      const charStringObject = {
        glyphName: glyph,
        charstring: output,
        width: charString.width,
        lsb: charString.lsb,
        seac: charString.seac
      };
      if (glyph === ".notdef") {
        program.charstrings.unshift(charStringObject);
      } else {
        program.charstrings.push(charStringObject);
      }
      if (properties.builtInEncoding) {
        const index = properties.builtInEncoding.indexOf(glyph);
        if (index > -1 && properties.widths[index] === undefined && index >= properties.firstChar && index <= properties.lastChar) {
          properties.widths[index] = charString.width;
        }
      }
    }
    return program;
  }
  extractFontHeader(properties) {
    let token;
    while ((token = this.getToken()) !== null) {
      if (token !== "/") {
        continue;
      }
      token = this.getToken();
      switch (token) {
        case "FontMatrix":
          const matrix = this.readNumberArray();
          properties.fontMatrix = matrix;
          break;
        case "Encoding":
          const encodingArg = this.getToken();
          let encoding;
          if (!/^\d+$/.test(encodingArg)) {
            encoding = (0, _encodings.getEncoding)(encodingArg);
          } else {
            encoding = [];
            const size = parseInt(encodingArg, 10) | 0;
            this.getToken();
            for (let j = 0; j < size; j++) {
              token = this.getToken();
              while (token !== "dup" && token !== "def") {
                token = this.getToken();
                if (token === null) {
                  return;
                }
              }
              if (token === "def") {
                break;
              }
              const index = this.readInt();
              this.getToken();
              const glyph = this.getToken();
              encoding[index] = glyph;
              this.getToken();
            }
          }
          properties.builtInEncoding = encoding;
          break;
        case "FontBBox":
          const fontBBox = this.readNumberArray();
          properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
          properties.descent = Math.min(fontBBox[1], fontBBox[3]);
          properties.ascentScaled = true;
          break;
      }
    }
  }
}
exports.Type1Parser = Type1Parser;

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Pattern = void 0;
exports.clearPatternCaches = clearPatternCaches;
exports.getTilingPatternIR = getTilingPatternIR;
var _util = __w_pdfjs_require__(2);
var _base_stream = __w_pdfjs_require__(5);
var _colorspace = __w_pdfjs_require__(12);
var _core_utils = __w_pdfjs_require__(3);
const ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
class Pattern {
  constructor() {
    (0, _util.unreachable)("Cannot initialize Pattern.");
  }
  static parseShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache) {
    const dict = shading instanceof _base_stream.BaseStream ? shading.dict : shading;
    const type = dict.get("ShadingType");
    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new RadialAxialShading(dict, xref, res, pdfFunctionFactory, localColorSpaceCache);
        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new MeshShading(shading, xref, res, pdfFunctionFactory, localColorSpaceCache);
        default:
          throw new _util.FormatError("Unsupported ShadingType: " + type);
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(ex);
      return new DummyShading();
    }
  }
}
exports.Pattern = Pattern;
class BaseShading {
  static SMALL_NUMBER = 1e-6;
  constructor() {
    if (this.constructor === BaseShading) {
      (0, _util.unreachable)("Cannot initialize BaseShading.");
    }
  }
  getIR() {
    (0, _util.unreachable)("Abstract method `getIR` called.");
  }
}
class RadialAxialShading extends BaseShading {
  constructor(dict, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    this.coordsArr = dict.getArray("Coords");
    this.shadingType = dict.get("ShadingType");
    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    const bbox = dict.getArray("BBox");
    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
    let t0 = 0.0,
      t1 = 1.0;
    if (dict.has("Domain")) {
      const domainArr = dict.getArray("Domain");
      t0 = domainArr[0];
      t1 = domainArr[1];
    }
    let extendStart = false,
      extendEnd = false;
    if (dict.has("Extend")) {
      const extendArr = dict.getArray("Extend");
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }
    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
      const distance = Math.hypot(x1 - x2, y1 - y2);
      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        (0, _util.warn)("Unsupported radial gradient.");
      }
    }
    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    const fnObj = dict.getRaw("Function");
    const fn = pdfFunctionFactory.createFromArray(fnObj);
    const NUMBER_OF_SAMPLES = 840;
    const step = (t1 - t0) / NUMBER_OF_SAMPLES;
    const colorStops = this.colorStops = [];
    if (t0 >= t1 || step <= 0) {
      (0, _util.info)("Bad shading domain.");
      return;
    }
    const color = new Float32Array(cs.numComps),
      ratio = new Float32Array(1);
    let rgbColor;
    let iBase = 0;
    ratio[0] = t0;
    fn(ratio, 0, color, 0);
    let rgbBase = cs.getRgb(color, 0);
    const cssColorBase = _util.Util.makeHexColor(rgbBase[0], rgbBase[1], rgbBase[2]);
    colorStops.push([0, cssColorBase]);
    let iPrev = 1;
    ratio[0] = t0 + step;
    fn(ratio, 0, color, 0);
    let rgbPrev = cs.getRgb(color, 0);
    let maxSlopeR = rgbPrev[0] - rgbBase[0] + 1;
    let maxSlopeG = rgbPrev[1] - rgbBase[1] + 1;
    let maxSlopeB = rgbPrev[2] - rgbBase[2] + 1;
    let minSlopeR = rgbPrev[0] - rgbBase[0] - 1;
    let minSlopeG = rgbPrev[1] - rgbBase[1] - 1;
    let minSlopeB = rgbPrev[2] - rgbBase[2] - 1;
    for (let i = 2; i < NUMBER_OF_SAMPLES; i++) {
      ratio[0] = t0 + i * step;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);
      const run = i - iBase;
      maxSlopeR = Math.min(maxSlopeR, (rgbColor[0] - rgbBase[0] + 1) / run);
      maxSlopeG = Math.min(maxSlopeG, (rgbColor[1] - rgbBase[1] + 1) / run);
      maxSlopeB = Math.min(maxSlopeB, (rgbColor[2] - rgbBase[2] + 1) / run);
      minSlopeR = Math.max(minSlopeR, (rgbColor[0] - rgbBase[0] - 1) / run);
      minSlopeG = Math.max(minSlopeG, (rgbColor[1] - rgbBase[1] - 1) / run);
      minSlopeB = Math.max(minSlopeB, (rgbColor[2] - rgbBase[2] - 1) / run);
      const slopesExist = minSlopeR <= maxSlopeR && minSlopeG <= maxSlopeG && minSlopeB <= maxSlopeB;
      if (!slopesExist) {
        const cssColor = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
        colorStops.push([iPrev / NUMBER_OF_SAMPLES, cssColor]);
        maxSlopeR = rgbColor[0] - rgbPrev[0] + 1;
        maxSlopeG = rgbColor[1] - rgbPrev[1] + 1;
        maxSlopeB = rgbColor[2] - rgbPrev[2] + 1;
        minSlopeR = rgbColor[0] - rgbPrev[0] - 1;
        minSlopeG = rgbColor[1] - rgbPrev[1] - 1;
        minSlopeB = rgbColor[2] - rgbPrev[2] - 1;
        iBase = iPrev;
        rgbBase = rgbPrev;
      }
      iPrev = i;
      rgbPrev = rgbColor;
    }
    const cssColor = _util.Util.makeHexColor(rgbPrev[0], rgbPrev[1], rgbPrev[2]);
    colorStops.push([1, cssColor]);
    let background = "transparent";
    if (dict.has("Background")) {
      rgbColor = cs.getRgb(dict.get("Background"), 0);
      background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
    }
    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += BaseShading.SMALL_NUMBER;
    }
    if (!extendEnd) {
      colorStops.at(-1)[0] -= BaseShading.SMALL_NUMBER;
      colorStops.push([1, background]);
    }
    this.colorStops = colorStops;
  }
  getIR() {
    const coordsArr = this.coordsArr;
    const shadingType = this.shadingType;
    let type, p0, p1, r0, r1;
    if (shadingType === ShadingType.AXIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[2], coordsArr[3]];
      r0 = null;
      r1 = null;
      type = "axial";
    } else if (shadingType === ShadingType.RADIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[3], coordsArr[4]];
      r0 = coordsArr[2];
      r1 = coordsArr[5];
      type = "radial";
    } else {
      (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`);
    }
    return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
  }
}
class MeshStreamReader {
  constructor(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    const numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    const csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) {
      return this.stream.pos < this.stream.end;
    }
    if (this.bufferLength > 0) {
      return true;
    }
    const nextByte = this.stream.getByte();
    if (nextByte < 0) {
      return false;
    }
    this.buffer = nextByte;
    this.bufferLength = 8;
    return true;
  }
  readBits(n) {
    let buffer = this.buffer;
    let bufferLength = this.bufferLength;
    if (n === 32) {
      if (bufferLength === 0) {
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      }
      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const nextByte = this.stream.getByte();
      this.buffer = nextByte & (1 << bufferLength) - 1;
      return (buffer << 8 - bufferLength | (nextByte & 0xff) >> bufferLength) >>> 0;
    }
    if (n === 8 && bufferLength === 0) {
      return this.stream.getByte();
    }
    while (bufferLength < n) {
      buffer = buffer << 8 | this.stream.getByte();
      bufferLength += 8;
    }
    bufferLength -= n;
    this.bufferLength = bufferLength;
    this.buffer = buffer & (1 << bufferLength) - 1;
    return buffer >> bufferLength;
  }
  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const bitsPerCoordinate = this.context.bitsPerCoordinate;
    const xi = this.readBits(bitsPerCoordinate);
    const yi = this.readBits(bitsPerCoordinate);
    const decode = this.context.decode;
    const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
  }
  readComponents() {
    const numComps = this.context.numComps;
    const bitsPerComponent = this.context.bitsPerComponent;
    const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
    const decode = this.context.decode;
    const components = this.tmpCompsBuf;
    for (let i = 0, j = 4; i < numComps; i++, j += 2) {
      const ci = this.readBits(bitsPerComponent);
      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
    }
    const color = this.tmpCsCompsBuf;
    if (this.context.colorFn) {
      this.context.colorFn(components, 0, color, 0);
    }
    return this.context.colorSpace.getRgb(color, 0);
  }
}
let bCache = Object.create(null);
function buildB(count) {
  const lut = [];
  for (let i = 0; i <= count; i++) {
    const t = i / count,
      t_ = 1 - t;
    lut.push(new Float32Array([t_ ** 3, 3 * t * t_ ** 2, 3 * t ** 2 * t_, t ** 3]));
  }
  return lut;
}
function getB(count) {
  return bCache[count] ||= buildB(count);
}
function clearPatternCaches() {
  bCache = Object.create(null);
}
class MeshShading extends BaseShading {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(stream, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    if (!(stream instanceof _base_stream.BaseStream)) {
      throw new _util.FormatError("Mesh data is not a stream");
    }
    const dict = stream.dict;
    this.shadingType = dict.get("ShadingType");
    const bbox = dict.getArray("BBox");
    this.bbox = Array.isArray(bbox) && bbox.length === 4 ? _util.Util.normalizeRect(bbox) : null;
    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("CS") || dict.getRaw("ColorSpace"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
    const fnObj = dict.getRaw("Function");
    const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const decodeContext = {
      bitsPerCoordinate: dict.get("BitsPerCoordinate"),
      bitsPerComponent: dict.get("BitsPerComponent"),
      bitsPerFlag: dict.get("BitsPerFlag"),
      decode: dict.getArray("Decode"),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    const reader = new MeshStreamReader(stream, decodeContext);
    let patchMesh = false;
    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        this._decodeType4Shading(reader);
        break;
      case ShadingType.LATTICE_FORM_MESH:
        const verticesPerRow = dict.get("VerticesPerRow") | 0;
        if (verticesPerRow < 2) {
          throw new _util.FormatError("Invalid VerticesPerRow");
        }
        this._decodeType5Shading(reader, verticesPerRow);
        break;
      case ShadingType.COONS_PATCH_MESH:
        this._decodeType6Shading(reader);
        patchMesh = true;
        break;
      case ShadingType.TENSOR_PATCH_MESH:
        this._decodeType7Shading(reader);
        patchMesh = true;
        break;
      default:
        (0, _util.unreachable)("Unsupported mesh type.");
        break;
    }
    if (patchMesh) {
      this._updateBounds();
      for (let i = 0, ii = this.figures.length; i < ii; i++) {
        this._buildFigureFromPatch(i);
      }
    }
    this._updateBounds();
    this._packData();
  }
  _decodeType4Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const operators = [];
    const ps = [];
    let verticesLeft = 0;
    while (reader.hasData) {
      const f = reader.readFlag();
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      if (verticesLeft === 0) {
        if (!(0 <= f && f <= 2)) {
          throw new _util.FormatError("Unknown type4 flag");
        }
        switch (f) {
          case 0:
            verticesLeft = 3;
            break;
          case 1:
            ps.push(ps.at(-2), ps.at(-1));
            verticesLeft = 1;
            break;
          case 2:
            ps.push(ps.at(-3), ps.at(-1));
            verticesLeft = 1;
            break;
        }
        operators.push(f);
      }
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }
    this.figures.push({
      type: "triangles",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }
  _decodeType5Shading(reader, verticesPerRow) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = [];
    while (reader.hasData) {
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }
    this.figures.push({
      type: "lattice",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow
    });
  }
  _decodeType6Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type6 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  _decodeType7Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type7 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }
  _buildFigureFromPatch(index) {
    const figure = this.figures[index];
    (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
    const coords = this.coords,
      colors = this.colors;
    const pi = figure.coords;
    const ci = figure.colors;
    const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    let splitXBy = Math.ceil((figureMaxX - figureMinX) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    splitXBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    let splitYBy = Math.ceil((figureMaxY - figureMinY) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    splitYBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    const verticesPerRow = splitXBy + 1;
    const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    let k = 0;
    const cl = new Uint8Array(3),
      cr = new Uint8Array(3);
    const c0 = colors[ci[0]],
      c1 = colors[ci[1]],
      c2 = colors[ci[2]],
      c3 = colors[ci[3]];
    const bRow = getB(splitYBy),
      bCol = getB(splitXBy);
    for (let row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
      for (let col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }
        let x = 0,
          y = 0;
        let q = 0;
        for (let i = 0; i <= 3; i++) {
          for (let j = 0; j <= 3; j++, q++) {
            const m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }
        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        const newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }
    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    this.figures[index] = {
      type: "lattice",
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow
    };
  }
  _updateBounds() {
    let minX = this.coords[0][0],
      minY = this.coords[0][1],
      maxX = minX,
      maxY = minY;
    for (let i = 1, ii = this.coords.length; i < ii; i++) {
      const x = this.coords[i][0],
        y = this.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }
    this.bounds = [minX, minY, maxX, maxY];
  }
  _packData() {
    let i, ii, j, jj;
    const coords = this.coords;
    const coordsPacked = new Float32Array(coords.length * 2);
    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      const xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }
    this.coords = coordsPacked;
    const colors = this.colors;
    const colorsPacked = new Uint8Array(colors.length * 3);
    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      const c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }
    this.colors = colorsPacked;
    const figures = this.figures;
    for (i = 0, ii = figures.length; i < ii; i++) {
      const figure = figures[i],
        ps = figure.coords,
        cs = figure.colors;
      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }
  getIR() {
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
  }
}
class DummyShading extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
}
function getTilingPatternIR(operatorList, dict, color) {
  const matrix = dict.getArray("Matrix");
  const bbox = _util.Util.normalizeRect(dict.getArray("BBox"));
  const xstep = dict.get("XStep");
  const ystep = dict.get("YStep");
  const paintType = dict.get("PaintType");
  const tilingType = dict.get("TilingType");
  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
    throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
  }
  return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getXfaFontDict = getXfaFontDict;
exports.getXfaFontName = getXfaFontName;
var _calibri_factors = __w_pdfjs_require__(52);
var _primitives = __w_pdfjs_require__(4);
var _helvetica_factors = __w_pdfjs_require__(53);
var _liberationsans_widths = __w_pdfjs_require__(54);
var _myriadpro_factors = __w_pdfjs_require__(55);
var _segoeui_factors = __w_pdfjs_require__(56);
var _core_utils = __w_pdfjs_require__(3);
var _fonts_utils = __w_pdfjs_require__(38);
const getXFAFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _myriadpro_factors.MyriadProRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _myriadpro_factors.MyriadProRegularMetrics
  };
  t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _myriadpro_factors.MyriadProBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _myriadpro_factors.MyriadProBoldMetrics
  };
  t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _myriadpro_factors.MyriadProItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _myriadpro_factors.MyriadProItalicMetrics
  };
  t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _myriadpro_factors.MyriadProBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _myriadpro_factors.MyriadProBoldItalicMetrics
  };
  t.ArialMT = t.Arial = t["Arial-Regular"] = {
    name: "LiberationSans-Regular",
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping
  };
  t["Arial-BoldMT"] = t["Arial-Bold"] = {
    name: "LiberationSans-Bold",
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping
  };
  t["Arial-ItalicMT"] = t["Arial-Italic"] = {
    name: "LiberationSans-Italic",
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping
  };
  t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping
  };
  t["Calibri-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _calibri_factors.CalibriRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _calibri_factors.CalibriRegularMetrics
  };
  t["Calibri-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _calibri_factors.CalibriBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _calibri_factors.CalibriBoldMetrics
  };
  t["Calibri-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _calibri_factors.CalibriItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _calibri_factors.CalibriItalicMetrics
  };
  t["Calibri-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _calibri_factors.CalibriBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _calibri_factors.CalibriBoldItalicMetrics
  };
  t["Segoeui-Regular"] = {
    name: "LiberationSans-Regular",
    factors: _segoeui_factors.SegoeuiRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _segoeui_factors.SegoeuiRegularMetrics
  };
  t["Segoeui-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _segoeui_factors.SegoeuiBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _segoeui_factors.SegoeuiBoldMetrics
  };
  t["Segoeui-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _segoeui_factors.SegoeuiItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _segoeui_factors.SegoeuiItalicMetrics
  };
  t["Segoeui-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _segoeui_factors.SegoeuiBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _segoeui_factors.SegoeuiBoldItalicMetrics
  };
  t["Helvetica-Regular"] = t.Helvetica = {
    name: "LiberationSans-Regular",
    factors: _helvetica_factors.HelveticaRegularFactors,
    baseWidths: _liberationsans_widths.LiberationSansRegularWidths,
    baseMapping: _liberationsans_widths.LiberationSansRegularMapping,
    metrics: _helvetica_factors.HelveticaRegularMetrics
  };
  t["Helvetica-Bold"] = {
    name: "LiberationSans-Bold",
    factors: _helvetica_factors.HelveticaBoldFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldMapping,
    metrics: _helvetica_factors.HelveticaBoldMetrics
  };
  t["Helvetica-Italic"] = {
    name: "LiberationSans-Italic",
    factors: _helvetica_factors.HelveticaItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansItalicMapping,
    metrics: _helvetica_factors.HelveticaItalicMetrics
  };
  t["Helvetica-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _helvetica_factors.HelveticaBoldItalicFactors,
    baseWidths: _liberationsans_widths.LiberationSansBoldItalicWidths,
    baseMapping: _liberationsans_widths.LiberationSansBoldItalicMapping,
    metrics: _helvetica_factors.HelveticaBoldItalicMetrics
  };
});
function getXfaFontName(name) {
  const fontName = (0, _fonts_utils.normalizeFontName)(name);
  const fontMap = getXFAFontMap();
  return fontMap[fontName];
}
function getXfaFontWidths(name) {
  const info = getXfaFontName(name);
  if (!info) {
    return null;
  }
  const {
    baseWidths,
    baseMapping,
    factors
  } = info;
  const rescaledBaseWidths = !factors ? baseWidths : baseWidths.map((w, i) => w * factors[i]);
  let currentCode = -2;
  let currentArray;
  const newWidths = [];
  for (const [unicode, glyphIndex] of baseMapping.map((charUnicode, index) => [charUnicode, index]).sort(([unicode1], [unicode2]) => unicode1 - unicode2)) {
    if (unicode === -1) {
      continue;
    }
    if (unicode === currentCode + 1) {
      currentArray.push(rescaledBaseWidths[glyphIndex]);
      currentCode += 1;
    } else {
      currentCode = unicode;
      currentArray = [rescaledBaseWidths[glyphIndex]];
      newWidths.push(unicode, currentArray);
    }
  }
  return newWidths;
}
function getXfaFontDict(name) {
  const widths = getXfaFontWidths(name);
  const dict = new _primitives.Dict(null);
  dict.set("BaseFont", _primitives.Name.get(name));
  dict.set("Type", _primitives.Name.get("Font"));
  dict.set("Subtype", _primitives.Name.get("CIDFontType2"));
  dict.set("Encoding", _primitives.Name.get("Identity-H"));
  dict.set("CIDToGIDMap", _primitives.Name.get("Identity"));
  dict.set("W", widths);
  dict.set("FirstChar", widths[0]);
  dict.set("LastChar", widths.at(-2) + widths.at(-1).length - 1);
  const descriptor = new _primitives.Dict(null);
  dict.set("FontDescriptor", descriptor);
  const systemInfo = new _primitives.Dict(null);
  systemInfo.set("Ordering", "Identity");
  systemInfo.set("Registry", "Adobe");
  systemInfo.set("Supplement", 0);
  dict.set("CIDSystemInfo", systemInfo);
  return dict;
}

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CalibriRegularMetrics = exports.CalibriRegularFactors = exports.CalibriItalicMetrics = exports.CalibriItalicFactors = exports.CalibriBoldMetrics = exports.CalibriBoldItalicMetrics = exports.CalibriBoldItalicFactors = exports.CalibriBoldFactors = void 0;
const CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriBoldFactors = CalibriBoldFactors;
const CalibriBoldMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriBoldMetrics = CalibriBoldMetrics;
const CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriBoldItalicFactors = CalibriBoldItalicFactors;
const CalibriBoldItalicMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriBoldItalicMetrics = CalibriBoldItalicMetrics;
const CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriItalicFactors = CalibriItalicFactors;
const CalibriItalicMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriItalicMetrics = CalibriItalicMetrics;
const CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.CalibriRegularFactors = CalibriRegularFactors;
const CalibriRegularMetrics = {
  lineHeight: 1.2207,
  lineGap: 0.2207
};
exports.CalibriRegularMetrics = CalibriRegularMetrics;

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HelveticaRegularMetrics = exports.HelveticaRegularFactors = exports.HelveticaItalicMetrics = exports.HelveticaItalicFactors = exports.HelveticaBoldMetrics = exports.HelveticaBoldItalicMetrics = exports.HelveticaBoldItalicFactors = exports.HelveticaBoldFactors = void 0;
const HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaBoldFactors = HelveticaBoldFactors;
const HelveticaBoldMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.HelveticaBoldMetrics = HelveticaBoldMetrics;
const HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaBoldItalicFactors = HelveticaBoldItalicFactors;
const HelveticaBoldItalicMetrics = {
  lineHeight: 1.35,
  lineGap: 0.2
};
exports.HelveticaBoldItalicMetrics = HelveticaBoldItalicMetrics;
const HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaItalicFactors = HelveticaItalicFactors;
const HelveticaItalicMetrics = {
  lineHeight: 1.35,
  lineGap: 0.2
};
exports.HelveticaItalicMetrics = HelveticaItalicMetrics;
const HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.HelveticaRegularFactors = HelveticaRegularFactors;
const HelveticaRegularMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.HelveticaRegularMetrics = HelveticaRegularMetrics;

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LiberationSansRegularWidths = exports.LiberationSansRegularMapping = exports.LiberationSansItalicWidths = exports.LiberationSansItalicMapping = exports.LiberationSansBoldWidths = exports.LiberationSansBoldMapping = exports.LiberationSansBoldItalicWidths = exports.LiberationSansBoldItalicMapping = void 0;
const LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
exports.LiberationSansBoldWidths = LiberationSansBoldWidths;
const LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansBoldMapping = LiberationSansBoldMapping;
const LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1000, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1000, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1000, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1000, 1000, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1000, 1000, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1000, 768, 600, 834, 834, 834, 834, 999, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
exports.LiberationSansBoldItalicWidths = LiberationSansBoldItalicWidths;
const LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansBoldItalicMapping = LiberationSansBoldItalicMapping;
const LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 998, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
exports.LiberationSansItalicWidths = LiberationSansItalicWidths;
const LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansItalicMapping = LiberationSansItalicMapping;
const LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1000, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1000, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1000, 1000, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1000, 1000, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1000, 768, 600, 834, 834, 834, 834, 1000, 500, 1000, 500, 1000, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1000, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
exports.LiberationSansRegularWidths = LiberationSansRegularWidths;
const LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
exports.LiberationSansRegularMapping = LiberationSansRegularMapping;

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MyriadProRegularMetrics = exports.MyriadProRegularFactors = exports.MyriadProItalicMetrics = exports.MyriadProItalicFactors = exports.MyriadProBoldMetrics = exports.MyriadProBoldItalicMetrics = exports.MyriadProBoldItalicFactors = exports.MyriadProBoldFactors = void 0;
const MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProBoldFactors = MyriadProBoldFactors;
const MyriadProBoldMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProBoldMetrics = MyriadProBoldMetrics;
const MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProBoldItalicFactors = MyriadProBoldItalicFactors;
const MyriadProBoldItalicMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProBoldItalicMetrics = MyriadProBoldItalicMetrics;
const MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProItalicFactors = MyriadProItalicFactors;
const MyriadProItalicMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProItalicMetrics = MyriadProItalicMetrics;
const MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.MyriadProRegularFactors = MyriadProRegularFactors;
const MyriadProRegularMetrics = {
  lineHeight: 1.2,
  lineGap: 0.2
};
exports.MyriadProRegularMetrics = MyriadProRegularMetrics;

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SegoeuiRegularMetrics = exports.SegoeuiRegularFactors = exports.SegoeuiItalicMetrics = exports.SegoeuiItalicFactors = exports.SegoeuiBoldMetrics = exports.SegoeuiBoldItalicMetrics = exports.SegoeuiBoldItalicFactors = exports.SegoeuiBoldFactors = void 0;
const SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiBoldFactors = SegoeuiBoldFactors;
const SegoeuiBoldMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiBoldMetrics = SegoeuiBoldMetrics;
const SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiBoldItalicFactors = SegoeuiBoldItalicFactors;
const SegoeuiBoldItalicMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiBoldItalicMetrics = SegoeuiBoldItalicMetrics;
const SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiItalicFactors = SegoeuiItalicFactors;
const SegoeuiItalicMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiItalicMetrics = SegoeuiItalicMetrics;
const SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
exports.SegoeuiRegularFactors = SegoeuiRegularFactors;
const SegoeuiRegularMetrics = {
  lineHeight: 1.33008,
  lineGap: 0
};
exports.SegoeuiRegularMetrics = SegoeuiRegularMetrics;

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptEvaluator = exports.PostScriptCompiler = exports.PDFFunctionFactory = void 0;
exports.isPDFFunction = isPDFFunction;
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
var _ps_parser = __w_pdfjs_require__(58);
var _base_stream = __w_pdfjs_require__(5);
var _image_utils = __w_pdfjs_require__(59);
class PDFFunctionFactory {
  constructor({
    xref,
    isEvalSupported = true
  }) {
    this.xref = xref;
    this.isEvalSupported = isEvalSupported !== false;
  }
  create(fn) {
    const cachedFunction = this.getCached(fn);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parse({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
    });
    this._cache(fn, parsedFunction);
    return parsedFunction;
  }
  createFromArray(fnObj) {
    const cachedFunction = this.getCached(fnObj);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parseArray({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
    });
    this._cache(fnObj, parsedFunction);
    return parsedFunction;
  }
  getCached(cacheKey) {
    let fnRef;
    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if (cacheKey instanceof _base_stream.BaseStream) {
      fnRef = cacheKey.dict?.objId;
    }
    if (fnRef) {
      const localFunction = this._localFunctionCache.getByRef(fnRef);
      if (localFunction) {
        return localFunction;
      }
    }
    return null;
  }
  _cache(cacheKey, parsedFunction) {
    if (!parsedFunction) {
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    }
    let fnRef;
    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if (cacheKey instanceof _base_stream.BaseStream) {
      fnRef = cacheKey.dict?.objId;
    }
    if (fnRef) {
      this._localFunctionCache.set(null, fnRef, parsedFunction);
    }
  }
  get _localFunctionCache() {
    return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
  }
}
exports.PDFFunctionFactory = PDFFunctionFactory;
function toNumberArray(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const length = arr.length;
  for (let i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      const result = new Array(length);
      for (let j = 0; j < length; j++) {
        result[j] = +arr[j];
      }
      return result;
    }
  }
  return arr;
}
class PDFFunction {
  static getSampleArray(size, outputSize, bps, stream) {
    let i, ii;
    let length = 1;
    for (i = 0, ii = size.length; i < ii; i++) {
      length *= size[i];
    }
    length *= outputSize;
    const array = new Array(length);
    let codeSize = 0;
    let codeBuf = 0;
    const sampleMul = 1.0 / (2.0 ** bps - 1);
    const strBytes = stream.getBytes((length * bps + 7) / 8);
    let strIdx = 0;
    for (i = 0; i < length; i++) {
      while (codeSize < bps) {
        codeBuf <<= 8;
        codeBuf |= strBytes[strIdx++];
        codeSize += 8;
      }
      codeSize -= bps;
      array[i] = (codeBuf >> codeSize) * sampleMul;
      codeBuf &= (1 << codeSize) - 1;
    }
    return array;
  }
  static parse({
    xref,
    isEvalSupported,
    fn
  }) {
    const dict = fn.dict || fn;
    const typeNum = dict.get("FunctionType");
    switch (typeNum) {
      case 0:
        return this.constructSampled({
          xref,
          isEvalSupported,
          fn,
          dict
        });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({
          xref,
          isEvalSupported,
          dict
        });
      case 3:
        return this.constructStiched({
          xref,
          isEvalSupported,
          dict
        });
      case 4:
        return this.constructPostScript({
          xref,
          isEvalSupported,
          fn,
          dict
        });
    }
    throw new _util.FormatError("Unknown type of function");
  }
  static parseArray({
    xref,
    isEvalSupported,
    fnObj
  }) {
    if (!Array.isArray(fnObj)) {
      return this.parse({
        xref,
        isEvalSupported,
        fn: fnObj
      });
    }
    const fnArray = [];
    for (const fn of fnObj) {
      fnArray.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fn)
      }));
    }
    return function (src, srcOffset, dest, destOffset) {
      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        fnArray[i](src, srcOffset, dest, destOffset + i);
      }
    };
  }
  static constructSampled({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    function toMultiArray(arr) {
      const inputLength = arr.length;
      const out = [];
      let index = 0;
      for (let i = 0; i < inputLength; i += 2) {
        out[index++] = [arr[i], arr[i + 1]];
      }
      return out;
    }
    function interpolate(x, xmin, xmax, ymin, ymax) {
      return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
    }
    let domain = toNumberArray(dict.getArray("Domain"));
    let range = toNumberArray(dict.getArray("Range"));
    if (!domain || !range) {
      throw new _util.FormatError("No domain or range");
    }
    const inputSize = domain.length / 2;
    const outputSize = range.length / 2;
    domain = toMultiArray(domain);
    range = toMultiArray(range);
    const size = toNumberArray(dict.getArray("Size"));
    const bps = dict.get("BitsPerSample");
    const order = dict.get("Order") || 1;
    if (order !== 1) {
      (0, _util.info)("No support for cubic spline interpolation: " + order);
    }
    let encode = toNumberArray(dict.getArray("Encode"));
    if (!encode) {
      encode = [];
      for (let i = 0; i < inputSize; ++i) {
        encode.push([0, size[i] - 1]);
      }
    } else {
      encode = toMultiArray(encode);
    }
    let decode = toNumberArray(dict.getArray("Decode"));
    decode = !decode ? range : toMultiArray(decode);
    const samples = this.getSampleArray(size, outputSize, bps, fn);
    return function constructSampledFn(src, srcOffset, dest, destOffset) {
      const cubeVertices = 1 << inputSize;
      const cubeN = new Float64Array(cubeVertices);
      const cubeVertex = new Uint32Array(cubeVertices);
      let i, j;
      for (j = 0; j < cubeVertices; j++) {
        cubeN[j] = 1;
      }
      let k = outputSize,
        pos = 1;
      for (i = 0; i < inputSize; ++i) {
        const domain_2i = domain[i][0];
        const domain_2i_1 = domain[i][1];
        const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
        let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
        const size_i = size[i];
        e = Math.min(Math.max(e, 0), size_i - 1);
        const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
        const n0 = e0 + 1 - e;
        const n1 = e - e0;
        const offset0 = e0 * k;
        const offset1 = offset0 + k;
        for (j = 0; j < cubeVertices; j++) {
          if (j & pos) {
            cubeN[j] *= n1;
            cubeVertex[j] += offset1;
          } else {
            cubeN[j] *= n0;
            cubeVertex[j] += offset0;
          }
        }
        k *= size_i;
        pos <<= 1;
      }
      for (j = 0; j < outputSize; ++j) {
        let rj = 0;
        for (i = 0; i < cubeVertices; i++) {
          rj += samples[cubeVertex[i] + j] * cubeN[i];
        }
        rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
        dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
      }
    };
  }
  static constructInterpolated({
    xref,
    isEvalSupported,
    dict
  }) {
    const c0 = toNumberArray(dict.getArray("C0")) || [0];
    const c1 = toNumberArray(dict.getArray("C1")) || [1];
    const n = dict.get("N");
    const diff = [];
    for (let i = 0, ii = c0.length; i < ii; ++i) {
      diff.push(c1[i] - c0[i]);
    }
    const length = diff.length;
    return function constructInterpolatedFn(src, srcOffset, dest, destOffset) {
      const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
      for (let j = 0; j < length; ++j) {
        dest[destOffset + j] = c0[j] + x * diff[j];
      }
    };
  }
  static constructStiched({
    xref,
    isEvalSupported,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    if (!domain) {
      throw new _util.FormatError("No domain");
    }
    const inputSize = domain.length / 2;
    if (inputSize !== 1) {
      throw new _util.FormatError("Bad domain for stiched function");
    }
    const fns = [];
    for (const fn of dict.get("Functions")) {
      fns.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fn)
      }));
    }
    const bounds = toNumberArray(dict.getArray("Bounds"));
    const encode = toNumberArray(dict.getArray("Encode"));
    const tmpBuf = new Float32Array(1);
    return function constructStichedFn(src, srcOffset, dest, destOffset) {
      const clip = function constructStichedFromIRClip(v, min, max) {
        if (v > max) {
          v = max;
        } else if (v < min) {
          v = min;
        }
        return v;
      };
      const v = clip(src[srcOffset], domain[0], domain[1]);
      const length = bounds.length;
      let i;
      for (i = 0; i < length; ++i) {
        if (v < bounds[i]) {
          break;
        }
      }
      let dmin = domain[0];
      if (i > 0) {
        dmin = bounds[i - 1];
      }
      let dmax = domain[1];
      if (i < bounds.length) {
        dmax = bounds[i];
      }
      const rmin = encode[2 * i];
      const rmax = encode[2 * i + 1];
      tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
      fns[i](tmpBuf, 0, dest, destOffset);
    };
  }
  static constructPostScript({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    const range = toNumberArray(dict.getArray("Range"));
    if (!domain) {
      throw new _util.FormatError("No domain.");
    }
    if (!range) {
      throw new _util.FormatError("No range.");
    }
    const lexer = new _ps_parser.PostScriptLexer(fn);
    const parser = new _ps_parser.PostScriptParser(lexer);
    const code = parser.parse();
    if (isEvalSupported && _util.FeatureTest.isEvalSupported) {
      const compiled = new PostScriptCompiler().compile(code, domain, range);
      if (compiled) {
        return new Function("src", "srcOffset", "dest", "destOffset", compiled);
      }
    }
    (0, _util.info)("Unable to compile PS function");
    const numOutputs = range.length >> 1;
    const numInputs = domain.length >> 1;
    const evaluator = new PostScriptEvaluator(code);
    const cache = Object.create(null);
    const MAX_CACHE_SIZE = 2048 * 4;
    let cache_available = MAX_CACHE_SIZE;
    const tmpBuf = new Float32Array(numInputs);
    return function constructPostScriptFn(src, srcOffset, dest, destOffset) {
      let i, value;
      let key = "";
      const input = tmpBuf;
      for (i = 0; i < numInputs; i++) {
        value = src[srcOffset + i];
        input[i] = value;
        key += value + "_";
      }
      const cachedValue = cache[key];
      if (cachedValue !== undefined) {
        dest.set(cachedValue, destOffset);
        return;
      }
      const output = new Float32Array(numOutputs);
      const stack = evaluator.execute(input);
      const stackIndex = stack.length - numOutputs;
      for (i = 0; i < numOutputs; i++) {
        value = stack[stackIndex + i];
        let bound = range[i * 2];
        if (value < bound) {
          value = bound;
        } else {
          bound = range[i * 2 + 1];
          if (value > bound) {
            value = bound;
          }
        }
        output[i] = value;
      }
      if (cache_available > 0) {
        cache_available--;
        cache[key] = output;
      }
      dest.set(output, destOffset);
    };
  }
}
function isPDFFunction(v) {
  let fnDict;
  if (v instanceof _primitives.Dict) {
    fnDict = v;
  } else if (v instanceof _base_stream.BaseStream) {
    fnDict = v.dict;
  } else {
    return false;
  }
  return fnDict.has("FunctionType");
}
class PostScriptStack {
  static MAX_STACK_SIZE = 100;
  constructor(initialStack) {
    this.stack = initialStack ? Array.from(initialStack) : [];
  }
  push(value) {
    if (this.stack.length >= PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    this.stack.push(value);
  }
  pop() {
    if (this.stack.length <= 0) {
      throw new Error("PostScript function stack underflow.");
    }
    return this.stack.pop();
  }
  copy(n) {
    if (this.stack.length + n >= PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    const stack = this.stack;
    for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
      stack.push(stack[i]);
    }
  }
  index(n) {
    this.push(this.stack[this.stack.length - n - 1]);
  }
  roll(n, p) {
    const stack = this.stack;
    const l = stack.length - n;
    const r = stack.length - 1;
    const c = l + (p - Math.floor(p / n) * n);
    for (let i = l, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = l, j = c - 1; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = c, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
  }
}
class PostScriptEvaluator {
  constructor(operators) {
    this.operators = operators;
  }
  execute(initialStack) {
    const stack = new PostScriptStack(initialStack);
    let counter = 0;
    const operators = this.operators;
    const length = operators.length;
    let operator, a, b;
    while (counter < length) {
      operator = operators[counter++];
      if (typeof operator === "number") {
        stack.push(operator);
        continue;
      }
      switch (operator) {
        case "jz":
          b = stack.pop();
          a = stack.pop();
          if (!a) {
            counter = b;
          }
          break;
        case "j":
          a = stack.pop();
          counter = a;
          break;
        case "abs":
          a = stack.pop();
          stack.push(Math.abs(a));
          break;
        case "add":
          b = stack.pop();
          a = stack.pop();
          stack.push(a + b);
          break;
        case "and":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a && b);
          } else {
            stack.push(a & b);
          }
          break;
        case "atan":
          b = stack.pop();
          a = stack.pop();
          a = Math.atan2(a, b) / Math.PI * 180;
          if (a < 0) {
            a += 360;
          }
          stack.push(a);
          break;
        case "bitshift":
          b = stack.pop();
          a = stack.pop();
          if (a > 0) {
            stack.push(a << b);
          } else {
            stack.push(a >> b);
          }
          break;
        case "ceiling":
          a = stack.pop();
          stack.push(Math.ceil(a));
          break;
        case "copy":
          a = stack.pop();
          stack.copy(a);
          break;
        case "cos":
          a = stack.pop();
          stack.push(Math.cos(a % 360 / 180 * Math.PI));
          break;
        case "cvi":
          a = stack.pop() | 0;
          stack.push(a);
          break;
        case "cvr":
          break;
        case "div":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b);
          break;
        case "dup":
          stack.copy(1);
          break;
        case "eq":
          b = stack.pop();
          a = stack.pop();
          stack.push(a === b);
          break;
        case "exch":
          stack.roll(2, 1);
          break;
        case "exp":
          b = stack.pop();
          a = stack.pop();
          stack.push(a ** b);
          break;
        case "false":
          stack.push(false);
          break;
        case "floor":
          a = stack.pop();
          stack.push(Math.floor(a));
          break;
        case "ge":
          b = stack.pop();
          a = stack.pop();
          stack.push(a >= b);
          break;
        case "gt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a > b);
          break;
        case "idiv":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b | 0);
          break;
        case "index":
          a = stack.pop();
          stack.index(a);
          break;
        case "le":
          b = stack.pop();
          a = stack.pop();
          stack.push(a <= b);
          break;
        case "ln":
          a = stack.pop();
          stack.push(Math.log(a));
          break;
        case "log":
          a = stack.pop();
          stack.push(Math.log10(a));
          break;
        case "lt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a < b);
          break;
        case "mod":
          b = stack.pop();
          a = stack.pop();
          stack.push(a % b);
          break;
        case "mul":
          b = stack.pop();
          a = stack.pop();
          stack.push(a * b);
          break;
        case "ne":
          b = stack.pop();
          a = stack.pop();
          stack.push(a !== b);
          break;
        case "neg":
          a = stack.pop();
          stack.push(-a);
          break;
        case "not":
          a = stack.pop();
          if (typeof a === "boolean") {
            stack.push(!a);
          } else {
            stack.push(~a);
          }
          break;
        case "or":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a || b);
          } else {
            stack.push(a | b);
          }
          break;
        case "pop":
          stack.pop();
          break;
        case "roll":
          b = stack.pop();
          a = stack.pop();
          stack.roll(a, b);
          break;
        case "round":
          a = stack.pop();
          stack.push(Math.round(a));
          break;
        case "sin":
          a = stack.pop();
          stack.push(Math.sin(a % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          a = stack.pop();
          stack.push(Math.sqrt(a));
          break;
        case "sub":
          b = stack.pop();
          a = stack.pop();
          stack.push(a - b);
          break;
        case "true":
          stack.push(true);
          break;
        case "truncate":
          a = stack.pop();
          a = a < 0 ? Math.ceil(a) : Math.floor(a);
          stack.push(a);
          break;
        case "xor":
          b = stack.pop();
          a = stack.pop();
          if (typeof a === "boolean" && typeof b === "boolean") {
            stack.push(a !== b);
          } else {
            stack.push(a ^ b);
          }
          break;
        default:
          throw new _util.FormatError(`Unknown operator ${operator}`);
      }
    }
    return stack.stack;
  }
}
exports.PostScriptEvaluator = PostScriptEvaluator;
class AstNode {
  constructor(type) {
    this.type = type;
  }
  visit(visitor) {
    (0, _util.unreachable)("abstract method");
  }
}
class AstArgument extends AstNode {
  constructor(index, min, max) {
    super("args");
    this.index = index;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitArgument(this);
  }
}
class AstLiteral extends AstNode {
  constructor(number) {
    super("literal");
    this.number = number;
    this.min = number;
    this.max = number;
  }
  visit(visitor) {
    visitor.visitLiteral(this);
  }
}
class AstBinaryOperation extends AstNode {
  constructor(op, arg1, arg2, min, max) {
    super("binary");
    this.op = op;
    this.arg1 = arg1;
    this.arg2 = arg2;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitBinaryOperation(this);
  }
}
class AstMin extends AstNode {
  constructor(arg, max) {
    super("max");
    this.arg = arg;
    this.min = arg.min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitMin(this);
  }
}
class AstVariable extends AstNode {
  constructor(index, min, max) {
    super("var");
    this.index = index;
    this.min = min;
    this.max = max;
  }
  visit(visitor) {
    visitor.visitVariable(this);
  }
}
class AstVariableDefinition extends AstNode {
  constructor(variable, arg) {
    super("definition");
    this.variable = variable;
    this.arg = arg;
  }
  visit(visitor) {
    visitor.visitVariableDefinition(this);
  }
}
class ExpressionBuilderVisitor {
  constructor() {
    this.parts = [];
  }
  visitArgument(arg) {
    this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
  }
  visitVariable(variable) {
    this.parts.push("v", variable.index);
  }
  visitLiteral(literal) {
    this.parts.push(literal.number);
  }
  visitBinaryOperation(operation) {
    this.parts.push("(");
    operation.arg1.visit(this);
    this.parts.push(" ", operation.op, " ");
    operation.arg2.visit(this);
    this.parts.push(")");
  }
  visitVariableDefinition(definition) {
    this.parts.push("var ");
    definition.variable.visit(this);
    this.parts.push(" = ");
    definition.arg.visit(this);
    this.parts.push(";");
  }
  visitMin(max) {
    this.parts.push("Math.min(");
    max.arg.visit(this);
    this.parts.push(", ", max.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function buildAddOperation(num1, num2) {
  if (num2.type === "literal" && num2.number === 0) {
    return num1;
  }
  if (num1.type === "literal" && num1.number === 0) {
    return num2;
  }
  if (num2.type === "literal" && num1.type === "literal") {
    return new AstLiteral(num1.number + num2.number);
  }
  return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
}
function buildMulOperation(num1, num2) {
  if (num2.type === "literal") {
    if (num2.number === 0) {
      return new AstLiteral(0);
    } else if (num2.number === 1) {
      return num1;
    } else if (num1.type === "literal") {
      return new AstLiteral(num1.number * num2.number);
    }
  }
  if (num1.type === "literal") {
    if (num1.number === 0) {
      return new AstLiteral(0);
    } else if (num1.number === 1) {
      return num2;
    }
  }
  const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
  const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
  return new AstBinaryOperation("*", num1, num2, min, max);
}
function buildSubOperation(num1, num2) {
  if (num2.type === "literal") {
    if (num2.number === 0) {
      return num1;
    } else if (num1.type === "literal") {
      return new AstLiteral(num1.number - num2.number);
    }
  }
  if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
    return num2.arg2;
  }
  return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
}
function buildMinOperation(num1, max) {
  if (num1.min >= max) {
    return new AstLiteral(max);
  } else if (num1.max <= max) {
    return num1;
  }
  return new AstMin(num1, max);
}
class PostScriptCompiler {
  compile(code, domain, range) {
    const stack = [];
    const instructions = [];
    const inputSize = domain.length >> 1,
      outputSize = range.length >> 1;
    let lastRegister = 0;
    let n, j;
    let num1, num2, ast1, ast2, tmpVar, item;
    for (let i = 0; i < inputSize; i++) {
      stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
    }
    for (let i = 0, ii = code.length; i < ii; i++) {
      item = code[i];
      if (typeof item === "number") {
        stack.push(new AstLiteral(item));
        continue;
      }
      switch (item) {
        case "add":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildAddOperation(num1, num2));
          break;
        case "cvr":
          if (stack.length < 1) {
            return null;
          }
          break;
        case "mul":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildMulOperation(num1, num2));
          break;
        case "sub":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          stack.push(buildSubOperation(num1, num2));
          break;
        case "exch":
          if (stack.length < 2) {
            return null;
          }
          ast1 = stack.pop();
          ast2 = stack.pop();
          stack.push(ast1, ast2);
          break;
        case "pop":
          if (stack.length < 1) {
            return null;
          }
          stack.pop();
          break;
        case "index":
          if (stack.length < 1) {
            return null;
          }
          num1 = stack.pop();
          if (num1.type !== "literal") {
            return null;
          }
          n = num1.number;
          if (n < 0 || !Number.isInteger(n) || stack.length < n) {
            return null;
          }
          ast1 = stack[stack.length - n - 1];
          if (ast1.type === "literal" || ast1.type === "var") {
            stack.push(ast1);
            break;
          }
          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
          stack[stack.length - n - 1] = tmpVar;
          stack.push(tmpVar);
          instructions.push(new AstVariableDefinition(tmpVar, ast1));
          break;
        case "dup":
          if (stack.length < 1) {
            return null;
          }
          if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
            num1 = stack.pop();
            stack.push(buildMinOperation(num1, code[i + 1]));
            i += 6;
            break;
          }
          ast1 = stack.at(-1);
          if (ast1.type === "literal" || ast1.type === "var") {
            stack.push(ast1);
            break;
          }
          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
          stack[stack.length - 1] = tmpVar;
          stack.push(tmpVar);
          instructions.push(new AstVariableDefinition(tmpVar, ast1));
          break;
        case "roll":
          if (stack.length < 2) {
            return null;
          }
          num2 = stack.pop();
          num1 = stack.pop();
          if (num2.type !== "literal" || num1.type !== "literal") {
            return null;
          }
          j = num2.number;
          n = num1.number;
          if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
            return null;
          }
          j = (j % n + n) % n;
          if (j === 0) {
            break;
          }
          stack.push(...stack.splice(stack.length - n, n - j));
          break;
        default:
          return null;
      }
    }
    if (stack.length !== outputSize) {
      return null;
    }
    const result = [];
    for (const instruction of instructions) {
      const statementBuilder = new ExpressionBuilderVisitor();
      instruction.visit(statementBuilder);
      result.push(statementBuilder.toString());
    }
    for (let i = 0, ii = stack.length; i < ii; i++) {
      const expr = stack[i],
        statementBuilder = new ExpressionBuilderVisitor();
      expr.visit(statementBuilder);
      const min = range[i * 2],
        max = range[i * 2 + 1];
      const out = [statementBuilder.toString()];
      if (min > expr.min) {
        out.unshift("Math.max(", min, ", ");
        out.push(")");
      }
      if (max < expr.max) {
        out.unshift("Math.min(", max, ", ");
        out.push(")");
      }
      out.unshift("dest[destOffset + ", i, "] = ");
      out.push(";");
      result.push(out.join(""));
    }
    return result.join("\n");
  }
}
exports.PostScriptCompiler = PostScriptCompiler;

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptParser = exports.PostScriptLexer = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
class PostScriptParser {
  constructor(lexer) {
    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }
  accept(type) {
    if (this.token.type === type) {
      this.nextToken();
      return true;
    }
    return false;
  }
  expect(type) {
    if (this.accept(type)) {
      return true;
    }
    throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
  }
  parse() {
    this.nextToken();
    this.expect(PostScriptTokenTypes.LBRACE);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    return this.operators;
  }
  parseBlock() {
    while (true) {
      if (this.accept(PostScriptTokenTypes.NUMBER)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        this.parseCondition();
      } else {
        return;
      }
    }
  }
  parseCondition() {
    const conditionLocation = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    if (this.accept(PostScriptTokenTypes.IF)) {
      this.operators[conditionLocation] = this.operators.length;
      this.operators[conditionLocation + 1] = "jz";
    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
      const jumpLocation = this.operators.length;
      this.operators.push(null, null);
      const endOfTrue = this.operators.length;
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      this.expect(PostScriptTokenTypes.IFELSE);
      this.operators[jumpLocation] = this.operators.length;
      this.operators[jumpLocation + 1] = "j";
      this.operators[conditionLocation] = endOfTrue;
      this.operators[conditionLocation + 1] = "jz";
    } else {
      throw new _util.FormatError("PS Function: error parsing conditional.");
    }
  }
}
exports.PostScriptParser = PostScriptParser;
const PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
class PostScriptToken {
  static get opCache() {
    return (0, _util.shadow)(this, "opCache", Object.create(null));
  }
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static getOperator(op) {
    return PostScriptToken.opCache[op] ||= new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
  }
  static get LBRACE() {
    return (0, _util.shadow)(this, "LBRACE", new PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
  }
  static get RBRACE() {
    return (0, _util.shadow)(this, "RBRACE", new PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
  }
  static get IF() {
    return (0, _util.shadow)(this, "IF", new PostScriptToken(PostScriptTokenTypes.IF, "IF"));
  }
  static get IFELSE() {
    return (0, _util.shadow)(this, "IFELSE", new PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
  }
}
class PostScriptLexer {
  constructor(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch < 0) {
        return _primitives.EOF;
      }
      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
        break;
      }
      ch = this.nextChar();
    }
    switch (ch | 0) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x2b:
      case 0x2d:
      case 0x2e:
        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
      case 0x7b:
        this.nextChar();
        return PostScriptToken.LBRACE;
      case 0x7d:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5a || ch >= 0x61 && ch <= 0x7a)) {
      strBuf.push(String.fromCharCode(ch));
    }
    const str = strBuf.join("");
    switch (str.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(str);
    }
  }
  getNumber() {
    let ch = this.currentChar;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0) {
      if (ch >= 0x30 && ch <= 0x39 || ch === 0x2d || ch === 0x2e) {
        strBuf.push(String.fromCharCode(ch));
      } else {
        break;
      }
    }
    const value = parseFloat(strBuf.join(""));
    if (isNaN(value)) {
      throw new _util.FormatError(`Invalid floating point number: ${value}`);
    }
    return value;
  }
}
exports.PostScriptLexer = PostScriptLexer;

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RegionalImageCache = exports.LocalTilingPatternCache = exports.LocalImageCache = exports.LocalGStateCache = exports.LocalFunctionCache = exports.LocalColorSpaceCache = exports.GlobalImageCache = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
class BaseLocalCache {
  constructor(options) {
    if (this.constructor === BaseLocalCache) {
      (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
    }
    this._onlyRefs = options?.onlyRefs === true;
    if (!this._onlyRefs) {
      this._nameRefMap = new Map();
      this._imageMap = new Map();
    }
    this._imageCache = new _primitives.RefSetCache();
  }
  getByName(name) {
    if (this._onlyRefs) {
      (0, _util.unreachable)("Should not call `getByName` method.");
    }
    const ref = this._nameRefMap.get(name);
    if (ref) {
      return this.getByRef(ref);
    }
    return this._imageMap.get(name) || null;
  }
  getByRef(ref) {
    return this._imageCache.get(ref) || null;
  }
  set(name, ref, data) {
    (0, _util.unreachable)("Abstract method `set` called.");
  }
}
class LocalImageCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalImageCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalImageCache = LocalImageCache;
class LocalColorSpaceCache extends BaseLocalCache {
  set(name = null, ref = null, data) {
    if (typeof name !== "string" && !ref) {
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      if (name !== null) {
        this._nameRefMap.set(name, ref);
      }
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalColorSpaceCache = LocalColorSpaceCache;
class LocalFunctionCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.LocalFunctionCache = LocalFunctionCache;
class LocalGStateCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
}
exports.LocalGStateCache = LocalGStateCache;
class LocalTilingPatternCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.LocalTilingPatternCache = LocalTilingPatternCache;
class RegionalImageCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('RegionalImageCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
}
exports.RegionalImageCache = RegionalImageCache;
class GlobalImageCache {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5 * _util.MAX_IMAGE_SIZE_TO_CACHE;
  constructor() {
    this._refCache = new _primitives.RefSetCache();
    this._imageCache = new _primitives.RefSetCache();
  }
  get _byteSize() {
    let byteSize = 0;
    for (const imageData of this._imageCache) {
      byteSize += imageData.byteSize;
    }
    return byteSize;
  }
  get _cacheLimitReached() {
    if (this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) {
      return false;
    }
    if (this._byteSize < GlobalImageCache.MAX_BYTE_SIZE) {
      return false;
    }
    return true;
  }
  shouldCache(ref, pageIndex) {
    let pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      pageIndexSet = new Set();
      this._refCache.put(ref, pageIndexSet);
    }
    pageIndexSet.add(pageIndex);
    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return false;
    }
    if (!this._imageCache.has(ref) && this._cacheLimitReached) {
      return false;
    }
    return true;
  }
  addByteSize(ref, byteSize) {
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return;
    }
    if (imageData.byteSize) {
      return;
    }
    imageData.byteSize = byteSize;
  }
  getData(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      return null;
    }
    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return null;
    }
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return null;
    }
    pageIndexSet.add(pageIndex);
    return imageData;
  }
  setData(ref, data) {
    if (!this._refCache.has(ref)) {
      throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    if (this._cacheLimitReached) {
      (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
      return;
    }
    this._imageCache.put(ref, data);
  }
  clear(onlyData = false) {
    if (!onlyData) {
      this._refCache.clear();
    }
    this._imageCache.clear();
  }
}
exports.GlobalImageCache = GlobalImageCache;

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bidi = bidi;
var _util = __w_pdfjs_require__(2);
const baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
const arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(i) {
  return (i & 1) !== 0;
}
function isEven(i) {
  return (i & 1) === 0;
}
function findUnequal(arr, start, value) {
  let j, jj;
  for (j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }
  return j;
}
function setValues(arr, start, end, value) {
  for (let j = start; j < end; ++j) {
    arr[j] = value;
  }
}
function reverseValues(arr, start, end) {
  for (let i = start, j = end - 1; i < j; ++i, --j) {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
function createBidiText(str, isLTR, vertical = false) {
  let dir = "ltr";
  if (vertical) {
    dir = "ttb";
  } else if (!isLTR) {
    dir = "rtl";
  }
  return {
    str,
    dir
  };
}
const chars = [];
const types = [];
function bidi(str, startLevel = -1, vertical = false) {
  let isLTR = true;
  const strLength = str.length;
  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }
  chars.length = strLength;
  types.length = strLength;
  let numBidi = 0;
  let i, ii;
  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    const charCode = str.charCodeAt(i);
    let charType = "L";
    if (charCode <= 0x00ff) {
      charType = baseTypes[charCode];
    } else if (0x0590 <= charCode && charCode <= 0x05f4) {
      charType = "R";
    } else if (0x0600 <= charCode && charCode <= 0x06ff) {
      charType = arabicTypes[charCode & 0xff];
      if (!charType) {
        (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
      }
    } else if (0x0700 <= charCode && charCode <= 0x08ac || 0xfb50 <= charCode && charCode <= 0xfdff || 0xfe70 <= charCode && charCode <= 0xfeff) {
      charType = "AL";
    }
    if (charType === "R" || charType === "AL" || charType === "AN") {
      numBidi++;
    }
    types[i] = charType;
  }
  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }
  if (startLevel === -1) {
    if (numBidi / strLength < 0.3 && strLength > 4) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }
  const levels = [];
  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }
  const e = isOdd(startLevel) ? "R" : "L";
  const sor = e;
  const eor = sor;
  let lastType = sor;
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "NSM") {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }
  lastType = sor;
  let t;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "AL" ? "AN" : "EN";
    } else if (t === "R" || t === "L" || t === "AL") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "AL") {
      types[i] = "R";
    }
  }
  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
      types[i] = "EN";
    }
    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "EN") {
      for (let j = i - 1; j >= 0; --j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
      for (let j = i + 1; j < strLength; ++j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
      types[i] = "ON";
    }
  }
  lastType = sor;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "L" ? "L" : "EN";
    } else if (t === "R" || t === "L") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      const end = findUnequal(types, i + 1, "ON");
      let before = sor;
      if (i > 0) {
        before = types[i - 1];
      }
      let after = eor;
      if (end + 1 < strLength) {
        after = types[end + 1];
      }
      if (before !== "L") {
        before = "R";
      }
      if (after !== "L") {
        after = "R";
      }
      if (before === after) {
        setValues(types, i, end, before);
      }
      i = end - 1;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      types[i] = e;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (isEven(levels[i])) {
      if (t === "R") {
        levels[i] += 1;
      } else if (t === "AN" || t === "EN") {
        levels[i] += 2;
      }
    } else if (t === "L" || t === "AN" || t === "EN") {
      levels[i] += 1;
    }
  }
  let highestLevel = -1;
  let lowestOddLevel = 99;
  let level;
  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];
    if (highestLevel < level) {
      highestLevel = level;
    }
    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }
  for (level = highestLevel; level >= lowestOddLevel; --level) {
    let start = -1;
    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }
    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }
  for (i = 0, ii = chars.length; i < ii; ++i) {
    const ch = chars[i];
    if (ch === "<" || ch === ">") {
      chars[i] = "";
    }
  }
  return createBidiText(chars.join(""), isLTR);
}

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFontSubstitution = getFontSubstitution;
var _fonts_utils = __w_pdfjs_require__(38);
var _core_utils = __w_pdfjs_require__(3);
const NORMAL = {
  style: "normal",
  weight: "normal"
};
const BOLD = {
  style: "normal",
  weight: "bold"
};
const ITALIC = {
  style: "italic",
  weight: "normal"
};
const BOLDITALIC = {
  style: "italic",
  weight: "bold"
};
const substitutionMap = new Map([["Times-Roman", {
  local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
  style: NORMAL,
  ultimate: "serif"
}], ["Times-Bold", {
  alias: "Times-Roman",
  style: BOLD,
  ultimate: "serif"
}], ["Times-Italic", {
  alias: "Times-Roman",
  style: ITALIC,
  ultimate: "serif"
}], ["Times-BoldItalic", {
  alias: "Times-Roman",
  style: BOLDITALIC,
  ultimate: "serif"
}], ["Helvetica", {
  local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
  path: "LiberationSans-Regular.ttf",
  style: NORMAL,
  ultimate: "sans-serif"
}], ["Helvetica-Bold", {
  alias: "Helvetica",
  path: "LiberationSans-Bold.ttf",
  style: BOLD,
  ultimate: "sans-serif"
}], ["Helvetica-Oblique", {
  alias: "Helvetica",
  path: "LiberationSans-Italic.ttf",
  style: ITALIC,
  ultimate: "sans-serif"
}], ["Helvetica-BoldOblique", {
  alias: "Helvetica",
  path: "LiberationSans-BoldItalic.ttf",
  style: BOLDITALIC,
  ultimate: "sans-serif"
}], ["Courier", {
  local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"],
  style: NORMAL,
  ultimate: "monospace"
}], ["Courier-Bold", {
  alias: "Courier",
  style: BOLD,
  ultimate: "monospace"
}], ["Courier-Oblique", {
  alias: "Courier",
  style: ITALIC,
  ultimate: "monospace"
}], ["Courier-BoldOblique", {
  alias: "Courier",
  style: BOLDITALIC,
  ultimate: "monospace"
}], ["ArialBlack", {
  local: ["Arial Black"],
  style: {
    style: "normal",
    weight: "900"
  },
  fallback: "Helvetica-Bold"
}], ["ArialBlack-Bold", {
  alias: "ArialBlack"
}], ["ArialBlack-Italic", {
  alias: "ArialBlack",
  style: {
    style: "italic",
    weight: "900"
  },
  fallback: "Helvetica-BoldOblique"
}], ["ArialBlack-BoldItalic", {
  alias: "ArialBlack-Italic"
}], ["ArialNarrow", {
  local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
  style: NORMAL,
  fallback: "Helvetica"
}], ["ArialNarrow-Bold", {
  alias: "ArialNarrow",
  style: BOLD,
  fallback: "Helvetica-Bold"
}], ["ArialNarrow-Italic", {
  alias: "ArialNarrow",
  style: ITALIC,
  fallback: "Helvetica-Oblique"
}], ["ArialNarrow-BoldItalic", {
  alias: "ArialNarrow",
  style: BOLDITALIC,
  fallback: "Helvetica-BoldOblique"
}], ["Calibri", {
  local: ["Calibri", "Carlito"],
  style: NORMAL,
  fallback: "Helvetica"
}], ["Calibri-Bold", {
  alias: "Calibri",
  style: BOLD,
  fallback: "Helvetica-Bold"
}], ["Calibri-Italic", {
  alias: "Calibri",
  style: ITALIC,
  fallback: "Helvetica-Oblique"
}], ["Calibri-BoldItalic", {
  alias: "Calibri",
  style: BOLDITALIC,
  fallback: "Helvetica-BoldOblique"
}], ["Wingdings", {
  local: ["Wingdings", "URW Dingbats"],
  style: NORMAL
}], ["Wingdings-Regular", {
  alias: "Wingdings"
}], ["Wingdings-Bold", {
  alias: "Wingdings"
}]]);
const fontAliases = new Map([["Arial-Black", "ArialBlack"]]);
function getStyleToAppend(style) {
  switch (style) {
    case BOLD:
      return "Bold";
    case ITALIC:
      return "Italic";
    case BOLDITALIC:
      return "Bold Italic";
    default:
      if (style?.weight === "bold") {
        return "Bold";
      }
      if (style?.style === "italic") {
        return "Italic";
      }
  }
  return "";
}
function generateFont({
  alias,
  local,
  path,
  fallback,
  style,
  ultimate
}, src, localFontPath, useFallback = true, usePath = true, append = "") {
  const result = {
    style: null,
    ultimate: null
  };
  if (local) {
    const extra = append ? ` ${append}` : "";
    for (const name of local) {
      src.push(`local(${name}${extra})`);
    }
  }
  if (alias) {
    const substitution = substitutionMap.get(alias);
    const aliasAppend = append || getStyleToAppend(style);
    Object.assign(result, generateFont(substitution, src, localFontPath, useFallback && !fallback, usePath && !path, aliasAppend));
  }
  if (style) {
    result.style = style;
  }
  if (ultimate) {
    result.ultimate = ultimate;
  }
  if (useFallback && fallback) {
    const fallbackInfo = substitutionMap.get(fallback);
    const {
      ultimate: fallbackUltimate
    } = generateFont(fallbackInfo, src, localFontPath, useFallback, usePath && !path, append);
    result.ultimate ||= fallbackUltimate;
  }
  if (usePath && path && localFontPath) {
    src.push(`url(${localFontPath}${path})`);
  }
  return result;
}
function getFontSubstitution(systemFontCache, idFactory, localFontPath, baseFontName, standardFontName) {
  baseFontName = (0, _fonts_utils.normalizeFontName)(baseFontName);
  const key = baseFontName;
  let substitutionInfo = systemFontCache.get(key);
  if (substitutionInfo) {
    return substitutionInfo;
  }
  let substitution = substitutionMap.get(baseFontName);
  if (!substitution) {
    for (const [alias, subst] of fontAliases) {
      if (baseFontName.startsWith(alias)) {
        baseFontName = `${subst}${baseFontName.substring(alias.length)}`;
        substitution = substitutionMap.get(baseFontName);
        break;
      }
    }
  }
  let mustAddBaseFont = false;
  if (!substitution) {
    substitution = substitutionMap.get(standardFontName);
    mustAddBaseFont = true;
  }
  const loadedName = `${idFactory.getDocId()}_s${idFactory.createFontId()}`;
  if (!substitution) {
    if (!(0, _core_utils.validateFontName)(baseFontName)) {
      systemFontCache.set(key, null);
      return null;
    }
    const bold = /bold/gi.test(baseFontName);
    const italic = /oblique|italic/gi.test(baseFontName);
    const style = bold && italic && BOLDITALIC || bold && BOLD || italic && ITALIC || NORMAL;
    substitutionInfo = {
      css: loadedName,
      guessFallback: true,
      loadedName,
      baseFontName,
      src: `local(${baseFontName})`,
      style
    };
    systemFontCache.set(key, substitutionInfo);
    return substitutionInfo;
  }
  const src = [];
  if (mustAddBaseFont && (0, _core_utils.validateFontName)(baseFontName)) {
    src.push(`local(${baseFontName})`);
  }
  const {
    style,
    ultimate
  } = generateFont(substitution, src, localFontPath);
  const guessFallback = ultimate === null;
  const fallback = guessFallback ? "" : `,${ultimate}`;
  substitutionInfo = {
    css: `${loadedName}${fallback}`,
    guessFallback,
    loadedName,
    baseFontName,
    src: src.join(","),
    style
  };
  systemFontCache.set(key, substitutionInfo);
  return substitutionInfo;
}

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ImageResizer = void 0;
var _util = __w_pdfjs_require__(2);
const MIN_IMAGE_DIM = 2048;
const MAX_IMAGE_DIM = 65537;
const MAX_ERROR = 128;
class ImageResizer {
  constructor(imgData, isMask) {
    this._imgData = imgData;
    this._isMask = isMask;
  }
  static needsToBeResized(width, height) {
    if (width <= this._goodSquareLength && height <= this._goodSquareLength) {
      return false;
    }
    const {
      MAX_DIM
    } = this;
    if (width > MAX_DIM || height > MAX_DIM) {
      return true;
    }
    const area = width * height;
    if (this._hasMaxArea) {
      return area > this.MAX_AREA;
    }
    if (area < this._goodSquareLength ** 2) {
      return false;
    }
    if (this._areGoodDims(width, height)) {
      this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(width * height)));
      return false;
    }
    this._goodSquareLength = this._guessMax(this._goodSquareLength, MAX_DIM, MAX_ERROR, 0);
    const maxArea = this.MAX_AREA = this._goodSquareLength ** 2;
    return area > maxArea;
  }
  static get MAX_DIM() {
    return (0, _util.shadow)(this, "MAX_DIM", this._guessMax(MIN_IMAGE_DIM, MAX_IMAGE_DIM, 0, 1));
  }
  static get MAX_AREA() {
    this._hasMaxArea = true;
    return (0, _util.shadow)(this, "MAX_AREA", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, MAX_ERROR, 0) ** 2);
  }
  static set MAX_AREA(area) {
    if (area >= 0) {
      this._hasMaxArea = true;
      (0, _util.shadow)(this, "MAX_AREA", area);
    }
  }
  static setMaxArea(area) {
    if (!this._hasMaxArea) {
      this.MAX_AREA = area >> 2;
    }
  }
  static _areGoodDims(width, height) {
    try {
      const canvas = new OffscreenCanvas(width, height);
      const ctx = canvas.getContext("2d");
      ctx.fillRect(0, 0, 1, 1);
      const opacity = ctx.getImageData(0, 0, 1, 1).data[3];
      canvas.width = canvas.height = 1;
      return opacity !== 0;
    } catch {
      return false;
    }
  }
  static _guessMax(start, end, tolerance, defaultHeight) {
    while (start + tolerance + 1 < end) {
      const middle = Math.floor((start + end) / 2);
      const height = defaultHeight || middle;
      if (this._areGoodDims(middle, height)) {
        start = middle;
      } else {
        end = middle;
      }
    }
    return start;
  }
  static async createImage(imgData, isMask = false) {
    return new ImageResizer(imgData, isMask)._createImage();
  }
  async _createImage() {
    const data = this._encodeBMP();
    const blob = new Blob([data.buffer], {
      type: "image/bmp"
    });
    const bitmapPromise = createImageBitmap(blob);
    const {
      MAX_AREA,
      MAX_DIM
    } = ImageResizer;
    const {
      _imgData: imgData
    } = this;
    const {
      width,
      height
    } = imgData;
    const minFactor = Math.max(width / MAX_DIM, height / MAX_DIM, Math.sqrt(width * height / MAX_AREA));
    const firstFactor = Math.max(minFactor, 2);
    const factor = Math.round(10 * (minFactor + 1.25)) / 10 / firstFactor;
    const N = Math.floor(Math.log2(factor));
    const steps = new Array(N + 2).fill(2);
    steps[0] = firstFactor;
    steps.splice(-1, 1, factor / (1 << N));
    let newWidth = width;
    let newHeight = height;
    let bitmap = await bitmapPromise;
    for (const step of steps) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      newWidth = Math.floor(newWidth / step) - 1;
      newHeight = Math.floor(newHeight / step) - 1;
      const canvas = new OffscreenCanvas(newWidth, newHeight);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = canvas.transferToImageBitmap();
    }
    imgData.data = null;
    imgData.bitmap = bitmap;
    imgData.width = newWidth;
    imgData.height = newHeight;
    return imgData;
  }
  _encodeBMP() {
    const {
      width,
      height,
      kind
    } = this._imgData;
    let data = this._imgData.data;
    let bitPerPixel;
    let colorTable = new Uint8Array(0);
    let maskTable = colorTable;
    let compression = 0;
    switch (kind) {
      case _util.ImageKind.GRAYSCALE_1BPP:
        {
          bitPerPixel = 1;
          colorTable = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
          const rowLen = width + 7 >> 3;
          const rowSize = rowLen + 3 & -4;
          if (rowLen !== rowSize) {
            const newData = new Uint8Array(rowSize * height);
            let k = 0;
            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen, k += rowSize) {
              newData.set(data.subarray(i, i + rowLen), k);
            }
            data = newData;
          }
          break;
        }
      case _util.ImageKind.RGB_24BPP:
        {
          bitPerPixel = 24;
          if (width & 3) {
            const rowLen = 3 * width;
            const rowSize = rowLen + 3 & -4;
            const extraLen = rowSize - rowLen;
            const newData = new Uint8Array(rowSize * height);
            let k = 0;
            for (let i = 0, ii = height * rowLen; i < ii; i += rowLen) {
              const row = data.subarray(i, i + rowLen);
              for (let j = 0; j < rowLen; j += 3) {
                newData[k++] = row[j + 2];
                newData[k++] = row[j + 1];
                newData[k++] = row[j];
              }
              k += extraLen;
            }
            data = newData;
          } else {
            for (let i = 0, ii = data.length; i < ii; i += 3) {
              const tmp = data[i];
              data[i] = data[i + 2];
              data[i + 2] = tmp;
            }
          }
          break;
        }
      case _util.ImageKind.RGBA_32BPP:
        bitPerPixel = 32;
        compression = 3;
        maskTable = new Uint8Array(4 + 4 + 4 + 4 + 52);
        const view = new DataView(maskTable.buffer);
        if (_util.FeatureTest.isLittleEndian) {
          view.setUint32(0, 0x000000ff, true);
          view.setUint32(4, 0x0000ff00, true);
          view.setUint32(8, 0x00ff0000, true);
          view.setUint32(12, 0xff000000, true);
        } else {
          view.setUint32(0, 0xff000000, true);
          view.setUint32(4, 0x00ff0000, true);
          view.setUint32(8, 0x0000ff00, true);
          view.setUint32(12, 0x000000ff, true);
        }
        break;
      default:
        throw new Error("invalid format");
    }
    let i = 0;
    const headerLength = 40 + maskTable.length;
    const fileLength = 14 + headerLength + colorTable.length + data.length;
    const bmpData = new Uint8Array(fileLength);
    const view = new DataView(bmpData.buffer);
    view.setUint16(i, 0x4d42, true);
    i += 2;
    view.setUint32(i, fileLength, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    view.setUint32(i, 14 + headerLength + colorTable.length, true);
    i += 4;
    view.setUint32(i, headerLength, true);
    i += 4;
    view.setInt32(i, width, true);
    i += 4;
    view.setInt32(i, -height, true);
    i += 4;
    view.setUint16(i, 1, true);
    i += 2;
    view.setUint16(i, bitPerPixel, true);
    i += 2;
    view.setUint32(i, compression, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    view.setInt32(i, 0, true);
    i += 4;
    view.setInt32(i, 0, true);
    i += 4;
    view.setUint32(i, colorTable.length / 4, true);
    i += 4;
    view.setUint32(i, 0, true);
    i += 4;
    bmpData.set(maskTable, i);
    i += maskTable.length;
    bmpData.set(colorTable, i);
    i += colorTable.length;
    bmpData.set(data, i);
    return bmpData;
  }
}
exports.ImageResizer = ImageResizer;
ImageResizer._goodSquareLength = MIN_IMAGE_DIM;

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;
var _util = __w_pdfjs_require__(2);
const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;
class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
      k2 = 0;
    let h1 = this.h1,
      h2 = this.h2;
    const C1 = 0xcc9e2d51,
      C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
      C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1,
      h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
}
exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OperatorList = void 0;
var _util = __w_pdfjs_require__(2);
function addState(parentState, pattern, checkFn, iterateFn, processFn) {
  let state = parentState;
  for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
    const item = pattern[i];
    state = state[item] ||= [];
  }
  state[pattern.at(-1)] = {
    checkFn,
    iterateFn,
    processFn
  };
}
const InitialState = [];
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      return fnArray[i] === _util.OPS.transform;
    case 2:
      return fnArray[i] === _util.OPS.paintInlineImageXObject;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
}, function foundInlineImageGroup(context, i) {
  const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
  const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
  const MAX_WIDTH = 1000;
  const IMAGE_PADDING = 1;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIIXO = curr - 1;
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
  if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let maxX = 0;
  const map = [];
  let maxLineHeight = 0;
  let currentX = IMAGE_PADDING,
    currentY = IMAGE_PADDING;
  for (let q = 0; q < count; q++) {
    const transform = argsArray[iFirstTransform + (q << 2)];
    const img = argsArray[iFirstPIIXO + (q << 2)][0];
    if (currentX + img.width > MAX_WIDTH) {
      maxX = Math.max(maxX, currentX);
      currentY += maxLineHeight + 2 * IMAGE_PADDING;
      currentX = 0;
      maxLineHeight = 0;
    }
    map.push({
      transform,
      x: currentX,
      y: currentY,
      w: img.width,
      h: img.height
    });
    currentX += img.width + 2 * IMAGE_PADDING;
    maxLineHeight = Math.max(maxLineHeight, img.height);
  }
  const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
  const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
  const imgData = new Uint8Array(imgWidth * imgHeight * 4);
  const imgRowSize = imgWidth << 2;
  for (let q = 0; q < count; q++) {
    const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
    const rowSize = map[q].w << 2;
    let dataOffset = 0;
    let offset = map[q].x + map[q].y * imgWidth << 2;
    imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
    for (let k = 0, kk = map[q].h; k < kk; k++) {
      imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
      dataOffset += rowSize;
      offset += imgRowSize;
    }
    imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
    while (offset >= 0) {
      data[offset - 4] = data[offset];
      data[offset - 3] = data[offset + 1];
      data[offset - 2] = data[offset + 2];
      data[offset - 1] = data[offset + 3];
      data[offset + rowSize] = data[offset + rowSize - 4];
      data[offset + rowSize + 1] = data[offset + rowSize - 3];
      data[offset + rowSize + 2] = data[offset + rowSize - 2];
      data[offset + rowSize + 3] = data[offset + rowSize - 1];
      offset -= imgRowSize;
    }
  }
  const img = {
    width: imgWidth,
    height: imgHeight
  };
  if (context.isOffscreenCanvasSupported) {
    const canvas = new OffscreenCanvas(imgWidth, imgHeight);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(new ImageData(new Uint8ClampedArray(imgData.buffer), imgWidth, imgHeight), 0, 0);
    img.bitmap = canvas.transferToImageBitmap();
    img.data = null;
  } else {
    img.kind = _util.ImageKind.RGBA_32BPP;
    img.data = imgData;
  }
  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
  argsArray.splice(iFirstSave, count * 4, [img, map]);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      return fnArray[i] === _util.OPS.transform;
    case 2:
      return fnArray[i] === _util.OPS.paintImageMaskXObject;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
}, function foundImageMaskGroup(context, i) {
  const MIN_IMAGES_IN_MASKS_BLOCK = 10;
  const MAX_IMAGES_IN_MASKS_BLOCK = 100;
  const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIMXO = curr - 1;
  let count = Math.floor((i - iFirstSave) / 4);
  if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let isSameImage = false;
  let iTransform, transformArgs;
  const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0],
    firstTransformArg1 = argsArray[iFirstTransform][1],
    firstTransformArg2 = argsArray[iFirstTransform][2],
    firstTransformArg3 = argsArray[iFirstTransform][3];
  if (firstTransformArg1 === firstTransformArg2) {
    isSameImage = true;
    iTransform = iFirstTransform + 4;
    let iPIMXO = iFirstPIMXO + 4;
    for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
      transformArgs = argsArray[iTransform];
      if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
        if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
          isSameImage = false;
        } else {
          count = q;
        }
        break;
      }
    }
  }
  if (isSameImage) {
    count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
    const positions = new Float32Array(count * 2);
    iTransform = iFirstTransform;
    for (let q = 0; q < count; q++, iTransform += 4) {
      transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }
    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
  } else {
    count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
    const images = [];
    for (let q = 0; q < count; q++) {
      transformArgs = argsArray[iFirstTransform + (q << 2)];
      const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
      images.push({
        data: maskParams.data,
        width: maskParams.width,
        height: maskParams.height,
        interpolate: maskParams.interpolate,
        count: maskParams.count,
        transform: transformArgs
      });
    }
    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [images]);
  }
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) {
  const argsArray = context.argsArray;
  const iFirstTransform = context.iCurr - 2;
  return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
}, function iterateImageGroup(context, i) {
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;
    case 1:
      if (fnArray[i] !== _util.OPS.transform) {
        return false;
      }
      const iFirstTransform = context.iCurr - 2;
      const firstTransformArg0 = argsArray[iFirstTransform][0];
      const firstTransformArg3 = argsArray[iFirstTransform][3];
      if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
        return false;
      }
      return true;
    case 2:
      if (fnArray[i] !== _util.OPS.paintImageXObject) {
        return false;
      }
      const iFirstPIXO = context.iCurr - 1;
      const firstPIXOArg0 = argsArray[iFirstPIXO][0];
      if (argsArray[i][0] !== firstPIXOArg0) {
        return false;
      }
      return true;
    case 3:
      return fnArray[i] === _util.OPS.restore;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_IMAGES_IN_BLOCK = 3;
  const MAX_IMAGES_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIXO = curr - 1;
  const firstPIXOArg0 = argsArray[iFirstPIXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0];
  const firstTransformArg3 = argsArray[iFirstTransform][3];
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
  if (count < MIN_IMAGES_IN_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  const positions = new Float32Array(count * 2);
  let iTransform = iFirstTransform;
  for (let q = 0; q < count; q++, iTransform += 4) {
    const transformArgs = argsArray[iTransform];
    positions[q << 1] = transformArgs[4];
    positions[(q << 1) + 1] = transformArgs[5];
  }
  const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
  argsArray.splice(iFirstSave, count * 4, args);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) {
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 4;
  const pos = (i - iFirstSave) % 5;
  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.beginText;
    case 1:
      return fnArray[i] === _util.OPS.setFont;
    case 2:
      return fnArray[i] === _util.OPS.setTextMatrix;
    case 3:
      if (fnArray[i] !== _util.OPS.showText) {
        return false;
      }
      const iFirstSetFont = context.iCurr - 3;
      const firstSetFontArg0 = argsArray[iFirstSetFont][0];
      const firstSetFontArg1 = argsArray[iFirstSetFont][1];
      if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
        return false;
      }
      return true;
    case 4:
      return fnArray[i] === _util.OPS.endText;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_CHARS_IN_BLOCK = 3;
  const MAX_CHARS_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
    argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstBeginText = curr - 4;
  const iFirstSetFont = curr - 3;
  const iFirstSetTextMatrix = curr - 2;
  const iFirstShowText = curr - 1;
  const iFirstEndText = curr;
  const firstSetFontArg0 = argsArray[iFirstSetFont][0];
  const firstSetFontArg1 = argsArray[iFirstSetFont][1];
  let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
  if (count < MIN_CHARS_IN_BLOCK) {
    return i - (i - iFirstBeginText) % 5;
  }
  let iFirst = iFirstBeginText;
  if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
    count++;
    iFirst -= 5;
  }
  let iEndText = iFirst + 4;
  for (let q = 1; q < count; q++) {
    fnArray.splice(iEndText, 3);
    argsArray.splice(iEndText, 3);
    iEndText += 2;
  }
  return iEndText + 1;
});
class NullOptimizer {
  constructor(queue) {
    this.queue = queue;
  }
  _optimize() {}
  push(fn, args) {
    this.queue.fnArray.push(fn);
    this.queue.argsArray.push(args);
    this._optimize();
  }
  flush() {}
  reset() {}
}
class QueueOptimizer extends NullOptimizer {
  constructor(queue) {
    super(queue);
    this.state = null;
    this.context = {
      iCurr: 0,
      fnArray: queue.fnArray,
      argsArray: queue.argsArray,
      isOffscreenCanvasSupported: false
    };
    this.match = null;
    this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(value) {
    this.context.isOffscreenCanvasSupported = value;
  }
  _optimize() {
    const fnArray = this.queue.fnArray;
    let i = this.lastProcessed,
      ii = fnArray.length;
    let state = this.state;
    let match = this.match;
    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
      this.lastProcessed = ii;
      return;
    }
    const context = this.context;
    while (i < ii) {
      if (match) {
        const iterate = (0, match.iterateFn)(context, i);
        if (iterate) {
          i++;
          continue;
        }
        i = (0, match.processFn)(context, i + 1);
        ii = fnArray.length;
        match = null;
        state = null;
        if (i >= ii) {
          break;
        }
      }
      state = (state || InitialState)[fnArray[i]];
      if (!state || Array.isArray(state)) {
        i++;
        continue;
      }
      context.iCurr = i;
      i++;
      if (state.checkFn && !(0, state.checkFn)(context)) {
        state = null;
        continue;
      }
      match = state;
      state = null;
    }
    this.state = state;
    this.match = match;
    this.lastProcessed = i;
  }
  flush() {
    while (this.match) {
      const length = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, length);
      this.match = null;
      this.state = null;
      this._optimize();
    }
  }
  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }
}
class OperatorList {
  static CHUNK_SIZE = 1000;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  constructor(intent = 0, streamSink) {
    this._streamSink = streamSink;
    this.fnArray = [];
    this.argsArray = [];
    this.optimizer = streamSink && !(intent & _util.RenderingIntentFlag.OPLIST) ? new QueueOptimizer(this) : new NullOptimizer(this);
    this.dependencies = new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = streamSink ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(value) {
    this.optimizer.isOffscreenCanvasSupported = value;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(fn, args) {
    this.optimizer.push(fn, args);
    this.weight++;
    if (this._streamSink) {
      if (this.weight >= OperatorList.CHUNK_SIZE) {
        this.flush();
      } else if (this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
        this.flush();
      }
    }
  }
  addImageOps(fn, args, optionalContent) {
    if (optionalContent !== undefined) {
      this.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    this.addOp(fn, args);
    if (optionalContent !== undefined) {
      this.addOp(_util.OPS.endMarkedContent, []);
    }
  }
  addDependency(dependency) {
    if (this.dependencies.has(dependency)) {
      return;
    }
    this.dependencies.add(dependency);
    this.addOp(_util.OPS.dependency, [dependency]);
  }
  addDependencies(dependencies) {
    for (const dependency of dependencies) {
      this.addDependency(dependency);
    }
  }
  addOpList(opList) {
    if (!(opList instanceof OperatorList)) {
      (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
      return;
    }
    for (const dependency of opList.dependencies) {
      this.dependencies.add(dependency);
    }
    for (let i = 0, ii = opList.length; i < ii; i++) {
      this.addOp(opList.fnArray[i], opList.argsArray[i]);
    }
  }
  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }
  get _transfers() {
    const transfers = [];
    const {
      fnArray,
      argsArray,
      length
    } = this;
    for (let i = 0; i < length; i++) {
      switch (fnArray[i]) {
        case _util.OPS.paintInlineImageXObject:
        case _util.OPS.paintInlineImageXObjectGroup:
        case _util.OPS.paintImageMaskXObject:
          const arg = argsArray[i][0];
          if (!arg.cached && arg.data?.buffer instanceof ArrayBuffer) {
            transfers.push(arg.data.buffer);
          }
          break;
      }
    }
    return transfers;
  }
  flush(lastChunk = false, separateAnnots = null) {
    this.optimizer.flush();
    const length = this.length;
    this._totalLength += length;
    this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk,
      separateAnnots,
      length
    }, 1, this._transfers);
    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }
}
exports.OperatorList = OperatorList;

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFImage = void 0;
var _util = __w_pdfjs_require__(2);
var _image_utils = __w_pdfjs_require__(28);
var _base_stream = __w_pdfjs_require__(5);
var _colorspace = __w_pdfjs_require__(12);
var _decode_stream = __w_pdfjs_require__(18);
var _image_resizer = __w_pdfjs_require__(62);
var _jpeg_stream = __w_pdfjs_require__(26);
var _jpx = __w_pdfjs_require__(30);
var _primitives = __w_pdfjs_require__(4);
function decodeAndClamp(value, addend, coefficient, max) {
  value = addend + value * coefficient;
  if (value < 0) {
    value = 0;
  } else if (value > max) {
    value = max;
  }
  return value;
}
function resizeImageMask(src, bpc, w1, h1, w2, h2) {
  const length = w2 * h2;
  let dest;
  if (bpc <= 8) {
    dest = new Uint8Array(length);
  } else if (bpc <= 16) {
    dest = new Uint16Array(length);
  } else {
    dest = new Uint32Array(length);
  }
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let i,
    j,
    py,
    newIndex = 0,
    oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1;
  for (i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio);
  }
  for (i = 0; i < h2; i++) {
    py = Math.floor(i * yRatio) * w1Scanline;
    for (j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex];
    }
  }
  return dest;
}
class PDFImage {
  constructor({
    xref,
    res,
    image,
    isInline = false,
    smask = null,
    mask = null,
    isMask = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    this.image = image;
    const dict = image.dict;
    const filter = dict.get("F", "Filter");
    let filterName;
    if (filter instanceof _primitives.Name) {
      filterName = filter.name;
    } else if (Array.isArray(filter)) {
      const filterZero = xref.fetchIfRef(filter[0]);
      if (filterZero instanceof _primitives.Name) {
        filterName = filterZero.name;
      }
    }
    switch (filterName) {
      case "JPXDecode":
        const jpxImage = new _jpx.JpxImage();
        jpxImage.parseImageProperties(image.stream);
        image.stream.reset();
        image.width = jpxImage.width;
        image.height = jpxImage.height;
        image.bitsPerComponent = jpxImage.bitsPerComponent;
        image.numComps = jpxImage.componentsCount;
        break;
      case "JBIG2Decode":
        image.bitsPerComponent = 1;
        image.numComps = 1;
        break;
    }
    let width = dict.get("W", "Width");
    let height = dict.get("H", "Height");
    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
      (0, _util.warn)("PDFImage - using the Width/Height of the image data, " + "rather than the image dictionary.");
      width = image.width;
      height = image.height;
    }
    if (width < 1 || height < 1) {
      throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`);
    }
    this.width = width;
    this.height = height;
    this.interpolate = dict.get("I", "Interpolate");
    this.imageMask = dict.get("IM", "ImageMask") || false;
    this.matte = dict.get("Matte") || false;
    let bitsPerComponent = image.bitsPerComponent;
    if (!bitsPerComponent) {
      bitsPerComponent = dict.get("BPC", "BitsPerComponent");
      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);
        }
      }
    }
    this.bpc = bitsPerComponent;
    if (!this.imageMask) {
      let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
      if (!colorSpace) {
        (0, _util.info)("JPX images (which do not require color spaces)");
        switch (image.numComps) {
          case 1:
            colorSpace = _primitives.Name.get("DeviceGray");
            break;
          case 3:
            colorSpace = _primitives.Name.get("DeviceRGB");
            break;
          case 4:
            colorSpace = _primitives.Name.get("DeviceCMYK");
            break;
          default:
            throw new Error(`JPX images with ${image.numComps} color components not supported.`);
        }
      }
      this.colorSpace = _colorspace.ColorSpace.parse({
        cs: colorSpace,
        xref,
        resources: isInline ? res : null,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      this.numComps = this.colorSpace.numComps;
    }
    this.decode = dict.getArray("D", "Decode");
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const isIndexed = this.colorSpace?.name === "Indexed";
      for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        const dmin = this.decode[i];
        const dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
      }
    }
    if (smask) {
      this.smask = new PDFImage({
        xref,
        res,
        image: smask,
        isInline,
        pdfFunctionFactory,
        localColorSpaceCache
      });
    } else if (mask) {
      if (mask instanceof _base_stream.BaseStream) {
        const maskDict = mask.dict,
          imageMask = maskDict.get("IM", "ImageMask");
        if (!imageMask) {
          (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
        } else {
          this.mask = new PDFImage({
            xref,
            res,
            image: mask,
            isInline,
            isMask: true,
            pdfFunctionFactory,
            localColorSpaceCache
          });
        }
      } else {
        this.mask = mask;
      }
    }
  }
  static async buildImage({
    xref,
    res,
    image,
    isInline = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const imageData = image;
    let smaskData = null;
    let maskData = null;
    const smask = image.dict.get("SMask");
    const mask = image.dict.get("Mask");
    if (smask) {
      if (smask instanceof _base_stream.BaseStream) {
        smaskData = smask;
      } else {
        (0, _util.warn)("Unsupported /SMask format.");
      }
    } else if (mask) {
      if (mask instanceof _base_stream.BaseStream || Array.isArray(mask)) {
        maskData = mask;
      } else {
        (0, _util.warn)("Unsupported /Mask format.");
      }
    }
    return new PDFImage({
      xref,
      res,
      image: imageData,
      isInline,
      smask: smaskData,
      mask: maskData,
      pdfFunctionFactory,
      localColorSpaceCache
    });
  }
  static createRawMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode,
    interpolate
  }) {
    const computedLength = (width + 7 >> 3) * height;
    const actualLength = imgArray.byteLength;
    const haveFullData = computedLength === actualLength;
    let data, i;
    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
      data = imgArray;
    } else if (!inverseDecode) {
      data = new Uint8Array(imgArray);
    } else {
      data = new Uint8Array(computedLength);
      data.set(imgArray);
      data.fill(0xff, actualLength);
    }
    if (inverseDecode) {
      for (i = 0; i < actualLength; i++) {
        data[i] ^= 0xff;
      }
    }
    return {
      data,
      width,
      height,
      interpolate
    };
  }
  static async createMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode,
    interpolate,
    isOffscreenCanvasSupported = false
  }) {
    const isSingleOpaquePixel = width === 1 && height === 1 && inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
    if (isSingleOpaquePixel) {
      return {
        isSingleOpaquePixel
      };
    }
    if (isOffscreenCanvasSupported) {
      if (_image_resizer.ImageResizer.needsToBeResized(width, height)) {
        const data = new Uint8ClampedArray(width * height * 4);
        (0, _image_utils.convertBlackAndWhiteToRGBA)({
          src: imgArray,
          dest: data,
          width,
          height,
          nonBlackColor: 0,
          inverseDecode
        });
        return _image_resizer.ImageResizer.createImage({
          kind: _util.ImageKind.RGBA_32BPP,
          data,
          width,
          height,
          interpolate
        });
      }
      const canvas = new OffscreenCanvas(width, height);
      const ctx = canvas.getContext("2d");
      const imgData = ctx.createImageData(width, height);
      (0, _image_utils.convertBlackAndWhiteToRGBA)({
        src: imgArray,
        dest: imgData.data,
        width,
        height,
        nonBlackColor: 0,
        inverseDecode
      });
      ctx.putImageData(imgData, 0, 0);
      const bitmap = canvas.transferToImageBitmap();
      return {
        data: null,
        width,
        height,
        interpolate,
        bitmap
      };
    }
    return this.createRawMask({
      imgArray,
      width,
      height,
      inverseDecode,
      imageIsFromDecodeStream,
      interpolate
    });
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(buffer) {
    const bpc = this.bpc;
    const numComps = this.numComps;
    const decodeAddends = this.decodeAddends;
    const decodeCoefficients = this.decodeCoefficients;
    const max = (1 << bpc) - 1;
    let i, ii;
    if (bpc === 1) {
      for (i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = +!buffer[i];
      }
      return;
    }
    let index = 0;
    for (i = 0, ii = this.width * this.height; i < ii; i++) {
      for (let j = 0; j < numComps; j++) {
        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
        index++;
      }
    }
  }
  getComponents(buffer) {
    const bpc = this.bpc;
    if (bpc === 8) {
      return buffer;
    }
    const width = this.width;
    const height = this.height;
    const numComps = this.numComps;
    const length = width * height * numComps;
    let bufferPos = 0;
    let output;
    if (bpc <= 8) {
      output = new Uint8Array(length);
    } else if (bpc <= 16) {
      output = new Uint16Array(length);
    } else {
      output = new Uint32Array(length);
    }
    const rowComps = width * numComps;
    const max = (1 << bpc) - 1;
    let i = 0,
      ii,
      buf;
    if (bpc === 1) {
      let mask, loop1End, loop2End;
      for (let j = 0; j < height; j++) {
        loop1End = i + (rowComps & ~7);
        loop2End = i + rowComps;
        while (i < loop1End) {
          buf = buffer[bufferPos++];
          output[i] = buf >> 7 & 1;
          output[i + 1] = buf >> 6 & 1;
          output[i + 2] = buf >> 5 & 1;
          output[i + 3] = buf >> 4 & 1;
          output[i + 4] = buf >> 3 & 1;
          output[i + 5] = buf >> 2 & 1;
          output[i + 6] = buf >> 1 & 1;
          output[i + 7] = buf & 1;
          i += 8;
        }
        if (i < loop2End) {
          buf = buffer[bufferPos++];
          mask = 128;
          while (i < loop2End) {
            output[i++] = +!!(buf & mask);
            mask >>= 1;
          }
        }
      }
    } else {
      let bits = 0;
      buf = 0;
      for (i = 0, ii = length; i < ii; ++i) {
        if (i % rowComps === 0) {
          buf = 0;
          bits = 0;
        }
        while (bits < bpc) {
          buf = buf << 8 | buffer[bufferPos++];
          bits += 8;
        }
        const remainingBits = bits - bpc;
        let value = buf >> remainingBits;
        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }
        output[i] = value;
        buf &= (1 << remainingBits) - 1;
        bits = remainingBits;
      }
    }
    return output;
  }
  fillOpacity(rgbaBuf, width, height, actualHeight, image) {
    const smask = this.smask;
    const mask = this.mask;
    let alphaBuf, sw, sh, i, ii, j;
    if (smask) {
      sw = smask.width;
      sh = smask.height;
      alphaBuf = new Uint8ClampedArray(sw * sh);
      smask.fillGrayBuffer(alphaBuf);
      if (sw !== width || sh !== height) {
        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
      }
    } else if (mask) {
      if (mask instanceof PDFImage) {
        sw = mask.width;
        sh = mask.height;
        alphaBuf = new Uint8ClampedArray(sw * sh);
        mask.numComps = 1;
        mask.fillGrayBuffer(alphaBuf);
        for (i = 0, ii = sw * sh; i < ii; ++i) {
          alphaBuf[i] = 255 - alphaBuf[i];
        }
        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
        }
      } else if (Array.isArray(mask)) {
        alphaBuf = new Uint8ClampedArray(width * height);
        const numComps = this.numComps;
        for (i = 0, ii = width * height; i < ii; ++i) {
          let opacity = 0;
          const imageOffset = i * numComps;
          for (j = 0; j < numComps; ++j) {
            const color = image[imageOffset + j];
            const maskOffset = j * 2;
            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
              opacity = 255;
              break;
            }
          }
          alphaBuf[i] = opacity;
        }
      } else {
        throw new _util.FormatError("Unknown mask format.");
      }
    }
    if (alphaBuf) {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = alphaBuf[i];
      }
    } else {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = 255;
      }
    }
  }
  undoPreblend(buffer, width, height) {
    const matte = this.smask?.matte;
    if (!matte) {
      return;
    }
    const matteRgb = this.colorSpace.getRgb(matte, 0);
    const matteR = matteRgb[0];
    const matteG = matteRgb[1];
    const matteB = matteRgb[2];
    const length = width * height * 4;
    for (let i = 0; i < length; i += 4) {
      const alpha = buffer[i + 3];
      if (alpha === 0) {
        buffer[i] = 255;
        buffer[i + 1] = 255;
        buffer[i + 2] = 255;
        continue;
      }
      const k = 255 / alpha;
      buffer[i] = (buffer[i] - matteR) * k + matteR;
      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
    }
  }
  async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {
    const drawWidth = this.drawWidth;
    const drawHeight = this.drawHeight;
    const imgData = {
      width: drawWidth,
      height: drawHeight,
      interpolate: this.interpolate,
      kind: 0,
      data: null
    };
    const numComps = this.numComps;
    const originalWidth = this.width;
    const originalHeight = this.height;
    const bpc = this.bpc;
    const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
    const mustBeResized = isOffscreenCanvasSupported && _image_resizer.ImageResizer.needsToBeResized(drawWidth, drawHeight);
    if (!forceRGBA) {
      let kind;
      if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
        kind = _util.ImageKind.GRAYSCALE_1BPP;
      } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
        kind = _util.ImageKind.RGB_24BPP;
      }
      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
        const data = this.getImageBytes(originalHeight * rowBytes, {});
        if (isOffscreenCanvasSupported) {
          if (mustBeResized) {
            return _image_resizer.ImageResizer.createImage({
              data,
              kind,
              width: drawWidth,
              height: drawHeight,
              interpolate: this.interpolate
            }, this.needsDecode);
          }
          return this.createBitmap(kind, originalWidth, originalHeight, data);
        }
        imgData.kind = kind;
        imgData.data = data;
        if (this.needsDecode) {
          (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const buffer = imgData.data;
          for (let i = 0, ii = buffer.length; i < ii; i++) {
            buffer[i] ^= 0xff;
          }
        }
        return imgData;
      }
      if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
        let imageLength = originalHeight * rowBytes;
        if (isOffscreenCanvasSupported && !mustBeResized) {
          let isHandled = false;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              imageLength *= 4;
              isHandled = true;
              break;
            case "DeviceRGB":
              imageLength = imageLength / 3 * 4;
              isHandled = true;
              break;
            case "DeviceCMYK":
              isHandled = true;
              break;
          }
          if (isHandled) {
            const rgba = this.getImageBytes(imageLength, {
              drawWidth,
              drawHeight,
              forceRGBA: true
            });
            return this.createBitmap(_util.ImageKind.RGBA_32BPP, drawWidth, drawHeight, rgba);
          }
        } else {
          switch (this.colorSpace.name) {
            case "DeviceGray":
              imageLength *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              imgData.kind = _util.ImageKind.RGB_24BPP;
              imgData.data = this.getImageBytes(imageLength, {
                drawWidth,
                drawHeight,
                forceRGB: true
              });
              if (mustBeResized) {
                return _image_resizer.ImageResizer.createImage(imgData);
              }
              return imgData;
          }
        }
      }
    }
    const imgArray = this.getImageBytes(originalHeight * rowBytes, {
      internal: true
    });
    const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
    const comps = this.getComponents(imgArray);
    let alpha01, maybeUndoPreblend;
    let canvas, ctx, canvasImgData, data;
    if (isOffscreenCanvasSupported && !mustBeResized) {
      canvas = new OffscreenCanvas(drawWidth, drawHeight);
      ctx = canvas.getContext("2d");
      canvasImgData = ctx.createImageData(drawWidth, drawHeight);
      data = canvasImgData.data;
    }
    imgData.kind = _util.ImageKind.RGBA_32BPP;
    if (!forceRGBA && !this.smask && !this.mask) {
      if (!isOffscreenCanvasSupported || mustBeResized) {
        imgData.kind = _util.ImageKind.RGB_24BPP;
        data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
        alpha01 = 0;
      } else {
        const arr = new Uint32Array(data.buffer);
        arr.fill(_util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff);
        alpha01 = 1;
      }
      maybeUndoPreblend = false;
    } else {
      if (!isOffscreenCanvasSupported || mustBeResized) {
        data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
      }
      alpha01 = 1;
      maybeUndoPreblend = true;
      this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    this.colorSpace.fillRgb(data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
    if (maybeUndoPreblend) {
      this.undoPreblend(data, drawWidth, actualHeight);
    }
    if (isOffscreenCanvasSupported && !mustBeResized) {
      ctx.putImageData(canvasImgData, 0, 0);
      const bitmap = canvas.transferToImageBitmap();
      return {
        data: null,
        width: drawWidth,
        height: drawHeight,
        bitmap,
        interpolate: this.interpolate
      };
    }
    imgData.data = data;
    if (mustBeResized) {
      return _image_resizer.ImageResizer.createImage(imgData);
    }
    return imgData;
  }
  fillGrayBuffer(buffer) {
    const numComps = this.numComps;
    if (numComps !== 1) {
      throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`);
    }
    const width = this.width;
    const height = this.height;
    const bpc = this.bpc;
    const rowBytes = width * numComps * bpc + 7 >> 3;
    const imgArray = this.getImageBytes(height * rowBytes, {
      internal: true
    });
    const comps = this.getComponents(imgArray);
    let i, length;
    if (bpc === 1) {
      length = width * height;
      if (this.needsDecode) {
        for (i = 0; i < length; ++i) {
          buffer[i] = comps[i] - 1 & 255;
        }
      } else {
        for (i = 0; i < length; ++i) {
          buffer[i] = -comps[i] & 255;
        }
      }
      return;
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    length = width * height;
    const scale = 255 / ((1 << bpc) - 1);
    for (i = 0; i < length; ++i) {
      buffer[i] = scale * comps[i];
    }
  }
  createBitmap(kind, width, height, src) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    let imgData;
    if (kind === _util.ImageKind.RGBA_32BPP) {
      imgData = new ImageData(src, width, height);
    } else {
      imgData = ctx.createImageData(width, height);
      (0, _image_utils.convertToRGBA)({
        kind,
        src,
        dest: new Uint32Array(imgData.data.buffer),
        width,
        height,
        inverseDecode: this.needsDecode
      });
    }
    ctx.putImageData(imgData, 0, 0);
    const bitmap = canvas.transferToImageBitmap();
    return {
      data: null,
      width,
      height,
      bitmap,
      interpolate: this.interpolate
    };
  }
  getImageBytes(length, {
    drawWidth,
    drawHeight,
    forceRGBA = false,
    forceRGB = false,
    internal = false
  }) {
    this.image.reset();
    this.image.drawWidth = drawWidth || this.width;
    this.image.drawHeight = drawHeight || this.height;
    this.image.forceRGBA = !!forceRGBA;
    this.image.forceRGB = !!forceRGB;
    const imageBytes = this.image.getBytes(length);
    if (internal || this.image instanceof _decode_stream.DecodeStream) {
      return imageBytes;
    }
    (0, _util.assert)(imageBytes instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
    return new Uint8Array(imageBytes);
  }
}
exports.PDFImage = PDFImage;

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Catalog = void 0;
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _name_number_tree = __w_pdfjs_require__(67);
var _base_stream = __w_pdfjs_require__(5);
var _cleanup_helper = __w_pdfjs_require__(68);
var _colorspace = __w_pdfjs_require__(12);
var _file_spec = __w_pdfjs_require__(69);
var _image_utils = __w_pdfjs_require__(59);
var _metadata_parser = __w_pdfjs_require__(70);
var _struct_tree = __w_pdfjs_require__(72);
function fetchDestination(dest) {
  if (dest instanceof _primitives.Dict) {
    dest = dest.get("D");
  }
  return Array.isArray(dest) ? dest : null;
}
class Catalog {
  constructor(pdfManager, xref) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this._catDict = xref.getCatalogObj();
    if (!(this._catDict instanceof _primitives.Dict)) {
      throw new _util.FormatError("Catalog object is not a dictionary.");
    }
    this.toplevelPagesDict;
    this._actualNumPages = null;
    this.fontCache = new _primitives.RefSetCache();
    this.builtInCMapCache = new Map();
    this.standardFontDataCache = new Map();
    this.globalImageCache = new _image_utils.GlobalImageCache();
    this.pageKidsCountCache = new _primitives.RefSetCache();
    this.pageIndexCache = new _primitives.RefSetCache();
    this.nonBlendModesSet = new _primitives.RefSet();
    this.systemFontCache = new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const version = this._catDict.get("Version");
    if (version instanceof _primitives.Name) {
      if (_core_utils.PDF_VERSION_REGEXP.test(version.name)) {
        return (0, _util.shadow)(this, "version", version.name);
      }
      (0, _util.warn)(`Invalid PDF catalog version: ${version.name}`);
    }
    return (0, _util.shadow)(this, "version", null);
  }
  get lang() {
    const lang = this._catDict.get("Lang");
    return (0, _util.shadow)(this, "lang", typeof lang === "string" ? (0, _util.stringToPDFString)(lang) : null);
  }
  get needsRendering() {
    const needsRendering = this._catDict.get("NeedsRendering");
    return (0, _util.shadow)(this, "needsRendering", typeof needsRendering === "boolean" ? needsRendering : false);
  }
  get collection() {
    let collection = null;
    try {
      const obj = this._catDict.get("Collection");
      if (obj instanceof _primitives.Dict && obj.size > 0) {
        collection = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return (0, _util.shadow)(this, "collection", collection);
  }
  get acroForm() {
    let acroForm = null;
    try {
      const obj = this._catDict.get("AcroForm");
      if (obj instanceof _primitives.Dict && obj.size > 0) {
        acroForm = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return (0, _util.shadow)(this, "acroForm", acroForm);
  }
  get acroFormRef() {
    const value = this._catDict.getRaw("AcroForm");
    return (0, _util.shadow)(this, "acroFormRef", value instanceof _primitives.Ref ? value : null);
  }
  get metadata() {
    const streamRef = this._catDict.getRaw("Metadata");
    if (!(streamRef instanceof _primitives.Ref)) {
      return (0, _util.shadow)(this, "metadata", null);
    }
    let metadata = null;
    try {
      const stream = this.xref.fetch(streamRef, !this.xref.encrypt?.encryptMetadata);
      if (stream instanceof _base_stream.BaseStream && stream.dict instanceof _primitives.Dict) {
        const type = stream.dict.get("Type");
        const subtype = stream.dict.get("Subtype");
        if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
          const data = (0, _util.stringToUTF8String)(stream.getString());
          if (data) {
            metadata = new _metadata_parser.MetadataParser(data).serializable;
          }
        }
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.info)(`Skipping invalid Metadata: "${ex}".`);
    }
    return (0, _util.shadow)(this, "metadata", metadata);
  }
  get markInfo() {
    let markInfo = null;
    try {
      markInfo = this._readMarkInfo();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read mark info.");
    }
    return (0, _util.shadow)(this, "markInfo", markInfo);
  }
  _readMarkInfo() {
    const obj = this._catDict.get("MarkInfo");
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    const markInfo = {
      Marked: false,
      UserProperties: false,
      Suspects: false
    };
    for (const key in markInfo) {
      const value = obj.get(key);
      if (typeof value === "boolean") {
        markInfo[key] = value;
      }
    }
    return markInfo;
  }
  get structTreeRoot() {
    let structTree = null;
    try {
      structTree = this._readStructTreeRoot();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable read to structTreeRoot info.");
    }
    return (0, _util.shadow)(this, "structTreeRoot", structTree);
  }
  _readStructTreeRoot() {
    const rawObj = this._catDict.getRaw("StructTreeRoot");
    const obj = this.xref.fetchIfRef(rawObj);
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    const root = new _struct_tree.StructTreeRoot(obj, rawObj);
    root.init();
    return root;
  }
  get toplevelPagesDict() {
    const pagesObj = this._catDict.get("Pages");
    if (!(pagesObj instanceof _primitives.Dict)) {
      throw new _util.FormatError("Invalid top-level pages dictionary.");
    }
    return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
  }
  get documentOutline() {
    let obj = null;
    try {
      obj = this._readDocumentOutline();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read document outline.");
    }
    return (0, _util.shadow)(this, "documentOutline", obj);
  }
  _readDocumentOutline() {
    let obj = this._catDict.get("Outlines");
    if (!(obj instanceof _primitives.Dict)) {
      return null;
    }
    obj = obj.getRaw("First");
    if (!(obj instanceof _primitives.Ref)) {
      return null;
    }
    const root = {
      items: []
    };
    const queue = [{
      obj,
      parent: root
    }];
    const processed = new _primitives.RefSet();
    processed.put(obj);
    const xref = this.xref,
      blackColor = new Uint8ClampedArray(3);
    while (queue.length > 0) {
      const i = queue.shift();
      const outlineDict = xref.fetchIfRef(i.obj);
      if (outlineDict === null) {
        continue;
      }
      if (!outlineDict.has("Title")) {
        throw new _util.FormatError("Invalid outline item encountered.");
      }
      const data = {
        url: null,
        dest: null,
        action: null
      };
      Catalog.parseDestDictionary({
        destDict: outlineDict,
        resultObj: data,
        docBaseUrl: this.baseUrl,
        docAttachments: this.attachments
      });
      const title = outlineDict.get("Title");
      const flags = outlineDict.get("F") || 0;
      const color = outlineDict.getArray("C");
      const count = outlineDict.get("Count");
      let rgbColor = blackColor;
      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
        rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
      }
      const outlineItem = {
        action: data.action,
        attachment: data.attachment,
        dest: data.dest,
        url: data.url,
        unsafeUrl: data.unsafeUrl,
        newWindow: data.newWindow,
        setOCGState: data.setOCGState,
        title: (0, _util.stringToPDFString)(title),
        color: rgbColor,
        count: Number.isInteger(count) ? count : undefined,
        bold: !!(flags & 2),
        italic: !!(flags & 1),
        items: []
      };
      i.parent.items.push(outlineItem);
      obj = outlineDict.getRaw("First");
      if (obj instanceof _primitives.Ref && !processed.has(obj)) {
        queue.push({
          obj,
          parent: outlineItem
        });
        processed.put(obj);
      }
      obj = outlineDict.getRaw("Next");
      if (obj instanceof _primitives.Ref && !processed.has(obj)) {
        queue.push({
          obj,
          parent: i.parent
        });
        processed.put(obj);
      }
    }
    return root.items.length > 0 ? root.items : null;
  }
  get permissions() {
    let permissions = null;
    try {
      permissions = this._readPermissions();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read permissions.");
    }
    return (0, _util.shadow)(this, "permissions", permissions);
  }
  _readPermissions() {
    const encrypt = this.xref.trailer.get("Encrypt");
    if (!(encrypt instanceof _primitives.Dict)) {
      return null;
    }
    let flags = encrypt.get("P");
    if (typeof flags !== "number") {
      return null;
    }
    flags += 2 ** 32;
    const permissions = [];
    for (const key in _util.PermissionFlag) {
      const value = _util.PermissionFlag[key];
      if (flags & value) {
        permissions.push(value);
      }
    }
    return permissions;
  }
  get optionalContentConfig() {
    let config = null;
    try {
      const properties = this._catDict.get("OCProperties");
      if (!properties) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const defaultConfig = properties.get("D");
      if (!defaultConfig) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const groupsData = properties.get("OCGs");
      if (!Array.isArray(groupsData)) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }
      const groups = [];
      const groupRefs = [];
      for (const groupRef of groupsData) {
        if (!(groupRef instanceof _primitives.Ref)) {
          continue;
        }
        groupRefs.push(groupRef);
        const group = this.xref.fetchIfRef(groupRef);
        groups.push({
          id: groupRef.toString(),
          name: typeof group.get("Name") === "string" ? (0, _util.stringToPDFString)(group.get("Name")) : null,
          intent: typeof group.get("Intent") === "string" ? (0, _util.stringToPDFString)(group.get("Intent")) : null
        });
      }
      config = this._readOptionalContentConfig(defaultConfig, groupRefs);
      config.groups = groups;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`Unable to read optional content config: ${ex}`);
    }
    return (0, _util.shadow)(this, "optionalContentConfig", config);
  }
  _readOptionalContentConfig(config, contentGroupRefs) {
    function parseOnOff(refs) {
      const onParsed = [];
      if (Array.isArray(refs)) {
        for (const value of refs) {
          if (!(value instanceof _primitives.Ref)) {
            continue;
          }
          if (contentGroupRefs.includes(value)) {
            onParsed.push(value.toString());
          }
        }
      }
      return onParsed;
    }
    function parseOrder(refs, nestedLevels = 0) {
      if (!Array.isArray(refs)) {
        return null;
      }
      const order = [];
      for (const value of refs) {
        if (value instanceof _primitives.Ref && contentGroupRefs.includes(value)) {
          parsedOrderRefs.put(value);
          order.push(value.toString());
          continue;
        }
        const nestedOrder = parseNestedOrder(value, nestedLevels);
        if (nestedOrder) {
          order.push(nestedOrder);
        }
      }
      if (nestedLevels > 0) {
        return order;
      }
      const hiddenGroups = [];
      for (const groupRef of contentGroupRefs) {
        if (parsedOrderRefs.has(groupRef)) {
          continue;
        }
        hiddenGroups.push(groupRef.toString());
      }
      if (hiddenGroups.length) {
        order.push({
          name: null,
          order: hiddenGroups
        });
      }
      return order;
    }
    function parseNestedOrder(ref, nestedLevels) {
      if (++nestedLevels > MAX_NESTED_LEVELS) {
        (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }
      const value = xref.fetchIfRef(ref);
      if (!Array.isArray(value)) {
        return null;
      }
      const nestedName = xref.fetchIfRef(value[0]);
      if (typeof nestedName !== "string") {
        return null;
      }
      const nestedOrder = parseOrder(value.slice(1), nestedLevels);
      if (!nestedOrder || !nestedOrder.length) {
        return null;
      }
      return {
        name: (0, _util.stringToPDFString)(nestedName),
        order: nestedOrder
      };
    }
    const xref = this.xref,
      parsedOrderRefs = new _primitives.RefSet(),
      MAX_NESTED_LEVELS = 10;
    return {
      name: typeof config.get("Name") === "string" ? (0, _util.stringToPDFString)(config.get("Name")) : null,
      creator: typeof config.get("Creator") === "string" ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
      baseState: config.get("BaseState") instanceof _primitives.Name ? config.get("BaseState").name : null,
      on: parseOnOff(config.get("ON")),
      off: parseOnOff(config.get("OFF")),
      order: parseOrder(config.get("Order")),
      groups: null
    };
  }
  setActualNumPages(num = null) {
    this._actualNumPages = num;
  }
  get hasActualNumPages() {
    return this._actualNumPages !== null;
  }
  get _pagesCount() {
    const obj = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(obj)) {
      throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
    }
    return (0, _util.shadow)(this, "_pagesCount", obj);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const obj = this._readDests(),
      dests = Object.create(null);
    if (obj instanceof _name_number_tree.NameTree) {
      for (const [key, value] of obj.getAll()) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[(0, _util.stringToPDFString)(key)] = dest;
        }
      }
    } else if (obj instanceof _primitives.Dict) {
      obj.forEach(function (key, value) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[key] = dest;
        }
      });
    }
    return (0, _util.shadow)(this, "destinations", dests);
  }
  getDestination(id) {
    const obj = this._readDests();
    if (obj instanceof _name_number_tree.NameTree) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
      const allDest = this.destinations[id];
      if (allDest) {
        (0, _util.warn)(`Found "${id}" at an incorrect position in the NameTree.`);
        return allDest;
      }
    } else if (obj instanceof _primitives.Dict) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
    }
    return null;
  }
  _readDests() {
    const obj = this._catDict.get("Names");
    if (obj?.has("Dests")) {
      return new _name_number_tree.NameTree(obj.getRaw("Dests"), this.xref);
    } else if (this._catDict.has("Dests")) {
      return this._catDict.get("Dests");
    }
    return undefined;
  }
  get pageLabels() {
    let obj = null;
    try {
      obj = this._readPageLabels();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)("Unable to read page labels.");
    }
    return (0, _util.shadow)(this, "pageLabels", obj);
  }
  _readPageLabels() {
    const obj = this._catDict.getRaw("PageLabels");
    if (!obj) {
      return null;
    }
    const pageLabels = new Array(this.numPages);
    let style = null,
      prefix = "";
    const numberTree = new _name_number_tree.NumberTree(obj, this.xref);
    const nums = numberTree.getAll();
    let currentLabel = "",
      currentIndex = 1;
    for (let i = 0, ii = this.numPages; i < ii; i++) {
      const labelDict = nums.get(i);
      if (labelDict !== undefined) {
        if (!(labelDict instanceof _primitives.Dict)) {
          throw new _util.FormatError("PageLabel is not a dictionary.");
        }
        if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
          throw new _util.FormatError("Invalid type in PageLabel dictionary.");
        }
        if (labelDict.has("S")) {
          const s = labelDict.get("S");
          if (!(s instanceof _primitives.Name)) {
            throw new _util.FormatError("Invalid style in PageLabel dictionary.");
          }
          style = s.name;
        } else {
          style = null;
        }
        if (labelDict.has("P")) {
          const p = labelDict.get("P");
          if (typeof p !== "string") {
            throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
          }
          prefix = (0, _util.stringToPDFString)(p);
        } else {
          prefix = "";
        }
        if (labelDict.has("St")) {
          const st = labelDict.get("St");
          if (!(Number.isInteger(st) && st >= 1)) {
            throw new _util.FormatError("Invalid start in PageLabel dictionary.");
          }
          currentIndex = st;
        } else {
          currentIndex = 1;
        }
      }
      switch (style) {
        case "D":
          currentLabel = currentIndex;
          break;
        case "R":
        case "r":
          currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
          break;
        case "A":
        case "a":
          const LIMIT = 26;
          const A_UPPER_CASE = 0x41,
            A_LOWER_CASE = 0x61;
          const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
          const letterIndex = currentIndex - 1;
          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
          currentLabel = character.repeat(Math.floor(letterIndex / LIMIT) + 1);
          break;
        default:
          if (style) {
            throw new _util.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
          }
          currentLabel = "";
      }
      pageLabels[i] = prefix + currentLabel;
      currentIndex++;
    }
    return pageLabels;
  }
  get pageLayout() {
    const obj = this._catDict.get("PageLayout");
    let pageLayout = "";
    if (obj instanceof _primitives.Name) {
      switch (obj.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          pageLayout = obj.name;
      }
    }
    return (0, _util.shadow)(this, "pageLayout", pageLayout);
  }
  get pageMode() {
    const obj = this._catDict.get("PageMode");
    let pageMode = "UseNone";
    if (obj instanceof _primitives.Name) {
      switch (obj.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          pageMode = obj.name;
      }
    }
    return (0, _util.shadow)(this, "pageMode", pageMode);
  }
  get viewerPreferences() {
    const obj = this._catDict.get("ViewerPreferences");
    if (!(obj instanceof _primitives.Dict)) {
      return (0, _util.shadow)(this, "viewerPreferences", null);
    }
    let prefs = null;
    for (const key of obj.getKeys()) {
      const value = obj.get(key);
      let prefValue;
      switch (key) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          if (typeof value === "boolean") {
            prefValue = value;
          }
          break;
        case "NonFullScreenPageMode":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                prefValue = value.name;
                break;
              default:
                prefValue = "UseNone";
            }
          }
          break;
        case "Direction":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "L2R":
              case "R2L":
                prefValue = value.name;
                break;
              default:
                prefValue = "L2R";
            }
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                prefValue = value.name;
                break;
              default:
                prefValue = "CropBox";
            }
          }
          break;
        case "PrintScaling":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "None":
              case "AppDefault":
                prefValue = value.name;
                break;
              default:
                prefValue = "AppDefault";
            }
          }
          break;
        case "Duplex":
          if (value instanceof _primitives.Name) {
            switch (value.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                prefValue = value.name;
                break;
              default:
                prefValue = "None";
            }
          }
          break;
        case "PrintPageRange":
          if (Array.isArray(value) && value.length % 2 === 0) {
            const isValid = value.every((page, i, arr) => {
              return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
            });
            if (isValid) {
              prefValue = value;
            }
          }
          break;
        case "NumCopies":
          if (Number.isInteger(value) && value > 0) {
            prefValue = value;
          }
          break;
        default:
          (0, _util.warn)(`Ignoring non-standard key in ViewerPreferences: ${key}.`);
          continue;
      }
      if (prefValue === undefined) {
        (0, _util.warn)(`Bad value, for key "${key}", in ViewerPreferences: ${value}.`);
        continue;
      }
      if (!prefs) {
        prefs = Object.create(null);
      }
      prefs[key] = prefValue;
    }
    return (0, _util.shadow)(this, "viewerPreferences", prefs);
  }
  get openAction() {
    const obj = this._catDict.get("OpenAction");
    const openAction = Object.create(null);
    if (obj instanceof _primitives.Dict) {
      const destDict = new _primitives.Dict(this.xref);
      destDict.set("A", obj);
      const resultObj = {
        url: null,
        dest: null,
        action: null
      };
      Catalog.parseDestDictionary({
        destDict,
        resultObj
      });
      if (Array.isArray(resultObj.dest)) {
        openAction.dest = resultObj.dest;
      } else if (resultObj.action) {
        openAction.action = resultObj.action;
      }
    } else if (Array.isArray(obj)) {
      openAction.dest = obj;
    }
    return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
  }
  get attachments() {
    const obj = this._catDict.get("Names");
    let attachments = null;
    if (obj instanceof _primitives.Dict && obj.has("EmbeddedFiles")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        const fs = new _file_spec.FileSpec(value, this.xref);
        if (!attachments) {
          attachments = Object.create(null);
        }
        attachments[(0, _util.stringToPDFString)(key)] = fs.serializable;
      }
    }
    return (0, _util.shadow)(this, "attachments", attachments);
  }
  get xfaImages() {
    const obj = this._catDict.get("Names");
    let xfaImages = null;
    if (obj instanceof _primitives.Dict && obj.has("XFAImages")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("XFAImages"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        if (!xfaImages) {
          xfaImages = new _primitives.Dict(this.xref);
        }
        xfaImages.set((0, _util.stringToPDFString)(key), value);
      }
    }
    return (0, _util.shadow)(this, "xfaImages", xfaImages);
  }
  _collectJavaScript() {
    const obj = this._catDict.get("Names");
    let javaScript = null;
    function appendIfJavaScriptDict(name, jsDict) {
      if (!(jsDict instanceof _primitives.Dict)) {
        return;
      }
      if (!(0, _primitives.isName)(jsDict.get("S"), "JavaScript")) {
        return;
      }
      let js = jsDict.get("JS");
      if (js instanceof _base_stream.BaseStream) {
        js = js.getString();
      } else if (typeof js !== "string") {
        return;
      }
      js = (0, _util.stringToPDFString)(js).replaceAll("\x00", "");
      if (js) {
        (javaScript ||= new Map()).set(name, js);
      }
    }
    if (obj instanceof _primitives.Dict && obj.has("JavaScript")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("JavaScript"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        appendIfJavaScriptDict((0, _util.stringToPDFString)(key), value);
      }
    }
    const openAction = this._catDict.get("OpenAction");
    if (openAction) {
      appendIfJavaScriptDict("OpenAction", openAction);
    }
    return javaScript;
  }
  get jsActions() {
    const javaScript = this._collectJavaScript();
    let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);
    if (javaScript) {
      actions ||= Object.create(null);
      for (const [key, val] of javaScript) {
        if (key in actions) {
          actions[key].push(val);
        } else {
          actions[key] = [val];
        }
      }
    }
    return (0, _util.shadow)(this, "jsActions", actions);
  }
  async fontFallback(id, handler) {
    const translatedFonts = await Promise.all(this.fontCache);
    for (const translatedFont of translatedFonts) {
      if (translatedFont.loadedName === id) {
        translatedFont.fallback(handler);
        return;
      }
    }
  }
  async cleanup(manuallyTriggered = false) {
    (0, _cleanup_helper.clearGlobalCaches)();
    this.globalImageCache.clear(manuallyTriggered);
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.nonBlendModesSet.clear();
    const translatedFonts = await Promise.all(this.fontCache);
    for (const {
      dict
    } of translatedFonts) {
      delete dict.cacheKey;
    }
    this.fontCache.clear();
    this.builtInCMapCache.clear();
    this.standardFontDataCache.clear();
    this.systemFontCache.clear();
  }
  async getPageDict(pageIndex) {
    const nodesToVisit = [this.toplevelPagesDict];
    const visitedNodes = new _primitives.RefSet();
    const pagesRef = this._catDict.getRaw("Pages");
    if (pagesRef instanceof _primitives.Ref) {
      visitedNodes.put(pagesRef);
    }
    const xref = this.xref,
      pageKidsCountCache = this.pageKidsCountCache,
      pageIndexCache = this.pageIndexCache;
    let currentPageIndex = 0;
    while (nodesToVisit.length) {
      const currentNode = nodesToVisit.pop();
      if (currentNode instanceof _primitives.Ref) {
        const count = pageKidsCountCache.get(currentNode);
        if (count >= 0 && currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
        if (visitedNodes.has(currentNode)) {
          throw new _util.FormatError("Pages tree contains circular reference.");
        }
        visitedNodes.put(currentNode);
        const obj = await xref.fetchAsync(currentNode);
        if (obj instanceof _primitives.Dict) {
          let type = obj.getRaw("Type");
          if (type instanceof _primitives.Ref) {
            type = await xref.fetchAsync(type);
          }
          if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
            if (!pageKidsCountCache.has(currentNode)) {
              pageKidsCountCache.put(currentNode, 1);
            }
            if (!pageIndexCache.has(currentNode)) {
              pageIndexCache.put(currentNode, currentPageIndex);
            }
            if (currentPageIndex === pageIndex) {
              return [obj, currentNode];
            }
            currentPageIndex++;
            continue;
          }
        }
        nodesToVisit.push(obj);
        continue;
      }
      if (!(currentNode instanceof _primitives.Dict)) {
        throw new _util.FormatError("Page dictionary kid reference points to wrong type of object.");
      }
      const {
        objId
      } = currentNode;
      let count = currentNode.getRaw("Count");
      if (count instanceof _primitives.Ref) {
        count = await xref.fetchAsync(count);
      }
      if (Number.isInteger(count) && count >= 0) {
        if (objId && !pageKidsCountCache.has(objId)) {
          pageKidsCountCache.put(objId, count);
        }
        if (currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
      }
      let kids = currentNode.getRaw("Kids");
      if (kids instanceof _primitives.Ref) {
        kids = await xref.fetchAsync(kids);
      }
      if (!Array.isArray(kids)) {
        let type = currentNode.getRaw("Type");
        if (type instanceof _primitives.Ref) {
          type = await xref.fetchAsync(type);
        }
        if ((0, _primitives.isName)(type, "Page") || !currentNode.has("Kids")) {
          if (currentPageIndex === pageIndex) {
            return [currentNode, null];
          }
          currentPageIndex++;
          continue;
        }
        throw new _util.FormatError("Page dictionary kids object is not an array.");
      }
      for (let last = kids.length - 1; last >= 0; last--) {
        nodesToVisit.push(kids[last]);
      }
    }
    throw new Error(`Page index ${pageIndex} not found.`);
  }
  async getAllPageDicts(recoveryMode = false) {
    const {
      ignoreErrors
    } = this.pdfManager.evaluatorOptions;
    const queue = [{
      currentNode: this.toplevelPagesDict,
      posInKids: 0
    }];
    const visitedNodes = new _primitives.RefSet();
    const pagesRef = this._catDict.getRaw("Pages");
    if (pagesRef instanceof _primitives.Ref) {
      visitedNodes.put(pagesRef);
    }
    const map = new Map(),
      xref = this.xref,
      pageIndexCache = this.pageIndexCache;
    let pageIndex = 0;
    function addPageDict(pageDict, pageRef) {
      if (pageRef && !pageIndexCache.has(pageRef)) {
        pageIndexCache.put(pageRef, pageIndex);
      }
      map.set(pageIndex++, [pageDict, pageRef]);
    }
    function addPageError(error) {
      if (error instanceof _core_utils.XRefEntryException && !recoveryMode) {
        throw error;
      }
      if (recoveryMode && ignoreErrors && pageIndex === 0) {
        (0, _util.warn)(`getAllPageDicts - Skipping invalid first page: "${error}".`);
        error = _primitives.Dict.empty;
      }
      map.set(pageIndex++, [error, null]);
    }
    while (queue.length > 0) {
      const queueItem = queue.at(-1);
      const {
        currentNode,
        posInKids
      } = queueItem;
      let kids = currentNode.getRaw("Kids");
      if (kids instanceof _primitives.Ref) {
        try {
          kids = await xref.fetchAsync(kids);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      }
      if (!Array.isArray(kids)) {
        addPageError(new _util.FormatError("Page dictionary kids object is not an array."));
        break;
      }
      if (posInKids >= kids.length) {
        queue.pop();
        continue;
      }
      const kidObj = kids[posInKids];
      let obj;
      if (kidObj instanceof _primitives.Ref) {
        if (visitedNodes.has(kidObj)) {
          addPageError(new _util.FormatError("Pages tree contains circular reference."));
          break;
        }
        visitedNodes.put(kidObj);
        try {
          obj = await xref.fetchAsync(kidObj);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      } else {
        obj = kidObj;
      }
      if (!(obj instanceof _primitives.Dict)) {
        addPageError(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let type = obj.getRaw("Type");
      if (type instanceof _primitives.Ref) {
        try {
          type = await xref.fetchAsync(type);
        } catch (ex) {
          addPageError(ex);
          break;
        }
      }
      if ((0, _primitives.isName)(type, "Page") || !obj.has("Kids")) {
        addPageDict(obj, kidObj instanceof _primitives.Ref ? kidObj : null);
      } else {
        queue.push({
          currentNode: obj,
          posInKids: 0
        });
      }
      queueItem.posInKids++;
    }
    return map;
  }
  getPageIndex(pageRef) {
    const cachedPageIndex = this.pageIndexCache.get(pageRef);
    if (cachedPageIndex !== undefined) {
      return Promise.resolve(cachedPageIndex);
    }
    const xref = this.xref;
    function pagesBeforeRef(kidRef) {
      let total = 0,
        parentRef;
      return xref.fetchAsync(kidRef).then(function (node) {
        if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !(node instanceof _primitives.Dict && !node.has("Type") && node.has("Contents"))) {
          throw new _util.FormatError("The reference does not point to a /Page dictionary.");
        }
        if (!node) {
          return null;
        }
        if (!(node instanceof _primitives.Dict)) {
          throw new _util.FormatError("Node must be a dictionary.");
        }
        parentRef = node.getRaw("Parent");
        return node.getAsync("Parent");
      }).then(function (parent) {
        if (!parent) {
          return null;
        }
        if (!(parent instanceof _primitives.Dict)) {
          throw new _util.FormatError("Parent must be a dictionary.");
        }
        return parent.getAsync("Kids");
      }).then(function (kids) {
        if (!kids) {
          return null;
        }
        const kidPromises = [];
        let found = false;
        for (const kid of kids) {
          if (!(kid instanceof _primitives.Ref)) {
            throw new _util.FormatError("Kid must be a reference.");
          }
          if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
            found = true;
            break;
          }
          kidPromises.push(xref.fetchAsync(kid).then(function (obj) {
            if (!(obj instanceof _primitives.Dict)) {
              throw new _util.FormatError("Kid node must be a dictionary.");
            }
            if (obj.has("Count")) {
              total += obj.get("Count");
            } else {
              total++;
            }
          }));
        }
        if (!found) {
          throw new _util.FormatError("Kid reference not found in parent's kids.");
        }
        return Promise.all(kidPromises).then(function () {
          return [total, parentRef];
        });
      });
    }
    let total = 0;
    const next = ref => pagesBeforeRef(ref).then(args => {
      if (!args) {
        this.pageIndexCache.put(pageRef, total);
        return total;
      }
      const [count, parentRef] = args;
      total += count;
      return next(parentRef);
    });
    return next(pageRef);
  }
  get baseUrl() {
    const uri = this._catDict.get("URI");
    if (uri instanceof _primitives.Dict) {
      const base = uri.get("Base");
      if (typeof base === "string") {
        const absoluteUrl = (0, _util.createValidAbsoluteUrl)(base, null, {
          tryConvertEncoding: true
        });
        if (absoluteUrl) {
          return (0, _util.shadow)(this, "baseUrl", absoluteUrl.href);
        }
      }
    }
    return (0, _util.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({
    destDict,
    resultObj,
    docBaseUrl = null,
    docAttachments = null
  }) {
    if (!(destDict instanceof _primitives.Dict)) {
      (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let action = destDict.get("A"),
      url,
      dest;
    if (!(action instanceof _primitives.Dict)) {
      if (destDict.has("Dest")) {
        action = destDict.get("Dest");
      } else {
        action = destDict.get("AA");
        if (action instanceof _primitives.Dict) {
          if (action.has("D")) {
            action = action.get("D");
          } else if (action.has("U")) {
            action = action.get("U");
          }
        }
      }
    }
    if (action instanceof _primitives.Dict) {
      const actionType = action.get("S");
      if (!(actionType instanceof _primitives.Name)) {
        (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const actionName = actionType.name;
      switch (actionName) {
        case "ResetForm":
          const flags = action.get("Flags");
          const include = ((typeof flags === "number" ? flags : 0) & 1) === 0;
          const fields = [];
          const refs = [];
          for (const obj of action.get("Fields") || []) {
            if (obj instanceof _primitives.Ref) {
              refs.push(obj.toString());
            } else if (typeof obj === "string") {
              fields.push((0, _util.stringToPDFString)(obj));
            }
          }
          resultObj.resetForm = {
            fields,
            refs,
            include
          };
          break;
        case "URI":
          url = action.get("URI");
          if (url instanceof _primitives.Name) {
            url = "/" + url.name;
          }
          break;
        case "GoTo":
          dest = action.get("D");
          break;
        case "Launch":
        case "GoToR":
          const urlDict = action.get("F");
          if (urlDict instanceof _primitives.Dict) {
            url = urlDict.get("F") || null;
          } else if (typeof urlDict === "string") {
            url = urlDict;
          }
          let remoteDest = action.get("D");
          if (remoteDest) {
            if (remoteDest instanceof _primitives.Name) {
              remoteDest = remoteDest.name;
            }
            if (typeof url === "string") {
              const baseUrl = url.split("#")[0];
              if (typeof remoteDest === "string") {
                url = baseUrl + "#" + remoteDest;
              } else if (Array.isArray(remoteDest)) {
                url = baseUrl + "#" + JSON.stringify(remoteDest);
              }
            }
          }
          const newWindow = action.get("NewWindow");
          if (typeof newWindow === "boolean") {
            resultObj.newWindow = newWindow;
          }
          break;
        case "GoToE":
          const target = action.get("T");
          let attachment;
          if (docAttachments && target instanceof _primitives.Dict) {
            const relationship = target.get("R");
            const name = target.get("N");
            if ((0, _primitives.isName)(relationship, "C") && typeof name === "string") {
              attachment = docAttachments[(0, _util.stringToPDFString)(name)];
            }
          }
          if (attachment) {
            resultObj.attachment = attachment;
          } else {
            (0, _util.warn)(`parseDestDictionary - unimplemented "GoToE" action.`);
          }
          break;
        case "Named":
          const namedAction = action.get("N");
          if (namedAction instanceof _primitives.Name) {
            resultObj.action = namedAction.name;
          }
          break;
        case "SetOCGState":
          const state = action.get("State");
          const preserveRB = action.get("PreserveRB");
          if (!Array.isArray(state) || state.length === 0) {
            break;
          }
          const stateArr = [];
          for (const elem of state) {
            if (elem instanceof _primitives.Name) {
              switch (elem.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  stateArr.push(elem.name);
                  break;
              }
            } else if (elem instanceof _primitives.Ref) {
              stateArr.push(elem.toString());
            }
          }
          if (stateArr.length !== state.length) {
            break;
          }
          resultObj.setOCGState = {
            state: stateArr,
            preserveRB: typeof preserveRB === "boolean" ? preserveRB : true
          };
          break;
        case "JavaScript":
          const jsAction = action.get("JS");
          let js;
          if (jsAction instanceof _base_stream.BaseStream) {
            js = jsAction.getString();
          } else if (typeof jsAction === "string") {
            js = jsAction;
          }
          const jsURL = js && (0, _core_utils.recoverJsURL)((0, _util.stringToPDFString)(js));
          if (jsURL) {
            url = jsURL.url;
            resultObj.newWindow = jsURL.newWindow;
            break;
          }
        default:
          if (actionName === "JavaScript" || actionName === "SubmitForm") {
            break;
          }
          (0, _util.warn)(`parseDestDictionary - unsupported action: "${actionName}".`);
          break;
      }
    } else if (destDict.has("Dest")) {
      dest = destDict.get("Dest");
    }
    if (typeof url === "string") {
      const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl, {
        addDefaultProtocol: true,
        tryConvertEncoding: true
      });
      if (absoluteUrl) {
        resultObj.url = absoluteUrl.href;
      }
      resultObj.unsafeUrl = url;
    }
    if (dest) {
      if (dest instanceof _primitives.Name) {
        dest = dest.name;
      }
      if (typeof dest === "string") {
        resultObj.dest = (0, _util.stringToPDFString)(dest);
      } else if (Array.isArray(dest)) {
        resultObj.dest = dest;
      }
    }
  }
}
exports.Catalog = Catalog;

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NumberTree = exports.NameTree = void 0;
var _primitives = __w_pdfjs_require__(4);
var _util = __w_pdfjs_require__(2);
class NameOrNumberTree {
  constructor(root, xref, type) {
    if (this.constructor === NameOrNumberTree) {
      (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
    }
    this.root = root;
    this.xref = xref;
    this._type = type;
  }
  getAll() {
    const map = new Map();
    if (!this.root) {
      return map;
    }
    const xref = this.xref;
    const processed = new _primitives.RefSet();
    processed.put(this.root);
    const queue = [this.root];
    while (queue.length > 0) {
      const obj = xref.fetchIfRef(queue.shift());
      if (!(obj instanceof _primitives.Dict)) {
        continue;
      }
      if (obj.has("Kids")) {
        const kids = obj.get("Kids");
        if (!Array.isArray(kids)) {
          continue;
        }
        for (const kid of kids) {
          if (processed.has(kid)) {
            throw new _util.FormatError(`Duplicate entry in "${this._type}" tree.`);
          }
          queue.push(kid);
          processed.put(kid);
        }
        continue;
      }
      const entries = obj.get(this._type);
      if (!Array.isArray(entries)) {
        continue;
      }
      for (let i = 0, ii = entries.length; i < ii; i += 2) {
        map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
      }
    }
    return map;
  }
  get(key) {
    if (!this.root) {
      return null;
    }
    const xref = this.xref;
    let kidsOrEntries = xref.fetchIfRef(this.root);
    let loopCount = 0;
    const MAX_LEVELS = 10;
    while (kidsOrEntries.has("Kids")) {
      if (++loopCount > MAX_LEVELS) {
        (0, _util.warn)(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }
      const kids = kidsOrEntries.get("Kids");
      if (!Array.isArray(kids)) {
        return null;
      }
      let l = 0,
        r = kids.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const kid = xref.fetchIfRef(kids[m]);
        const limits = kid.get("Limits");
        if (key < xref.fetchIfRef(limits[0])) {
          r = m - 1;
        } else if (key > xref.fetchIfRef(limits[1])) {
          l = m + 1;
        } else {
          kidsOrEntries = kid;
          break;
        }
      }
      if (l > r) {
        return null;
      }
    }
    const entries = kidsOrEntries.get(this._type);
    if (Array.isArray(entries)) {
      let l = 0,
        r = entries.length - 2;
      while (l <= r) {
        const tmp = l + r >> 1,
          m = tmp + (tmp & 1);
        const currentKey = xref.fetchIfRef(entries[m]);
        if (key < currentKey) {
          r = m - 2;
        } else if (key > currentKey) {
          l = m + 2;
        } else {
          return xref.fetchIfRef(entries[m + 1]);
        }
      }
    }
    return null;
  }
}
class NameTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Names");
  }
}
exports.NameTree = NameTree;
class NumberTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Nums");
  }
}
exports.NumberTree = NumberTree;

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearGlobalCaches = clearGlobalCaches;
var _pattern = __w_pdfjs_require__(50);
var _primitives = __w_pdfjs_require__(4);
var _unicode = __w_pdfjs_require__(40);
function clearGlobalCaches() {
  (0, _pattern.clearPatternCaches)();
  (0, _primitives.clearPrimitiveCaches)();
  (0, _unicode.clearUnicodeCaches)();
}

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileSpec = void 0;
var _util = __w_pdfjs_require__(2);
var _base_stream = __w_pdfjs_require__(5);
var _primitives = __w_pdfjs_require__(4);
function pickPlatformItem(dict) {
  if (dict.has("UF")) {
    return dict.get("UF");
  } else if (dict.has("F")) {
    return dict.get("F");
  } else if (dict.has("Unix")) {
    return dict.get("Unix");
  } else if (dict.has("Mac")) {
    return dict.get("Mac");
  } else if (dict.has("DOS")) {
    return dict.get("DOS");
  }
  return null;
}
class FileSpec {
  constructor(root, xref) {
    if (!(root instanceof _primitives.Dict)) {
      return;
    }
    this.xref = xref;
    this.root = root;
    if (root.has("FS")) {
      this.fs = root.get("FS");
    }
    this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
    if (root.has("RF")) {
      (0, _util.warn)("Related file specifications are not supported");
    }
    this.contentAvailable = true;
    if (!root.has("EF")) {
      this.contentAvailable = false;
      (0, _util.warn)("Non-embedded file specifications are not supported");
    }
  }
  get filename() {
    if (!this._filename && this.root) {
      const filename = pickPlatformItem(this.root) || "unnamed";
      this._filename = (0, _util.stringToPDFString)(filename).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
    }
    return this._filename;
  }
  get content() {
    if (!this.contentAvailable) {
      return null;
    }
    if (!this.contentRef && this.root) {
      this.contentRef = pickPlatformItem(this.root.get("EF"));
    }
    let content = null;
    if (this.contentRef) {
      const fileObj = this.xref.fetchIfRef(this.contentRef);
      if (fileObj instanceof _base_stream.BaseStream) {
        content = fileObj.getBytes();
      } else {
        (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
      }
    } else {
      (0, _util.warn)("Embedded file specification does not have a content");
    }
    return content;
  }
  get serializable() {
    return {
      filename: this.filename,
      content: this.content
    };
  }
}
exports.FileSpec = FileSpec;

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MetadataParser = void 0;
var _xml_parser = __w_pdfjs_require__(71);
class MetadataParser {
  constructor(data) {
    data = this._repair(data);
    const parser = new _xml_parser.SimpleXMLParser({
      lowerCaseName: true
    });
    const xmlDocument = parser.parseFromString(data);
    this._metadataMap = new Map();
    this._data = data;
    if (xmlDocument) {
      this._parse(xmlDocument);
    }
  }
  _repair(data) {
    return data.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function (all, codes) {
      const bytes = codes.replaceAll(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
        switch (name) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${name} isn't defined.`);
      });
      const charBuf = [">"];
      for (let i = 0, ii = bytes.length; i < ii; i += 2) {
        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
          charBuf.push(String.fromCharCode(code));
        } else {
          charBuf.push("&#x" + (0x10000 + code).toString(16).substring(1) + ";");
        }
      }
      return charBuf.join("");
    });
  }
  _getSequence(entry) {
    const name = entry.nodeName;
    if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
      return null;
    }
    return entry.childNodes.filter(node => node.nodeName === "rdf:li");
  }
  _parseArray(entry) {
    if (!entry.hasChildNodes()) {
      return;
    }
    const [seqNode] = entry.childNodes;
    const sequence = this._getSequence(seqNode) || [];
    this._metadataMap.set(entry.nodeName, sequence.map(node => node.textContent.trim()));
  }
  _parse(xmlDocument) {
    let rdf = xmlDocument.documentElement;
    if (rdf.nodeName !== "rdf:rdf") {
      rdf = rdf.firstChild;
      while (rdf && rdf.nodeName !== "rdf:rdf") {
        rdf = rdf.nextSibling;
      }
    }
    if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
      return;
    }
    for (const desc of rdf.childNodes) {
      if (desc.nodeName !== "rdf:description") {
        continue;
      }
      for (const entry of desc.childNodes) {
        const name = entry.nodeName;
        switch (name) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(entry);
            continue;
        }
        this._metadataMap.set(name, entry.textContent.trim());
      }
    }
  }
  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }
}
exports.MetadataParser = MetadataParser;

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;
var _core_utils = __w_pdfjs_require__(3);
const XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};
exports.XMLParserErrorCode = XMLParserErrorCode;
function isWhitespace(s, index) {
  const ch = s[index];
  return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
}
function isWhitespaceString(s) {
  for (let i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }
  return true;
}
class XMLParserBase {
  _resolveEntities(s) {
    return s.replaceAll(/&([^;]+);/g, (all, entity) => {
      if (entity.substring(0, 2) === "#x") {
        return String.fromCodePoint(parseInt(entity.substring(2), 16));
      } else if (entity.substring(0, 1) === "#") {
        return String.fromCodePoint(parseInt(entity.substring(1), 10));
      }
      switch (entity) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(entity);
    });
  }
  _parseContent(s, start) {
    const attributes = [];
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
      skipWs();
      let attrName = "",
        attrValue = "";
      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
        attrName += s[pos];
        ++pos;
      }
      skipWs();
      if (s[pos] !== "=") {
        return null;
      }
      ++pos;
      skipWs();
      const attrEndChar = s[pos];
      if (attrEndChar !== '"' && attrEndChar !== "'") {
        return null;
      }
      const attrEndIndex = s.indexOf(attrEndChar, ++pos);
      if (attrEndIndex < 0) {
        return null;
      }
      attrValue = s.substring(pos, attrEndIndex);
      attributes.push({
        name: attrName,
        value: this._resolveEntities(attrValue)
      });
      pos = attrEndIndex + 1;
      skipWs();
    }
    return {
      name,
      attributes,
      parsed: pos - start
    };
  }
  _parseProcessingInstruction(s, start) {
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    const attrStart = pos;
    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
      ++pos;
    }
    const value = s.substring(attrStart, pos);
    return {
      name,
      value,
      parsed: pos - start
    };
  }
  parseXml(s) {
    let i = 0;
    while (i < s.length) {
      const ch = s[i];
      let j = i;
      if (ch === "<") {
        ++j;
        const ch2 = s[j];
        let q;
        switch (ch2) {
          case "/":
            ++j;
            q = s.indexOf(">", j);
            if (q < 0) {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onEndElement(s.substring(j, q));
            j = q + 1;
            break;
          case "?":
            ++j;
            const pi = this._parseProcessingInstruction(s, j);
            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
              return;
            }
            this.onPi(pi.name, pi.value);
            j += pi.parsed + 2;
            break;
          case "!":
            if (s.substring(j + 1, j + 3) === "--") {
              q = s.indexOf("-->", j + 3);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedComment);
                return;
              }
              this.onComment(s.substring(j + 3, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
              q = s.indexOf("]]>", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedCdat);
                return;
              }
              this.onCdata(s.substring(j + 8, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
              const q2 = s.indexOf("[", j + 8);
              let complexDoctype = false;
              q = s.indexOf(">", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                return;
              }
              if (q2 > 0 && q > q2) {
                q = s.indexOf("]>", j + 8);
                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }
                complexDoctype = true;
              }
              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
              this.onDoctype(doctypeContent);
              j = q + (complexDoctype ? 2 : 1);
            } else {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            break;
          default:
            const content = this._parseContent(s, j);
            if (content === null) {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            let isClosed = false;
            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
              isClosed = true;
            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onBeginElement(content.name, content.attributes, isClosed);
            j += content.parsed + (isClosed ? 2 : 1);
            break;
        }
      } else {
        while (j < s.length && s[j] !== "<") {
          j++;
        }
        const text = s.substring(i, j);
        this.onText(this._resolveEntities(text));
      }
      i = j;
    }
  }
  onResolveEntity(name) {
    return `&${name};`;
  }
  onPi(name, value) {}
  onComment(text) {}
  onCdata(text) {}
  onDoctype(doctypeContent) {}
  onText(text) {}
  onBeginElement(name, attributes, isEmpty) {}
  onEndElement(name) {}
  onError(code) {}
}
exports.XMLParserBase = XMLParserBase;
class SimpleDOMNode {
  constructor(nodeName, nodeValue) {
    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, "parentNode", {
      value: null,
      writable: true
    });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const childNodes = this.parentNode.childNodes;
    if (!childNodes) {
      return undefined;
    }
    const index = childNodes.indexOf(this);
    if (index === -1) {
      return undefined;
    }
    return childNodes[index + 1];
  }
  get textContent() {
    if (!this.childNodes) {
      return this.nodeValue || "";
    }
    return this.childNodes.map(function (child) {
      return child.textContent;
    }).join("");
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(paths, pos) {
    if (pos >= paths.length) {
      return this;
    }
    const component = paths[pos];
    if (component.name.startsWith("#") && pos < paths.length - 1) {
      return this.searchNode(paths, pos + 1);
    }
    const stack = [];
    let node = this;
    while (true) {
      if (component.name === node.nodeName) {
        if (component.pos === 0) {
          const res = node.searchNode(paths, pos + 1);
          if (res !== null) {
            return res;
          }
        } else if (stack.length === 0) {
          return null;
        } else {
          const [parent] = stack.pop();
          let siblingPos = 0;
          for (const child of parent.childNodes) {
            if (component.name === child.nodeName) {
              if (siblingPos === component.pos) {
                return child.searchNode(paths, pos + 1);
              }
              siblingPos++;
            }
          }
          return node.searchNode(paths, pos + 1);
        }
      }
      if (node.childNodes?.length > 0) {
        stack.push([node, 0]);
        node = node.childNodes[0];
      } else if (stack.length === 0) {
        return null;
      } else {
        while (stack.length !== 0) {
          const [parent, currentPos] = stack.pop();
          const newPos = currentPos + 1;
          if (newPos < parent.childNodes.length) {
            stack.push([parent, newPos]);
            node = parent.childNodes[newPos];
            break;
          }
        }
        if (stack.length === 0) {
          return null;
        }
      }
    }
  }
  dump(buffer) {
    if (this.nodeName === "#text") {
      buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue));
      return;
    }
    buffer.push(`<${this.nodeName}`);
    if (this.attributes) {
      for (const attribute of this.attributes) {
        buffer.push(` ${attribute.name}="${(0, _core_utils.encodeToXmlString)(attribute.value)}"`);
      }
    }
    if (this.hasChildNodes()) {
      buffer.push(">");
      for (const child of this.childNodes) {
        child.dump(buffer);
      }
      buffer.push(`</${this.nodeName}>`);
    } else if (this.nodeValue) {
      buffer.push(`>${(0, _core_utils.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
    } else {
      buffer.push("/>");
    }
  }
}
exports.SimpleDOMNode = SimpleDOMNode;
class SimpleXMLParser extends XMLParserBase {
  constructor({
    hasAttributes = false,
    lowerCaseName = false
  }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = XMLParserErrorCode.NoError;
    this._hasAttributes = hasAttributes;
    this._lowerCaseName = lowerCaseName;
  }
  parseFromString(data) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = XMLParserErrorCode.NoError;
    this.parseXml(data);
    if (this._errorCode !== XMLParserErrorCode.NoError) {
      return undefined;
    }
    const [documentElement] = this._currentFragment;
    if (!documentElement) {
      return undefined;
    }
    return {
      documentElement
    };
  }
  onText(text) {
    if (isWhitespaceString(text)) {
      return;
    }
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onCdata(text) {
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onBeginElement(name, attributes, isEmpty) {
    if (this._lowerCaseName) {
      name = name.toLowerCase();
    }
    const node = new SimpleDOMNode(name);
    node.childNodes = [];
    if (this._hasAttributes) {
      node.attributes = attributes;
    }
    this._currentFragment.push(node);
    if (isEmpty) {
      return;
    }
    this._stack.push(this._currentFragment);
    this._currentFragment = node.childNodes;
  }
  onEndElement(name) {
    this._currentFragment = this._stack.pop() || [];
    const lastElement = this._currentFragment.at(-1);
    if (!lastElement) {
      return null;
    }
    for (const childNode of lastElement.childNodes) {
      childNode.parentNode = lastElement;
    }
    return lastElement;
  }
  onError(code) {
    this._errorCode = code;
  }
}
exports.SimpleXMLParser = SimpleXMLParser;

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StructTreeRoot = exports.StructTreePage = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _name_number_tree = __w_pdfjs_require__(67);
var _writer = __w_pdfjs_require__(73);
const MAX_DEPTH = 40;
const StructElementType = {
  PAGE_CONTENT: 1,
  STREAM_CONTENT: 2,
  OBJECT: 3,
  ANNOTATION: 4,
  ELEMENT: 5
};
class StructTreeRoot {
  constructor(rootDict, rootRef) {
    this.dict = rootDict;
    this.ref = rootRef instanceof _primitives.Ref ? rootRef : null;
    this.roleMap = new Map();
    this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #addIdToPage(pageRef, id, type) {
    if (!(pageRef instanceof _primitives.Ref) || id < 0) {
      return;
    }
    this.structParentIds ||= new _primitives.RefSetCache();
    let ids = this.structParentIds.get(pageRef);
    if (!ids) {
      ids = [];
      this.structParentIds.put(pageRef, ids);
    }
    ids.push([id, type]);
  }
  addAnnotationIdToPage(pageRef, id) {
    this.#addIdToPage(pageRef, id, StructElementType.ANNOTATION);
  }
  readRoleMap() {
    const roleMapDict = this.dict.get("RoleMap");
    if (!(roleMapDict instanceof _primitives.Dict)) {
      return;
    }
    roleMapDict.forEach((key, value) => {
      if (!(value instanceof _primitives.Name)) {
        return;
      }
      this.roleMap.set(key, value.name);
    });
  }
  static async canCreateStructureTree({
    catalogRef,
    pdfManager,
    newAnnotationsByPage
  }) {
    if (!(catalogRef instanceof _primitives.Ref)) {
      (0, _util.warn)("Cannot save the struct tree: no catalog reference.");
      return false;
    }
    let nextKey = 0;
    let hasNothingToUpdate = true;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      if (!(pageRef instanceof _primitives.Ref)) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
        hasNothingToUpdate = true;
        break;
      }
      for (const element of elements) {
        if (element.accessibilityData?.type) {
          element.parentTreeId = nextKey++;
          hasNothingToUpdate = false;
        }
      }
    }
    if (hasNothingToUpdate) {
      for (const elements of newAnnotationsByPage.values()) {
        for (const element of elements) {
          delete element.parentTreeId;
        }
      }
      return false;
    }
    return true;
  }
  static async createStructureTree({
    newAnnotationsByPage,
    xref,
    catalogRef,
    pdfManager,
    newRefs
  }) {
    const root = pdfManager.catalog.cloneDict();
    const structTreeRootRef = xref.getNewTemporaryRef();
    root.set("StructTreeRoot", structTreeRootRef);
    const buffer = [];
    await (0, _writer.writeObject)(catalogRef, root, buffer, xref);
    newRefs.push({
      ref: catalogRef,
      data: buffer.join("")
    });
    const structTreeRoot = new _primitives.Dict(xref);
    structTreeRoot.set("Type", _primitives.Name.get("StructTreeRoot"));
    const parentTreeRef = xref.getNewTemporaryRef();
    structTreeRoot.set("ParentTree", parentTreeRef);
    const kids = [];
    structTreeRoot.set("K", kids);
    const parentTree = new _primitives.Dict(xref);
    const nums = [];
    parentTree.set("Nums", nums);
    const nextKey = await this.#writeKids({
      newAnnotationsByPage,
      structTreeRootRef,
      kids,
      nums,
      xref,
      pdfManager,
      newRefs,
      buffer
    });
    structTreeRoot.set("ParentTreeNextKey", nextKey);
    buffer.length = 0;
    await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
    newRefs.push({
      ref: parentTreeRef,
      data: buffer.join("")
    });
    buffer.length = 0;
    await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
    newRefs.push({
      ref: structTreeRootRef,
      data: buffer.join("")
    });
  }
  async canUpdateStructTree({
    pdfManager,
    newAnnotationsByPage
  }) {
    if (!this.ref) {
      (0, _util.warn)("Cannot update the struct tree: no root reference.");
      return false;
    }
    let nextKey = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(nextKey) || nextKey < 0) {
      (0, _util.warn)("Cannot update the struct tree: invalid next key.");
      return false;
    }
    const parentTree = this.dict.get("ParentTree");
    if (!(parentTree instanceof _primitives.Dict)) {
      (0, _util.warn)("Cannot update the struct tree: ParentTree isn't a dict.");
      return false;
    }
    const nums = parentTree.get("Nums");
    if (!Array.isArray(nums)) {
      (0, _util.warn)("Cannot update the struct tree: nums isn't an array.");
      return false;
    }
    const {
      numPages
    } = pdfManager.catalog;
    for (const pageIndex of newAnnotationsByPage.keys()) {
      const {
        pageDict,
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      if (!(pageRef instanceof _primitives.Ref)) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no ref.`);
        return false;
      }
      const id = pageDict.get("StructParents");
      if (!Number.isInteger(id) || id < 0 || id >= numPages) {
        (0, _util.warn)(`Cannot save the struct tree: page ${pageIndex} has no id.`);
        return false;
      }
    }
    let hasNothingToUpdate = true;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        pageDict
      } = await pdfManager.getPage(pageIndex);
      StructTreeRoot.#collectParents({
        elements,
        xref: this.dict.xref,
        pageDict,
        parentTree
      });
      for (const element of elements) {
        if (element.accessibilityData?.type) {
          element.parentTreeId = nextKey++;
          hasNothingToUpdate = false;
        }
      }
    }
    if (hasNothingToUpdate) {
      for (const elements of newAnnotationsByPage.values()) {
        for (const element of elements) {
          delete element.parentTreeId;
          delete element.structTreeParent;
        }
      }
      return false;
    }
    return true;
  }
  async updateStructureTree({
    newAnnotationsByPage,
    pdfManager,
    newRefs
  }) {
    const xref = this.dict.xref;
    const structTreeRoot = this.dict.clone();
    const structTreeRootRef = this.ref;
    let parentTreeRef = structTreeRoot.getRaw("ParentTree");
    let parentTree;
    if (parentTreeRef instanceof _primitives.Ref) {
      parentTree = xref.fetch(parentTreeRef);
    } else {
      parentTree = parentTreeRef;
      parentTreeRef = xref.getNewTemporaryRef();
      structTreeRoot.set("ParentTree", parentTreeRef);
    }
    parentTree = parentTree.clone();
    let nums = parentTree.getRaw("Nums");
    let numsRef = null;
    if (nums instanceof _primitives.Ref) {
      numsRef = nums;
      nums = xref.fetch(numsRef);
    }
    nums = nums.slice();
    if (!numsRef) {
      parentTree.set("Nums", nums);
    }
    let kids = structTreeRoot.getRaw("K");
    let kidsRef = null;
    if (kids instanceof _primitives.Ref) {
      kidsRef = kids;
      kids = xref.fetch(kidsRef);
    } else {
      kidsRef = xref.getNewTemporaryRef();
      structTreeRoot.set("K", kidsRef);
    }
    kids = Array.isArray(kids) ? kids.slice() : [kids];
    const buffer = [];
    const newNextkey = await StructTreeRoot.#writeKids({
      newAnnotationsByPage,
      structTreeRootRef,
      kids,
      nums,
      xref,
      pdfManager,
      newRefs,
      buffer
    });
    structTreeRoot.set("ParentTreeNextKey", newNextkey);
    buffer.length = 0;
    await (0, _writer.writeObject)(kidsRef, kids, buffer, xref);
    newRefs.push({
      ref: kidsRef,
      data: buffer.join("")
    });
    if (numsRef) {
      buffer.length = 0;
      await (0, _writer.writeObject)(numsRef, nums, buffer, xref);
      newRefs.push({
        ref: numsRef,
        data: buffer.join("")
      });
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentTreeRef, parentTree, buffer, xref);
    newRefs.push({
      ref: parentTreeRef,
      data: buffer.join("")
    });
    buffer.length = 0;
    await (0, _writer.writeObject)(structTreeRootRef, structTreeRoot, buffer, xref);
    newRefs.push({
      ref: structTreeRootRef,
      data: buffer.join("")
    });
  }
  static async #writeKids({
    newAnnotationsByPage,
    structTreeRootRef,
    kids,
    nums,
    xref,
    pdfManager,
    newRefs,
    buffer
  }) {
    const objr = _primitives.Name.get("OBJR");
    let nextKey = -Infinity;
    for (const [pageIndex, elements] of newAnnotationsByPage) {
      const {
        ref: pageRef
      } = await pdfManager.getPage(pageIndex);
      for (const {
        accessibilityData: {
          type,
          title,
          lang,
          alt,
          expanded,
          actualText
        },
        ref,
        parentTreeId,
        structTreeParent
      } of elements) {
        nextKey = Math.max(nextKey, parentTreeId);
        const tagRef = xref.getNewTemporaryRef();
        const tagDict = new _primitives.Dict(xref);
        tagDict.set("S", _primitives.Name.get(type));
        if (title) {
          tagDict.set("T", title);
        }
        if (lang) {
          tagDict.set("Lang", lang);
        }
        if (alt) {
          tagDict.set("Alt", alt);
        }
        if (expanded) {
          tagDict.set("E", expanded);
        }
        if (actualText) {
          tagDict.set("ActualText", actualText);
        }
        if (structTreeParent) {
          await this.#updateParentTag({
            structTreeParent,
            tagDict,
            newTagRef: tagRef,
            fallbackRef: structTreeRootRef,
            xref,
            newRefs,
            buffer
          });
        } else {
          tagDict.set("P", structTreeRootRef);
        }
        const objDict = new _primitives.Dict(xref);
        tagDict.set("K", objDict);
        objDict.set("Type", objr);
        objDict.set("Pg", pageRef);
        objDict.set("Obj", ref);
        buffer.length = 0;
        await (0, _writer.writeObject)(tagRef, tagDict, buffer, xref);
        newRefs.push({
          ref: tagRef,
          data: buffer.join("")
        });
        nums.push(parentTreeId, tagRef);
        kids.push(tagRef);
      }
    }
    return nextKey + 1;
  }
  static #collectParents({
    elements,
    xref,
    pageDict,
    parentTree
  }) {
    const idToElement = new Map();
    for (const element of elements) {
      if (element.structTreeParentId) {
        const id = parseInt(element.structTreeParentId.split("_mc")[1], 10);
        idToElement.set(id, element);
      }
    }
    const id = pageDict.get("StructParents");
    const numberTree = new _name_number_tree.NumberTree(parentTree, xref);
    const parentArray = numberTree.get(id);
    if (!Array.isArray(parentArray)) {
      return;
    }
    const updateElement = (kid, pageKid, kidRef) => {
      const element = idToElement.get(kid);
      if (element) {
        const parentRef = pageKid.getRaw("P");
        const parentDict = xref.fetchIfRef(parentRef);
        if (parentRef instanceof _primitives.Ref && parentDict instanceof _primitives.Dict) {
          element.structTreeParent = {
            ref: kidRef,
            dict: pageKid
          };
        }
        return true;
      }
      return false;
    };
    for (const kidRef of parentArray) {
      if (!(kidRef instanceof _primitives.Ref)) {
        continue;
      }
      const pageKid = xref.fetch(kidRef);
      const k = pageKid.get("K");
      if (Number.isInteger(k)) {
        updateElement(k, pageKid, kidRef);
        continue;
      }
      if (!Array.isArray(k)) {
        continue;
      }
      for (let kid of k) {
        kid = xref.fetchIfRef(kid);
        if (Number.isInteger(kid) && updateElement(kid, pageKid, kidRef)) {
          break;
        }
      }
    }
  }
  static async #updateParentTag({
    structTreeParent: {
      ref,
      dict
    },
    tagDict,
    newTagRef,
    fallbackRef,
    xref,
    newRefs,
    buffer
  }) {
    const parentRef = dict.getRaw("P");
    let parentDict = xref.fetchIfRef(parentRef);
    tagDict.set("P", parentRef);
    let saveParentDict = false;
    let parentKids;
    let parentKidsRef = parentDict.getRaw("K");
    if (!(parentKidsRef instanceof _primitives.Ref)) {
      parentKids = parentKidsRef;
      parentKidsRef = xref.getNewTemporaryRef();
      parentDict = parentDict.clone();
      parentDict.set("K", parentKidsRef);
      saveParentDict = true;
    } else {
      parentKids = xref.fetch(parentKidsRef);
    }
    if (Array.isArray(parentKids)) {
      const index = parentKids.indexOf(ref);
      if (index >= 0) {
        parentKids = parentKids.slice();
        parentKids.splice(index + 1, 0, newTagRef);
      } else {
        (0, _util.warn)("Cannot update the struct tree: parent kid not found.");
        tagDict.set("P", fallbackRef);
        return;
      }
    } else if (parentKids instanceof _primitives.Dict) {
      parentKids = [parentKidsRef, newTagRef];
      parentKidsRef = xref.getNewTemporaryRef();
      parentDict.set("K", parentKidsRef);
      saveParentDict = true;
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentKidsRef, parentKids, buffer, xref);
    newRefs.push({
      ref: parentKidsRef,
      data: buffer.join("")
    });
    if (!saveParentDict) {
      return;
    }
    buffer.length = 0;
    await (0, _writer.writeObject)(parentRef, parentDict, buffer, xref);
    newRefs.push({
      ref: parentRef,
      data: buffer.join("")
    });
  }
}
exports.StructTreeRoot = StructTreeRoot;
class StructElementNode {
  constructor(tree, dict) {
    this.tree = tree;
    this.dict = dict;
    this.kids = [];
    this.parseKids();
  }
  get role() {
    const nameObj = this.dict.get("S");
    const name = nameObj instanceof _primitives.Name ? nameObj.name : "";
    const {
      root
    } = this.tree;
    if (root.roleMap.has(name)) {
      return root.roleMap.get(name);
    }
    return name;
  }
  parseKids() {
    let pageObjId = null;
    const objRef = this.dict.getRaw("Pg");
    if (objRef instanceof _primitives.Ref) {
      pageObjId = objRef.toString();
    }
    const kids = this.dict.get("K");
    if (Array.isArray(kids)) {
      for (const kid of kids) {
        const element = this.parseKid(pageObjId, kid);
        if (element) {
          this.kids.push(element);
        }
      }
    } else {
      const element = this.parseKid(pageObjId, kids);
      if (element) {
        this.kids.push(element);
      }
    }
  }
  parseKid(pageObjId, kid) {
    if (Number.isInteger(kid)) {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      return new StructElement({
        type: StructElementType.PAGE_CONTENT,
        mcid: kid,
        pageObjId
      });
    }
    let kidDict = null;
    if (kid instanceof _primitives.Ref) {
      kidDict = this.dict.xref.fetch(kid);
    } else if (kid instanceof _primitives.Dict) {
      kidDict = kid;
    }
    if (!kidDict) {
      return null;
    }
    const pageRef = kidDict.getRaw("Pg");
    if (pageRef instanceof _primitives.Ref) {
      pageObjId = pageRef.toString();
    }
    const type = kidDict.get("Type") instanceof _primitives.Name ? kidDict.get("Type").name : null;
    if (type === "MCR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      const kidRef = kidDict.getRaw("Stm");
      return new StructElement({
        type: StructElementType.STREAM_CONTENT,
        refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
        pageObjId,
        mcid: kidDict.get("MCID")
      });
    }
    if (type === "OBJR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      const kidRef = kidDict.getRaw("Obj");
      return new StructElement({
        type: StructElementType.OBJECT,
        refObjId: kidRef instanceof _primitives.Ref ? kidRef.toString() : null,
        pageObjId
      });
    }
    return new StructElement({
      type: StructElementType.ELEMENT,
      dict: kidDict
    });
  }
}
class StructElement {
  constructor({
    type,
    dict = null,
    mcid = null,
    pageObjId = null,
    refObjId = null
  }) {
    this.type = type;
    this.dict = dict;
    this.mcid = mcid;
    this.pageObjId = pageObjId;
    this.refObjId = refObjId;
    this.parentNode = null;
  }
}
class StructTreePage {
  constructor(structTreeRoot, pageDict) {
    this.root = structTreeRoot;
    this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
    this.pageDict = pageDict;
    this.nodes = [];
  }
  parse(pageRef) {
    if (!this.root || !this.rootDict) {
      return;
    }
    const parentTree = this.rootDict.get("ParentTree");
    if (!parentTree) {
      return;
    }
    const id = this.pageDict.get("StructParents");
    const ids = pageRef instanceof _primitives.Ref && this.root.structParentIds?.get(pageRef);
    if (!Number.isInteger(id) && !ids) {
      return;
    }
    const map = new Map();
    const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref);
    if (Number.isInteger(id)) {
      const parentArray = numberTree.get(id);
      if (Array.isArray(parentArray)) {
        for (const ref of parentArray) {
          if (ref instanceof _primitives.Ref) {
            this.addNode(this.rootDict.xref.fetch(ref), map);
          }
        }
      }
    }
    if (!ids) {
      return;
    }
    for (const [elemId, type] of ids) {
      const obj = numberTree.get(elemId);
      if (obj) {
        const elem = this.addNode(this.rootDict.xref.fetchIfRef(obj), map);
        if (elem?.kids?.length === 1 && elem.kids[0].type === StructElementType.OBJECT) {
          elem.kids[0].type = type;
        }
      }
    }
  }
  addNode(dict, map, level = 0) {
    if (level > MAX_DEPTH) {
      (0, _util.warn)("StructTree MAX_DEPTH reached.");
      return null;
    }
    if (map.has(dict)) {
      return map.get(dict);
    }
    const element = new StructElementNode(this, dict);
    map.set(dict, element);
    const parent = dict.get("P");
    if (!parent || (0, _primitives.isName)(parent.get("Type"), "StructTreeRoot")) {
      if (!this.addTopLevelNode(dict, element)) {
        map.delete(dict);
      }
      return element;
    }
    const parentNode = this.addNode(parent, map, level + 1);
    if (!parentNode) {
      return element;
    }
    let save = false;
    for (const kid of parentNode.kids) {
      if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
        kid.parentNode = element;
        save = true;
      }
    }
    if (!save) {
      map.delete(dict);
    }
    return element;
  }
  addTopLevelNode(dict, element) {
    const obj = this.rootDict.get("K");
    if (!obj) {
      return false;
    }
    if (obj instanceof _primitives.Dict) {
      if (obj.objId !== dict.objId) {
        return false;
      }
      this.nodes[0] = element;
      return true;
    }
    if (!Array.isArray(obj)) {
      return true;
    }
    let save = false;
    for (let i = 0; i < obj.length; i++) {
      const kidRef = obj[i];
      if (kidRef?.toString() === dict.objId) {
        this.nodes[i] = element;
        save = true;
      }
    }
    return save;
  }
  get serializable() {
    function nodeToSerializable(node, parent, level = 0) {
      if (level > MAX_DEPTH) {
        (0, _util.warn)("StructTree too deep to be fully serialized.");
        return;
      }
      const obj = Object.create(null);
      obj.role = node.role;
      obj.children = [];
      parent.children.push(obj);
      const alt = node.dict.get("Alt");
      if (typeof alt === "string") {
        obj.alt = (0, _util.stringToPDFString)(alt);
      }
      const lang = node.dict.get("Lang");
      if (typeof lang === "string") {
        obj.lang = (0, _util.stringToPDFString)(lang);
      }
      for (const kid of node.kids) {
        const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;
        if (kidElement) {
          nodeToSerializable(kidElement, obj, level + 1);
          continue;
        } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
          obj.children.push({
            type: "content",
            id: `p${kid.pageObjId}_mc${kid.mcid}`
          });
        } else if (kid.type === StructElementType.OBJECT) {
          obj.children.push({
            type: "object",
            id: kid.refObjId
          });
        } else if (kid.type === StructElementType.ANNOTATION) {
          obj.children.push({
            type: "annotation",
            id: `${_util.AnnotationPrefix}${kid.refObjId}`
          });
        }
      }
    }
    const root = Object.create(null);
    root.children = [];
    root.role = "Root";
    for (const child of this.nodes) {
      if (!child) {
        continue;
      }
      nodeToSerializable(child, root);
    }
    return root;
  }
}
exports.StructTreePage = StructTreePage;

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.incrementalUpdate = incrementalUpdate;
exports.writeDict = writeDict;
exports.writeObject = writeObject;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _core_utils = __w_pdfjs_require__(3);
var _xml_parser = __w_pdfjs_require__(71);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
async function writeObject(ref, obj, buffer, {
  encrypt = null
}) {
  const transform = encrypt?.createCipherTransform(ref.num, ref.gen);
  buffer.push(`${ref.num} ${ref.gen} obj\n`);
  if (obj instanceof _primitives.Dict) {
    await writeDict(obj, buffer, transform);
  } else if (obj instanceof _base_stream.BaseStream) {
    await writeStream(obj, buffer, transform);
  } else if (Array.isArray(obj)) {
    await writeArray(obj, buffer, transform);
  }
  buffer.push("\nendobj\n");
}
async function writeDict(dict, buffer, transform) {
  buffer.push("<<");
  for (const key of dict.getKeys()) {
    buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `);
    await writeValue(dict.getRaw(key), buffer, transform);
  }
  buffer.push(">>");
}
async function writeStream(stream, buffer, transform) {
  let string = stream.getString();
  const {
    dict
  } = stream;
  const [filter, params] = await Promise.all([dict.getAsync("Filter"), dict.getAsync("DecodeParms")]);
  const filterZero = Array.isArray(filter) ? await dict.xref.fetchIfRefAsync(filter[0]) : filter;
  const isFilterZeroFlateDecode = (0, _primitives.isName)(filterZero, "FlateDecode");
  const MIN_LENGTH_FOR_COMPRESSING = 256;
  if (typeof CompressionStream !== "undefined" && (string.length >= MIN_LENGTH_FOR_COMPRESSING || isFilterZeroFlateDecode)) {
    try {
      const byteArray = (0, _util.stringToBytes)(string);
      const cs = new CompressionStream("deflate");
      const writer = cs.writable.getWriter();
      writer.write(byteArray);
      writer.close();
      const buf = await new Response(cs.readable).arrayBuffer();
      string = (0, _util.bytesToString)(new Uint8Array(buf));
      let newFilter, newParams;
      if (!filter) {
        newFilter = _primitives.Name.get("FlateDecode");
      } else if (!isFilterZeroFlateDecode) {
        newFilter = Array.isArray(filter) ? [_primitives.Name.get("FlateDecode"), ...filter] : [_primitives.Name.get("FlateDecode"), filter];
        if (params) {
          newParams = Array.isArray(params) ? [null, ...params] : [null, params];
        }
      }
      if (newFilter) {
        dict.set("Filter", newFilter);
      }
      if (newParams) {
        dict.set("DecodeParms", newParams);
      }
    } catch (ex) {
      (0, _util.info)(`writeStream - cannot compress data: "${ex}".`);
    }
  }
  if (transform) {
    string = transform.encryptString(string);
  }
  dict.set("Length", string.length);
  await writeDict(dict, buffer, transform);
  buffer.push(" stream\n", string, "\nendstream");
}
async function writeArray(array, buffer, transform) {
  buffer.push("[");
  let first = true;
  for (const val of array) {
    if (!first) {
      buffer.push(" ");
    } else {
      first = false;
    }
    await writeValue(val, buffer, transform);
  }
  buffer.push("]");
}
async function writeValue(value, buffer, transform) {
  if (value instanceof _primitives.Name) {
    buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`);
  } else if (value instanceof _primitives.Ref) {
    buffer.push(`${value.num} ${value.gen} R`);
  } else if (Array.isArray(value)) {
    await writeArray(value, buffer, transform);
  } else if (typeof value === "string") {
    if (transform) {
      value = transform.encryptString(value);
    }
    buffer.push(`(${(0, _core_utils.escapeString)(value)})`);
  } else if (typeof value === "number") {
    buffer.push((0, _core_utils.numberToString)(value));
  } else if (typeof value === "boolean") {
    buffer.push(value.toString());
  } else if (value instanceof _primitives.Dict) {
    await writeDict(value, buffer, transform);
  } else if (value instanceof _base_stream.BaseStream) {
    await writeStream(value, buffer, transform);
  } else if (value === null) {
    buffer.push("null");
  } else {
    (0, _util.warn)(`Unhandled value in writer: ${typeof value}, please file a bug.`);
  }
}
function writeInt(number, size, offset, buffer) {
  for (let i = size + offset - 1; i > offset - 1; i--) {
    buffer[i] = number & 0xff;
    number >>= 8;
  }
  return offset + size;
}
function writeString(string, offset, buffer) {
  for (let i = 0, len = string.length; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i) & 0xff;
  }
}
function computeMD5(filesize, xrefInfo) {
  const time = Math.floor(Date.now() / 1000);
  const filename = xrefInfo.filename || "";
  const md5Buffer = [time.toString(), filename, filesize.toString()];
  let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);
  for (const value of Object.values(xrefInfo.info)) {
    md5Buffer.push(value);
    md5BufferLen += value.length;
  }
  const array = new Uint8Array(md5BufferLen);
  let offset = 0;
  for (const str of md5Buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
}
function writeXFADataForAcroform(str, newRefs) {
  const xml = new _xml_parser.SimpleXMLParser({
    hasAttributes: true
  }).parseFromString(str);
  for (const {
    xfa
  } of newRefs) {
    if (!xfa) {
      continue;
    }
    const {
      path,
      value
    } = xfa;
    if (!path) {
      continue;
    }
    const nodePath = (0, _core_utils.parseXFAPath)(path);
    let node = xml.documentElement.searchNode(nodePath, 0);
    if (!node && nodePath.length > 1) {
      node = xml.documentElement.searchNode([nodePath.at(-1)], 0);
    }
    if (node) {
      node.childNodes = Array.isArray(value) ? value.map(val => new _xml_parser.SimpleDOMNode("value", val)) : [new _xml_parser.SimpleDOMNode("#text", value)];
    } else {
      (0, _util.warn)(`Node not found for path: ${path}`);
    }
  }
  const buffer = [];
  xml.documentElement.dump(buffer);
  return buffer.join("");
}
async function updateAcroform({
  xref,
  acroForm,
  acroFormRef,
  hasXfa,
  hasXfaDatasetsEntry,
  xfaDatasetsRef,
  needAppearances,
  newRefs
}) {
  if (hasXfa && !hasXfaDatasetsEntry && !xfaDatasetsRef) {
    (0, _util.warn)("XFA - Cannot save it");
  }
  if (!needAppearances && (!hasXfa || !xfaDatasetsRef || hasXfaDatasetsEntry)) {
    return;
  }
  const dict = acroForm.clone();
  if (hasXfa && !hasXfaDatasetsEntry) {
    const newXfa = acroForm.get("XFA").slice();
    newXfa.splice(2, 0, "datasets");
    newXfa.splice(3, 0, xfaDatasetsRef);
    dict.set("XFA", newXfa);
  }
  if (needAppearances) {
    dict.set("NeedAppearances", true);
  }
  const buffer = [];
  await writeObject(acroFormRef, dict, buffer, xref);
  newRefs.push({
    ref: acroFormRef,
    data: buffer.join("")
  });
}
function updateXFA({
  xfaData,
  xfaDatasetsRef,
  newRefs,
  xref
}) {
  if (xfaData === null) {
    const datasets = xref.fetchIfRef(xfaDatasetsRef);
    xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);
  }
  const encrypt = xref.encrypt;
  if (encrypt) {
    const transform = encrypt.createCipherTransform(xfaDatasetsRef.num, xfaDatasetsRef.gen);
    xfaData = transform.encryptString(xfaData);
  }
  const data = `${xfaDatasetsRef.num} ${xfaDatasetsRef.gen} obj\n` + `<< /Type /EmbeddedFile /Length ${xfaData.length}>>\nstream\n` + xfaData + "\nendstream\nendobj\n";
  newRefs.push({
    ref: xfaDatasetsRef,
    data
  });
}
async function incrementalUpdate({
  originalData,
  xrefInfo,
  newRefs,
  xref = null,
  hasXfa = false,
  xfaDatasetsRef = null,
  hasXfaDatasetsEntry = false,
  needAppearances,
  acroFormRef = null,
  acroForm = null,
  xfaData = null
}) {
  await updateAcroform({
    xref,
    acroForm,
    acroFormRef,
    hasXfa,
    hasXfaDatasetsEntry,
    xfaDatasetsRef,
    needAppearances,
    newRefs
  });
  if (hasXfa) {
    updateXFA({
      xfaData,
      xfaDatasetsRef,
      newRefs,
      xref
    });
  }
  const newXref = new _primitives.Dict(null);
  const refForXrefTable = xrefInfo.newRef;
  let buffer, baseOffset;
  const lastByte = originalData.at(-1);
  if (lastByte === 0x0a || lastByte === 0x0d) {
    buffer = [];
    baseOffset = originalData.length;
  } else {
    buffer = ["\n"];
    baseOffset = originalData.length + 1;
  }
  newXref.set("Size", refForXrefTable.num + 1);
  newXref.set("Prev", xrefInfo.startXRef);
  newXref.set("Type", _primitives.Name.get("XRef"));
  if (xrefInfo.rootRef !== null) {
    newXref.set("Root", xrefInfo.rootRef);
  }
  if (xrefInfo.infoRef !== null) {
    newXref.set("Info", xrefInfo.infoRef);
  }
  if (xrefInfo.encryptRef !== null) {
    newXref.set("Encrypt", xrefInfo.encryptRef);
  }
  newRefs.push({
    ref: refForXrefTable,
    data: ""
  });
  newRefs = newRefs.sort((a, b) => {
    return a.ref.num - b.ref.num;
  });
  const xrefTableData = [[0, 1, 0xffff]];
  const indexes = [0, 1];
  let maxOffset = 0;
  for (const {
    ref,
    data
  } of newRefs) {
    maxOffset = Math.max(maxOffset, baseOffset);
    xrefTableData.push([1, baseOffset, Math.min(ref.gen, 0xffff)]);
    baseOffset += data.length;
    indexes.push(ref.num, 1);
    buffer.push(data);
  }
  newXref.set("Index", indexes);
  if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
    const md5 = computeMD5(baseOffset, xrefInfo);
    newXref.set("ID", [xrefInfo.fileIds[0], md5]);
  }
  const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
  const sizes = [1, offsetSize, 2];
  const structSize = sizes[0] + sizes[1] + sizes[2];
  const tableLength = structSize * xrefTableData.length;
  newXref.set("W", sizes);
  newXref.set("Length", tableLength);
  buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj\n`);
  await writeDict(newXref, buffer, null);
  buffer.push(" stream\n");
  const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
  const footer = `\nendstream\nendobj\nstartxref\n${baseOffset}\n%%EOF\n`;
  const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
  array.set(originalData);
  let offset = originalData.length;
  for (const str of buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  for (const [type, objOffset, gen] of xrefTableData) {
    offset = writeInt(type, sizes[0], offset, array);
    offset = writeInt(objOffset, sizes[1], offset, array);
    offset = writeInt(gen, sizes[2], offset, array);
  }
  writeString(footer, offset, array);
  return array;
}

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calculateSHA256 = exports.calculateMD5 = exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = void 0;
exports.calculateSHA384 = calculateSHA384;
exports.calculateSHA512 = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _decrypt_stream = __w_pdfjs_require__(75);
class ARCFourCipher {
  constructor(key) {
    this.a = 0;
    this.b = 0;
    const s = new Uint8Array(256);
    const keyLength = key.length;
    for (let i = 0; i < 256; ++i) {
      s[i] = i;
    }
    for (let i = 0, j = 0; i < 256; ++i) {
      const tmp = s[i];
      j = j + tmp + key[i % keyLength] & 0xff;
      s[i] = s[j];
      s[j] = tmp;
    }
    this.s = s;
  }
  encryptBlock(data) {
    let a = this.a,
      b = this.b;
    const s = this.s;
    const n = data.length;
    const output = new Uint8Array(n);
    for (let i = 0; i < n; ++i) {
      a = a + 1 & 0xff;
      const tmp = s[a];
      b = b + tmp & 0xff;
      const tmp2 = s[b];
      s[a] = tmp2;
      s[b] = tmp;
      output[i] = data[i] ^ s[tmp + tmp2 & 0xff];
    }
    this.a = a;
    this.b = b;
    return output;
  }
  decryptBlock(data) {
    return this.encryptBlock(data);
  }
  encrypt(data) {
    return this.encryptBlock(data);
  }
}
exports.ARCFourCipher = ARCFourCipher;
const calculateMD5 = function calculateMD5Closure() {
  const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  function hash(data, offset, length) {
    let h0 = 1732584193,
      h1 = -271733879,
      h2 = -1732584194,
      h3 = 271733878;
    const paddedLength = length + 72 & ~63;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = length << 3 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    const w = new Int32Array(16);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }
      let a = h0,
        b = h1,
        c = h2,
        d = h3,
        f,
        g;
      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }
        const tmp = d,
          rotateArg = a + f + k[j] + w[g] | 0,
          rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }
    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
  }
  return hash;
}();
exports.calculateMD5 = calculateMD5;
class Word64 {
  constructor(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }
  and(word) {
    this.high &= word.high;
    this.low &= word.low;
  }
  xor(word) {
    this.high ^= word.high;
    this.low ^= word.low;
  }
  or(word) {
    this.high |= word.high;
    this.low |= word.low;
  }
  shiftRight(places) {
    if (places >= 32) {
      this.low = this.high >>> places - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> places | this.high << 32 - places;
      this.high = this.high >>> places | 0;
    }
  }
  shiftLeft(places) {
    if (places >= 32) {
      this.high = this.low << places - 32;
      this.low = 0;
    } else {
      this.high = this.high << places | this.low >>> 32 - places;
      this.low <<= places;
    }
  }
  rotateRight(places) {
    let low, high;
    if (places & 32) {
      high = this.low;
      low = this.high;
    } else {
      low = this.low;
      high = this.high;
    }
    places &= 31;
    this.low = low >>> places | high << 32 - places;
    this.high = high >>> places | low << 32 - places;
  }
  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }
  add(word) {
    const lowAdd = (this.low >>> 0) + (word.low >>> 0);
    let highAdd = (this.high >>> 0) + (word.high >>> 0);
    if (lowAdd > 0xffffffff) {
      highAdd += 1;
    }
    this.low = lowAdd | 0;
    this.high = highAdd | 0;
  }
  copyTo(bytes, offset) {
    bytes[offset] = this.high >>> 24 & 0xff;
    bytes[offset + 1] = this.high >> 16 & 0xff;
    bytes[offset + 2] = this.high >> 8 & 0xff;
    bytes[offset + 3] = this.high & 0xff;
    bytes[offset + 4] = this.low >>> 24 & 0xff;
    bytes[offset + 5] = this.low >> 16 & 0xff;
    bytes[offset + 6] = this.low >> 8 & 0xff;
    bytes[offset + 7] = this.low & 0xff;
  }
  assign(word) {
    this.high = word.high;
    this.low = word.low;
  }
}
const calculateSHA256 = function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }
  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }
  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }
  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }
  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }
  const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  function hash(data, offset, length) {
    let h0 = 0x6a09e667,
      h1 = 0xbb67ae85,
      h2 = 0x3c6ef372,
      h3 = 0xa54ff53a,
      h4 = 0x510e527f,
      h5 = 0x9b05688c,
      h6 = 0x1f83d9ab,
      h7 = 0x5be0cd19;
    const paddedLength = Math.ceil((length + 9) / 64) * 64;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Uint32Array(64);
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }
      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }
      let a = h0,
        b = h1,
        c = h2,
        d = h3,
        e = h4,
        f = h5,
        g = h6,
        h = h7,
        t1,
        t2;
      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }
    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
  }
  return hash;
}();
exports.calculateSHA256 = calculateSHA256;
const calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }
  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }
  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }
  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }
  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }
  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }
  const k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];
  function hash(data, offset, length, mode384 = false) {
    let h0, h1, h2, h3, h4, h5, h6, h7;
    if (!mode384) {
      h0 = new Word64(0x6a09e667, 0xf3bcc908);
      h1 = new Word64(0xbb67ae85, 0x84caa73b);
      h2 = new Word64(0x3c6ef372, 0xfe94f82b);
      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
      h4 = new Word64(0x510e527f, 0xade682d1);
      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
      h7 = new Word64(0x5be0cd19, 0x137e2179);
    } else {
      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
      h1 = new Word64(0x629a292a, 0x367cd507);
      h2 = new Word64(0x9159015a, 0x3070dd17);
      h3 = new Word64(0x152fecd8, 0xf70e5939);
      h4 = new Word64(0x67332667, 0xffc00b31);
      h5 = new Word64(0x8eb44a87, 0x68581511);
      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
      h7 = new Word64(0x47b5481d, 0xbefa4fa4);
    }
    const paddedLength = Math.ceil((length + 17) / 128) * 128;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 0x80;
    const n = paddedLength - 16;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Array(80);
    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }
    let a = new Word64(0, 0),
      b = new Word64(0, 0),
      c = new Word64(0, 0);
    let d = new Word64(0, 0),
      e = new Word64(0, 0),
      f = new Word64(0, 0);
    let g = new Word64(0, 0),
      h = new Word64(0, 0);
    const t1 = new Word64(0, 0),
      t2 = new Word64(0, 0);
    const tmp1 = new Word64(0, 0),
      tmp2 = new Word64(0, 0);
    let tmp3;
    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }
      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }
      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);
      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }
      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }
    let result;
    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }
    return result;
  }
  return hash;
}();
exports.calculateSHA512 = calculateSHA512;
function calculateSHA384(data, offset, length) {
  return calculateSHA512(data, offset, length, true);
}
class NullCipher {
  decryptBlock(data) {
    return data;
  }
  encrypt(data) {
    return data;
  }
}
class AESBaseCipher {
  constructor() {
    if (this.constructor === AESBaseCipher) {
      (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
    }
    this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
    this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
    this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
    this._mixCol = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      this._mixCol[i] = i < 128 ? i << 1 : i << 1 ^ 0x1b;
    }
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  _expandKey(cipherKey) {
    (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
  }
  _decrypt(input, key) {
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;
      for (let j = 0; j < 16; ++j) {
        state[j] = this._inv_s[state[j]];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
      for (let j = 0; j < 16; j += 4) {
        const s0 = this._mix[state[j]];
        const s1 = this._mix[state[j + 1]];
        const s2 = this._mix[state[j + 2]];
        const s3 = this._mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 0xff;
        state[j + 1] = t >> 16 & 0xff;
        state[j + 2] = t >> 8 & 0xff;
        state[j + 3] = t & 0xff;
      }
    }
    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;
    for (let j = 0; j < 16; ++j) {
      state[j] = this._inv_s[state[j]];
      state[j] ^= key[j];
    }
    return state;
  }
  _encrypt(input, key) {
    const s = this._s;
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }
    for (let i = 1; i < this._cyclesOfRepetition; i++) {
      for (let j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }
      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;
      for (let j = 0; j < 16; j += 4) {
        const s0 = state[j + 0];
        const s1 = state[j + 1];
        const s2 = state[j + 2];
        const s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }
    for (let j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }
    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    return state;
  }
  _decryptBlock2(data, finalize) {
    const sourceLength = data.length;
    let buffer = this.buffer,
      bufferLength = this.bufferPosition;
    const result = [];
    let iv = this.iv;
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      const plain = this._decrypt(buffer, this._key);
      for (let j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }
      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    let outputLength = 16 * result.length;
    if (finalize) {
      const lastBlock = result.at(-1);
      let psLen = lastBlock[15];
      if (psLen <= 16) {
        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }
        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
  decryptBlock(data, finalize, iv = null) {
    const sourceLength = data.length;
    const buffer = this.buffer;
    let bufferLength = this.bufferPosition;
    if (iv) {
      this.iv = iv;
    } else {
      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
        buffer[bufferLength] = data[i];
      }
      if (bufferLength < 16) {
        this.bufferLength = bufferLength;
        return new Uint8Array(0);
      }
      this.iv = buffer;
      data = data.subarray(16);
    }
    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(data, finalize);
  }
  encrypt(data, iv) {
    const sourceLength = data.length;
    let buffer = this.buffer,
      bufferLength = this.bufferPosition;
    const result = [];
    if (!iv) {
      iv = new Uint8Array(16);
    }
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      for (let j = 0; j < 16; ++j) {
        buffer[j] ^= iv[j];
      }
      const cipher = this._encrypt(buffer, this._key);
      iv = cipher;
      result.push(cipher);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    const outputLength = 16 * result.length;
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
}
class AES128Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 176;
    const s = this._s;
    const rcon = this._rcon;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    for (let j = 16, i = 1; j < b; ++i) {
      let t1 = result[j - 3];
      let t2 = result[j - 2];
      let t3 = result[j - 1];
      let t4 = result[j - 4];
      t1 = s[t1];
      t2 = s[t2];
      t3 = s[t3];
      t4 = s[t4];
      t1 ^= rcon[i];
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 16];
        j++;
        result[j] = t2 ^= result[j - 16];
        j++;
        result[j] = t3 ^= result[j - 16];
        j++;
        result[j] = t4 ^= result[j - 16];
        j++;
      }
    }
    return result;
  }
}
exports.AES128Cipher = AES128Cipher;
class AES256Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 240;
    const s = this._s;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    let r = 1;
    let t1, t2, t3, t4;
    for (let j = 32, i = 1; j < b; ++i) {
      if (j % 32 === 16) {
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
      } else if (j % 32 === 0) {
        t1 = result[j - 3];
        t2 = result[j - 2];
        t3 = result[j - 1];
        t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 ^= r;
        if ((r <<= 1) >= 256) {
          r = (r ^ 0x1b) & 0xff;
        }
      }
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 32];
        j++;
        result[j] = t2 ^= result[j - 32];
        j++;
        result[j] = t3 ^= result[j - 32];
        j++;
        result[j] = t4 ^= result[j - 32];
        j++;
      }
    }
    return result;
  }
}
exports.AES256Cipher = AES256Cipher;
class PDF17 {
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, ownerPassword);
  }
  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, userPassword);
  }
  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }
  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }
}
exports.PDF17 = PDF17;
class PDF20 {
  _hash(password, input, userBytes) {
    let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    let e = [0];
    let i = 0;
    while (i < 64 || e.at(-1) > i - 32) {
      const combinedLength = password.length + k.length + userBytes.length,
        combinedArray = new Uint8Array(combinedLength);
      let writeOffset = 0;
      combinedArray.set(password, writeOffset);
      writeOffset += password.length;
      combinedArray.set(k, writeOffset);
      writeOffset += k.length;
      combinedArray.set(userBytes, writeOffset);
      const k1 = new Uint8Array(combinedLength * 64);
      for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
        k1.set(combinedArray, pos);
      }
      const cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      const remainder = e.slice(0, 16).reduce((a, b) => a + b, 0) % 3;
      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }
      i++;
    }
    return k.subarray(0, 32);
  }
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = this._hash(password, hashData, userBytes);
    return (0, _util.isArrayEqual)(result, ownerPassword);
  }
  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = this._hash(password, hashData, []);
    return (0, _util.isArrayEqual)(result, userPassword);
  }
  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = this._hash(password, hashData, userBytes);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }
  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = this._hash(password, hashData, []);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }
}
exports.PDF20 = PDF20;
class CipherTransform {
  constructor(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }
  createStream(stream, length) {
    const cipher = new this.StreamCipherConstructor();
    return new _decrypt_stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
      return cipher.decryptBlock(data, finalize);
    });
  }
  decryptString(s) {
    const cipher = new this.StringCipherConstructor();
    let data = (0, _util.stringToBytes)(s);
    data = cipher.decryptBlock(data, true);
    return (0, _util.bytesToString)(data);
  }
  encryptString(s) {
    const cipher = new this.StringCipherConstructor();
    if (cipher instanceof AESBaseCipher) {
      const strLen = s.length;
      const pad = 16 - strLen % 16;
      s += String.fromCharCode(pad).repeat(pad);
      const iv = new Uint8Array(16);
      if (typeof crypto !== "undefined") {
        crypto.getRandomValues(iv);
      } else {
        for (let i = 0; i < 16; i++) {
          iv[i] = Math.floor(256 * Math.random());
        }
      }
      let data = (0, _util.stringToBytes)(s);
      data = cipher.encrypt(data, iv);
      const buf = new Uint8Array(16 + data.length);
      buf.set(iv);
      buf.set(data, 16);
      return (0, _util.bytesToString)(buf);
    }
    let data = (0, _util.stringToBytes)(s);
    data = cipher.encrypt(data);
    return (0, _util.bytesToString)(data);
  }
}
class CipherTransformFactory {
  static #defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);
  #createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      const passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }
    const pdfAlgorithm = revision === 6 ? new PDF20() : new PDF17();
    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }
    return null;
  }
  #prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    const hashDataSize = 40 + ownerPassword.length + fileId.length;
    const hashData = new Uint8Array(hashDataSize);
    let i = 0,
      j,
      n;
    if (password) {
      n = Math.min(32, password.length);
      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }
    j = 0;
    while (i < 32) {
      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];
    }
    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }
    hashData[i++] = flags & 0xff;
    hashData[i++] = flags >> 8 & 0xff;
    hashData[i++] = flags >> 16 & 0xff;
    hashData[i++] = flags >>> 24 & 0xff;
    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }
    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }
    const encryptionKey = hash.subarray(0, keyLengthInBytes);
    let cipher, checkData;
    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = CipherTransformFactory.#defaultPasswordBytes[i];
      }
      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      const derivedKey = new Uint8Array(n);
      for (j = 1; j <= 19; ++j) {
        for (let k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(CipherTransformFactory.#defaultPasswordBytes);
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }
    return encryptionKey;
  }
  #decodeUserPassword(password, ownerPassword, revision, keyLength) {
    const hashData = new Uint8Array(32);
    let i = 0;
    const n = Math.min(32, password.length);
    for (; i < n; ++i) {
      hashData[i] = password[i];
    }
    let j = 0;
    while (i < 32) {
      hashData[i++] = CipherTransformFactory.#defaultPasswordBytes[j++];
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }
    let cipher, userPassword;
    if (revision >= 3) {
      userPassword = ownerPassword;
      const derivedKey = new Uint8Array(keyLengthInBytes);
      for (j = 19; j >= 0; j--) {
        for (let k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }
    return userPassword;
  }
  #buildObjectKey(num, gen, encryptionKey, isAes = false) {
    const key = new Uint8Array(encryptionKey.length + 9);
    const n = encryptionKey.length;
    let i;
    for (i = 0; i < n; ++i) {
      key[i] = encryptionKey[i];
    }
    key[i++] = num & 0xff;
    key[i++] = num >> 8 & 0xff;
    key[i++] = num >> 16 & 0xff;
    key[i++] = gen & 0xff;
    key[i++] = gen >> 8 & 0xff;
    if (isAes) {
      key[i++] = 0x73;
      key[i++] = 0x41;
      key[i++] = 0x6c;
      key[i++] = 0x54;
    }
    const hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }
  #buildCipherConstructor(cf, name, num, gen, key) {
    if (!(name instanceof _primitives.Name)) {
      throw new _util.FormatError("Invalid crypt filter name.");
    }
    const self = this;
    const cryptFilter = cf.get(name.name);
    const cfm = cryptFilter?.get("CFM");
    if (!cfm || cfm.name === "None") {
      return function () {
        return new NullCipher();
      };
    }
    if (cfm.name === "V2") {
      return function () {
        return new ARCFourCipher(self.#buildObjectKey(num, gen, key, false));
      };
    }
    if (cfm.name === "AESV2") {
      return function () {
        return new AES128Cipher(self.#buildObjectKey(num, gen, key, true));
      };
    }
    if (cfm.name === "AESV3") {
      return function () {
        return new AES256Cipher(key);
      };
    }
    throw new _util.FormatError("Unknown crypto method");
  }
  constructor(dict, fileId, password) {
    const filter = dict.get("Filter");
    if (!(0, _primitives.isName)(filter, "Standard")) {
      throw new _util.FormatError("unknown encryption method");
    }
    this.filterName = filter.name;
    this.dict = dict;
    const algorithm = dict.get("V");
    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
      throw new _util.FormatError("unsupported encryption algorithm");
    }
    this.algorithm = algorithm;
    let keyLength = dict.get("Length");
    if (!keyLength) {
      if (algorithm <= 3) {
        keyLength = 40;
      } else {
        const cfDict = dict.get("CF");
        const streamCryptoName = dict.get("StmF");
        if (cfDict instanceof _primitives.Dict && streamCryptoName instanceof _primitives.Name) {
          cfDict.suppressEncryption = true;
          const handlerDict = cfDict.get(streamCryptoName.name);
          keyLength = handlerDict?.get("Length") || 128;
          if (keyLength < 40) {
            keyLength <<= 3;
          }
        }
      }
    }
    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
      throw new _util.FormatError("invalid key length");
    }
    const ownerBytes = (0, _util.stringToBytes)(dict.get("O")),
      userBytes = (0, _util.stringToBytes)(dict.get("U"));
    const ownerPassword = ownerBytes.subarray(0, 32);
    const userPassword = userBytes.subarray(0, 32);
    const flags = dict.get("P");
    const revision = dict.get("R");
    const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
    this.encryptMetadata = encryptMetadata;
    const fileIdBytes = (0, _util.stringToBytes)(fileId);
    let passwordBytes;
    if (password) {
      if (revision === 6) {
        try {
          password = (0, _util.utf8StringToString)(password);
        } catch {
          (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
      }
      passwordBytes = (0, _util.stringToBytes)(password);
    }
    let encryptionKey;
    if (algorithm !== 5) {
      encryptionKey = this.#prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    } else {
      const ownerValidationSalt = ownerBytes.subarray(32, 40);
      const ownerKeySalt = ownerBytes.subarray(40, 48);
      const uBytes = userBytes.subarray(0, 48);
      const userValidationSalt = userBytes.subarray(32, 40);
      const userKeySalt = userBytes.subarray(40, 48);
      const ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
      const userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
      const perms = (0, _util.stringToBytes)(dict.get("Perms"));
      encryptionKey = this.#createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
    }
    if (!encryptionKey && !password) {
      throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
    } else if (!encryptionKey && password) {
      const decodedPassword = this.#decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
      encryptionKey = this.#prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
    }
    if (!encryptionKey) {
      throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
    }
    this.encryptionKey = encryptionKey;
    if (algorithm >= 4) {
      const cf = dict.get("CF");
      if (cf instanceof _primitives.Dict) {
        cf.suppressEncryption = true;
      }
      this.cf = cf;
      this.stmf = dict.get("StmF") || _primitives.Name.get("Identity");
      this.strf = dict.get("StrF") || _primitives.Name.get("Identity");
      this.eff = dict.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(num, gen) {
    if (this.algorithm === 4 || this.algorithm === 5) {
      return new CipherTransform(this.#buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey), this.#buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey));
    }
    const key = this.#buildObjectKey(num, gen, this.encryptionKey, false);
    const cipherConstructor = function () {
      return new ARCFourCipher(key);
    };
    return new CipherTransform(cipherConstructor, cipherConstructor);
  }
}
exports.CipherTransformFactory = CipherTransformFactory;

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DecryptStream = void 0;
var _decode_stream = __w_pdfjs_require__(18);
const chunkSize = 512;
class DecryptStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, decrypt) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
  }
  readBlock() {
    let chunk;
    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }
    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(chunkSize);
    const hasMoreData = this.nextChunk?.length > 0;
    const decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    const bufferLength = this.bufferLength,
      newLength = bufferLength + chunk.length,
      buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  }
}
exports.DecryptStream = DecryptStream;

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ObjectLoader = void 0;
var _primitives = __w_pdfjs_require__(4);
var _base_stream = __w_pdfjs_require__(5);
var _core_utils = __w_pdfjs_require__(3);
var _util = __w_pdfjs_require__(2);
function mayHaveChildren(value) {
  return value instanceof _primitives.Ref || value instanceof _primitives.Dict || value instanceof _base_stream.BaseStream || Array.isArray(value);
}
function addChildren(node, nodesToVisit) {
  if (node instanceof _primitives.Dict) {
    node = node.getRawValues();
  } else if (node instanceof _base_stream.BaseStream) {
    node = node.dict.getRawValues();
  } else if (!Array.isArray(node)) {
    return;
  }
  for (const rawValue of node) {
    if (mayHaveChildren(rawValue)) {
      nodesToVisit.push(rawValue);
    }
  }
}
class ObjectLoader {
  constructor(dict, keys, xref) {
    this.dict = dict;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded) {
      return undefined;
    }
    const {
      keys,
      dict
    } = this;
    this.refSet = new _primitives.RefSet();
    const nodesToVisit = [];
    for (const key of keys) {
      const rawValue = dict.getRaw(key);
      if (rawValue !== undefined) {
        nodesToVisit.push(rawValue);
      }
    }
    return this._walk(nodesToVisit);
  }
  async _walk(nodesToVisit) {
    const nodesToRevisit = [];
    const pendingRequests = [];
    while (nodesToVisit.length) {
      let currentNode = nodesToVisit.pop();
      if (currentNode instanceof _primitives.Ref) {
        if (this.refSet.has(currentNode)) {
          continue;
        }
        try {
          this.refSet.put(currentNode);
          currentNode = this.xref.fetch(currentNode);
        } catch (ex) {
          if (!(ex instanceof _core_utils.MissingDataException)) {
            (0, _util.warn)(`ObjectLoader._walk - requesting all data: "${ex}".`);
            this.refSet = null;
            const {
              manager
            } = this.xref.stream;
            return manager.requestAllChunks();
          }
          nodesToRevisit.push(currentNode);
          pendingRequests.push({
            begin: ex.begin,
            end: ex.end
          });
        }
      }
      if (currentNode instanceof _base_stream.BaseStream) {
        const baseStreams = currentNode.getBaseStreams();
        if (baseStreams) {
          let foundMissingData = false;
          for (const stream of baseStreams) {
            if (stream.isDataLoaded) {
              continue;
            }
            foundMissingData = true;
            pendingRequests.push({
              begin: stream.start,
              end: stream.end
            });
          }
          if (foundMissingData) {
            nodesToRevisit.push(currentNode);
          }
        }
      }
      addChildren(currentNode, nodesToVisit);
    }
    if (pendingRequests.length) {
      await this.xref.stream.manager.requestRanges(pendingRequests);
      for (const node of nodesToRevisit) {
        if (node instanceof _primitives.Ref) {
          this.refSet.remove(node);
        }
      }
      return this._walk(nodesToRevisit);
    }
    this.refSet = null;
    return undefined;
  }
}
exports.ObjectLoader = ObjectLoader;

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAFactory = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _bind = __w_pdfjs_require__(79);
var _data = __w_pdfjs_require__(89);
var _fonts = __w_pdfjs_require__(85);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _parser = __w_pdfjs_require__(90);
var _xhtml = __w_pdfjs_require__(100);
class XFAFactory {
  constructor(data) {
    try {
      this.root = new _parser.XFAParser().parse(XFAFactory._createDocument(data));
      const binder = new _bind.Binder(this.root);
      this.form = binder.bind();
      this.dataHandler = new _data.DataHandler(this.root, binder.getData());
      this.form[_symbol_utils.$globalData].template = this.form;
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during parsing and binding: ${e}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const iterator = this.form[_symbol_utils.$toPages]();
    return new Promise((resolve, reject) => {
      const nextIteration = () => {
        try {
          const value = iterator.next();
          if (value.done) {
            resolve(value.value);
          } else {
            setTimeout(nextIteration, 0);
          }
        } catch (e) {
          reject(e);
        }
      };
      setTimeout(nextIteration, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper();
      this.dims = this.pages.children.map(c => {
        const {
          width,
          height
        } = c.attributes.style;
        return [0, 0, parseInt(width), parseInt(height)];
      });
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during layout: ${e}`);
    }
  }
  getBoundingBox(pageIndex) {
    return this.dims[pageIndex];
  }
  async getNumPages() {
    if (!this.pages) {
      await this._createPages();
    }
    return this.dims.length;
  }
  setImages(images) {
    this.form[_symbol_utils.$globalData].images = images;
  }
  setFonts(fonts) {
    this.form[_symbol_utils.$globalData].fontFinder = new _fonts.FontFinder(fonts);
    const missingFonts = [];
    for (let typeface of this.form[_symbol_utils.$globalData].usedTypefaces) {
      typeface = (0, _utils.stripQuotes)(typeface);
      const font = this.form[_symbol_utils.$globalData].fontFinder.find(typeface);
      if (!font) {
        missingFonts.push(typeface);
      }
    }
    if (missingFonts.length > 0) {
      return missingFonts;
    }
    return null;
  }
  appendFonts(fonts, reallyMissingFonts) {
    this.form[_symbol_utils.$globalData].fontFinder.add(fonts, reallyMissingFonts);
  }
  async getPages() {
    if (!this.pages) {
      await this._createPages();
    }
    const pages = this.pages;
    this.pages = null;
    return pages;
  }
  serializeData(storage) {
    return this.dataHandler.serialize(storage);
  }
  static _createDocument(data) {
    if (!data["/xdp:xdp"]) {
      return data["xdp:xdp"];
    }
    return Object.values(data).join("");
  }
  static getRichTextAsHtml(rc) {
    if (!rc || typeof rc !== "string") {
      return null;
    }
    try {
      let root = new _parser.XFAParser(_xhtml.XhtmlNamespace, true).parse(rc);
      if (!["body", "xhtml"].includes(root[_symbol_utils.$nodeName])) {
        const newRoot = _xhtml.XhtmlNamespace.body({});
        newRoot[_symbol_utils.$appendChild](root);
        root = newRoot;
      }
      const result = root[_symbol_utils.$toHTML]();
      if (!result.success) {
        return null;
      }
      const {
        html
      } = result;
      const {
        attributes
      } = html;
      if (attributes) {
        if (attributes.class) {
          attributes.class = attributes.class.filter(attr => !attr.startsWith("xfa"));
        }
        attributes.dir = "auto";
      }
      return {
        html,
        str: root[_symbol_utils.$text]()
      };
    } catch (e) {
      (0, _util.warn)(`XFA - an error occurred during parsing of rich text: ${e}`);
    }
    return null;
  }
}
exports.XFAFactory = XFAFactory;

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.$uid = exports.$toStyle = exports.$toString = exports.$toPages = exports.$toHTML = exports.$text = exports.$tabIndex = exports.$setValue = exports.$setSetAttributes = exports.$setId = exports.$searchNode = exports.$root = exports.$resolvePrototypes = exports.$removeChild = exports.$pushPara = exports.$pushGlyphs = exports.$popPara = exports.$onText = exports.$onChildCheck = exports.$onChild = exports.$nsAttributes = exports.$nodeName = exports.$namespaceId = exports.$lastAttribute = exports.$isUsable = exports.$isTransparent = exports.$isThereMoreWidth = exports.$isSplittable = exports.$isNsAgnostic = exports.$isDescendent = exports.$isDataValue = exports.$isCDATAXml = exports.$isBindable = exports.$insertAt = exports.$indexOf = exports.$ids = exports.$hasSettableValue = exports.$globalData = exports.$getTemplateRoot = exports.$getSubformParent = exports.$getRealChildrenByNameIt = exports.$getParent = exports.$getNextPage = exports.$getExtra = exports.$getDataValue = exports.$getContainedChildren = exports.$getChildrenByNameIt = exports.$getChildrenByName = exports.$getChildrenByClass = exports.$getChildren = exports.$getAvailableSpace = exports.$getAttributes = exports.$getAttributeIt = exports.$flushHTML = exports.$finalize = exports.$extra = exports.$dump = exports.$data = exports.$content = exports.$consumed = exports.$clone = exports.$cleanup = exports.$cleanPage = exports.$clean = exports.$childrenToHTML = exports.$appendChild = exports.$addHTML = exports.$acceptWhitespace = void 0;
const $acceptWhitespace = Symbol();
exports.$acceptWhitespace = $acceptWhitespace;
const $addHTML = Symbol();
exports.$addHTML = $addHTML;
const $appendChild = Symbol();
exports.$appendChild = $appendChild;
const $childrenToHTML = Symbol();
exports.$childrenToHTML = $childrenToHTML;
const $clean = Symbol();
exports.$clean = $clean;
const $cleanPage = Symbol();
exports.$cleanPage = $cleanPage;
const $cleanup = Symbol();
exports.$cleanup = $cleanup;
const $clone = Symbol();
exports.$clone = $clone;
const $consumed = Symbol();
exports.$consumed = $consumed;
const $content = Symbol("content");
exports.$content = $content;
const $data = Symbol("data");
exports.$data = $data;
const $dump = Symbol();
exports.$dump = $dump;
const $extra = Symbol("extra");
exports.$extra = $extra;
const $finalize = Symbol();
exports.$finalize = $finalize;
const $flushHTML = Symbol();
exports.$flushHTML = $flushHTML;
const $getAttributeIt = Symbol();
exports.$getAttributeIt = $getAttributeIt;
const $getAttributes = Symbol();
exports.$getAttributes = $getAttributes;
const $getAvailableSpace = Symbol();
exports.$getAvailableSpace = $getAvailableSpace;
const $getChildrenByClass = Symbol();
exports.$getChildrenByClass = $getChildrenByClass;
const $getChildrenByName = Symbol();
exports.$getChildrenByName = $getChildrenByName;
const $getChildrenByNameIt = Symbol();
exports.$getChildrenByNameIt = $getChildrenByNameIt;
const $getDataValue = Symbol();
exports.$getDataValue = $getDataValue;
const $getExtra = Symbol();
exports.$getExtra = $getExtra;
const $getRealChildrenByNameIt = Symbol();
exports.$getRealChildrenByNameIt = $getRealChildrenByNameIt;
const $getChildren = Symbol();
exports.$getChildren = $getChildren;
const $getContainedChildren = Symbol();
exports.$getContainedChildren = $getContainedChildren;
const $getNextPage = Symbol();
exports.$getNextPage = $getNextPage;
const $getSubformParent = Symbol();
exports.$getSubformParent = $getSubformParent;
const $getParent = Symbol();
exports.$getParent = $getParent;
const $getTemplateRoot = Symbol();
exports.$getTemplateRoot = $getTemplateRoot;
const $globalData = Symbol();
exports.$globalData = $globalData;
const $hasSettableValue = Symbol();
exports.$hasSettableValue = $hasSettableValue;
const $ids = Symbol();
exports.$ids = $ids;
const $indexOf = Symbol();
exports.$indexOf = $indexOf;
const $insertAt = Symbol();
exports.$insertAt = $insertAt;
const $isCDATAXml = Symbol();
exports.$isCDATAXml = $isCDATAXml;
const $isBindable = Symbol();
exports.$isBindable = $isBindable;
const $isDataValue = Symbol();
exports.$isDataValue = $isDataValue;
const $isDescendent = Symbol();
exports.$isDescendent = $isDescendent;
const $isNsAgnostic = Symbol();
exports.$isNsAgnostic = $isNsAgnostic;
const $isSplittable = Symbol();
exports.$isSplittable = $isSplittable;
const $isThereMoreWidth = Symbol();
exports.$isThereMoreWidth = $isThereMoreWidth;
const $isTransparent = Symbol();
exports.$isTransparent = $isTransparent;
const $isUsable = Symbol();
exports.$isUsable = $isUsable;
const $lastAttribute = Symbol();
exports.$lastAttribute = $lastAttribute;
const $namespaceId = Symbol("namespaceId");
exports.$namespaceId = $namespaceId;
const $nodeName = Symbol("nodeName");
exports.$nodeName = $nodeName;
const $nsAttributes = Symbol();
exports.$nsAttributes = $nsAttributes;
const $onChild = Symbol();
exports.$onChild = $onChild;
const $onChildCheck = Symbol();
exports.$onChildCheck = $onChildCheck;
const $onText = Symbol();
exports.$onText = $onText;
const $pushGlyphs = Symbol();
exports.$pushGlyphs = $pushGlyphs;
const $popPara = Symbol();
exports.$popPara = $popPara;
const $pushPara = Symbol();
exports.$pushPara = $pushPara;
const $removeChild = Symbol();
exports.$removeChild = $removeChild;
const $root = Symbol("root");
exports.$root = $root;
const $resolvePrototypes = Symbol();
exports.$resolvePrototypes = $resolvePrototypes;
const $searchNode = Symbol();
exports.$searchNode = $searchNode;
const $setId = Symbol();
exports.$setId = $setId;
const $setSetAttributes = Symbol();
exports.$setSetAttributes = $setSetAttributes;
const $setValue = Symbol();
exports.$setValue = $setValue;
const $tabIndex = Symbol();
exports.$tabIndex = $tabIndex;
const $text = Symbol();
exports.$text = $text;
const $toPages = Symbol();
exports.$toPages = $toPages;
const $toHTML = Symbol();
exports.$toHTML = $toHTML;
const $toString = Symbol();
exports.$toString = $toString;
const $toStyle = Symbol();
exports.$toStyle = $toStyle;
const $uid = Symbol("uid");
exports.$uid = $uid;

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Binder = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _template = __w_pdfjs_require__(80);
var _som = __w_pdfjs_require__(88);
var _xfa_object = __w_pdfjs_require__(87);
var _namespaces = __w_pdfjs_require__(81);
var _util = __w_pdfjs_require__(2);
const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
function createText(content) {
  const node = new _template.Text({});
  node[_symbol_utils.$content] = content;
  return node;
}
class Binder {
  constructor(root) {
    this.root = root;
    this.datasets = root.datasets;
    this.data = root.datasets?.data || new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, "data");
    this.emptyMerge = this.data[_symbol_utils.$getChildren]().length === 0;
    this.root.form = this.form = root.template[_symbol_utils.$clone]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    this._bindElement(this.form, this.data);
    return this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(formNode, data, picture) {
    formNode[_symbol_utils.$data] = data;
    if (formNode[_symbol_utils.$hasSettableValue]()) {
      if (data[_symbol_utils.$isDataValue]()) {
        const value = data[_symbol_utils.$getDataValue]();
        formNode[_symbol_utils.$setValue](createText(value));
      } else if (formNode instanceof _template.Field && formNode.ui?.choiceList?.open === "multiSelect") {
        const value = data[_symbol_utils.$getChildren]().map(child => child[_symbol_utils.$content].trim()).join("\n");
        formNode[_symbol_utils.$setValue](createText(value));
      } else if (this._isConsumeData()) {
        (0, _util.warn)(`XFA - Nodes haven't the same type.`);
      }
    } else if (!data[_symbol_utils.$isDataValue]() || this._isMatchTemplate()) {
      this._bindElement(formNode, data);
    } else {
      (0, _util.warn)(`XFA - Nodes haven't the same type.`);
    }
  }
  _findDataByNameToConsume(name, isValue, dataNode, global) {
    if (!name) {
      return null;
    }
    let generator, match;
    for (let i = 0; i < 3; i++) {
      generator = dataNode[_symbol_utils.$getRealChildrenByNameIt](name, false, true);
      while (true) {
        match = generator.next().value;
        if (!match) {
          break;
        }
        if (isValue === match[_symbol_utils.$isDataValue]()) {
          return match;
        }
      }
      if (dataNode[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.datasets.id && dataNode[_symbol_utils.$nodeName] === "data") {
        break;
      }
      dataNode = dataNode[_symbol_utils.$getParent]();
    }
    if (!global) {
      return null;
    }
    generator = this.data[_symbol_utils.$getRealChildrenByNameIt](name, true, false);
    match = generator.next().value;
    if (match) {
      return match;
    }
    generator = this.data[_symbol_utils.$getAttributeIt](name, true);
    match = generator.next().value;
    if (match?.[_symbol_utils.$isDataValue]()) {
      return match;
    }
    return null;
  }
  _setProperties(formNode, dataNode) {
    if (!formNode.hasOwnProperty("setProperty")) {
      return;
    }
    for (const {
      ref,
      target,
      connection
    } of formNode.setProperty.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
      if (!nodes) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      const [node] = nodes;
      if (!node[_symbol_utils.$isDescendent](this.data)) {
        (0, _util.warn)(`XFA - Invalid node: must be a data node.`);
        continue;
      }
      const targetNodes = (0, _som.searchNode)(this.root, formNode, target, false, false);
      if (!targetNodes) {
        (0, _util.warn)(`XFA - Invalid target: ${target}.`);
        continue;
      }
      const [targetNode] = targetNodes;
      if (!targetNode[_symbol_utils.$isDescendent](formNode)) {
        (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`);
        continue;
      }
      const targetParent = targetNode[_symbol_utils.$getParent]();
      if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
        continue;
      }
      if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
        continue;
      }
      const content = node[_symbol_utils.$text]();
      const name = targetNode[_symbol_utils.$nodeName];
      if (targetNode instanceof _xfa_object.XFAAttribute) {
        const attrs = Object.create(null);
        attrs[name] = content;
        const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
        targetParent[name] = obj[name];
        continue;
      }
      if (!targetNode.hasOwnProperty(_symbol_utils.$content)) {
        (0, _util.warn)(`XFA - Invalid node to use in setProperty`);
        continue;
      }
      targetNode[_symbol_utils.$data] = node;
      targetNode[_symbol_utils.$content] = content;
      targetNode[_symbol_utils.$finalize]();
    }
  }
  _bindItems(formNode, dataNode) {
    if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
      return;
    }
    for (const item of formNode.items.children) {
      formNode[_symbol_utils.$removeChild](item);
    }
    formNode.items.clear();
    const labels = new _template.Items({});
    const values = new _template.Items({});
    formNode[_symbol_utils.$appendChild](labels);
    formNode.items.push(labels);
    formNode[_symbol_utils.$appendChild](values);
    formNode.items.push(values);
    for (const {
      ref,
      labelRef,
      valueRef,
      connection
    } of formNode.bindItems.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);
      if (!nodes) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      for (const node of nodes) {
        if (!node[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`);
          continue;
        }
        const labelNodes = (0, _som.searchNode)(this.root, node, labelRef, true, false);
        if (!labelNodes) {
          (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`);
          continue;
        }
        const [labelNode] = labelNodes;
        if (!labelNode[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`);
          continue;
        }
        const valueNodes = (0, _som.searchNode)(this.root, node, valueRef, true, false);
        if (!valueNodes) {
          (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`);
          continue;
        }
        const [valueNode] = valueNodes;
        if (!valueNode[_symbol_utils.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`);
          continue;
        }
        const label = createText(labelNode[_symbol_utils.$text]());
        const value = createText(valueNode[_symbol_utils.$text]());
        labels[_symbol_utils.$appendChild](label);
        labels.text.push(label);
        values[_symbol_utils.$appendChild](value);
        values.text.push(value);
      }
    }
  }
  _bindOccurrences(formNode, matches, picture) {
    let baseClone;
    if (matches.length > 1) {
      baseClone = formNode[_symbol_utils.$clone]();
      baseClone[_symbol_utils.$removeChild](baseClone.occur);
      baseClone.occur = null;
    }
    this._bindValue(formNode, matches[0], picture);
    this._setProperties(formNode, matches[0]);
    this._bindItems(formNode, matches[0]);
    if (matches.length === 1) {
      return;
    }
    const parent = formNode[_symbol_utils.$getParent]();
    const name = formNode[_symbol_utils.$nodeName];
    const pos = parent[_symbol_utils.$indexOf](formNode);
    for (let i = 1, ii = matches.length; i < ii; i++) {
      const match = matches[i];
      const clone = baseClone[_symbol_utils.$clone]();
      parent[name].push(clone);
      parent[_symbol_utils.$insertAt](pos + i, clone);
      this._bindValue(clone, match, picture);
      this._setProperties(clone, match);
      this._bindItems(clone, match);
    }
  }
  _createOccurrences(formNode) {
    if (!this.emptyMerge) {
      return;
    }
    const {
      occur
    } = formNode;
    if (!occur || occur.initial <= 1) {
      return;
    }
    const parent = formNode[_symbol_utils.$getParent]();
    const name = formNode[_symbol_utils.$nodeName];
    if (!(parent[name] instanceof _xfa_object.XFAObjectArray)) {
      return;
    }
    let currentNumber;
    if (formNode.name) {
      currentNumber = parent[name].children.filter(e => e.name === formNode.name).length;
    } else {
      currentNumber = parent[name].children.length;
    }
    const pos = parent[_symbol_utils.$indexOf](formNode) + 1;
    const ii = occur.initial - currentNumber;
    if (ii) {
      const nodeClone = formNode[_symbol_utils.$clone]();
      nodeClone[_symbol_utils.$removeChild](nodeClone.occur);
      nodeClone.occur = null;
      parent[name].push(nodeClone);
      parent[_symbol_utils.$insertAt](pos, nodeClone);
      for (let i = 1; i < ii; i++) {
        const clone = nodeClone[_symbol_utils.$clone]();
        parent[name].push(clone);
        parent[_symbol_utils.$insertAt](pos + i, clone);
      }
    }
  }
  _getOccurInfo(formNode) {
    const {
      name,
      occur
    } = formNode;
    if (!occur || !name) {
      return [1, 1];
    }
    const max = occur.max === -1 ? Infinity : occur.max;
    return [occur.min, max];
  }
  _setAndBind(formNode, dataNode) {
    this._setProperties(formNode, dataNode);
    this._bindItems(formNode, dataNode);
    this._bindElement(formNode, dataNode);
  }
  _bindElement(formNode, dataNode) {
    const uselessNodes = [];
    this._createOccurrences(formNode);
    for (const child of formNode[_symbol_utils.$getChildren]()) {
      if (child[_symbol_utils.$data]) {
        continue;
      }
      if (this._mergeMode === undefined && child[_symbol_utils.$nodeName] === "subform") {
        this._mergeMode = child.mergeMode === "consumeData";
        const dataChildren = dataNode[_symbol_utils.$getChildren]();
        if (dataChildren.length > 0) {
          this._bindOccurrences(child, [dataChildren[0]], null);
        } else if (this.emptyMerge) {
          const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
          const dataChild = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name || "root");
          dataNode[_symbol_utils.$appendChild](dataChild);
          this._bindElement(child, dataChild);
        }
        continue;
      }
      if (!child[_symbol_utils.$isBindable]()) {
        continue;
      }
      let global = false;
      let picture = null;
      let ref = null;
      let match = null;
      if (child.bind) {
        switch (child.bind.match) {
          case "none":
            this._setAndBind(child, dataNode);
            continue;
          case "global":
            global = true;
            break;
          case "dataRef":
            if (!child.bind.ref) {
              (0, _util.warn)(`XFA - ref is empty in node ${child[_symbol_utils.$nodeName]}.`);
              this._setAndBind(child, dataNode);
              continue;
            }
            ref = child.bind.ref;
            break;
          default:
            break;
        }
        if (child.bind.picture) {
          picture = child.bind.picture[_symbol_utils.$content];
        }
      }
      const [min, max] = this._getOccurInfo(child);
      if (ref) {
        match = (0, _som.searchNode)(this.root, dataNode, ref, true, false);
        if (match === null) {
          match = (0, _som.createDataNode)(this.data, dataNode, ref);
          if (!match) {
            continue;
          }
          if (this._isConsumeData()) {
            match[_symbol_utils.$consumed] = true;
          }
          this._setAndBind(child, match);
          continue;
        } else {
          if (this._isConsumeData()) {
            match = match.filter(node => !node[_symbol_utils.$consumed]);
          }
          if (match.length > max) {
            match = match.slice(0, max);
          } else if (match.length === 0) {
            match = null;
          }
          if (match && this._isConsumeData()) {
            match.forEach(node => {
              node[_symbol_utils.$consumed] = true;
            });
          }
        }
      } else {
        if (!child.name) {
          this._setAndBind(child, dataNode);
          continue;
        }
        if (this._isConsumeData()) {
          const matches = [];
          while (matches.length < max) {
            const found = this._findDataByNameToConsume(child.name, child[_symbol_utils.$hasSettableValue](), dataNode, global);
            if (!found) {
              break;
            }
            found[_symbol_utils.$consumed] = true;
            matches.push(found);
          }
          match = matches.length > 0 ? matches : null;
        } else {
          match = dataNode[_symbol_utils.$getRealChildrenByNameIt](child.name, false, this.emptyMerge).next().value;
          if (!match) {
            if (min === 0) {
              uselessNodes.push(child);
              continue;
            }
            const nsId = dataNode[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : dataNode[_symbol_utils.$namespaceId];
            match = child[_symbol_utils.$data] = new _xfa_object.XmlObject(nsId, child.name);
            if (this.emptyMerge) {
              match[_symbol_utils.$consumed] = true;
            }
            dataNode[_symbol_utils.$appendChild](match);
            this._setAndBind(child, match);
            continue;
          }
          if (this.emptyMerge) {
            match[_symbol_utils.$consumed] = true;
          }
          match = [match];
        }
      }
      if (match) {
        this._bindOccurrences(child, match, picture);
      } else if (min > 0) {
        this._setAndBind(child, dataNode);
      } else {
        uselessNodes.push(child);
      }
    }
    uselessNodes.forEach(node => node[_symbol_utils.$getParent]()[_symbol_utils.$removeChild](node));
  }
}
exports.Binder = Binder;

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Value = exports.Text = exports.TemplateNamespace = exports.Template = exports.SetProperty = exports.Items = exports.Field = exports.BindItems = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _layout = __w_pdfjs_require__(82);
var _html_utils = __w_pdfjs_require__(83);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _fonts = __w_pdfjs_require__(85);
var _core_utils = __w_pdfjs_require__(3);
var _som = __w_pdfjs_require__(88);
const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id;
const SVG_NS = "http://www.w3.org/2000/svg";
const MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
const MAX_EMPTY_PAGES = 3;
const DEFAULT_TAB_INDEX = 5000;
const HEADING_PATTERN = /^H(\d+)$/;
const MIMES = new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
const IMAGES_HEADERS = [[[0x42, 0x4d], "image/bmp"], [[0xff, 0xd8, 0xff], "image/jpeg"], [[0x49, 0x49, 0x2a, 0x00], "image/tiff"], [[0x4d, 0x4d, 0x00, 0x2a], "image/tiff"], [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61], "image/gif"], [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a], "image/png"]];
function getBorderDims(node) {
  if (!node || !node.border) {
    return {
      w: 0,
      h: 0
    };
  }
  const borderExtra = node.border[_symbol_utils.$getExtra]();
  if (!borderExtra) {
    return {
      w: 0,
      h: 0
    };
  }
  return {
    w: borderExtra.widths[0] + borderExtra.widths[2] + borderExtra.insets[0] + borderExtra.insets[2],
    h: borderExtra.widths[1] + borderExtra.widths[3] + borderExtra.insets[1] + borderExtra.insets[3]
  };
}
function hasMargin(node) {
  return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);
}
function _setValue(templateNode, value) {
  if (!templateNode.value) {
    const nodeValue = new Value({});
    templateNode[_symbol_utils.$appendChild](nodeValue);
    templateNode.value = nodeValue;
  }
  templateNode.value[_symbol_utils.$setValue](value);
}
function* getContainedChildren(node) {
  for (const child of node[_symbol_utils.$getChildren]()) {
    if (child instanceof SubformSet) {
      yield* child[_symbol_utils.$getContainedChildren]();
      continue;
    }
    yield child;
  }
}
function isRequired(node) {
  return node.validate?.nullTest === "error";
}
function setTabIndex(node) {
  while (node) {
    if (!node.traversal) {
      node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
      return;
    }
    if (node[_symbol_utils.$tabIndex]) {
      return;
    }
    let next = null;
    for (const child of node.traversal[_symbol_utils.$getChildren]()) {
      if (child.operation === "next") {
        next = child;
        break;
      }
    }
    if (!next || !next.ref) {
      node[_symbol_utils.$tabIndex] = node[_symbol_utils.$getParent]()[_symbol_utils.$tabIndex];
      return;
    }
    const root = node[_symbol_utils.$getTemplateRoot]();
    node[_symbol_utils.$tabIndex] = ++root[_symbol_utils.$tabIndex];
    const ref = root[_symbol_utils.$searchNode](next.ref, node);
    if (!ref) {
      return;
    }
    node = ref[0];
  }
}
function applyAssist(obj, attributes) {
  const assist = obj.assist;
  if (assist) {
    const assistTitle = assist[_symbol_utils.$toHTML]();
    if (assistTitle) {
      attributes.title = assistTitle;
    }
    const role = assist.role;
    const match = role.match(HEADING_PATTERN);
    if (match) {
      const ariaRole = "heading";
      const ariaLevel = match[1];
      attributes.role = ariaRole;
      attributes["aria-level"] = ariaLevel;
    }
  }
  if (obj.layout === "table") {
    attributes.role = "table";
  } else if (obj.layout === "row") {
    attributes.role = "row";
  } else {
    const parent = obj[_symbol_utils.$getParent]();
    if (parent.layout === "row") {
      attributes.role = parent.assist?.role === "TH" ? "columnheader" : "cell";
    }
  }
}
function ariaLabel(obj) {
  if (!obj.assist) {
    return null;
  }
  const assist = obj.assist;
  if (assist.speak && assist.speak[_symbol_utils.$content] !== "") {
    return assist.speak[_symbol_utils.$content];
  }
  if (assist.toolTip) {
    return assist.toolTip[_symbol_utils.$content];
  }
  return null;
}
function valueToHtml(value) {
  return _utils.HTMLResult.success({
    name: "div",
    attributes: {
      class: ["xfaRich"],
      style: Object.create(null)
    },
    children: [{
      name: "span",
      attributes: {
        style: Object.create(null)
      },
      value
    }]
  });
}
function setFirstUnsplittable(node) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  if (root[_symbol_utils.$extra].firstUnsplittable === null) {
    root[_symbol_utils.$extra].firstUnsplittable = node;
    root[_symbol_utils.$extra].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(node) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  if (root[_symbol_utils.$extra].firstUnsplittable === node) {
    root[_symbol_utils.$extra].noLayoutFailure = false;
  }
}
function handleBreak(node) {
  if (node[_symbol_utils.$extra]) {
    return false;
  }
  node[_symbol_utils.$extra] = Object.create(null);
  if (node.targetType === "auto") {
    return false;
  }
  const root = node[_symbol_utils.$getTemplateRoot]();
  let target = null;
  if (node.target) {
    target = root[_symbol_utils.$searchNode](node.target, node[_symbol_utils.$getParent]());
    if (!target) {
      return false;
    }
    target = target[0];
  }
  const {
    currentPageArea,
    currentContentArea
  } = root[_symbol_utils.$extra];
  if (node.targetType === "pageArea") {
    if (!(target instanceof PageArea)) {
      target = null;
    }
    if (node.startNew) {
      node[_symbol_utils.$extra].target = target || currentPageArea;
      return true;
    } else if (target && target !== currentPageArea) {
      node[_symbol_utils.$extra].target = target;
      return true;
    }
    return false;
  }
  if (!(target instanceof ContentArea)) {
    target = null;
  }
  const pageArea = target && target[_symbol_utils.$getParent]();
  let index;
  let nextPageArea = pageArea;
  if (node.startNew) {
    if (target) {
      const contentAreas = pageArea.contentArea.children;
      const indexForCurrent = contentAreas.indexOf(currentContentArea);
      const indexForTarget = contentAreas.indexOf(target);
      if (indexForCurrent !== -1 && indexForCurrent < indexForTarget) {
        nextPageArea = null;
      }
      index = indexForTarget - 1;
    } else {
      index = currentPageArea.contentArea.children.indexOf(currentContentArea);
    }
  } else if (target && target !== currentContentArea) {
    const contentAreas = pageArea.contentArea.children;
    index = contentAreas.indexOf(target) - 1;
    nextPageArea = pageArea === currentPageArea ? null : pageArea;
  } else {
    return false;
  }
  node[_symbol_utils.$extra].target = nextPageArea;
  node[_symbol_utils.$extra].index = index;
  return true;
}
function handleOverflow(node, extraNode, space) {
  const root = node[_symbol_utils.$getTemplateRoot]();
  const saved = root[_symbol_utils.$extra].noLayoutFailure;
  const savedMethod = extraNode[_symbol_utils.$getSubformParent];
  extraNode[_symbol_utils.$getSubformParent] = () => node;
  root[_symbol_utils.$extra].noLayoutFailure = true;
  const res = extraNode[_symbol_utils.$toHTML](space);
  node[_symbol_utils.$addHTML](res.html, res.bbox);
  root[_symbol_utils.$extra].noLayoutFailure = saved;
  extraNode[_symbol_utils.$getSubformParent] = savedMethod;
}
class AppearanceFilter extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "appearanceFilter");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Arc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "arc", true);
    this.circular = (0, _utils.getInteger)({
      data: attributes.circular,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.startAngle = (0, _utils.getFloat)({
      data: attributes.startAngle,
      defaultValue: 0,
      validate: x => true
    });
    this.sweepAngle = (0, _utils.getFloat)({
      data: attributes.sweepAngle,
      defaultValue: 360,
      validate: x => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
    this.fill = null;
  }
  [_symbol_utils.$toHTML]() {
    const edge = this.edge || new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    let arc;
    const attributes = {
      xmlns: SVG_NS,
      style: {
        width: "100%",
        height: "100%",
        overflow: "visible"
      }
    };
    if (this.sweepAngle === 360) {
      arc = {
        name: "ellipse",
        attributes: {
          xmlns: SVG_NS,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style
        }
      };
    } else {
      const startAngle = this.startAngle * Math.PI / 180;
      const sweepAngle = this.sweepAngle * Math.PI / 180;
      const largeArc = this.sweepAngle > 180 ? 1 : 0;
      const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(startAngle + sweepAngle)), 50 * (1 - Math.sin(startAngle + sweepAngle))];
      arc = {
        name: "path",
        attributes: {
          xmlns: SVG_NS,
          d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
          vectorEffect: "non-scaling-stroke",
          style
        }
      };
      Object.assign(attributes, {
        viewBox: "0 0 100 100",
        preserveAspectRatio: "none"
      });
    }
    const svg = {
      name: "svg",
      children: [arc],
      attributes
    };
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "area", true);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$isTransparent]() {
    return true;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$addHTML](html, bbox) {
    const [x, y, w, h] = bbox;
    this[_symbol_utils.$extra].width = Math.max(this[_symbol_utils.$extra].width, x + w);
    this[_symbol_utils.$extra].height = Math.max(this[_symbol_utils.$extra].height, y + h);
    this[_symbol_utils.$extra].children.push(html);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return this[_symbol_utils.$extra].availableSpace;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "position");
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: ["xfaArea"]
    };
    if ((0, _html_utils.isPrintOnly)(this)) {
      attributes.class.push("xfaPrintOnly");
    }
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    this[_symbol_utils.$extra] = {
      children,
      width: 0,
      height: 0,
      availableSpace
    };
    const result = this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
      include: true
    });
    if (!result.success) {
      if (result.isBreak()) {
        return result;
      }
      delete this[_symbol_utils.$extra];
      return _utils.HTMLResult.FAILURE;
    }
    style.width = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].width);
    style.height = (0, _html_utils.measureToString)(this[_symbol_utils.$extra].height);
    const html = {
      name: "div",
      attributes,
      children
    };
    const bbox = [this.x, this.y, this[_symbol_utils.$extra].width, this[_symbol_utils.$extra].height];
    delete this[_symbol_utils.$extra];
    return _utils.HTMLResult.success(html, bbox);
  }
}
class Assist extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "assist", true);
    this.id = attributes.id || "";
    this.role = attributes.role || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }
  [_symbol_utils.$toHTML]() {
    return this.toolTip?.[_symbol_utils.$content] || null;
  }
}
class Barcode extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "barcode", true);
    this.charEncoding = (0, _utils.getKeyword)({
      data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
    });
    this.checksum = (0, _utils.getStringOption)(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = (0, _utils.getInteger)({
      data: attributes.dataColumnCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataLength = (0, _utils.getInteger)({
      data: attributes.dataLength,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = (0, _utils.getInteger)({
      data: attributes.dataRowCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.endChar = attributes.endChar || "";
    this.errorCorrectionLevel = (0, _utils.getInteger)({
      data: attributes.errorCorrectionLevel,
      defaultValue: -1,
      validate: x => x >= 0 && x <= 8
    });
    this.id = attributes.id || "";
    this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, "5mm");
    this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, "0.25mm");
    this.printCheckDigit = (0, _utils.getInteger)({
      data: attributes.printCheckDigit,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio);
    this.startChar = attributes.startChar || "";
    this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = (0, _utils.getInteger)({
      data: attributes.truncate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }
}
class Bind extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bind", true);
    this.match = (0, _utils.getStringOption)(attributes.match, ["once", "dataRef", "global", "none"]);
    this.ref = attributes.ref || "";
    this.picture = null;
  }
}
class BindItems extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bindItems");
    this.connection = attributes.connection || "";
    this.labelRef = attributes.labelRef || "";
    this.ref = attributes.ref || "";
    this.valueRef = attributes.valueRef || "";
  }
}
exports.BindItems = BindItems;
class Bookend extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bookend");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class BooleanElement extends _xfa_object.Option01 {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "boolean");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] === 1 ? "1" : "0");
  }
}
class Border extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "border", true);
    this.break = (0, _utils.getStringOption)(attributes.break, ["close", "open"]);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }
  [_symbol_utils.$getExtra]() {
    if (!this[_symbol_utils.$extra]) {
      const edges = this.edge.children.slice();
      if (edges.length < 4) {
        const defaultEdge = edges.at(-1) || new Edge({});
        for (let i = edges.length; i < 4; i++) {
          edges.push(defaultEdge);
        }
      }
      const widths = edges.map(edge => edge.thickness);
      const insets = [0, 0, 0, 0];
      if (this.margin) {
        insets[0] = this.margin.topInset;
        insets[1] = this.margin.rightInset;
        insets[2] = this.margin.bottomInset;
        insets[3] = this.margin.leftInset;
      }
      this[_symbol_utils.$extra] = {
        widths,
        insets,
        edges
      };
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toStyle]() {
    const {
      edges
    } = this[_symbol_utils.$getExtra]();
    const edgeStyles = edges.map(node => {
      const style = node[_symbol_utils.$toStyle]();
      style.color ||= "#000000";
      return style;
    });
    const style = Object.create(null);
    if (this.margin) {
      Object.assign(style, this.margin[_symbol_utils.$toStyle]());
    }
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    }
    if (this.corner.children.some(node => node.radius !== 0)) {
      const cornerStyles = this.corner.children.map(node => node[_symbol_utils.$toStyle]());
      if (cornerStyles.length === 2 || cornerStyles.length === 3) {
        const last = cornerStyles.at(-1);
        for (let i = cornerStyles.length; i < 4; i++) {
          cornerStyles.push(last);
        }
      }
      style.borderRadius = cornerStyles.map(s => s.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        style.borderStyle = "";
        break;
      case "inactive":
        style.borderStyle = "none";
        break;
      default:
        style.borderStyle = edgeStyles.map(s => s.style).join(" ");
        break;
    }
    style.borderWidth = edgeStyles.map(s => s.width).join(" ");
    style.borderColor = edgeStyles.map(s => s.color).join(" ");
    return style;
  }
}
class Break extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "break", true);
    this.after = (0, _utils.getStringOption)(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = attributes.afterTarget || "";
    this.before = (0, _utils.getStringOption)(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = attributes.beforeTarget || "";
    this.bookendLeader = attributes.bookendLeader || "";
    this.bookendTrailer = attributes.bookendTrailer || "";
    this.id = attributes.id || "";
    this.overflowLeader = attributes.overflowLeader || "";
    this.overflowTarget = attributes.overflowTarget || "";
    this.overflowTrailer = attributes.overflowTrailer || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class BreakAfter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakAfter", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
}
class BreakBefore extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakBefore", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    this[_symbol_utils.$extra] = {};
    return _utils.HTMLResult.FAILURE;
  }
}
class Button extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "button", true);
    this.highlight = (0, _utils.getStringOption)(attributes.highlight, ["inverted", "none", "outline", "push"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const parent = this[_symbol_utils.$getParent]();
    const grandpa = parent[_symbol_utils.$getParent]();
    const htmlButton = {
      name: "button",
      attributes: {
        id: this[_symbol_utils.$uid],
        class: ["xfaButton"],
        style: {}
      },
      children: []
    };
    for (const event of grandpa.event.children) {
      if (event.activity !== "click" || !event.script) {
        continue;
      }
      const jsURL = (0, _core_utils.recoverJsURL)(event.script[_symbol_utils.$content]);
      if (!jsURL) {
        continue;
      }
      const href = (0, _html_utils.fixURL)(jsURL.url);
      if (!href) {
        continue;
      }
      htmlButton.children.push({
        name: "a",
        attributes: {
          id: "link" + this[_symbol_utils.$uid],
          href,
          newWindow: jsURL.newWindow,
          class: ["xfaLink"],
          style: {}
        },
        children: []
      });
    }
    return _utils.HTMLResult.success(htmlButton);
  }
}
class Calculate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "calculate", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getStringOption)(attributes.override, ["disabled", "error", "ignore", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }
}
class Caption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "caption", true);
    this.id = attributes.id || "";
    this.placement = (0, _utils.getStringOption)(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = Math.ceil((0, _utils.getMeasurement)(attributes.reserve));
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$getExtra](availableSpace) {
    if (!this[_symbol_utils.$extra]) {
      let {
        width,
        height
      } = availableSpace;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          width = this.reserve <= 0 ? width : this.reserve;
          break;
        case "top":
        case "bottom":
          height = this.reserve <= 0 ? height : this.reserve;
          break;
      }
      this[_symbol_utils.$extra] = (0, _html_utils.layoutNode)(this, {
        width,
        height
      });
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (!this.value) {
      return _utils.HTMLResult.EMPTY;
    }
    this[_symbol_utils.$pushPara]();
    const value = this.value[_symbol_utils.$toHTML](availableSpace).html;
    if (!value) {
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.EMPTY;
    }
    const savedReserve = this.reserve;
    if (this.reserve <= 0) {
      const {
        w,
        h
      } = this[_symbol_utils.$getExtra](availableSpace);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = w;
          break;
        case "top":
        case "bottom":
          this.reserve = h;
          break;
      }
    }
    const children = [];
    if (typeof value === "string") {
      children.push({
        name: "#text",
        value
      });
    } else {
      children.push(value);
    }
    const style = (0, _html_utils.toStyle)(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        if (this.reserve > 0) {
          style.width = (0, _html_utils.measureToString)(this.reserve);
        }
        break;
      case "top":
      case "bottom":
        if (this.reserve > 0) {
          style.height = (0, _html_utils.measureToString)(this.reserve);
        }
        break;
    }
    (0, _html_utils.setPara)(this, null, value);
    this[_symbol_utils.$popPara]();
    this.reserve = savedReserve;
    return _utils.HTMLResult.success({
      name: "div",
      attributes: {
        style,
        class: ["xfaCaption"]
      },
      children
    });
  }
}
class Certificate extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificate");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Certificates extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificates", true);
    this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, ["optional", "required"]);
    this.id = attributes.id || "";
    this.url = attributes.url || "";
    this.urlPolicy = attributes.urlPolicy || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }
}
class CheckButton extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "checkButton", true);
    this.id = attributes.id || "";
    this.mark = (0, _utils.getStringOption)(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = (0, _utils.getStringOption)(attributes.shape, ["square", "round"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)("margin");
    const size = (0, _html_utils.measureToString)(this.size);
    style.width = style.height = size;
    let type;
    let className;
    let groupId;
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const items = field.items.children.length && field.items.children[0][_symbol_utils.$toHTML]().html || [];
    const exportedValue = {
      on: (items[0] !== undefined ? items[0] : "on").toString(),
      off: (items[1] !== undefined ? items[1] : "off").toString()
    };
    const value = field.value?.[_symbol_utils.$text]() || "off";
    const checked = value === exportedValue.on || undefined;
    const container = field[_symbol_utils.$getSubformParent]();
    const fieldId = field[_symbol_utils.$uid];
    let dataId;
    if (container instanceof ExclGroup) {
      groupId = container[_symbol_utils.$uid];
      type = "radio";
      className = "xfaRadio";
      dataId = container[_symbol_utils.$data]?.[_symbol_utils.$uid] || container[_symbol_utils.$uid];
    } else {
      type = "checkbox";
      className = "xfaCheckbox";
      dataId = field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid];
    }
    const input = {
      name: "input",
      attributes: {
        class: [className],
        style,
        fieldId,
        dataId,
        type,
        checked,
        xfaOn: exportedValue.on,
        xfaOff: exportedValue.off,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (groupId) {
      input.attributes.name = groupId;
    }
    if (isRequired(field)) {
      input.attributes["aria-required"] = true;
      input.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [input]
    });
  }
}
class ChoiceList extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "choiceList", true);
    this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, ["select", "exit"]);
    this.id = attributes.id || "";
    this.open = (0, _utils.getStringOption)(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = (0, _utils.getInteger)({
      data: attributes.textEntry,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "margin");
    const ui = this[_symbol_utils.$getParent]();
    const field = ui[_symbol_utils.$getParent]();
    const fontSize = field.font?.size || 10;
    const optionStyle = {
      fontSize: `calc(${fontSize}px * var(--scale-factor))`
    };
    const children = [];
    if (field.items.children.length > 0) {
      const items = field.items;
      let displayedIndex = 0;
      let saveIndex = 0;
      if (items.children.length === 2) {
        displayedIndex = items.children[0].save;
        saveIndex = 1 - displayedIndex;
      }
      const displayed = items.children[displayedIndex][_symbol_utils.$toHTML]().html;
      const values = items.children[saveIndex][_symbol_utils.$toHTML]().html;
      let selected = false;
      const value = field.value?.[_symbol_utils.$text]() || "";
      for (let i = 0, ii = displayed.length; i < ii; i++) {
        const option = {
          name: "option",
          attributes: {
            value: values[i] || displayed[i],
            style: optionStyle
          },
          value: displayed[i]
        };
        if (values[i] === value) {
          option.attributes.selected = selected = true;
        }
        children.push(option);
      }
      if (!selected) {
        children.splice(0, 0, {
          name: "option",
          attributes: {
            hidden: true,
            selected: true
          },
          value: " "
        });
      }
    }
    const selectAttributes = {
      class: ["xfaSelect"],
      fieldId: field[_symbol_utils.$uid],
      dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
      style,
      "aria-label": ariaLabel(field),
      "aria-required": false
    };
    if (isRequired(field)) {
      selectAttributes["aria-required"] = true;
      selectAttributes.required = true;
    }
    if (this.open === "multiSelect") {
      selectAttributes.multiple = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [{
        name: "select",
        children,
        attributes: selectAttributes
      }]
    });
  }
}
class Color extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "color", true);
    this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, ["SRGB"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.value = attributes.value ? (0, _utils.getColor)(attributes.value) : "";
    this.extras = null;
  }
  [_symbol_utils.$hasSettableValue]() {
    return false;
  }
  [_symbol_utils.$toStyle]() {
    return this.value ? _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class Comb extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "comb");
    this.id = attributes.id || "";
    this.numberOfCells = (0, _utils.getInteger)({
      data: attributes.numberOfCells,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Connect extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "connect", true);
    this.connection = attributes.connection || "";
    this.id = attributes.id || "";
    this.ref = attributes.ref || "";
    this.usage = (0, _utils.getStringOption)(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.picture = null;
  }
}
class ContentArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "contentArea", true);
    this.h = (0, _utils.getMeasurement)(attributes.h);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = (0, _utils.getMeasurement)(attributes.w);
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const left = (0, _html_utils.measureToString)(this.x);
    const top = (0, _html_utils.measureToString)(this.y);
    const style = {
      left,
      top,
      width: (0, _html_utils.measureToString)(this.w),
      height: (0, _html_utils.measureToString)(this.h)
    };
    const classNames = ["xfaContentarea"];
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    return _utils.HTMLResult.success({
      name: "div",
      children: [],
      attributes: {
        style,
        class: classNames,
        id: this[_symbol_utils.$uid]
      }
    });
  }
}
class Corner extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "corner", true);
    this.id = attributes.id || "";
    this.inverted = (0, _utils.getInteger)({
      data: attributes.inverted,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.join = (0, _utils.getStringOption)(attributes.join, ["square", "round"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = (0, _utils.getMeasurement)(attributes.radius);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    style.radius = (0, _html_utils.measureToString)(this.join === "square" ? 0 : this.radius);
    return style;
  }
}
class DateElement extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "date");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class DateTime extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTime");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class DateTimeEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTimeEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.picker = (0, _utils.getStringOption)(attributes.picker, ["host", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[_symbol_utils.$uid],
        dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
        class: ["xfaTextfield"],
        style,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Decimal extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "decimal");
    this.fracDigits = (0, _utils.getInteger)({
      data: attributes.fracDigits,
      defaultValue: 2,
      validate: x => true
    });
    this.id = attributes.id || "";
    this.leadDigits = (0, _utils.getInteger)({
      data: attributes.leadDigits,
      defaultValue: -1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseFloat(this[_symbol_utils.$content].trim());
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class DefaultUi extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "defaultUi", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class Desc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "desc", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class DigestMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class DigestMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.digestMethod = new _xfa_object.XFAObjectArray();
  }
}
class Draw extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "draw", true);
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.presence === "hidden" || this.presence === "inactive") {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    this[_symbol_utils.$pushPara]();
    const savedW = this.w;
    const savedH = this.h;
    const {
      w,
      h,
      isBroken
    } = (0, _html_utils.layoutNode)(this, availableSpace);
    if (w && this.w === "") {
      if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
        this[_symbol_utils.$popPara]();
        return _utils.HTMLResult.FAILURE;
      }
      this.w = w;
    }
    if (h && this.h === "") {
      this.h = h;
    }
    setFirstUnsplittable(this);
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = (0, _html_utils.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    (0, _html_utils.setMinMaxDimensions)(this, style);
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    const classNames = ["xfaDraw"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: classNames
    };
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const html = {
      name: "div",
      attributes,
      children: []
    };
    applyAssist(this, attributes);
    const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
    const value = this.value ? this.value[_symbol_utils.$toHTML](availableSpace).html : null;
    if (value === null) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    html.children.push(value);
    (0, _html_utils.setPara)(this, style, value);
    this.w = savedW;
    this.h = savedH;
    this[_symbol_utils.$popPara]();
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
class Edge extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "edge", true);
    this.cap = (0, _utils.getStringOption)(attributes.cap, ["square", "butt", "round"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    Object.assign(style, {
      linecap: this.cap,
      width: (0, _html_utils.measureToString)(this.thickness),
      color: this.color ? this.color[_symbol_utils.$toStyle]() : "#000000",
      style: ""
    });
    if (this.presence !== "visible") {
      style.style = "none";
    } else {
      switch (this.stroke) {
        case "solid":
          style.style = "solid";
          break;
        case "dashDot":
          style.style = "dashed";
          break;
        case "dashDotDot":
          style.style = "dashed";
          break;
        case "dashed":
          style.style = "dashed";
          break;
        case "dotted":
          style.style = "dotted";
          break;
        case "embossed":
          style.style = "ridge";
          break;
        case "etched":
          style.style = "groove";
          break;
        case "lowered":
          style.style = "inset";
          break;
        case "raised":
          style.style = "outset";
          break;
      }
    }
    return style;
  }
}
class Encoding extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Encodings extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encodings", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encoding = new _xfa_object.XFAObjectArray();
  }
}
class Encrypt extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encrypt", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = null;
  }
}
class EncryptData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["encrypt", "decrypt"]);
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
}
class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryption", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class EncryptionMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class EncryptionMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
  }
}
class Event extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "event", true);
    this.activity = (0, _utils.getStringOption)(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = attributes.id || "";
    this.listen = (0, _utils.getStringOption)(attributes.listen, ["refOnly", "refAndDescendents"]);
    this.name = attributes.name || "";
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }
}
class ExData extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exData");
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.maxLength = (0, _utils.getInteger)({
      data: attributes.maxLength,
      defaultValue: -1,
      validate: x => x >= -1
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["none", "base64", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$isCDATAXml]() {
    return this.contentType === "text/html";
  }
  [_symbol_utils.$onChild](child) {
    if (this.contentType === "text/html" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_symbol_utils.$content] = child;
      return true;
    }
    if (this.contentType === "text/xml") {
      this[_symbol_utils.$content] = child;
      return true;
    }
    return false;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (this.contentType !== "text/html" || !this[_symbol_utils.$content]) {
      return _utils.HTMLResult.EMPTY;
    }
    return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
  }
}
class ExObject extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exObject", true);
    this.archive = attributes.archive || "";
    this.classId = attributes.classId || "";
    this.codeBase = attributes.codeBase || "";
    this.codeType = attributes.codeType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class ExclGroup extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exclGroup", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$hasSettableValue]() {
    return true;
  }
  [_symbol_utils.$setValue](value) {
    for (const field of this.field.children) {
      if (!field.value) {
        const nodeValue = new Value({});
        field[_symbol_utils.$appendChild](nodeValue);
        field.value = nodeValue;
      }
      field.value[_symbol_utils.$setValue](value);
    }
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
  }
  [_symbol_utils.$isSplittable]() {
    const parent = this[_symbol_utils.$getSubformParent]();
    if (!parent[_symbol_utils.$isSplittable]()) {
      return false;
    }
    if (this[_symbol_utils.$extra]._isSplittable !== undefined) {
      return this[_symbol_utils.$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout?.endsWith("-tb") && parent[_symbol_utils.$extra].numberInLine !== 0) {
      return false;
    }
    this[_symbol_utils.$extra]._isSplittable = true;
    return true;
  }
  [_symbol_utils.$flushHTML]() {
    return (0, _layout.flushHTML)(this);
  }
  [_symbol_utils.$addHTML](html, bbox) {
    (0, _layout.addHTML)(this, html, bbox);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return (0, _layout.getAvailableSpace)(this);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    const children = [];
    const attributes = {
      id: this[_symbol_utils.$uid],
      class: []
    };
    (0, _html_utils.setAccess)(this, attributes.class);
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = Object.create(null);
    }
    Object.assign(this[_symbol_utils.$extra], {
      children,
      attributes,
      attempt: 0,
      line: null,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const isSplittable = this[_symbol_utils.$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      return _utils.HTMLResult.FAILURE;
    }
    const filter = new Set(["field"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[_symbol_utils.$extra].columnWidths = columnWidths;
        this[_symbol_utils.$extra].currentColumn = 0;
      }
    }
    const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaExclgroup"];
    const cl = (0, _html_utils.layoutClass)(this);
    if (cl) {
      classNames.push(cl);
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    this[_symbol_utils.$pushPara]();
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
      if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[_symbol_utils.$extra].numberInLine = 0;
      }
      const result = this[_symbol_utils.$childrenToHTML]({
        filter,
        include: true
      });
      if (result.success) {
        break;
      }
      if (result.isBreak()) {
        this[_symbol_utils.$popPara]();
        return result;
      }
      if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        this[_symbol_utils.$extra].attempt = maxRun;
        break;
      }
    }
    this[_symbol_utils.$popPara]();
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    if (this[_symbol_utils.$extra].attempt === maxRun) {
      if (!isSplittable) {
        delete this[_symbol_utils.$extra];
      }
      return _utils.HTMLResult.FAILURE;
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
    const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = (0, _html_utils.measureToString)(width);
    }
    if (this.h === "") {
      style.height = (0, _html_utils.measureToString)(height);
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    delete this[_symbol_utils.$extra];
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
class Execute extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "execute");
    this.connection = attributes.connection || "";
    this.executeType = (0, _utils.getStringOption)(attributes.executeType, ["import", "remerge"]);
    this.id = attributes.id || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Extras extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "extras", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
}
class Field extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "field", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new _xfa_object.XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$setValue](value) {
    _setValue(this, value);
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (!this.ui) {
      this.ui = new Ui({});
      this.ui[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
      this[_symbol_utils.$appendChild](this.ui);
      let node;
      switch (this.items.children.length) {
        case 0:
          node = new TextEdit({});
          this.ui.textEdit = node;
          break;
        case 1:
          node = new CheckButton({});
          this.ui.checkButton = node;
          break;
        case 2:
          node = new ChoiceList({});
          this.ui.choiceList = node;
          break;
      }
      this.ui[_symbol_utils.$appendChild](node);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    if (this.caption) {
      delete this.caption[_symbol_utils.$extra];
    }
    this[_symbol_utils.$pushPara]();
    const caption = this.caption ? this.caption[_symbol_utils.$toHTML](availableSpace).html : null;
    const savedW = this.w;
    const savedH = this.h;
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    let borderDims = null;
    if (this.w === "" || this.h === "") {
      let width = null;
      let height = null;
      let uiW = 0;
      let uiH = 0;
      if (this.ui.checkButton) {
        uiW = uiH = this.ui.checkButton.size;
      } else {
        const {
          w,
          h
        } = (0, _html_utils.layoutNode)(this, availableSpace);
        if (w !== null) {
          uiW = w;
          uiH = h;
        } else {
          uiH = (0, _fonts.getMetrics)(this.font, true).lineNoGap;
        }
      }
      borderDims = getBorderDims(this.ui[_symbol_utils.$getExtra]());
      uiW += borderDims.w;
      uiH += borderDims.h;
      if (this.caption) {
        const {
          w,
          h,
          isBroken
        } = this.caption[_symbol_utils.$getExtra](availableSpace);
        if (isBroken && this[_symbol_utils.$getSubformParent]()[_symbol_utils.$isThereMoreWidth]()) {
          this[_symbol_utils.$popPara]();
          return _utils.HTMLResult.FAILURE;
        }
        width = w;
        height = h;
        switch (this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            width += uiW;
            break;
          case "top":
          case "bottom":
            height += uiH;
            break;
        }
      } else {
        width = uiW;
        height = uiH;
      }
      if (width && this.w === "") {
        width += marginH;
        this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, this.minW + 1 < width ? width : this.minW);
      }
      if (height && this.h === "") {
        height += marginV;
        this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, this.minH + 1 < height ? height : this.minH);
      }
    }
    this[_symbol_utils.$popPara]();
    (0, _html_utils.fixDimensions)(this);
    setFirstUnsplittable(this);
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      this[_symbol_utils.$popPara]();
      return _utils.HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = (0, _html_utils.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    (0, _html_utils.setMinMaxDimensions)(this, style);
    const classNames = ["xfaField"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if ((0, _html_utils.isPrintOnly)(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[_symbol_utils.$uid],
      class: classNames
    };
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    (0, _html_utils.setAccess)(this, classNames);
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    const borderStyle = this.border ? this.border[_symbol_utils.$toStyle]() : null;
    const bbox = (0, _html_utils.computeBbox)(this, html, availableSpace);
    const ui = this.ui[_symbol_utils.$toHTML]().html;
    if (!ui) {
      Object.assign(style, borderStyle);
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    if (this[_symbol_utils.$tabIndex]) {
      if (ui.children?.[0]) {
        ui.children[0].attributes.tabindex = this[_symbol_utils.$tabIndex];
      } else {
        ui.attributes.tabindex = this[_symbol_utils.$tabIndex];
      }
    }
    if (!ui.attributes.style) {
      ui.attributes.style = Object.create(null);
    }
    let aElement = null;
    if (this.ui.button) {
      if (ui.children.length === 1) {
        [aElement] = ui.children.splice(0, 1);
      }
      Object.assign(ui.attributes.style, borderStyle);
    } else {
      Object.assign(style, borderStyle);
    }
    children.push(ui);
    if (this.value) {
      if (this.ui.imageEdit) {
        ui.children.push(this.value[_symbol_utils.$toHTML]().html);
      } else if (!this.ui.button) {
        let value = "";
        if (this.value.exData) {
          value = this.value.exData[_symbol_utils.$text]();
        } else if (this.value.text) {
          value = this.value.text[_symbol_utils.$getExtra]();
        } else {
          const htmlValue = this.value[_symbol_utils.$toHTML]().html;
          if (htmlValue !== null) {
            value = htmlValue.children[0].value;
          }
        }
        if (this.ui.textEdit && this.value.text?.maxChars) {
          ui.children[0].attributes.maxLength = this.value.text.maxChars;
        }
        if (value) {
          if (this.ui.numericEdit) {
            value = parseFloat(value);
            value = isNaN(value) ? "" : value.toString();
          }
          if (ui.children[0].name === "textarea") {
            ui.children[0].attributes.textContent = value;
          } else {
            ui.children[0].attributes.value = value;
          }
        }
      }
    }
    if (!this.ui.imageEdit && ui.children?.[0] && this.h) {
      borderDims = borderDims || getBorderDims(this.ui[_symbol_utils.$getExtra]());
      let captionHeight = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        captionHeight = this.caption.reserve;
        if (captionHeight <= 0) {
          captionHeight = this.caption[_symbol_utils.$getExtra](availableSpace).h;
        }
        const inputHeight = this.h - captionHeight - marginV - borderDims.h;
        ui.children[0].attributes.style.height = (0, _html_utils.measureToString)(inputHeight);
      } else {
        ui.children[0].attributes.style.height = "100%";
      }
    }
    if (aElement) {
      ui.children.push(aElement);
    }
    if (!caption) {
      if (ui.attributes.class) {
        ui.attributes.class.push("xfaLeft");
      }
      this.w = savedW;
      this.h = savedH;
      return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    }
    if (this.ui.button) {
      if (style.padding) {
        delete style.padding;
      }
      if (caption.name === "div") {
        caption.name = "span";
      }
      ui.children.push(caption);
      return _utils.HTMLResult.success(html, bbox);
    } else if (this.ui.checkButton) {
      caption.attributes.class[0] = "xfaCaptionForCheckButton";
    }
    if (!ui.attributes.class) {
      ui.attributes.class = [];
    }
    ui.children.splice(0, 0, caption);
    switch (this.caption.placement) {
      case "left":
        ui.attributes.class.push("xfaLeft");
        break;
      case "right":
        ui.attributes.class.push("xfaRight");
        break;
      case "top":
        ui.attributes.class.push("xfaTop");
        break;
      case "bottom":
        ui.attributes.class.push("xfaBottom");
        break;
      case "inline":
        ui.attributes.class.push("xfaLeft");
        break;
    }
    this.w = savedW;
    this.h = savedH;
    return _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
  }
}
exports.Field = Field;
class Fill extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "fill", true);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }
  [_symbol_utils.$toStyle]() {
    const parent = this[_symbol_utils.$getParent]();
    const grandpa = parent[_symbol_utils.$getParent]();
    const ggrandpa = grandpa[_symbol_utils.$getParent]();
    const style = Object.create(null);
    let propName = "color";
    let altPropName = propName;
    if (parent instanceof Border) {
      propName = "background-color";
      altPropName = "background";
      if (ggrandpa instanceof Ui) {
        style.backgroundColor = "white";
      }
    }
    if (parent instanceof Rectangle || parent instanceof Arc) {
      propName = altPropName = "fill";
      style.fill = "white";
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "color") {
        continue;
      }
      const obj = this[name];
      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }
      const color = obj[_symbol_utils.$toStyle](this.color);
      if (color) {
        style[color.startsWith("#") ? propName : altPropName] = color;
      }
      return style;
    }
    if (this.color?.value) {
      const color = this.color[_symbol_utils.$toStyle]();
      style[color.startsWith("#") ? propName : altPropName] = color;
    }
    return style;
  }
}
class Filter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "filter", true);
    this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.version = (0, _utils.getInteger)({
      data: this.version,
      defaultValue: 5,
      validate: x => x >= 1 && x <= 5
    });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }
}
class Float extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "float");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseFloat(this[_symbol_utils.$content].trim());
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class Font extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "font", true);
    this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift);
    this.fontHorizontalScale = (0, _utils.getFloat)({
      data: attributes.fontHorizontalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.fontVerticalScale = (0, _utils.getFloat)({
      data: attributes.fontVerticalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.id = attributes.id || "";
    this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, ["none", "pair"]);
    this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, "0");
    this.lineThrough = (0, _utils.getInteger)({
      data: attributes.lineThrough,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, ["all", "word"]);
    this.overline = (0, _utils.getInteger)({
      data: attributes.overline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, ["all", "word"]);
    this.posture = (0, _utils.getStringOption)(attributes.posture, ["normal", "italic"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.typeface = attributes.typeface || "Courier";
    this.underline = (0, _utils.getInteger)({
      data: attributes.underline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, ["all", "word"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.weight = (0, _utils.getStringOption)(attributes.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    this[_symbol_utils.$globalData].usedTypefaces.add(this.typeface);
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "fill");
    const color = style.color;
    if (color) {
      if (color === "#000000") {
        delete style.color;
      } else if (!color.startsWith("#")) {
        style.background = color;
        style.backgroundClip = "text";
        style.color = "transparent";
      }
    }
    if (this.baselineShift) {
      style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift);
    }
    style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
    style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing);
    if (this.lineThrough !== 0) {
      style.textDecoration = "line-through";
      if (this.lineThrough === 2) {
        style.textDecorationStyle = "double";
      }
    }
    if (this.overline !== 0) {
      style.textDecoration = "overline";
      if (this.overline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontStyle = this.posture;
    style.fontSize = (0, _html_utils.measureToString)(0.99 * this.size);
    (0, _html_utils.setFontFamily)(this, this, this[_symbol_utils.$globalData].fontFinder, style);
    if (this.underline !== 0) {
      style.textDecoration = "underline";
      if (this.underline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontWeight = this.weight;
    return style;
  }
}
class Format extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "format", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
  }
}
class Handler extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "handler");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Hyphenation extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "hyphenation");
    this.excludeAllCaps = (0, _utils.getInteger)({
      data: attributes.excludeAllCaps,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.excludeInitialCap = (0, _utils.getInteger)({
      data: attributes.excludeInitialCap,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hyphenate = (0, _utils.getInteger)({
      data: attributes.hyphenate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.pushCharacterCount = (0, _utils.getInteger)({
      data: attributes.pushCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.remainCharacterCount = (0, _utils.getInteger)({
      data: attributes.remainCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wordCharacterCount = (0, _utils.getInteger)({
      data: attributes.wordCharacterCount,
      defaultValue: 7,
      validate: x => x >= 0
    });
  }
}
class Image extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "image");
    this.aspect = (0, _utils.getStringOption)(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["base64", "none", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$toHTML]() {
    if (this.contentType && !MIMES.has(this.contentType.toLowerCase())) {
      return _utils.HTMLResult.EMPTY;
    }
    let buffer = this[_symbol_utils.$globalData].images && this[_symbol_utils.$globalData].images.get(this.href);
    if (!buffer && (this.href || !this[_symbol_utils.$content])) {
      return _utils.HTMLResult.EMPTY;
    }
    if (!buffer && this.transferEncoding === "base64") {
      buffer = (0, _util.stringToBytes)(atob(this[_symbol_utils.$content]));
    }
    if (!buffer) {
      return _utils.HTMLResult.EMPTY;
    }
    if (!this.contentType) {
      for (const [header, type] of IMAGES_HEADERS) {
        if (buffer.length > header.length && header.every((x, i) => x === buffer[i])) {
          this.contentType = type;
          break;
        }
      }
      if (!this.contentType) {
        return _utils.HTMLResult.EMPTY;
      }
    }
    const blob = new Blob([buffer], {
      type: this.contentType
    });
    let style;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        style = {
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "none":
        style = {
          width: "100%",
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "width":
        style = {
          width: "100%",
          objectFit: "fill"
        };
        break;
    }
    const parent = this[_symbol_utils.$getParent]();
    return _utils.HTMLResult.success({
      name: "img",
      attributes: {
        class: ["xfaImage"],
        style,
        src: URL.createObjectURL(blob),
        alt: parent ? ariaLabel(parent[_symbol_utils.$getParent]()) : null
      }
    });
  }
}
class ImageEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "imageEdit", true);
    this.data = (0, _utils.getStringOption)(attributes.data, ["link", "embed"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (this.data === "embed") {
      return _utils.HTMLResult.success({
        name: "div",
        children: [],
        attributes: {}
      });
    }
    return _utils.HTMLResult.EMPTY;
  }
}
class Integer extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "integer");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const number = parseInt(this[_symbol_utils.$content].trim(), 10);
    this[_symbol_utils.$content] = isNaN(number) ? null : number;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] !== null ? this[_symbol_utils.$content].toString() : "");
  }
}
class Issuers extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "issuers", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class Items extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "items", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = attributes.ref || "";
    this.save = (0, _utils.getInteger)({
      data: attributes.save,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$toHTML]() {
    const output = [];
    for (const child of this[_symbol_utils.$getChildren]()) {
      output.push(child[_symbol_utils.$text]());
    }
    return _utils.HTMLResult.success(output);
  }
}
exports.Items = Items;
class Keep extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keep", true);
    this.id = attributes.id || "";
    const options = ["none", "contentArea", "pageArea"];
    this.intact = (0, _utils.getStringOption)(attributes.intact, options);
    this.next = (0, _utils.getStringOption)(attributes.next, options);
    this.previous = (0, _utils.getStringOption)(attributes.previous, options);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
}
class KeyUsage extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keyUsage");
    const options = ["", "yes", "no"];
    this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options);
    this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options);
    this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options);
    this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options);
    this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options);
    this.id = attributes.id || "";
    this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options);
    this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options);
    this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options);
    this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options);
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Line extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "line", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.slope = (0, _utils.getStringOption)(attributes.slope, ["\\", "/"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
  }
  [_symbol_utils.$toHTML]() {
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const edge = this.edge || new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    const thickness = edge.presence === "visible" ? edge.thickness : 0;
    style.strokeWidth = (0, _html_utils.measureToString)(thickness);
    style.stroke = edgeStyle.color;
    let x1, y1, x2, y2;
    let width = "100%";
    let height = "100%";
    if (parent.w <= thickness) {
      [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
      width = style.strokeWidth;
    } else if (parent.h <= thickness) {
      [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
      height = style.strokeWidth;
    } else if (this.slope === "\\") {
      [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
    } else {
      [x1, y1, x2, y2] = [0, "100%", "100%", 0];
    }
    const line = {
      name: "line",
      attributes: {
        xmlns: SVG_NS,
        x1,
        y1,
        x2,
        y2,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [line],
      attributes: {
        xmlns: SVG_NS,
        width,
        height,
        style: {
          overflow: "visible"
        }
      }
    };
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class Linear extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "linear", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
  }
}
class LockDocument extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "lockDocument");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getStringOption)(this[_symbol_utils.$content], ["auto", "0", "1"]);
  }
}
class Manifest extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "manifest", true);
    this.action = (0, _utils.getStringOption)(attributes.action, ["include", "all", "exclude"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.ref = new _xfa_object.XFAObjectArray();
  }
}
class Margin extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "margin", true);
    this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, "0");
    this.id = attributes.id || "";
    this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, "0");
    this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, "0");
    this.topInset = (0, _utils.getMeasurement)(attributes.topInset, "0");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toStyle]() {
    return {
      margin: (0, _html_utils.measureToString)(this.topInset) + " " + (0, _html_utils.measureToString)(this.rightInset) + " " + (0, _html_utils.measureToString)(this.bottomInset) + " " + (0, _html_utils.measureToString)(this.leftInset)
    };
  }
}
class Mdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "mdp");
    this.id = attributes.id || "";
    this.permissions = (0, _utils.getInteger)({
      data: attributes.permissions,
      defaultValue: 2,
      validate: x => x === 1 || x === 3
    });
    this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, ["filler", "author"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Medium extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "medium");
    this.id = attributes.id || "";
    this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox);
    this.long = (0, _utils.getMeasurement)(attributes.long);
    this.orientation = (0, _utils.getStringOption)(attributes.orientation, ["portrait", "landscape"]);
    this.short = (0, _utils.getMeasurement)(attributes.short);
    this.stock = attributes.stock || "";
    this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, ["auto", "delegate"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "message", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.text = new _xfa_object.XFAObjectArray();
  }
}
class NumericEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "numericEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[_symbol_utils.$uid],
        dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
        class: ["xfaTextfield"],
        style,
        "aria-label": ariaLabel(field),
        "aria-required": false
      }
    };
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Occur extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "occur", true);
    this.id = attributes.id || "";
    this.initial = attributes.initial !== "" ? (0, _utils.getInteger)({
      data: attributes.initial,
      defaultValue: "",
      validate: x => true
    }) : "";
    this.max = attributes.max !== "" ? (0, _utils.getInteger)({
      data: attributes.max,
      defaultValue: 1,
      validate: x => true
    }) : "";
    this.min = attributes.min !== "" ? (0, _utils.getInteger)({
      data: attributes.min,
      defaultValue: 1,
      validate: x => true
    }) : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$clean]() {
    const parent = this[_symbol_utils.$getParent]();
    const originalMin = this.min;
    if (this.min === "") {
      this.min = parent instanceof PageArea || parent instanceof PageSet ? 0 : 1;
    }
    if (this.max === "") {
      if (originalMin === "") {
        this.max = parent instanceof PageArea || parent instanceof PageSet ? -1 : 1;
      } else {
        this.max = this.min;
      }
    }
    if (this.max !== -1 && this.max < this.min) {
      this.max = this.min;
    }
    if (this.initial === "") {
      this.initial = parent instanceof Template ? 1 : this.min;
    }
  }
}
class Oid extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oid");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Oids extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oids", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.oid = new _xfa_object.XFAObjectArray();
  }
}
class Overflow extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "overflow");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.target = attributes.target || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$getExtra]() {
    if (!this[_symbol_utils.$extra]) {
      const parent = this[_symbol_utils.$getParent]();
      const root = this[_symbol_utils.$getTemplateRoot]();
      const target = root[_symbol_utils.$searchNode](this.target, parent);
      const leader = root[_symbol_utils.$searchNode](this.leader, parent);
      const trailer = root[_symbol_utils.$searchNode](this.trailer, parent);
      this[_symbol_utils.$extra] = {
        target: target?.[0] || null,
        leader: leader?.[0] || null,
        trailer: trailer?.[0] || null,
        addLeader: false,
        addTrailer: false
      };
    }
    return this[_symbol_utils.$extra];
  }
}
class PageArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageArea", true);
    this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = attributes.id || "";
    this.initialNumber = (0, _utils.getInteger)({
      data: attributes.initialNumber,
      defaultValue: 1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.numbered = (0, _utils.getInteger)({
      data: attributes.numbered,
      defaultValue: 1,
      validate: x => true
    });
    this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isUsable]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 0
      };
      return true;
    }
    return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
  }
  [_symbol_utils.$cleanPage]() {
    delete this[_symbol_utils.$extra];
  }
  [_symbol_utils.$getNextPage]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 0
      };
    }
    const parent = this[_symbol_utils.$getParent]();
    if (parent.relation === "orderedOccurrence") {
      if (this[_symbol_utils.$isUsable]()) {
        this[_symbol_utils.$extra].numberOfUse += 1;
        return this;
      }
    }
    return parent[_symbol_utils.$getNextPage]();
  }
  [_symbol_utils.$getAvailableSpace]() {
    return this[_symbol_utils.$extra].space || {
      width: 0,
      height: 0
    };
  }
  [_symbol_utils.$toHTML]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 1
      };
    }
    const children = [];
    this[_symbol_utils.$extra].children = children;
    const style = Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      style.width = (0, _html_utils.measureToString)(this.medium.short);
      style.height = (0, _html_utils.measureToString)(this.medium.long);
      this[_symbol_utils.$extra].space = {
        width: this.medium.short,
        height: this.medium.long
      };
      if (this.medium.orientation === "landscape") {
        const x = style.width;
        style.width = style.height;
        style.height = x;
        this[_symbol_utils.$extra].space = {
          width: this.medium.long,
          height: this.medium.short
        };
      }
    } else {
      (0, _util.warn)("XFA - No medium specified in pageArea: please file a bug.");
    }
    this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "subform"]),
      include: true
    });
    this[_symbol_utils.$childrenToHTML]({
      filter: new Set(["contentArea"]),
      include: true
    });
    return _utils.HTMLResult.success({
      name: "div",
      children,
      attributes: {
        class: ["xfaPage"],
        id: this[_symbol_utils.$uid],
        style,
        xfaName: this.name
      }
    });
  }
}
class PageSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageSet", true);
    this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$cleanPage]() {
    for (const page of this.pageArea.children) {
      page[_symbol_utils.$cleanPage]();
    }
    for (const page of this.pageSet.children) {
      page[_symbol_utils.$cleanPage]();
    }
  }
  [_symbol_utils.$isUsable]() {
    return !this.occur || this.occur.max === -1 || this[_symbol_utils.$extra].numberOfUse < this.occur.max;
  }
  [_symbol_utils.$getNextPage]() {
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = {
        numberOfUse: 1,
        pageIndex: -1,
        pageSetIndex: -1
      };
    }
    if (this.relation === "orderedOccurrence") {
      if (this[_symbol_utils.$extra].pageIndex + 1 < this.pageArea.children.length) {
        this[_symbol_utils.$extra].pageIndex += 1;
        const pageArea = this.pageArea.children[this[_symbol_utils.$extra].pageIndex];
        return pageArea[_symbol_utils.$getNextPage]();
      }
      if (this[_symbol_utils.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
        this[_symbol_utils.$extra].pageSetIndex += 1;
        return this.pageSet.children[this[_symbol_utils.$extra].pageSetIndex][_symbol_utils.$getNextPage]();
      }
      if (this[_symbol_utils.$isUsable]()) {
        this[_symbol_utils.$extra].numberOfUse += 1;
        this[_symbol_utils.$extra].pageIndex = -1;
        this[_symbol_utils.$extra].pageSetIndex = -1;
        return this[_symbol_utils.$getNextPage]();
      }
      const parent = this[_symbol_utils.$getParent]();
      if (parent instanceof PageSet) {
        return parent[_symbol_utils.$getNextPage]();
      }
      this[_symbol_utils.$cleanPage]();
      return this[_symbol_utils.$getNextPage]();
    }
    const pageNumber = this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].pageNumber;
    const parity = pageNumber % 2 === 0 ? "even" : "odd";
    const position = pageNumber === 0 ? "first" : "rest";
    let page = this.pageArea.children.find(p => p.oddOrEven === parity && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find(p => p.oddOrEven === "any" && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find(p => p.oddOrEven === "any" && p.pagePosition === "any");
    if (page) {
      return page;
    }
    return this.pageArea.children[0];
  }
}
class Para extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "para", true);
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, "0pt") : "";
    this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, "0pt") : "";
    this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, "0pt") : "";
    this.orphans = (0, _utils.getInteger)({
      data: attributes.orphans,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.preserve = attributes.preserve || "";
    this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, "0pt") : "";
    this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, "0pt") : "";
    this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, "0pt") : "";
    this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : "";
    this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x);
    this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, "0pt") : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, ["top", "bottom", "middle"]);
    this.widows = (0, _utils.getInteger)({
      data: attributes.widows,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.hyphenation = null;
  }
  [_symbol_utils.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "hAlign");
    if (this.marginLeft !== "") {
      style.paddingLeft = (0, _html_utils.measureToString)(this.marginLeft);
    }
    if (this.marginRight !== "") {
      style.paddingight = (0, _html_utils.measureToString)(this.marginRight);
    }
    if (this.spaceAbove !== "") {
      style.paddingTop = (0, _html_utils.measureToString)(this.spaceAbove);
    }
    if (this.spaceBelow !== "") {
      style.paddingBottom = (0, _html_utils.measureToString)(this.spaceBelow);
    }
    if (this.textIndent !== "") {
      style.textIndent = (0, _html_utils.measureToString)(this.textIndent);
      (0, _html_utils.fixTextIndent)(style);
    }
    if (this.lineHeight > 0) {
      style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight);
    }
    if (this.tabDefault !== "") {
      style.tabSize = (0, _html_utils.measureToString)(this.tabDefault);
    }
    if (this.tabStops.length > 0) {}
    if (this.hyphenatation) {
      Object.assign(style, this.hyphenatation[_symbol_utils.$toStyle]());
    }
    return style;
  }
}
class PasswordEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "passwordEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.passwordChar = attributes.passwordChar || "*";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
}
class Pattern extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pattern", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    const width = 5;
    const cmd = "repeating-linear-gradient";
    const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;
    switch (this.type) {
      case "crossHatch":
        return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
      case "crossDiagonal":
        return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
      case "diagonalLeft":
        return `${cmd}(45deg,${colors})`;
      case "diagonalRight":
        return `${cmd}(-45deg,${colors})`;
      case "horizontal":
        return `${cmd}(to top,${colors})`;
      case "vertical":
        return `${cmd}(to right,${colors})`;
    }
    return "";
  }
}
class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "picture");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Proto extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "proto", true);
    this.appearanceFilter = new _xfa_object.XFAObjectArray();
    this.arc = new _xfa_object.XFAObjectArray();
    this.area = new _xfa_object.XFAObjectArray();
    this.assist = new _xfa_object.XFAObjectArray();
    this.barcode = new _xfa_object.XFAObjectArray();
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.bookend = new _xfa_object.XFAObjectArray();
    this.boolean = new _xfa_object.XFAObjectArray();
    this.border = new _xfa_object.XFAObjectArray();
    this.break = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.button = new _xfa_object.XFAObjectArray();
    this.calculate = new _xfa_object.XFAObjectArray();
    this.caption = new _xfa_object.XFAObjectArray();
    this.certificate = new _xfa_object.XFAObjectArray();
    this.certificates = new _xfa_object.XFAObjectArray();
    this.checkButton = new _xfa_object.XFAObjectArray();
    this.choiceList = new _xfa_object.XFAObjectArray();
    this.color = new _xfa_object.XFAObjectArray();
    this.comb = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.corner = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.dateTimeEdit = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.defaultUi = new _xfa_object.XFAObjectArray();
    this.desc = new _xfa_object.XFAObjectArray();
    this.digestMethod = new _xfa_object.XFAObjectArray();
    this.digestMethods = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.edge = new _xfa_object.XFAObjectArray();
    this.encoding = new _xfa_object.XFAObjectArray();
    this.encodings = new _xfa_object.XFAObjectArray();
    this.encrypt = new _xfa_object.XFAObjectArray();
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.encryption = new _xfa_object.XFAObjectArray();
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
    this.encryptionMethods = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.execute = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.fill = new _xfa_object.XFAObjectArray();
    this.filter = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.font = new _xfa_object.XFAObjectArray();
    this.format = new _xfa_object.XFAObjectArray();
    this.handler = new _xfa_object.XFAObjectArray();
    this.hyphenation = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.imageEdit = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.issuers = new _xfa_object.XFAObjectArray();
    this.items = new _xfa_object.XFAObjectArray();
    this.keep = new _xfa_object.XFAObjectArray();
    this.keyUsage = new _xfa_object.XFAObjectArray();
    this.line = new _xfa_object.XFAObjectArray();
    this.linear = new _xfa_object.XFAObjectArray();
    this.lockDocument = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.margin = new _xfa_object.XFAObjectArray();
    this.mdp = new _xfa_object.XFAObjectArray();
    this.medium = new _xfa_object.XFAObjectArray();
    this.message = new _xfa_object.XFAObjectArray();
    this.numericEdit = new _xfa_object.XFAObjectArray();
    this.occur = new _xfa_object.XFAObjectArray();
    this.oid = new _xfa_object.XFAObjectArray();
    this.oids = new _xfa_object.XFAObjectArray();
    this.overflow = new _xfa_object.XFAObjectArray();
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
    this.para = new _xfa_object.XFAObjectArray();
    this.passwordEdit = new _xfa_object.XFAObjectArray();
    this.pattern = new _xfa_object.XFAObjectArray();
    this.picture = new _xfa_object.XFAObjectArray();
    this.radial = new _xfa_object.XFAObjectArray();
    this.reason = new _xfa_object.XFAObjectArray();
    this.reasons = new _xfa_object.XFAObjectArray();
    this.rectangle = new _xfa_object.XFAObjectArray();
    this.ref = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
    this.signature = new _xfa_object.XFAObjectArray();
    this.signing = new _xfa_object.XFAObjectArray();
    this.solid = new _xfa_object.XFAObjectArray();
    this.speak = new _xfa_object.XFAObjectArray();
    this.stipple = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
    this.subjectDN = new _xfa_object.XFAObjectArray();
    this.subjectDNs = new _xfa_object.XFAObjectArray();
    this.submit = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.textEdit = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
    this.timeStamp = new _xfa_object.XFAObjectArray();
    this.toolTip = new _xfa_object.XFAObjectArray();
    this.traversal = new _xfa_object.XFAObjectArray();
    this.traverse = new _xfa_object.XFAObjectArray();
    this.ui = new _xfa_object.XFAObjectArray();
    this.validate = new _xfa_object.XFAObjectArray();
    this.value = new _xfa_object.XFAObjectArray();
    this.variables = new _xfa_object.XFAObjectArray();
  }
}
class Radial extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "radial", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toEdge", "toCenter"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    startColor = startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_symbol_utils.$toStyle]() : "#000000";
    const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
    return `radial-gradient(circle at center, ${colors})`;
  }
}
class Reason extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reason");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Reasons extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reasons", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.reason = new _xfa_object.XFAObjectArray();
  }
}
class Rectangle extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "rectangle", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.fill = null;
  }
  [_symbol_utils.$toHTML]() {
    const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});
    const edgeStyle = edge[_symbol_utils.$toStyle]();
    const style = Object.create(null);
    if (this.fill?.presence === "visible") {
      Object.assign(style, this.fill[_symbol_utils.$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = (0, _html_utils.measureToString)(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});
    const cornerStyle = corner[_symbol_utils.$toStyle]();
    const rect = {
      name: "rect",
      attributes: {
        xmlns: SVG_NS,
        width: "100%",
        height: "100%",
        x: 0,
        y: 0,
        rx: cornerStyle.radius,
        ry: cornerStyle.radius,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [rect],
      attributes: {
        xmlns: SVG_NS,
        style: {
          overflow: "visible"
        },
        width: "100%",
        height: "100%"
      }
    };
    const parent = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (hasMargin(parent)) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return _utils.HTMLResult.success(svg);
  }
}
class RefElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ref");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Script extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "script");
    this.binding = attributes.binding || "";
    this.contentType = attributes.contentType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SetProperty extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "setProperty");
    this.connection = attributes.connection || "";
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
  }
}
exports.SetProperty = SetProperty;
class SignData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["sign", "clear", "verify"]);
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
}
class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signature", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["PDF1.3", "PDF1.6"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }
}
class Signing extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signing", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }
}
class Solid extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "solid", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [_symbol_utils.$toStyle](startColor) {
    return startColor ? startColor[_symbol_utils.$toStyle]() : "#FFFFFF";
  }
}
class Speak extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "speak");
    this.disable = (0, _utils.getInteger)({
      data: attributes.disable,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.priority = (0, _utils.getStringOption)(attributes.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Stipple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "stipple", true);
    this.id = attributes.id || "";
    this.rate = (0, _utils.getInteger)({
      data: attributes.rate,
      defaultValue: 50,
      validate: x => x >= 0 && x <= 100
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [_symbol_utils.$toStyle](bgColor) {
    const alpha = this.rate / 100;
    return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
  }
}
class Subform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subform", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = (0, _utils.getInteger)({
      data: attributes.allowMacro,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1 || n === -1
    });
    this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map(x => x === "-1" ? -1 : (0, _utils.getMeasurement)(x));
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, ["manual", "auto"]);
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["name", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.proto = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$getSubformParent]() {
    const parent = this[_symbol_utils.$getParent]();
    if (parent instanceof SubformSet) {
      return parent[_symbol_utils.$getSubformParent]();
    }
    return parent;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine > 0 || this[_symbol_utils.$getParent]()[_symbol_utils.$isThereMoreWidth]();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$flushHTML]() {
    return (0, _layout.flushHTML)(this);
  }
  [_symbol_utils.$addHTML](html, bbox) {
    (0, _layout.addHTML)(this, html, bbox);
  }
  [_symbol_utils.$getAvailableSpace]() {
    return (0, _layout.getAvailableSpace)(this);
  }
  [_symbol_utils.$isSplittable]() {
    const parent = this[_symbol_utils.$getSubformParent]();
    if (!parent[_symbol_utils.$isSplittable]()) {
      return false;
    }
    if (this[_symbol_utils.$extra]._isSplittable !== undefined) {
      return this[_symbol_utils.$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (this.keep && this.keep.intact !== "none") {
      this[_symbol_utils.$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout?.endsWith("-tb") && parent[_symbol_utils.$extra].numberInLine !== 0) {
      return false;
    }
    this[_symbol_utils.$extra]._isSplittable = true;
    return true;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    setTabIndex(this);
    if (this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const node = new BreakAfter({
          targetType: this.break.after,
          target: this.break.afterTarget,
          startNew: this.break.startNew.toString()
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.breakAfter.push(node);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const node = new BreakBefore({
          targetType: this.break.before,
          target: this.break.beforeTarget,
          startNew: this.break.startNew.toString()
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.breakBefore.push(node);
      }
      if (this.break.overflowTarget !== "") {
        const node = new Overflow({
          target: this.break.overflowTarget,
          leader: this.break.overflowLeader,
          trailer: this.break.overflowTrailer
        });
        node[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
        this[_symbol_utils.$appendChild](node);
        this.overflow.push(node);
      }
      this[_symbol_utils.$removeChild](this.break);
      this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive") {
      return _utils.HTMLResult.EMPTY;
    }
    if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {
      (0, _util.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
    }
    if (this.breakBefore.children.length >= 1) {
      const breakBefore = this.breakBefore.children[0];
      if (handleBreak(breakBefore)) {
        return _utils.HTMLResult.breakNode(breakBefore);
      }
    }
    if (this[_symbol_utils.$extra]?.afterBreakAfter) {
      return _utils.HTMLResult.EMPTY;
    }
    (0, _html_utils.fixDimensions)(this);
    const children = [];
    const attributes = {
      id: this[_symbol_utils.$uid],
      class: []
    };
    (0, _html_utils.setAccess)(this, attributes.class);
    if (!this[_symbol_utils.$extra]) {
      this[_symbol_utils.$extra] = Object.create(null);
    }
    Object.assign(this[_symbol_utils.$extra], {
      children,
      line: null,
      attributes,
      attempt: 0,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const root = this[_symbol_utils.$getTemplateRoot]();
    const savedNoLayoutFailure = root[_symbol_utils.$extra].noLayoutFailure;
    const isSplittable = this[_symbol_utils.$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!(0, _layout.checkDimensions)(this, availableSpace)) {
      return _utils.HTMLResult.FAILURE;
    }
    const filter = new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[_symbol_utils.$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[_symbol_utils.$extra].columnWidths = columnWidths;
        this[_symbol_utils.$extra].currentColumn = 0;
      }
    }
    const style = (0, _html_utils.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaSubform"];
    const cl = (0, _html_utils.layoutClass)(this);
    if (cl) {
      classNames.push(cl);
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
      if (overflowExtra.addLeader) {
        overflowExtra.addLeader = false;
        handleOverflow(this, overflowExtra.leader, availableSpace);
      }
    }
    this[_symbol_utils.$pushPara]();
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[_symbol_utils.$extra].attempt < maxRun; this[_symbol_utils.$extra].attempt++) {
      if (isLrTb && this[_symbol_utils.$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[_symbol_utils.$extra].numberInLine = 0;
      }
      const result = this[_symbol_utils.$childrenToHTML]({
        filter,
        include: true
      });
      if (result.success) {
        break;
      }
      if (result.isBreak()) {
        this[_symbol_utils.$popPara]();
        return result;
      }
      if (isLrTb && this[_symbol_utils.$extra].attempt === 0 && this[_symbol_utils.$extra].numberInLine === 0 && !root[_symbol_utils.$extra].noLayoutFailure) {
        this[_symbol_utils.$extra].attempt = maxRun;
        break;
      }
    }
    this[_symbol_utils.$popPara]();
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    root[_symbol_utils.$extra].noLayoutFailure = savedNoLayoutFailure;
    if (this[_symbol_utils.$extra].attempt === maxRun) {
      if (this.overflow) {
        this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].overflowNode = this.overflow;
      }
      if (!isSplittable) {
        delete this[_symbol_utils.$extra];
      }
      return _utils.HTMLResult.FAILURE;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[_symbol_utils.$getExtra]();
      if (overflowExtra.addTrailer) {
        overflowExtra.addTrailer = false;
        handleOverflow(this, overflowExtra.trailer, availableSpace);
      }
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[_symbol_utils.$extra].width + marginH, this.w || 0);
    const height = Math.max(this[_symbol_utils.$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = (0, _html_utils.measureToString)(width);
    }
    if (this.h === "") {
      style.height = (0, _html_utils.measureToString)(height);
    }
    if ((style.width === "0px" || style.height === "0px") && children.length === 0) {
      return _utils.HTMLResult.EMPTY;
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    applyAssist(this, attributes);
    const result = _utils.HTMLResult.success((0, _html_utils.createWrapper)(this, html), bbox);
    if (this.breakAfter.children.length >= 1) {
      const breakAfter = this.breakAfter.children[0];
      if (handleBreak(breakAfter)) {
        this[_symbol_utils.$extra].afterBreakAfter = result;
        return _utils.HTMLResult.breakNode(breakAfter);
      }
    }
    delete this[_symbol_utils.$extra];
    return result;
  }
}
class SubformSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subformSet", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["ordered", "choice", "unordered"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }
  *[_symbol_utils.$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [_symbol_utils.$getSubformParent]() {
    let parent = this[_symbol_utils.$getParent]();
    while (!(parent instanceof Subform)) {
      parent = parent[_symbol_utils.$getParent]();
    }
    return parent;
  }
  [_symbol_utils.$isBindable]() {
    return true;
  }
}
class SubjectDN extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDN");
    this.delimiter = attributes.delimiter || ",";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].split(this.delimiter).map(kv => {
      kv = kv.split("=", 2);
      kv[0] = kv[0].trim();
      return kv;
    }));
  }
}
class SubjectDNs extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDNs", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.subjectDN = new _xfa_object.XFAObjectArray();
  }
}
class Submit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "submit", true);
    this.embedPDF = (0, _utils.getInteger)({
      data: attributes.embedPDF,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.format = (0, _utils.getStringOption)(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = attributes.id || "";
    this.target = attributes.target || "";
    this.textEncoding = (0, _utils.getKeyword)({
      data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-\d{2}/)
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.xdpContent = attributes.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
  }
}
class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "template", true);
    this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$finalize]() {
    if (this.subform.children.length === 0) {
      (0, _util.warn)("XFA - No subforms in template node.");
    }
    if (this.subform.children.length >= 2) {
      (0, _util.warn)("XFA - Several subforms in template node: please file a bug.");
    }
    this[_symbol_utils.$tabIndex] = DEFAULT_TAB_INDEX;
  }
  [_symbol_utils.$isSplittable]() {
    return true;
  }
  [_symbol_utils.$searchNode](expr, container) {
    if (expr.startsWith("#")) {
      return [this[_symbol_utils.$ids].get(expr.slice(1))];
    }
    return (0, _som.searchNode)(this, container, expr, true, true);
  }
  *[_symbol_utils.$toPages]() {
    if (!this.subform.children.length) {
      return _utils.HTMLResult.success({
        name: "div",
        children: []
      });
    }
    this[_symbol_utils.$extra] = {
      overflowNode: null,
      firstUnsplittable: null,
      currentContentArea: null,
      currentPageArea: null,
      noLayoutFailure: false,
      pageNumber: 1,
      pagePosition: "first",
      oddOrEven: "odd",
      blankOrNotBlank: "nonBlank",
      paraStack: []
    };
    const root = this.subform.children[0];
    root.pageSet[_symbol_utils.$cleanPage]();
    const pageAreas = root.pageSet.pageArea.children;
    const mainHtml = {
      name: "div",
      children: []
    };
    let pageArea = null;
    let breakBefore = null;
    let breakBeforeTarget = null;
    if (root.breakBefore.children.length >= 1) {
      breakBefore = root.breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {
      breakBefore = root.subform.children[0].breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.break?.beforeTarget) {
      breakBefore = root.break;
      breakBeforeTarget = breakBefore.beforeTarget;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].break?.beforeTarget) {
      breakBefore = root.subform.children[0].break;
      breakBeforeTarget = breakBefore.beforeTarget;
    }
    if (breakBefore) {
      const target = this[_symbol_utils.$searchNode](breakBeforeTarget, breakBefore[_symbol_utils.$getParent]());
      if (target instanceof PageArea) {
        pageArea = target;
        breakBefore[_symbol_utils.$extra] = {};
      }
    }
    if (!pageArea) {
      pageArea = pageAreas[0];
    }
    pageArea[_symbol_utils.$extra] = {
      numberOfUse: 1
    };
    const pageAreaParent = pageArea[_symbol_utils.$getParent]();
    pageAreaParent[_symbol_utils.$extra] = {
      numberOfUse: 1,
      pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
      pageSetIndex: 0
    };
    let targetPageArea;
    let leader = null;
    let trailer = null;
    let hasSomething = true;
    let hasSomethingCounter = 0;
    let startIndex = 0;
    while (true) {
      if (!hasSomething) {
        mainHtml.children.pop();
        if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
          (0, _util.warn)("XFA - Something goes wrong: please file a bug.");
          return mainHtml;
        }
      } else {
        hasSomethingCounter = 0;
      }
      targetPageArea = null;
      this[_symbol_utils.$extra].currentPageArea = pageArea;
      const page = pageArea[_symbol_utils.$toHTML]().html;
      mainHtml.children.push(page);
      if (leader) {
        this[_symbol_utils.$extra].noLayoutFailure = true;
        page.children.push(leader[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
        leader = null;
      }
      if (trailer) {
        this[_symbol_utils.$extra].noLayoutFailure = true;
        page.children.push(trailer[_symbol_utils.$toHTML](pageArea[_symbol_utils.$extra].space).html);
        trailer = null;
      }
      const contentAreas = pageArea.contentArea.children;
      const htmlContentAreas = page.children.filter(node => node.attributes.class.includes("xfaContentarea"));
      hasSomething = false;
      this[_symbol_utils.$extra].firstUnsplittable = null;
      this[_symbol_utils.$extra].noLayoutFailure = false;
      const flush = index => {
        const html = root[_symbol_utils.$flushHTML]();
        if (html) {
          hasSomething ||= html.children?.length > 0;
          htmlContentAreas[index].children.push(html);
        }
      };
      for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
        const contentArea = this[_symbol_utils.$extra].currentContentArea = contentAreas[i];
        const space = {
          width: contentArea.w,
          height: contentArea.h
        };
        startIndex = 0;
        if (leader) {
          htmlContentAreas[i].children.push(leader[_symbol_utils.$toHTML](space).html);
          leader = null;
        }
        if (trailer) {
          htmlContentAreas[i].children.push(trailer[_symbol_utils.$toHTML](space).html);
          trailer = null;
        }
        const html = root[_symbol_utils.$toHTML](space);
        if (html.success) {
          if (html.html) {
            hasSomething ||= html.html.children?.length > 0;
            htmlContentAreas[i].children.push(html.html);
          } else if (!hasSomething && mainHtml.children.length > 1) {
            mainHtml.children.pop();
          }
          return mainHtml;
        }
        if (html.isBreak()) {
          const node = html.breakNode;
          flush(i);
          if (node.targetType === "auto") {
            continue;
          }
          if (node.leader) {
            leader = this[_symbol_utils.$searchNode](node.leader, node[_symbol_utils.$getParent]());
            leader = leader ? leader[0] : null;
          }
          if (node.trailer) {
            trailer = this[_symbol_utils.$searchNode](node.trailer, node[_symbol_utils.$getParent]());
            trailer = trailer ? trailer[0] : null;
          }
          if (node.targetType === "pageArea") {
            targetPageArea = node[_symbol_utils.$extra].target;
            i = Infinity;
          } else if (!node[_symbol_utils.$extra].target) {
            i = node[_symbol_utils.$extra].index;
          } else {
            targetPageArea = node[_symbol_utils.$extra].target;
            startIndex = node[_symbol_utils.$extra].index + 1;
            i = Infinity;
          }
          continue;
        }
        if (this[_symbol_utils.$extra].overflowNode) {
          const node = this[_symbol_utils.$extra].overflowNode;
          this[_symbol_utils.$extra].overflowNode = null;
          const overflowExtra = node[_symbol_utils.$getExtra]();
          const target = overflowExtra.target;
          overflowExtra.addLeader = overflowExtra.leader !== null;
          overflowExtra.addTrailer = overflowExtra.trailer !== null;
          flush(i);
          const currentIndex = i;
          i = Infinity;
          if (target instanceof PageArea) {
            targetPageArea = target;
          } else if (target instanceof ContentArea) {
            const index = contentAreas.indexOf(target);
            if (index !== -1) {
              if (index > currentIndex) {
                i = index - 1;
              } else {
                startIndex = index;
              }
            } else {
              targetPageArea = target[_symbol_utils.$getParent]();
              startIndex = targetPageArea.contentArea.children.indexOf(target);
            }
          }
          continue;
        }
        flush(i);
      }
      this[_symbol_utils.$extra].pageNumber += 1;
      if (targetPageArea) {
        if (targetPageArea[_symbol_utils.$isUsable]()) {
          targetPageArea[_symbol_utils.$extra].numberOfUse += 1;
        } else {
          targetPageArea = null;
        }
      }
      pageArea = targetPageArea || pageArea[_symbol_utils.$getNextPage]();
      yield null;
    }
  }
}
exports.Template = Template;
class Text extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "text");
    this.id = attributes.id || "";
    this.maxChars = (0, _utils.getInteger)({
      data: attributes.maxChars,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$acceptWhitespace]() {
    return true;
  }
  [_symbol_utils.$onChild](child) {
    if (child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_symbol_utils.$content] = child;
      return true;
    }
    (0, _util.warn)(`XFA - Invalid content in Text: ${child[_symbol_utils.$nodeName]}.`);
    return false;
  }
  [_symbol_utils.$onText](str) {
    if (this[_symbol_utils.$content] instanceof _xfa_object.XFAObject) {
      return;
    }
    super[_symbol_utils.$onText](str);
  }
  [_symbol_utils.$finalize]() {
    if (typeof this[_symbol_utils.$content] === "string") {
      this[_symbol_utils.$content] = this[_symbol_utils.$content].replaceAll("\r\n", "\n");
    }
  }
  [_symbol_utils.$getExtra]() {
    if (typeof this[_symbol_utils.$content] === "string") {
      return this[_symbol_utils.$content].split(/[\u2029\u2028\n]/).reduce((acc, line) => {
        if (line) {
          acc.push(line);
        }
        return acc;
      }, []).join("\n");
    }
    return this[_symbol_utils.$content][_symbol_utils.$text]();
  }
  [_symbol_utils.$toHTML](availableSpace) {
    if (typeof this[_symbol_utils.$content] === "string") {
      const html = valueToHtml(this[_symbol_utils.$content]).html;
      if (this[_symbol_utils.$content].includes("\u2029")) {
        html.name = "div";
        html.children = [];
        this[_symbol_utils.$content].split("\u2029").map(para => para.split(/[\u2028\n]/).reduce((acc, line) => {
          acc.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
          return acc;
        }, [])).forEach(lines => {
          html.children.push({
            name: "p",
            children: lines
          });
        });
      } else if (/[\u2028\n]/.test(this[_symbol_utils.$content])) {
        html.name = "div";
        html.children = [];
        this[_symbol_utils.$content].split(/[\u2028\n]/).forEach(line => {
          html.children.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
        });
      }
      return _utils.HTMLResult.success(html);
    }
    return this[_symbol_utils.$content][_symbol_utils.$toHTML](availableSpace);
  }
}
exports.Text = Text;
class TextEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "textEdit", true);
    this.allowRichText = (0, _utils.getInteger)({
      data: attributes.allowRichText,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.multiLine = (0, _utils.getInteger)({
      data: attributes.multiLine,
      defaultValue: "",
      validate: x => x === 0 || x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    let html;
    const field = this[_symbol_utils.$getParent]()[_symbol_utils.$getParent]();
    if (this.multiLine === "") {
      this.multiLine = field instanceof Draw ? 1 : 0;
    }
    if (this.multiLine === 1) {
      html = {
        name: "textarea",
        attributes: {
          dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
          fieldId: field[_symbol_utils.$uid],
          class: ["xfaTextfield"],
          style,
          "aria-label": ariaLabel(field),
          "aria-required": false
        }
      };
    } else {
      html = {
        name: "input",
        attributes: {
          type: "text",
          dataId: field[_symbol_utils.$data]?.[_symbol_utils.$uid] || field[_symbol_utils.$uid],
          fieldId: field[_symbol_utils.$uid],
          class: ["xfaTextfield"],
          style,
          "aria-label": ariaLabel(field),
          "aria-required": false
        }
      };
    }
    if (isRequired(field)) {
      html.attributes["aria-required"] = true;
      html.attributes.required = true;
    }
    return _utils.HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
}
class Time extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "time");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [_symbol_utils.$finalize]() {
    const date = this[_symbol_utils.$content].trim();
    this[_symbol_utils.$content] = date ? new Date(date) : null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return valueToHtml(this[_symbol_utils.$content] ? this[_symbol_utils.$content].toString() : "");
  }
}
class TimeStamp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "timeStamp");
    this.id = attributes.id || "";
    this.server = attributes.server || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class ToolTip extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "toolTip");
    this.id = attributes.id || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Traversal extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traversal", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.traverse = new _xfa_object.XFAObjectArray();
  }
}
class Traverse extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traverse", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.script = null;
  }
  get name() {
    return this.operation;
  }
  [_symbol_utils.$isTransparent]() {
    return false;
  }
}
class Ui extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ui", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }
  [_symbol_utils.$getExtra]() {
    if (this[_symbol_utils.$extra] === undefined) {
      for (const name of Object.getOwnPropertyNames(this)) {
        if (name === "extras" || name === "picture") {
          continue;
        }
        const obj = this[name];
        if (!(obj instanceof _xfa_object.XFAObject)) {
          continue;
        }
        this[_symbol_utils.$extra] = obj;
        return obj;
      }
      this[_symbol_utils.$extra] = null;
    }
    return this[_symbol_utils.$extra];
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const obj = this[_symbol_utils.$getExtra]();
    if (obj) {
      return obj[_symbol_utils.$toHTML](availableSpace);
    }
    return _utils.HTMLResult.EMPTY;
  }
}
class Validate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "validate", true);
    this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, ["warning", "disabled", "error"]);
    this.id = attributes.id || "";
    this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, ["error", "disabled", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }
}
class Value extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "value", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getInteger)({
      data: attributes.override,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }
  [_symbol_utils.$setValue](value) {
    const parent = this[_symbol_utils.$getParent]();
    if (parent instanceof Field) {
      if (parent.ui?.imageEdit) {
        if (!this.image) {
          this.image = new Image({});
          this[_symbol_utils.$appendChild](this.image);
        }
        this.image[_symbol_utils.$content] = value[_symbol_utils.$content];
        return;
      }
    }
    const valueName = value[_symbol_utils.$nodeName];
    if (this[valueName] !== null) {
      this[valueName][_symbol_utils.$content] = value[_symbol_utils.$content];
      return;
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (obj instanceof _xfa_object.XFAObject) {
        this[name] = null;
        this[_symbol_utils.$removeChild](obj);
      }
    }
    this[value[_symbol_utils.$nodeName]] = value;
    this[_symbol_utils.$appendChild](value);
  }
  [_symbol_utils.$text]() {
    if (this.exData) {
      if (typeof this.exData[_symbol_utils.$content] === "string") {
        return this.exData[_symbol_utils.$content].trim();
      }
      return this.exData[_symbol_utils.$content][_symbol_utils.$text]().trim();
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "image") {
        continue;
      }
      const obj = this[name];
      if (obj instanceof _xfa_object.XFAObject) {
        return (obj[_symbol_utils.$content] || "").toString().trim();
      }
    }
    return null;
  }
  [_symbol_utils.$toHTML](availableSpace) {
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }
      return obj[_symbol_utils.$toHTML](availableSpace);
    }
    return _utils.HTMLResult.EMPTY;
  }
}
exports.Value = Value;
class Variables extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "variables", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }
  [_symbol_utils.$isTransparent]() {
    return true;
  }
}
class TemplateNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (TemplateNamespace.hasOwnProperty(name)) {
      const node = TemplateNamespace[name](attributes);
      node[_symbol_utils.$setSetAttributes](attributes);
      return node;
    }
    return undefined;
  }
  static appearanceFilter(attrs) {
    return new AppearanceFilter(attrs);
  }
  static arc(attrs) {
    return new Arc(attrs);
  }
  static area(attrs) {
    return new Area(attrs);
  }
  static assist(attrs) {
    return new Assist(attrs);
  }
  static barcode(attrs) {
    return new Barcode(attrs);
  }
  static bind(attrs) {
    return new Bind(attrs);
  }
  static bindItems(attrs) {
    return new BindItems(attrs);
  }
  static bookend(attrs) {
    return new Bookend(attrs);
  }
  static boolean(attrs) {
    return new BooleanElement(attrs);
  }
  static border(attrs) {
    return new Border(attrs);
  }
  static break(attrs) {
    return new Break(attrs);
  }
  static breakAfter(attrs) {
    return new BreakAfter(attrs);
  }
  static breakBefore(attrs) {
    return new BreakBefore(attrs);
  }
  static button(attrs) {
    return new Button(attrs);
  }
  static calculate(attrs) {
    return new Calculate(attrs);
  }
  static caption(attrs) {
    return new Caption(attrs);
  }
  static certificate(attrs) {
    return new Certificate(attrs);
  }
  static certificates(attrs) {
    return new Certificates(attrs);
  }
  static checkButton(attrs) {
    return new CheckButton(attrs);
  }
  static choiceList(attrs) {
    return new ChoiceList(attrs);
  }
  static color(attrs) {
    return new Color(attrs);
  }
  static comb(attrs) {
    return new Comb(attrs);
  }
  static connect(attrs) {
    return new Connect(attrs);
  }
  static contentArea(attrs) {
    return new ContentArea(attrs);
  }
  static corner(attrs) {
    return new Corner(attrs);
  }
  static date(attrs) {
    return new DateElement(attrs);
  }
  static dateTime(attrs) {
    return new DateTime(attrs);
  }
  static dateTimeEdit(attrs) {
    return new DateTimeEdit(attrs);
  }
  static decimal(attrs) {
    return new Decimal(attrs);
  }
  static defaultUi(attrs) {
    return new DefaultUi(attrs);
  }
  static desc(attrs) {
    return new Desc(attrs);
  }
  static digestMethod(attrs) {
    return new DigestMethod(attrs);
  }
  static digestMethods(attrs) {
    return new DigestMethods(attrs);
  }
  static draw(attrs) {
    return new Draw(attrs);
  }
  static edge(attrs) {
    return new Edge(attrs);
  }
  static encoding(attrs) {
    return new Encoding(attrs);
  }
  static encodings(attrs) {
    return new Encodings(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt(attrs);
  }
  static encryptData(attrs) {
    return new EncryptData(attrs);
  }
  static encryption(attrs) {
    return new Encryption(attrs);
  }
  static encryptionMethod(attrs) {
    return new EncryptionMethod(attrs);
  }
  static encryptionMethods(attrs) {
    return new EncryptionMethods(attrs);
  }
  static event(attrs) {
    return new Event(attrs);
  }
  static exData(attrs) {
    return new ExData(attrs);
  }
  static exObject(attrs) {
    return new ExObject(attrs);
  }
  static exclGroup(attrs) {
    return new ExclGroup(attrs);
  }
  static execute(attrs) {
    return new Execute(attrs);
  }
  static extras(attrs) {
    return new Extras(attrs);
  }
  static field(attrs) {
    return new Field(attrs);
  }
  static fill(attrs) {
    return new Fill(attrs);
  }
  static filter(attrs) {
    return new Filter(attrs);
  }
  static float(attrs) {
    return new Float(attrs);
  }
  static font(attrs) {
    return new Font(attrs);
  }
  static format(attrs) {
    return new Format(attrs);
  }
  static handler(attrs) {
    return new Handler(attrs);
  }
  static hyphenation(attrs) {
    return new Hyphenation(attrs);
  }
  static image(attrs) {
    return new Image(attrs);
  }
  static imageEdit(attrs) {
    return new ImageEdit(attrs);
  }
  static integer(attrs) {
    return new Integer(attrs);
  }
  static issuers(attrs) {
    return new Issuers(attrs);
  }
  static items(attrs) {
    return new Items(attrs);
  }
  static keep(attrs) {
    return new Keep(attrs);
  }
  static keyUsage(attrs) {
    return new KeyUsage(attrs);
  }
  static line(attrs) {
    return new Line(attrs);
  }
  static linear(attrs) {
    return new Linear(attrs);
  }
  static lockDocument(attrs) {
    return new LockDocument(attrs);
  }
  static manifest(attrs) {
    return new Manifest(attrs);
  }
  static margin(attrs) {
    return new Margin(attrs);
  }
  static mdp(attrs) {
    return new Mdp(attrs);
  }
  static medium(attrs) {
    return new Medium(attrs);
  }
  static message(attrs) {
    return new Message(attrs);
  }
  static numericEdit(attrs) {
    return new NumericEdit(attrs);
  }
  static occur(attrs) {
    return new Occur(attrs);
  }
  static oid(attrs) {
    return new Oid(attrs);
  }
  static oids(attrs) {
    return new Oids(attrs);
  }
  static overflow(attrs) {
    return new Overflow(attrs);
  }
  static pageArea(attrs) {
    return new PageArea(attrs);
  }
  static pageSet(attrs) {
    return new PageSet(attrs);
  }
  static para(attrs) {
    return new Para(attrs);
  }
  static passwordEdit(attrs) {
    return new PasswordEdit(attrs);
  }
  static pattern(attrs) {
    return new Pattern(attrs);
  }
  static picture(attrs) {
    return new Picture(attrs);
  }
  static proto(attrs) {
    return new Proto(attrs);
  }
  static radial(attrs) {
    return new Radial(attrs);
  }
  static reason(attrs) {
    return new Reason(attrs);
  }
  static reasons(attrs) {
    return new Reasons(attrs);
  }
  static rectangle(attrs) {
    return new Rectangle(attrs);
  }
  static ref(attrs) {
    return new RefElement(attrs);
  }
  static script(attrs) {
    return new Script(attrs);
  }
  static setProperty(attrs) {
    return new SetProperty(attrs);
  }
  static signData(attrs) {
    return new SignData(attrs);
  }
  static signature(attrs) {
    return new Signature(attrs);
  }
  static signing(attrs) {
    return new Signing(attrs);
  }
  static solid(attrs) {
    return new Solid(attrs);
  }
  static speak(attrs) {
    return new Speak(attrs);
  }
  static stipple(attrs) {
    return new Stipple(attrs);
  }
  static subform(attrs) {
    return new Subform(attrs);
  }
  static subformSet(attrs) {
    return new SubformSet(attrs);
  }
  static subjectDN(attrs) {
    return new SubjectDN(attrs);
  }
  static subjectDNs(attrs) {
    return new SubjectDNs(attrs);
  }
  static submit(attrs) {
    return new Submit(attrs);
  }
  static template(attrs) {
    return new Template(attrs);
  }
  static text(attrs) {
    return new Text(attrs);
  }
  static textEdit(attrs) {
    return new TextEdit(attrs);
  }
  static time(attrs) {
    return new Time(attrs);
  }
  static timeStamp(attrs) {
    return new TimeStamp(attrs);
  }
  static toolTip(attrs) {
    return new ToolTip(attrs);
  }
  static traversal(attrs) {
    return new Traversal(attrs);
  }
  static traverse(attrs) {
    return new Traverse(attrs);
  }
  static ui(attrs) {
    return new Ui(attrs);
  }
  static validate(attrs) {
    return new Validate(attrs);
  }
  static value(attrs) {
    return new Value(attrs);
  }
  static variables(attrs) {
    return new Variables(attrs);
  }
}
exports.TemplateNamespace = TemplateNamespace;

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceIds = exports.$buildXFAObject = void 0;
const $buildXFAObject = Symbol();
exports.$buildXFAObject = $buildXFAObject;
const NamespaceIds = {
  config: {
    id: 0,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: ns => ns === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: ns => ns === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: ns => ns === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: ns => ns === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: ns => ns === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: ns => ns === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: ns => ns === "http://ns.adobe.com/xmpmeta/"
  }
};
exports.NamespaceIds = NamespaceIds;

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addHTML = addHTML;
exports.checkDimensions = checkDimensions;
exports.flushHTML = flushHTML;
exports.getAvailableSpace = getAvailableSpace;
var _symbol_utils = __w_pdfjs_require__(78);
var _html_utils = __w_pdfjs_require__(83);
function createLine(node, children) {
  return {
    name: "div",
    attributes: {
      class: [node.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
    },
    children
  };
}
function flushHTML(node) {
  if (!node[_symbol_utils.$extra]) {
    return null;
  }
  const attributes = node[_symbol_utils.$extra].attributes;
  const html = {
    name: "div",
    attributes,
    children: node[_symbol_utils.$extra].children
  };
  if (node[_symbol_utils.$extra].failingNode) {
    const htmlFromFailing = node[_symbol_utils.$extra].failingNode[_symbol_utils.$flushHTML]();
    if (htmlFromFailing) {
      if (node.layout.endsWith("-tb")) {
        html.children.push(createLine(node, [htmlFromFailing]));
      } else {
        html.children.push(htmlFromFailing);
      }
    }
  }
  if (html.children.length === 0) {
    return null;
  }
  return html;
}
function addHTML(node, html, bbox) {
  const extra = node[_symbol_utils.$extra];
  const availableSpace = extra.availableSpace;
  const [x, y, w, h] = bbox;
  switch (node.layout) {
    case "position":
      {
        extra.width = Math.max(extra.width, x + w);
        extra.height = Math.max(extra.height, y + h);
        extra.children.push(html);
        break;
      }
    case "lr-tb":
    case "rl-tb":
      if (!extra.line || extra.attempt === 1) {
        extra.line = createLine(node, []);
        extra.children.push(extra.line);
        extra.numberInLine = 0;
      }
      extra.numberInLine += 1;
      extra.line.children.push(html);
      if (extra.attempt === 0) {
        extra.currentWidth += w;
        extra.height = Math.max(extra.height, extra.prevHeight + h);
      } else {
        extra.currentWidth = w;
        extra.prevHeight = extra.height;
        extra.height += h;
        extra.attempt = 0;
      }
      extra.width = Math.max(extra.width, extra.currentWidth);
      break;
    case "rl-row":
    case "row":
      {
        extra.children.push(html);
        extra.width += w;
        extra.height = Math.max(extra.height, h);
        const height = (0, _html_utils.measureToString)(extra.height);
        for (const child of extra.children) {
          child.attributes.style.height = height;
        }
        break;
      }
    case "table":
      {
        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
        extra.height += h;
        extra.children.push(html);
        break;
      }
    case "tb":
      {
        extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
        extra.height += h;
        extra.children.push(html);
        break;
      }
  }
}
function getAvailableSpace(node) {
  const availableSpace = node[_symbol_utils.$extra].availableSpace;
  const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;
  const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;
  switch (node.layout) {
    case "lr-tb":
    case "rl-tb":
      if (node[_symbol_utils.$extra].attempt === 0) {
        return {
          width: availableSpace.width - marginH - node[_symbol_utils.$extra].currentWidth,
          height: availableSpace.height - marginV - node[_symbol_utils.$extra].prevHeight
        };
      }
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
      };
    case "rl-row":
    case "row":
      const width = node[_symbol_utils.$extra].columnWidths.slice(node[_symbol_utils.$extra].currentColumn).reduce((a, x) => a + x);
      return {
        width,
        height: availableSpace.height - marginH
      };
    case "table":
    case "tb":
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[_symbol_utils.$extra].height
      };
    case "position":
    default:
      return availableSpace;
  }
}
function getTransformedBBox(node) {
  let w = node.w === "" ? NaN : node.w;
  let h = node.h === "" ? NaN : node.h;
  let [centerX, centerY] = [0, 0];
  switch (node.anchorType || "") {
    case "bottomCenter":
      [centerX, centerY] = [w / 2, h];
      break;
    case "bottomLeft":
      [centerX, centerY] = [0, h];
      break;
    case "bottomRight":
      [centerX, centerY] = [w, h];
      break;
    case "middleCenter":
      [centerX, centerY] = [w / 2, h / 2];
      break;
    case "middleLeft":
      [centerX, centerY] = [0, h / 2];
      break;
    case "middleRight":
      [centerX, centerY] = [w, h / 2];
      break;
    case "topCenter":
      [centerX, centerY] = [w / 2, 0];
      break;
    case "topRight":
      [centerX, centerY] = [w, 0];
      break;
  }
  let x, y;
  switch (node.rotate || 0) {
    case 0:
      [x, y] = [-centerX, -centerY];
      break;
    case 90:
      [x, y] = [-centerY, centerX];
      [w, h] = [h, -w];
      break;
    case 180:
      [x, y] = [centerX, centerY];
      [w, h] = [-w, -h];
      break;
    case 270:
      [x, y] = [centerY, -centerX];
      [w, h] = [-h, w];
      break;
  }
  return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];
}
function checkDimensions(node, space) {
  if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].firstUnsplittable === null) {
    return true;
  }
  if (node.w === 0 || node.h === 0) {
    return true;
  }
  const ERROR = 2;
  const parent = node[_symbol_utils.$getSubformParent]();
  const attempt = parent[_symbol_utils.$extra]?.attempt || 0;
  const [, y, w, h] = getTransformedBBox(node);
  switch (parent.layout) {
    case "lr-tb":
    case "rl-tb":
      if (attempt === 0) {
        if (!node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
          if (node.h !== "" && Math.round(h - space.height) > ERROR) {
            return false;
          }
          if (node.w !== "") {
            if (Math.round(w - space.width) <= ERROR) {
              return true;
            }
            if (parent[_symbol_utils.$extra].numberInLine === 0) {
              return space.height > ERROR;
            }
            return false;
          }
          return space.width > ERROR;
        }
        if (node.w !== "") {
          return Math.round(w - space.width) <= ERROR;
        }
        return space.width > ERROR;
      }
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && Math.round(h - space.height) > ERROR) {
        return false;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > ERROR;
      }
      if (parent[_symbol_utils.$isThereMoreWidth]()) {
        return false;
      }
      return space.height > ERROR;
    case "table":
    case "tb":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && !node[_symbol_utils.$isSplittable]()) {
        return Math.round(h - space.height) <= ERROR;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > ERROR;
      }
      if (parent[_symbol_utils.$isThereMoreWidth]()) {
        return false;
      }
      return space.height > ERROR;
    case "position":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h === "" || Math.round(h + y - space.height) <= ERROR) {
        return true;
      }
      const area = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].currentContentArea;
      return h + y > area.h;
    case "rl-row":
    case "row":
      if (node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "") {
        return Math.round(h - space.height) <= ERROR;
      }
      return true;
    default:
      return true;
  }
}

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.computeBbox = computeBbox;
exports.createWrapper = createWrapper;
exports.fixDimensions = fixDimensions;
exports.fixTextIndent = fixTextIndent;
exports.fixURL = fixURL;
exports.isPrintOnly = isPrintOnly;
exports.layoutClass = layoutClass;
exports.layoutNode = layoutNode;
exports.measureToString = measureToString;
exports.setAccess = setAccess;
exports.setFontFamily = setFontFamily;
exports.setMinMaxDimensions = setMinMaxDimensions;
exports.setPara = setPara;
exports.toStyle = toStyle;
var _symbol_utils = __w_pdfjs_require__(78);
var _util = __w_pdfjs_require__(2);
var _utils = __w_pdfjs_require__(84);
var _fonts = __w_pdfjs_require__(85);
var _text = __w_pdfjs_require__(86);
var _xfa_object = __w_pdfjs_require__(87);
function measureToString(m) {
  if (typeof m === "string") {
    return "0px";
  }
  return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
}
const converters = {
  anchorType(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    if (!parent || parent.layout && parent.layout !== "position") {
      return;
    }
    if (!("transform" in style)) {
      style.transform = "";
    }
    switch (node.anchorType) {
      case "bottomCenter":
        style.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        style.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        style.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        style.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        style.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        style.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        style.transform += "translate(-50%,0)";
        break;
      case "topRight":
        style.transform += "translate(-100%,0)";
        break;
    }
  },
  dimensions(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    let width = node.w;
    const height = node.h;
    if (parent.layout?.includes("row")) {
      const extra = parent[_symbol_utils.$extra];
      const colSpan = node.colSpan;
      let w;
      if (colSpan === -1) {
        w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);
        extra.currentColumn = 0;
      } else {
        w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);
        extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;
      }
      if (!isNaN(w)) {
        width = node.w = w;
      }
    }
    style.width = width !== "" ? measureToString(width) : "auto";
    style.height = height !== "" ? measureToString(height) : "auto";
  },
  position(node, style) {
    const parent = node[_symbol_utils.$getSubformParent]();
    if (parent?.layout && parent.layout !== "position") {
      return;
    }
    style.position = "absolute";
    style.left = measureToString(node.x);
    style.top = measureToString(node.y);
  },
  rotate(node, style) {
    if (node.rotate) {
      if (!("transform" in style)) {
        style.transform = "";
      }
      style.transform += `rotate(-${node.rotate}deg)`;
      style.transformOrigin = "top left";
    }
  },
  presence(node, style) {
    switch (node.presence) {
      case "invisible":
        style.visibility = "hidden";
        break;
      case "hidden":
      case "inactive":
        style.display = "none";
        break;
    }
  },
  hAlign(node, style) {
    if (node[_symbol_utils.$nodeName] === "para") {
      switch (node.hAlign) {
        case "justifyAll":
          style.textAlign = "justify-all";
          break;
        case "radix":
          style.textAlign = "left";
          break;
        default:
          style.textAlign = node.hAlign;
      }
    } else {
      switch (node.hAlign) {
        case "left":
          style.alignSelf = "start";
          break;
        case "center":
          style.alignSelf = "center";
          break;
        case "right":
          style.alignSelf = "end";
          break;
      }
    }
  },
  margin(node, style) {
    if (node.margin) {
      style.margin = node.margin[_symbol_utils.$toStyle]().margin;
    }
  }
};
function setMinMaxDimensions(node, style) {
  const parent = node[_symbol_utils.$getSubformParent]();
  if (parent.layout === "position") {
    if (node.minW > 0) {
      style.minWidth = measureToString(node.minW);
    }
    if (node.maxW > 0) {
      style.maxWidth = measureToString(node.maxW);
    }
    if (node.minH > 0) {
      style.minHeight = measureToString(node.minH);
    }
    if (node.maxH > 0) {
      style.maxHeight = measureToString(node.maxH);
    }
  }
}
function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {
  const measure = new _text.TextMeasure(xfaFont, margin, lineHeight, fontFinder);
  if (typeof text === "string") {
    measure.addString(text);
  } else {
    text[_symbol_utils.$pushGlyphs](measure);
  }
  return measure.compute(width);
}
function layoutNode(node, availableSpace) {
  let height = null;
  let width = null;
  let isBroken = false;
  if ((!node.w || !node.h) && node.value) {
    let marginH = 0;
    let marginV = 0;
    if (node.margin) {
      marginH = node.margin.leftInset + node.margin.rightInset;
      marginV = node.margin.topInset + node.margin.bottomInset;
    }
    let lineHeight = null;
    let margin = null;
    if (node.para) {
      margin = Object.create(null);
      lineHeight = node.para.lineHeight === "" ? null : node.para.lineHeight;
      margin.top = node.para.spaceAbove === "" ? 0 : node.para.spaceAbove;
      margin.bottom = node.para.spaceBelow === "" ? 0 : node.para.spaceBelow;
      margin.left = node.para.marginLeft === "" ? 0 : node.para.marginLeft;
      margin.right = node.para.marginRight === "" ? 0 : node.para.marginRight;
    }
    let font = node.font;
    if (!font) {
      const root = node[_symbol_utils.$getTemplateRoot]();
      let parent = node[_symbol_utils.$getParent]();
      while (parent && parent !== root) {
        if (parent.font) {
          font = parent.font;
          break;
        }
        parent = parent[_symbol_utils.$getParent]();
      }
    }
    const maxWidth = (node.w || availableSpace.width) - marginH;
    const fontFinder = node[_symbol_utils.$globalData].fontFinder;
    if (node.value.exData && node.value.exData[_symbol_utils.$content] && node.value.exData.contentType === "text/html") {
      const res = layoutText(node.value.exData[_symbol_utils.$content], font, margin, lineHeight, fontFinder, maxWidth);
      width = res.width;
      height = res.height;
      isBroken = res.isBroken;
    } else {
      const text = node.value[_symbol_utils.$text]();
      if (text) {
        const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);
        width = res.width;
        height = res.height;
        isBroken = res.isBroken;
      }
    }
    if (width !== null && !node.w) {
      width += marginH;
    }
    if (height !== null && !node.h) {
      height += marginV;
    }
  }
  return {
    w: width,
    h: height,
    isBroken
  };
}
function computeBbox(node, html, availableSpace) {
  let bbox;
  if (node.w !== "" && node.h !== "") {
    bbox = [node.x, node.y, node.w, node.h];
  } else {
    if (!availableSpace) {
      return null;
    }
    let width = node.w;
    if (width === "") {
      if (node.maxW === 0) {
        const parent = node[_symbol_utils.$getSubformParent]();
        width = parent.layout === "position" && parent.w !== "" ? 0 : node.minW;
      } else {
        width = Math.min(node.maxW, availableSpace.width);
      }
      html.attributes.style.width = measureToString(width);
    }
    let height = node.h;
    if (height === "") {
      if (node.maxH === 0) {
        const parent = node[_symbol_utils.$getSubformParent]();
        height = parent.layout === "position" && parent.h !== "" ? 0 : node.minH;
      } else {
        height = Math.min(node.maxH, availableSpace.height);
      }
      html.attributes.style.height = measureToString(height);
    }
    bbox = [node.x, node.y, width, height];
  }
  return bbox;
}
function fixDimensions(node) {
  const parent = node[_symbol_utils.$getSubformParent]();
  if (parent.layout?.includes("row")) {
    const extra = parent[_symbol_utils.$extra];
    const colSpan = node.colSpan;
    let width;
    if (colSpan === -1) {
      width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);
    } else {
      width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);
    }
    if (!isNaN(width)) {
      node.w = width;
    }
  }
  if (parent.layout && parent.layout !== "position") {
    node.x = node.y = 0;
  }
  if (node.layout === "table") {
    if (node.w === "" && Array.isArray(node.columnWidths)) {
      node.w = node.columnWidths.reduce((a, x) => a + x, 0);
    }
  }
}
function layoutClass(node) {
  switch (node.layout) {
    case "position":
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
    default:
      return "xfaPosition";
  }
}
function toStyle(node, ...names) {
  const style = Object.create(null);
  for (const name of names) {
    const value = node[name];
    if (value === null) {
      continue;
    }
    if (converters.hasOwnProperty(name)) {
      converters[name](node, style);
      continue;
    }
    if (value instanceof _xfa_object.XFAObject) {
      const newStyle = value[_symbol_utils.$toStyle]();
      if (newStyle) {
        Object.assign(style, newStyle);
      } else {
        (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`);
      }
    }
  }
  return style;
}
function createWrapper(node, html) {
  const {
    attributes
  } = html;
  const {
    style
  } = attributes;
  const wrapper = {
    name: "div",
    attributes: {
      class: ["xfaWrapper"],
      style: Object.create(null)
    },
    children: []
  };
  attributes.class.push("xfaWrapped");
  if (node.border) {
    const {
      widths,
      insets
    } = node.border[_symbol_utils.$extra];
    let width, height;
    let top = insets[0];
    let left = insets[3];
    const insetsH = insets[0] + insets[2];
    const insetsW = insets[1] + insets[3];
    switch (node.border.hand) {
      case "even":
        top -= widths[0] / 2;
        left -= widths[3] / 2;
        width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;
        height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;
        break;
      case "left":
        top -= widths[0];
        left -= widths[3];
        width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;
        height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;
        break;
      case "right":
        width = insetsW ? `calc(100% - ${insetsW}px)` : "100%";
        height = insetsH ? `calc(100% - ${insetsH}px)` : "100%";
        break;
    }
    const classNames = ["xfaBorder"];
    if (isPrintOnly(node.border)) {
      classNames.push("xfaPrintOnly");
    }
    const border = {
      name: "div",
      attributes: {
        class: classNames,
        style: {
          top: `${top}px`,
          left: `${left}px`,
          width,
          height
        }
      },
      children: []
    };
    for (const key of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) {
      if (style[key] !== undefined) {
        border.attributes.style[key] = style[key];
        delete style[key];
      }
    }
    wrapper.children.push(border, html);
  } else {
    wrapper.children.push(html);
  }
  for (const key of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) {
    if (style[key] !== undefined) {
      wrapper.attributes.style[key] = style[key];
      delete style[key];
    }
  }
  wrapper.attributes.style.position = style.position === "absolute" ? "absolute" : "relative";
  delete style.position;
  if (style.alignSelf) {
    wrapper.attributes.style.alignSelf = style.alignSelf;
    delete style.alignSelf;
  }
  return wrapper;
}
function fixTextIndent(styles) {
  const indent = (0, _utils.getMeasurement)(styles.textIndent, "0px");
  if (indent >= 0) {
    return;
  }
  const align = styles.textAlign === "right" ? "right" : "left";
  const name = "padding" + (align === "left" ? "Left" : "Right");
  const padding = (0, _utils.getMeasurement)(styles[name], "0px");
  styles[name] = `${padding - indent}px`;
}
function setAccess(node, classNames) {
  switch (node.access) {
    case "nonInteractive":
      classNames.push("xfaNonInteractive");
      break;
    case "readOnly":
      classNames.push("xfaReadOnly");
      break;
    case "protected":
      classNames.push("xfaDisabled");
      break;
  }
}
function isPrintOnly(node) {
  return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === "print";
}
function getCurrentPara(node) {
  const stack = node[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack;
  return stack.length ? stack.at(-1) : null;
}
function setPara(node, nodeStyle, value) {
  if (value.attributes.class?.includes("xfaRich")) {
    if (nodeStyle) {
      if (node.h === "") {
        nodeStyle.height = "auto";
      }
      if (node.w === "") {
        nodeStyle.width = "auto";
      }
    }
    const para = getCurrentPara(node);
    if (para) {
      const valueStyle = value.attributes.style;
      valueStyle.display = "flex";
      valueStyle.flexDirection = "column";
      switch (para.vAlign) {
        case "top":
          valueStyle.justifyContent = "start";
          break;
        case "bottom":
          valueStyle.justifyContent = "end";
          break;
        case "middle":
          valueStyle.justifyContent = "center";
          break;
      }
      const paraStyle = para[_symbol_utils.$toStyle]();
      for (const [key, val] of Object.entries(paraStyle)) {
        if (!(key in valueStyle)) {
          valueStyle[key] = val;
        }
      }
    }
  }
}
function setFontFamily(xfaFont, node, fontFinder, style) {
  if (!fontFinder) {
    delete style.fontFamily;
    return;
  }
  const name = (0, _utils.stripQuotes)(xfaFont.typeface);
  style.fontFamily = `"${name}"`;
  const typeface = fontFinder.find(name);
  if (typeface) {
    const {
      fontFamily
    } = typeface.regular.cssFontInfo;
    if (fontFamily !== name) {
      style.fontFamily = `"${fontFamily}"`;
    }
    const para = getCurrentPara(node);
    if (para && para.lineHeight !== "") {
      return;
    }
    if (style.lineHeight) {
      return;
    }
    const pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
    if (pdfFont) {
      style.lineHeight = Math.max(1.2, pdfFont.lineHeight);
    }
  }
}
function fixURL(str) {
  const absoluteUrl = (0, _util.createValidAbsoluteUrl)(str, null, {
    addDefaultProtocol: true,
    tryConvertEncoding: true
  });
  return absoluteUrl ? absoluteUrl.href : null;
}

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HTMLResult = void 0;
exports.getBBox = getBBox;
exports.getColor = getColor;
exports.getFloat = getFloat;
exports.getInteger = getInteger;
exports.getKeyword = getKeyword;
exports.getMeasurement = getMeasurement;
exports.getRatio = getRatio;
exports.getRelevant = getRelevant;
exports.getStringOption = getStringOption;
exports.stripQuotes = stripQuotes;
var _util = __w_pdfjs_require__(2);
const dimConverters = {
  pt: x => x,
  cm: x => x / 2.54 * 72,
  mm: x => x / (10 * 2.54) * 72,
  in: x => x * 72,
  px: x => x
};
const measurementPattern = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(str) {
  if (str.startsWith("'") || str.startsWith('"')) {
    return str.slice(1, -1);
  }
  return str;
}
function getInteger({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseInt(data, 10);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getFloat({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseFloat(data);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getKeyword({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  if (validate(data)) {
    return data;
  }
  return defaultValue;
}
function getStringOption(data, options) {
  return getKeyword({
    data,
    defaultValue: options[0],
    validate: k => options.includes(k)
  });
}
function getMeasurement(str, def = "0") {
  def ||= "0";
  if (!str) {
    return getMeasurement(def);
  }
  const match = str.trim().match(measurementPattern);
  if (!match) {
    return getMeasurement(def);
  }
  const [, valueStr, unit] = match;
  const value = parseFloat(valueStr);
  if (isNaN(value)) {
    return getMeasurement(def);
  }
  if (value === 0) {
    return 0;
  }
  const conv = dimConverters[unit];
  if (conv) {
    return conv(value);
  }
  return value;
}
function getRatio(data) {
  if (!data) {
    return {
      num: 1,
      den: 1
    };
  }
  const ratio = data.trim().split(/\s*:\s*/).map(x => parseFloat(x)).filter(x => !isNaN(x));
  if (ratio.length === 1) {
    ratio.push(1);
  }
  if (ratio.length === 0) {
    return {
      num: 1,
      den: 1
    };
  }
  const [num, den] = ratio;
  return {
    num,
    den
  };
}
function getRelevant(data) {
  if (!data) {
    return [];
  }
  return data.trim().split(/\s+/).map(e => {
    return {
      excluded: e[0] === "-",
      viewname: e.substring(1)
    };
  });
}
function getColor(data, def = [0, 0, 0]) {
  let [r, g, b] = def;
  if (!data) {
    return {
      r,
      g,
      b
    };
  }
  const color = data.trim().split(/\s*,\s*/).map(c => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map(c => isNaN(c) ? 0 : c);
  if (color.length < 3) {
    return {
      r,
      g,
      b
    };
  }
  [r, g, b] = color;
  return {
    r,
    g,
    b
  };
}
function getBBox(data) {
  const def = -1;
  if (!data) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const bbox = data.trim().split(/\s*,\s*/).map(m => getMeasurement(m, "-1"));
  if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const [x, y, width, height] = bbox;
  return {
    x,
    y,
    width,
    height
  };
}
class HTMLResult {
  static get FAILURE() {
    return (0, _util.shadow)(this, "FAILURE", new HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return (0, _util.shadow)(this, "EMPTY", new HTMLResult(true, null, null, null));
  }
  constructor(success, html, bbox, breakNode) {
    this.success = success;
    this.html = html;
    this.bbox = bbox;
    this.breakNode = breakNode;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(node) {
    return new HTMLResult(false, null, null, node);
  }
  static success(html, bbox = null) {
    return new HTMLResult(true, html, bbox, null);
  }
}
exports.HTMLResult = HTMLResult;

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontFinder = void 0;
exports.getMetrics = getMetrics;
exports.selectFont = selectFont;
var _symbol_utils = __w_pdfjs_require__(78);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
class FontFinder {
  constructor(pdfFonts) {
    this.fonts = new Map();
    this.cache = new Map();
    this.warned = new Set();
    this.defaultFont = null;
    this.add(pdfFonts);
  }
  add(pdfFonts, reallyMissingFonts = null) {
    for (const pdfFont of pdfFonts) {
      this.addPdfFont(pdfFont);
    }
    for (const pdfFont of this.fonts.values()) {
      if (!pdfFont.regular) {
        pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;
      }
    }
    if (!reallyMissingFonts || reallyMissingFonts.size === 0) {
      return;
    }
    const myriad = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const missing of reallyMissingFonts) {
      this.fonts.set(missing, myriad);
    }
  }
  addPdfFont(pdfFont) {
    const cssFontInfo = pdfFont.cssFontInfo;
    const name = cssFontInfo.fontFamily;
    let font = this.fonts.get(name);
    if (!font) {
      font = Object.create(null);
      this.fonts.set(name, font);
      if (!this.defaultFont) {
        this.defaultFont = font;
      }
    }
    let property = "";
    const fontWeight = parseFloat(cssFontInfo.fontWeight);
    if (parseFloat(cssFontInfo.italicAngle) !== 0) {
      property = fontWeight >= 700 ? "bolditalic" : "italic";
    } else if (fontWeight >= 700) {
      property = "bold";
    }
    if (!property) {
      if (pdfFont.name.includes("Bold") || pdfFont.psName?.includes("Bold")) {
        property = "bold";
      }
      if (pdfFont.name.includes("Italic") || pdfFont.name.endsWith("It") || pdfFont.psName?.includes("Italic") || pdfFont.psName?.endsWith("It")) {
        property += "italic";
      }
    }
    if (!property) {
      property = "regular";
    }
    font[property] = pdfFont;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(fontName, mustWarn = true) {
    let font = this.fonts.get(fontName) || this.cache.get(fontName);
    if (font) {
      return font;
    }
    const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let name = fontName.replaceAll(pattern, "");
    font = this.fonts.get(name);
    if (font) {
      this.cache.set(fontName, font);
      return font;
    }
    name = name.toLowerCase();
    const maybe = [];
    for (const [family, pdfFont] of this.fonts.entries()) {
      if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
        maybe.push(pdfFont);
      }
    }
    if (maybe.length === 0) {
      for (const [, pdfFont] of this.fonts.entries()) {
        if (pdfFont.regular.name?.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      name = name.replaceAll(/psmt|mt/gi, "");
      for (const [family, pdfFont] of this.fonts.entries()) {
        if (family.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      for (const pdfFont of this.fonts.values()) {
        if (pdfFont.regular.name?.replaceAll(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length >= 1) {
      if (maybe.length !== 1 && mustWarn) {
        (0, _util.warn)(`XFA - Too many choices to guess the correct font: ${fontName}`);
      }
      this.cache.set(fontName, maybe[0]);
      return maybe[0];
    }
    if (mustWarn && !this.warned.has(fontName)) {
      this.warned.add(fontName);
      (0, _util.warn)(`XFA - Cannot find the font: ${fontName}`);
    }
    return null;
  }
}
exports.FontFinder = FontFinder;
function selectFont(xfaFont, typeface) {
  if (xfaFont.posture === "italic") {
    if (xfaFont.weight === "bold") {
      return typeface.bolditalic;
    }
    return typeface.italic;
  } else if (xfaFont.weight === "bold") {
    return typeface.bold;
  }
  return typeface.regular;
}
function getMetrics(xfaFont, real = false) {
  let pdfFont = null;
  if (xfaFont) {
    const name = (0, _utils.stripQuotes)(xfaFont.typeface);
    const typeface = xfaFont[_symbol_utils.$globalData].fontFinder.find(name);
    pdfFont = selectFont(xfaFont, typeface);
  }
  if (!pdfFont) {
    return {
      lineHeight: 12,
      lineGap: 2,
      lineNoGap: 10
    };
  }
  const size = xfaFont.size || 10;
  const lineHeight = pdfFont.lineHeight ? Math.max(real ? 0 : 1.2, pdfFont.lineHeight) : 1.2;
  const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;
  return {
    lineHeight: lineHeight * size,
    lineGap: lineGap * size,
    lineNoGap: Math.max(1, lineHeight - lineGap) * size
  };
}

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextMeasure = void 0;
var _fonts = __w_pdfjs_require__(85);
const WIDTH_FACTOR = 1.02;
class FontInfo {
  constructor(xfaFont, margin, lineHeight, fontFinder) {
    this.lineHeight = lineHeight;
    this.paraMargin = margin || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    if (!xfaFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.xfaFont = {
      typeface: xfaFont.typeface,
      posture: xfaFont.posture,
      weight: xfaFont.weight,
      size: xfaFont.size,
      letterSpacing: xfaFont.letterSpacing
    };
    const typeface = fontFinder.find(xfaFont.typeface);
    if (!typeface) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.pdfFont = (0, _fonts.selectFont)(xfaFont, typeface);
    if (!this.pdfFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
    }
  }
  defaultFont(fontFinder) {
    const font = fontFinder.find("Helvetica", false) || fontFinder.find("Myriad Pro", false) || fontFinder.find("Arial", false) || fontFinder.getDefault();
    if (font?.regular) {
      const pdfFont = font.regular;
      const info = pdfFont.cssFontInfo;
      const xfaFont = {
        typeface: info.fontFamily,
        posture: "normal",
        weight: "normal",
        size: 10,
        letterSpacing: 0
      };
      return [pdfFont, xfaFont];
    }
    const xfaFont = {
      typeface: "Courier",
      posture: "normal",
      weight: "normal",
      size: 10,
      letterSpacing: 0
    };
    return [null, xfaFont];
  }
}
class FontSelector {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {
    this.fontFinder = fontFinder;
    this.stack = [new FontInfo(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];
  }
  pushData(xfaFont, margin, lineHeight) {
    const lastFont = this.stack.at(-1);
    for (const name of ["typeface", "posture", "weight", "size", "letterSpacing"]) {
      if (!xfaFont[name]) {
        xfaFont[name] = lastFont.xfaFont[name];
      }
    }
    for (const name of ["top", "bottom", "left", "right"]) {
      if (isNaN(margin[name])) {
        margin[name] = lastFont.paraMargin[name];
      }
    }
    const fontInfo = new FontInfo(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);
    if (!fontInfo.pdfFont) {
      fontInfo.pdfFont = lastFont.pdfFont;
    }
    this.stack.push(fontInfo);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class TextMeasure {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {
    this.glyphs = [];
    this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);
    this.extraHeight = 0;
  }
  pushData(xfaFont, margin, lineHeight) {
    this.fontSelector.pushData(xfaFont, margin, lineHeight);
  }
  popFont(xfaFont) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const lastFont = this.fontSelector.topFont();
    this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;
  }
  addString(str) {
    if (!str) {
      return;
    }
    const lastFont = this.fontSelector.topFont();
    const fontSize = lastFont.xfaFont.size;
    if (lastFont.pdfFont) {
      const letterSpacing = lastFont.xfaFont.letterSpacing;
      const pdfFont = lastFont.pdfFont;
      const fontLineHeight = pdfFont.lineHeight || 1.2;
      const lineHeight = lastFont.lineHeight || Math.max(1.2, fontLineHeight) * fontSize;
      const lineGap = pdfFont.lineGap === undefined ? 0.2 : pdfFont.lineGap;
      const noGap = fontLineHeight - lineGap;
      const firstLineHeight = Math.max(1, noGap) * fontSize;
      const scale = fontSize / 1000;
      const fallbackWidth = pdfFont.defaultWidth || pdfFont.charsToGlyphs(" ")[0].width;
      for (const line of str.split(/[\u2029\n]/)) {
        const encodedLine = pdfFont.encodeString(line).join("");
        const glyphs = pdfFont.charsToGlyphs(encodedLine);
        for (const glyph of glyphs) {
          const width = glyph.width || fallbackWidth;
          this.glyphs.push([width * scale + letterSpacing, lineHeight, firstLineHeight, glyph.unicode, false]);
        }
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
      return;
    }
    for (const line of str.split(/[\u2029\n]/)) {
      for (const char of line.split("")) {
        this.glyphs.push([fontSize, 1.2 * fontSize, fontSize, char, false]);
      }
      this.glyphs.push([0, 0, 0, "\n", true]);
    }
    this.glyphs.pop();
  }
  compute(maxWidth) {
    let lastSpacePos = -1,
      lastSpaceWidth = 0,
      width = 0,
      height = 0,
      currentLineWidth = 0,
      currentLineHeight = 0;
    let isBroken = false;
    let isFirstLine = true;
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      const [glyphWidth, lineHeight, firstLineHeight, char, isEOL] = this.glyphs[i];
      const isSpace = char === " ";
      const glyphHeight = isFirstLine ? firstLineHeight : lineHeight;
      if (isEOL) {
        width = Math.max(width, currentLineWidth);
        currentLineWidth = 0;
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        lastSpacePos = -1;
        lastSpaceWidth = 0;
        isFirstLine = false;
        continue;
      }
      if (isSpace) {
        if (currentLineWidth + glyphWidth > maxWidth) {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = 0;
          height += currentLineHeight;
          currentLineHeight = glyphHeight;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
          isBroken = true;
          isFirstLine = false;
        } else {
          currentLineHeight = Math.max(glyphHeight, currentLineHeight);
          lastSpaceWidth = currentLineWidth;
          currentLineWidth += glyphWidth;
          lastSpacePos = i;
        }
        continue;
      }
      if (currentLineWidth + glyphWidth > maxWidth) {
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        if (lastSpacePos !== -1) {
          i = lastSpacePos;
          width = Math.max(width, lastSpaceWidth);
          currentLineWidth = 0;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
        } else {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = glyphWidth;
        }
        isBroken = true;
        isFirstLine = false;
        continue;
      }
      currentLineWidth += glyphWidth;
      currentLineHeight = Math.max(glyphHeight, currentLineHeight);
    }
    width = Math.max(width, currentLineWidth);
    height += currentLineHeight + this.extraHeight;
    return {
      width: WIDTH_FACTOR * width,
      height,
      isBroken
    };
  }
}
exports.TextMeasure = TextMeasure;

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XmlObject = exports.XFAObjectArray = exports.XFAObject = exports.XFAAttribute = exports.StringObject = exports.OptionObject = exports.Option10 = exports.Option01 = exports.IntegerObject = exports.ContentObject = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _namespaces = __w_pdfjs_require__(81);
var _som = __w_pdfjs_require__(88);
const _applyPrototype = Symbol();
const _attributes = Symbol();
const _attributeNames = Symbol();
const _children = Symbol("_children");
const _cloneAttribute = Symbol();
const _dataValue = Symbol();
const _defaultValue = Symbol();
const _filteredChildrenGenerator = Symbol();
const _getPrototype = Symbol();
const _getUnsetAttributes = Symbol();
const _hasChildren = Symbol();
const _max = Symbol();
const _options = Symbol();
const _parent = Symbol("parent");
const _resolvePrototypesHelper = Symbol();
const _setAttributes = Symbol();
const _validator = Symbol();
let uid = 0;
const NS_DATASETS = _namespaces.NamespaceIds.datasets.id;
class XFAObject {
  constructor(nsId, name, hasChildren = false) {
    this[_symbol_utils.$namespaceId] = nsId;
    this[_symbol_utils.$nodeName] = name;
    this[_hasChildren] = hasChildren;
    this[_parent] = null;
    this[_children] = [];
    this[_symbol_utils.$uid] = `${name}${uid++}`;
    this[_symbol_utils.$globalData] = null;
  }
  get isXFAObject() {
    return true;
  }
  get isXFAObjectArray() {
    return false;
  }
  createNodes(path) {
    let root = this,
      node = null;
    for (const {
      name,
      index
    } of path) {
      for (let i = 0, ii = isFinite(index) ? index : 0; i <= ii; i++) {
        const nsId = root[_symbol_utils.$namespaceId] === NS_DATASETS ? -1 : root[_symbol_utils.$namespaceId];
        node = new XmlObject(nsId, name);
        root[_symbol_utils.$appendChild](node);
      }
      root = node;
    }
    return node;
  }
  [_symbol_utils.$onChild](child) {
    if (!this[_hasChildren] || !this[_symbol_utils.$onChildCheck](child)) {
      return false;
    }
    const name = child[_symbol_utils.$nodeName];
    const node = this[name];
    if (node instanceof XFAObjectArray) {
      if (node.push(child)) {
        this[_symbol_utils.$appendChild](child);
        return true;
      }
    } else {
      if (node !== null) {
        this[_symbol_utils.$removeChild](node);
      }
      this[name] = child;
      this[_symbol_utils.$appendChild](child);
      return true;
    }
    let id = "";
    if (this.id) {
      id = ` (id: ${this.id})`;
    } else if (this.name) {
      id = ` (name: ${this.name} ${this.h.value})`;
    }
    (0, _util.warn)(`XFA - node "${this[_symbol_utils.$nodeName]}"${id} has already enough "${name}"!`);
    return false;
  }
  [_symbol_utils.$onChildCheck](child) {
    return this.hasOwnProperty(child[_symbol_utils.$nodeName]) && child[_symbol_utils.$namespaceId] === this[_symbol_utils.$namespaceId];
  }
  [_symbol_utils.$isNsAgnostic]() {
    return false;
  }
  [_symbol_utils.$acceptWhitespace]() {
    return false;
  }
  [_symbol_utils.$isCDATAXml]() {
    return false;
  }
  [_symbol_utils.$isBindable]() {
    return false;
  }
  [_symbol_utils.$popPara]() {
    if (this.para) {
      this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.pop();
    }
  }
  [_symbol_utils.$pushPara]() {
    this[_symbol_utils.$getTemplateRoot]()[_symbol_utils.$extra].paraStack.push(this.para);
  }
  [_symbol_utils.$setId](ids) {
    if (this.id && this[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.template.id) {
      ids.set(this.id, this);
    }
  }
  [_symbol_utils.$getTemplateRoot]() {
    return this[_symbol_utils.$globalData].template;
  }
  [_symbol_utils.$isSplittable]() {
    return false;
  }
  [_symbol_utils.$isThereMoreWidth]() {
    return false;
  }
  [_symbol_utils.$appendChild](child) {
    child[_parent] = this;
    this[_children].push(child);
    if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
      child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
    }
  }
  [_symbol_utils.$removeChild](child) {
    const i = this[_children].indexOf(child);
    this[_children].splice(i, 1);
  }
  [_symbol_utils.$hasSettableValue]() {
    return this.hasOwnProperty("value");
  }
  [_symbol_utils.$setValue](_) {}
  [_symbol_utils.$onText](_) {}
  [_symbol_utils.$finalize]() {}
  [_symbol_utils.$clean](builder) {
    delete this[_hasChildren];
    if (this[_symbol_utils.$cleanup]) {
      builder.clean(this[_symbol_utils.$cleanup]);
      delete this[_symbol_utils.$cleanup];
    }
  }
  [_symbol_utils.$indexOf](child) {
    return this[_children].indexOf(child);
  }
  [_symbol_utils.$insertAt](i, child) {
    child[_parent] = this;
    this[_children].splice(i, 0, child);
    if (!child[_symbol_utils.$globalData] && this[_symbol_utils.$globalData]) {
      child[_symbol_utils.$globalData] = this[_symbol_utils.$globalData];
    }
  }
  [_symbol_utils.$isTransparent]() {
    return !this.name;
  }
  [_symbol_utils.$lastAttribute]() {
    return "";
  }
  [_symbol_utils.$text]() {
    if (this[_children].length === 0) {
      return this[_symbol_utils.$content];
    }
    return this[_children].map(c => c[_symbol_utils.$text]()).join("");
  }
  get [_attributeNames]() {
    const proto = Object.getPrototypeOf(this);
    if (!proto._attributes) {
      const attributes = proto._attributes = new Set();
      for (const name of Object.getOwnPropertyNames(this)) {
        if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) {
          break;
        }
        attributes.add(name);
      }
    }
    return (0, _util.shadow)(this, _attributeNames, proto._attributes);
  }
  [_symbol_utils.$isDescendent](parent) {
    let node = this;
    while (node) {
      if (node === parent) {
        return true;
      }
      node = node[_symbol_utils.$getParent]();
    }
    return false;
  }
  [_symbol_utils.$getParent]() {
    return this[_parent];
  }
  [_symbol_utils.$getSubformParent]() {
    return this[_symbol_utils.$getParent]();
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[name];
  }
  [_symbol_utils.$dump]() {
    const dumped = Object.create(null);
    if (this[_symbol_utils.$content]) {
      dumped.$content = this[_symbol_utils.$content];
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const value = this[name];
      if (value === null) {
        continue;
      }
      if (value instanceof XFAObject) {
        dumped[name] = value[_symbol_utils.$dump]();
      } else if (value instanceof XFAObjectArray) {
        if (!value.isEmpty()) {
          dumped[name] = value.dump();
        }
      } else {
        dumped[name] = value;
      }
    }
    return dumped;
  }
  [_symbol_utils.$toStyle]() {
    return null;
  }
  [_symbol_utils.$toHTML]() {
    return _utils.HTMLResult.EMPTY;
  }
  *[_symbol_utils.$getContainedChildren]() {
    for (const node of this[_symbol_utils.$getChildren]()) {
      yield node;
    }
  }
  *[_filteredChildrenGenerator](filter, include) {
    for (const node of this[_symbol_utils.$getContainedChildren]()) {
      if (!filter || include === filter.has(node[_symbol_utils.$nodeName])) {
        const availableSpace = this[_symbol_utils.$getAvailableSpace]();
        const res = node[_symbol_utils.$toHTML](availableSpace);
        if (!res.success) {
          this[_symbol_utils.$extra].failingNode = node;
        }
        yield res;
      }
    }
  }
  [_symbol_utils.$flushHTML]() {
    return null;
  }
  [_symbol_utils.$addHTML](html, bbox) {
    this[_symbol_utils.$extra].children.push(html);
  }
  [_symbol_utils.$getAvailableSpace]() {}
  [_symbol_utils.$childrenToHTML]({
    filter = null,
    include = true
  }) {
    if (!this[_symbol_utils.$extra].generator) {
      this[_symbol_utils.$extra].generator = this[_filteredChildrenGenerator](filter, include);
    } else {
      const availableSpace = this[_symbol_utils.$getAvailableSpace]();
      const res = this[_symbol_utils.$extra].failingNode[_symbol_utils.$toHTML](availableSpace);
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[_symbol_utils.$addHTML](res.html, res.bbox);
      }
      delete this[_symbol_utils.$extra].failingNode;
    }
    while (true) {
      const gen = this[_symbol_utils.$extra].generator.next();
      if (gen.done) {
        break;
      }
      const res = gen.value;
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[_symbol_utils.$addHTML](res.html, res.bbox);
      }
    }
    this[_symbol_utils.$extra].generator = null;
    return _utils.HTMLResult.EMPTY;
  }
  [_symbol_utils.$setSetAttributes](attributes) {
    this[_setAttributes] = new Set(Object.keys(attributes));
  }
  [_getUnsetAttributes](protoAttributes) {
    const allAttr = this[_attributeNames];
    const setAttr = this[_setAttributes];
    return [...protoAttributes].filter(x => allAttr.has(x) && !setAttr.has(x));
  }
  [_symbol_utils.$resolvePrototypes](ids, ancestors = new Set()) {
    for (const child of this[_children]) {
      child[_resolvePrototypesHelper](ids, ancestors);
    }
  }
  [_resolvePrototypesHelper](ids, ancestors) {
    const proto = this[_getPrototype](ids, ancestors);
    if (proto) {
      this[_applyPrototype](proto, ids, ancestors);
    } else {
      this[_symbol_utils.$resolvePrototypes](ids, ancestors);
    }
  }
  [_getPrototype](ids, ancestors) {
    const {
      use,
      usehref
    } = this;
    if (!use && !usehref) {
      return null;
    }
    let proto = null;
    let somExpression = null;
    let id = null;
    let ref = use;
    if (usehref) {
      ref = usehref;
      if (usehref.startsWith("#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice("#som(".length, -1);
      } else if (usehref.startsWith(".#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice(".#som(".length, -1);
      } else if (usehref.startsWith("#")) {
        id = usehref.slice(1);
      } else if (usehref.startsWith(".#")) {
        id = usehref.slice(2);
      }
    } else if (use.startsWith("#")) {
      id = use.slice(1);
    } else {
      somExpression = use;
    }
    this.use = this.usehref = "";
    if (id) {
      proto = ids.get(id);
    } else {
      proto = (0, _som.searchNode)(ids.get(_symbol_utils.$root), this, somExpression, true, false);
      if (proto) {
        proto = proto[0];
      }
    }
    if (!proto) {
      (0, _util.warn)(`XFA - Invalid prototype reference: ${ref}.`);
      return null;
    }
    if (proto[_symbol_utils.$nodeName] !== this[_symbol_utils.$nodeName]) {
      (0, _util.warn)(`XFA - Incompatible prototype: ${proto[_symbol_utils.$nodeName]} !== ${this[_symbol_utils.$nodeName]}.`);
      return null;
    }
    if (ancestors.has(proto)) {
      (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
      return null;
    }
    ancestors.add(proto);
    const protoProto = proto[_getPrototype](ids, ancestors);
    if (protoProto) {
      proto[_applyPrototype](protoProto, ids, ancestors);
    }
    proto[_symbol_utils.$resolvePrototypes](ids, ancestors);
    ancestors.delete(proto);
    return proto;
  }
  [_applyPrototype](proto, ids, ancestors) {
    if (ancestors.has(proto)) {
      (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
      return;
    }
    if (!this[_symbol_utils.$content] && proto[_symbol_utils.$content]) {
      this[_symbol_utils.$content] = proto[_symbol_utils.$content];
    }
    const newAncestors = new Set(ancestors);
    newAncestors.add(proto);
    for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
      this[unsetAttrName] = proto[unsetAttrName];
      if (this[_setAttributes]) {
        this[_setAttributes].add(unsetAttrName);
      }
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        continue;
      }
      const value = this[name];
      const protoValue = proto[name];
      if (value instanceof XFAObjectArray) {
        for (const child of value[_children]) {
          child[_resolvePrototypesHelper](ids, ancestors);
        }
        for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
          const child = proto[_children][i][_symbol_utils.$clone]();
          if (value.push(child)) {
            child[_parent] = this;
            this[_children].push(child);
            child[_resolvePrototypesHelper](ids, ancestors);
          } else {
            break;
          }
        }
        continue;
      }
      if (value !== null) {
        value[_symbol_utils.$resolvePrototypes](ids, ancestors);
        if (protoValue) {
          value[_applyPrototype](protoValue, ids, ancestors);
        }
        continue;
      }
      if (protoValue !== null) {
        const child = protoValue[_symbol_utils.$clone]();
        child[_parent] = this;
        this[name] = child;
        this[_children].push(child);
        child[_resolvePrototypesHelper](ids, ancestors);
      }
    }
  }
  static [_cloneAttribute](obj) {
    if (Array.isArray(obj)) {
      return obj.map(x => XFAObject[_cloneAttribute](x));
    }
    if (typeof obj === "object" && obj !== null) {
      return Object.assign({}, obj);
    }
    return obj;
  }
  [_symbol_utils.$clone]() {
    const clone = Object.create(Object.getPrototypeOf(this));
    for (const $symbol of Object.getOwnPropertySymbols(this)) {
      try {
        clone[$symbol] = this[$symbol];
      } catch {
        (0, _util.shadow)(clone, $symbol, this[$symbol]);
      }
    }
    clone[_symbol_utils.$uid] = `${clone[_symbol_utils.$nodeName]}${uid++}`;
    clone[_children] = [];
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        clone[name] = XFAObject[_cloneAttribute](this[name]);
        continue;
      }
      const value = this[name];
      clone[name] = value instanceof XFAObjectArray ? new XFAObjectArray(value[_max]) : null;
    }
    for (const child of this[_children]) {
      const name = child[_symbol_utils.$nodeName];
      const clonedChild = child[_symbol_utils.$clone]();
      clone[_children].push(clonedChild);
      clonedChild[_parent] = clone;
      if (clone[name] === null) {
        clone[name] = clonedChild;
      } else {
        clone[name][_children].push(clonedChild);
      }
    }
    return clone;
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter(c => c[_symbol_utils.$nodeName] === name);
  }
  [_symbol_utils.$getChildrenByClass](name) {
    return this[name];
  }
  [_symbol_utils.$getChildrenByName](name, allTransparent, first = true) {
    return Array.from(this[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first));
  }
  *[_symbol_utils.$getChildrenByNameIt](name, allTransparent, first = true) {
    if (name === "parent") {
      yield this[_parent];
      return;
    }
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name) {
        yield child;
      }
      if (child.name === name) {
        yield child;
      }
      if (allTransparent || child[_symbol_utils.$isTransparent]()) {
        yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent, false);
      }
    }
    if (first && this[_attributeNames].has(name)) {
      yield new XFAAttribute(this, name, this[name]);
    }
  }
}
exports.XFAObject = XFAObject;
class XFAObjectArray {
  constructor(max = Infinity) {
    this[_max] = max;
    this[_children] = [];
  }
  get isXFAObject() {
    return false;
  }
  get isXFAObjectArray() {
    return true;
  }
  push(child) {
    const len = this[_children].length;
    if (len <= this[_max]) {
      this[_children].push(child);
      return true;
    }
    (0, _util.warn)(`XFA - node "${child[_symbol_utils.$nodeName]}" accepts no more than ${this[_max]} children`);
    return false;
  }
  isEmpty() {
    return this[_children].length === 0;
  }
  dump() {
    return this[_children].length === 1 ? this[_children][0][_symbol_utils.$dump]() : this[_children].map(x => x[_symbol_utils.$dump]());
  }
  [_symbol_utils.$clone]() {
    const clone = new XFAObjectArray(this[_max]);
    clone[_children] = this[_children].map(c => c[_symbol_utils.$clone]());
    return clone;
  }
  get children() {
    return this[_children];
  }
  clear() {
    this[_children].length = 0;
  }
}
exports.XFAObjectArray = XFAObjectArray;
class XFAAttribute {
  constructor(node, name, value) {
    this[_parent] = node;
    this[_symbol_utils.$nodeName] = name;
    this[_symbol_utils.$content] = value;
    this[_symbol_utils.$consumed] = false;
    this[_symbol_utils.$uid] = `attribute${uid++}`;
  }
  [_symbol_utils.$getParent]() {
    return this[_parent];
  }
  [_symbol_utils.$isDataValue]() {
    return true;
  }
  [_symbol_utils.$getDataValue]() {
    return this[_symbol_utils.$content].trim();
  }
  [_symbol_utils.$setValue](value) {
    value = value.value || "";
    this[_symbol_utils.$content] = value.toString();
  }
  [_symbol_utils.$text]() {
    return this[_symbol_utils.$content];
  }
  [_symbol_utils.$isDescendent](parent) {
    return this[_parent] === parent || this[_parent][_symbol_utils.$isDescendent](parent);
  }
}
exports.XFAAttribute = XFAAttribute;
class XmlObject extends XFAObject {
  constructor(nsId, name, attributes = {}) {
    super(nsId, name);
    this[_symbol_utils.$content] = "";
    this[_dataValue] = null;
    if (name !== "#text") {
      const map = new Map();
      this[_attributes] = map;
      for (const [attrName, value] of Object.entries(attributes)) {
        map.set(attrName, new XFAAttribute(this, attrName, value));
      }
      if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
        const dataNode = attributes[_symbol_utils.$nsAttributes].xfa.dataNode;
        if (dataNode !== undefined) {
          if (dataNode === "dataGroup") {
            this[_dataValue] = false;
          } else if (dataNode === "dataValue") {
            this[_dataValue] = true;
          }
        }
      }
    }
    this[_symbol_utils.$consumed] = false;
  }
  [_symbol_utils.$toString](buf) {
    const tagName = this[_symbol_utils.$nodeName];
    if (tagName === "#text") {
      buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
      return;
    }
    const utf8TagName = (0, _util.utf8StringToString)(tagName);
    const prefix = this[_symbol_utils.$namespaceId] === NS_DATASETS ? "xfa:" : "";
    buf.push(`<${prefix}${utf8TagName}`);
    for (const [name, value] of this[_attributes].entries()) {
      const utf8Name = (0, _util.utf8StringToString)(name);
      buf.push(` ${utf8Name}="${(0, _core_utils.encodeToXmlString)(value[_symbol_utils.$content])}"`);
    }
    if (this[_dataValue] !== null) {
      if (this[_dataValue]) {
        buf.push(` xfa:dataNode="dataValue"`);
      } else {
        buf.push(` xfa:dataNode="dataGroup"`);
      }
    }
    if (!this[_symbol_utils.$content] && this[_children].length === 0) {
      buf.push("/>");
      return;
    }
    buf.push(">");
    if (this[_symbol_utils.$content]) {
      if (typeof this[_symbol_utils.$content] === "string") {
        buf.push((0, _core_utils.encodeToXmlString)(this[_symbol_utils.$content]));
      } else {
        this[_symbol_utils.$content][_symbol_utils.$toString](buf);
      }
    } else {
      for (const child of this[_children]) {
        child[_symbol_utils.$toString](buf);
      }
    }
    buf.push(`</${prefix}${utf8TagName}>`);
  }
  [_symbol_utils.$onChild](child) {
    if (this[_symbol_utils.$content]) {
      const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
      this[_symbol_utils.$appendChild](node);
      node[_symbol_utils.$content] = this[_symbol_utils.$content];
      this[_symbol_utils.$content] = "";
    }
    this[_symbol_utils.$appendChild](child);
    return true;
  }
  [_symbol_utils.$onText](str) {
    this[_symbol_utils.$content] += str;
  }
  [_symbol_utils.$finalize]() {
    if (this[_symbol_utils.$content] && this[_children].length > 0) {
      const node = new XmlObject(this[_symbol_utils.$namespaceId], "#text");
      this[_symbol_utils.$appendChild](node);
      node[_symbol_utils.$content] = this[_symbol_utils.$content];
      delete this[_symbol_utils.$content];
    }
  }
  [_symbol_utils.$toHTML]() {
    if (this[_symbol_utils.$nodeName] === "#text") {
      return _utils.HTMLResult.success({
        name: "#text",
        value: this[_symbol_utils.$content]
      });
    }
    return _utils.HTMLResult.EMPTY;
  }
  [_symbol_utils.$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter(c => c[_symbol_utils.$nodeName] === name);
  }
  [_symbol_utils.$getAttributes]() {
    return this[_attributes];
  }
  [_symbol_utils.$getChildrenByClass](name) {
    const value = this[_attributes].get(name);
    if (value !== undefined) {
      return value;
    }
    return this[_symbol_utils.$getChildren](name);
  }
  *[_symbol_utils.$getChildrenByNameIt](name, allTransparent) {
    const value = this[_attributes].get(name);
    if (value) {
      yield value;
    }
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name) {
        yield child;
      }
      if (allTransparent) {
        yield* child[_symbol_utils.$getChildrenByNameIt](name, allTransparent);
      }
    }
  }
  *[_symbol_utils.$getAttributeIt](name, skipConsumed) {
    const value = this[_attributes].get(name);
    if (value && (!skipConsumed || !value[_symbol_utils.$consumed])) {
      yield value;
    }
    for (const child of this[_children]) {
      yield* child[_symbol_utils.$getAttributeIt](name, skipConsumed);
    }
  }
  *[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
    for (const child of this[_children]) {
      if (child[_symbol_utils.$nodeName] === name && (!skipConsumed || !child[_symbol_utils.$consumed])) {
        yield child;
      }
      if (allTransparent) {
        yield* child[_symbol_utils.$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
      }
    }
  }
  [_symbol_utils.$isDataValue]() {
    if (this[_dataValue] === null) {
      return this[_children].length === 0 || this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id;
    }
    return this[_dataValue];
  }
  [_symbol_utils.$getDataValue]() {
    if (this[_dataValue] === null) {
      if (this[_children].length === 0) {
        return this[_symbol_utils.$content].trim();
      }
      if (this[_children][0][_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
        return this[_children][0][_symbol_utils.$text]().trim();
      }
      return null;
    }
    return this[_symbol_utils.$content].trim();
  }
  [_symbol_utils.$setValue](value) {
    value = value.value || "";
    this[_symbol_utils.$content] = value.toString();
  }
  [_symbol_utils.$dump](hasNS = false) {
    const dumped = Object.create(null);
    if (hasNS) {
      dumped.$ns = this[_symbol_utils.$namespaceId];
    }
    if (this[_symbol_utils.$content]) {
      dumped.$content = this[_symbol_utils.$content];
    }
    dumped.$name = this[_symbol_utils.$nodeName];
    dumped.children = [];
    for (const child of this[_children]) {
      dumped.children.push(child[_symbol_utils.$dump](hasNS));
    }
    dumped.attributes = Object.create(null);
    for (const [name, value] of this[_attributes]) {
      dumped.attributes[name] = value[_symbol_utils.$content];
    }
    return dumped;
  }
}
exports.XmlObject = XmlObject;
class ContentObject extends XFAObject {
  constructor(nsId, name) {
    super(nsId, name);
    this[_symbol_utils.$content] = "";
  }
  [_symbol_utils.$onText](text) {
    this[_symbol_utils.$content] += text;
  }
  [_symbol_utils.$finalize]() {}
}
exports.ContentObject = ContentObject;
class OptionObject extends ContentObject {
  constructor(nsId, name, options) {
    super(nsId, name);
    this[_options] = options;
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getKeyword)({
      data: this[_symbol_utils.$content],
      defaultValue: this[_options][0],
      validate: k => this[_options].includes(k)
    });
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    delete this[_options];
  }
}
exports.OptionObject = OptionObject;
class StringObject extends ContentObject {
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
  }
}
exports.StringObject = StringObject;
class IntegerObject extends ContentObject {
  constructor(nsId, name, defaultValue, validator) {
    super(nsId, name);
    this[_defaultValue] = defaultValue;
    this[_validator] = validator;
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = (0, _utils.getInteger)({
      data: this[_symbol_utils.$content],
      defaultValue: this[_defaultValue],
      validate: this[_validator]
    });
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    delete this[_defaultValue];
    delete this[_validator];
  }
}
exports.IntegerObject = IntegerObject;
class Option01 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 0, n => n === 1);
  }
}
exports.Option01 = Option01;
class Option10 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 1, n => n === 0);
  }
}
exports.Option10 = Option10;

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createDataNode = createDataNode;
exports.searchNode = searchNode;
var _symbol_utils = __w_pdfjs_require__(78);
var _util = __w_pdfjs_require__(2);
const namePattern = /^[^.[]+/;
const indexPattern = /^[^\]]+/;
const operators = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
};
const shortcuts = new Map([["$data", (root, current) => root.datasets ? root.datasets.data : root], ["$record", (root, current) => (root.datasets ? root.datasets.data : root)[_symbol_utils.$getChildren]()[0]], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
const somCache = new WeakMap();
function parseIndex(index) {
  index = index.trim();
  if (index === "*") {
    return Infinity;
  }
  return parseInt(index, 10) || 0;
}
function parseExpression(expr, dotDotAllowed, noExpr = true) {
  let match = expr.match(namePattern);
  if (!match) {
    return null;
  }
  let [name] = match;
  const parsed = [{
    name,
    cacheName: "." + name,
    index: 0,
    js: null,
    formCalc: null,
    operator: operators.dot
  }];
  let pos = name.length;
  while (pos < expr.length) {
    const spos = pos;
    const char = expr.charAt(pos++);
    if (char === "[") {
      match = expr.slice(pos).match(indexPattern);
      if (!match) {
        (0, _util.warn)("XFA - Invalid index in SOM expression");
        return null;
      }
      parsed.at(-1).index = parseIndex(match[0]);
      pos += match[0].length + 1;
      continue;
    }
    let operator;
    switch (expr.charAt(pos)) {
      case ".":
        if (!dotDotAllowed) {
          return null;
        }
        pos++;
        operator = operators.dotDot;
        break;
      case "#":
        pos++;
        operator = operators.dotHash;
        break;
      case "[":
        if (noExpr) {
          (0, _util.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotBracket;
        break;
      case "(":
        if (noExpr) {
          (0, _util.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotParen;
        break;
      default:
        operator = operators.dot;
        break;
    }
    match = expr.slice(pos).match(namePattern);
    if (!match) {
      break;
    }
    [name] = match;
    pos += name.length;
    parsed.push({
      name,
      cacheName: expr.slice(spos, pos),
      operator,
      index: 0,
      js: null,
      formCalc: null
    });
  }
  return parsed;
}
function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {
  const parsed = parseExpression(expr, dotDotAllowed);
  if (!parsed) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  let isQualified;
  if (fn) {
    isQualified = true;
    root = [fn(root, container)];
    i = 1;
  } else {
    isQualified = container === null;
    root = [container || root];
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      cacheName,
      operator,
      index
    } = parsed[i];
    const nodes = [];
    for (const node of root) {
      if (!node.isXFAObject) {
        continue;
      }
      let children, cached;
      if (useCache) {
        cached = somCache.get(node);
        if (!cached) {
          cached = new Map();
          somCache.set(node, cached);
        }
        children = cached.get(cacheName);
      }
      if (!children) {
        switch (operator) {
          case operators.dot:
            children = node[_symbol_utils.$getChildrenByName](name, false);
            break;
          case operators.dotDot:
            children = node[_symbol_utils.$getChildrenByName](name, true);
            break;
          case operators.dotHash:
            children = node[_symbol_utils.$getChildrenByClass](name);
            children = children.isXFAObjectArray ? children.children : [children];
            break;
          default:
            break;
        }
        if (useCache) {
          cached.set(cacheName, children);
        }
      }
      if (children.length > 0) {
        nodes.push(children);
      }
    }
    if (nodes.length === 0 && !isQualified && i === 0) {
      const parent = container[_symbol_utils.$getParent]();
      container = parent;
      if (!container) {
        return null;
      }
      i = -1;
      root = [container];
      continue;
    }
    root = isFinite(index) ? nodes.filter(node => index < node.length).map(node => node[index]) : nodes.flat();
  }
  if (root.length === 0) {
    return null;
  }
  return root;
}
function createDataNode(root, container, expr) {
  const parsed = parseExpression(expr);
  if (!parsed) {
    return null;
  }
  if (parsed.some(x => x.operator === operators.dotDot)) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  if (fn) {
    root = fn(root, container);
    i = 1;
  } else {
    root = container || root;
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      operator,
      index
    } = parsed[i];
    if (!isFinite(index)) {
      parsed[i].index = 0;
      return root.createNodes(parsed.slice(i));
    }
    let children;
    switch (operator) {
      case operators.dot:
        children = root[_symbol_utils.$getChildrenByName](name, false);
        break;
      case operators.dotDot:
        children = root[_symbol_utils.$getChildrenByName](name, true);
        break;
      case operators.dotHash:
        children = root[_symbol_utils.$getChildrenByClass](name);
        children = children.isXFAObjectArray ? children.children : [children];
        break;
      default:
        break;
    }
    if (children.length === 0) {
      return root.createNodes(parsed.slice(i));
    }
    if (index < children.length) {
      const child = children[index];
      if (!child.isXFAObject) {
        (0, _util.warn)(`XFA - Cannot create a node.`);
        return null;
      }
      root = child;
    } else {
      parsed[i].index = index - children.length;
      return root.createNodes(parsed.slice(i));
    }
  }
  return null;
}

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DataHandler = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
class DataHandler {
  constructor(root, data) {
    this.data = data;
    this.dataset = root.datasets || null;
  }
  serialize(storage) {
    const stack = [[-1, this.data[_symbol_utils.$getChildren]()]];
    while (stack.length > 0) {
      const last = stack.at(-1);
      const [i, children] = last;
      if (i + 1 === children.length) {
        stack.pop();
        continue;
      }
      const child = children[++last[0]];
      const storageEntry = storage.get(child[_symbol_utils.$uid]);
      if (storageEntry) {
        child[_symbol_utils.$setValue](storageEntry);
      } else {
        const attributes = child[_symbol_utils.$getAttributes]();
        for (const value of attributes.values()) {
          const entry = storage.get(value[_symbol_utils.$uid]);
          if (entry) {
            value[_symbol_utils.$setValue](entry);
            break;
          }
        }
      }
      const nodes = child[_symbol_utils.$getChildren]();
      if (nodes.length > 0) {
        stack.push([-1, nodes]);
      }
    }
    const buf = [`<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">`];
    if (this.dataset) {
      for (const child of this.dataset[_symbol_utils.$getChildren]()) {
        if (child[_symbol_utils.$nodeName] !== "data") {
          child[_symbol_utils.$toString](buf);
        }
      }
    }
    this.data[_symbol_utils.$toString](buf);
    buf.push("</xfa:datasets>");
    return buf.join("");
  }
}
exports.DataHandler = DataHandler;

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAParser = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _xml_parser = __w_pdfjs_require__(71);
var _builder = __w_pdfjs_require__(91);
var _util = __w_pdfjs_require__(2);
class XFAParser extends _xml_parser.XMLParserBase {
  constructor(rootNameSpace = null, richText = false) {
    super();
    this._builder = new _builder.Builder(rootNameSpace);
    this._stack = [];
    this._globalData = {
      usedTypefaces: new Set()
    };
    this._ids = new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = _xml_parser.XMLParserErrorCode.NoError;
    this._whiteRegex = /^\s+$/;
    this._nbsps = /\xa0+/g;
    this._richText = richText;
  }
  parse(data) {
    this.parseXml(data);
    if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) {
      return undefined;
    }
    this._current[_symbol_utils.$finalize]();
    return this._current.element;
  }
  onText(text) {
    text = text.replace(this._nbsps, match => match.slice(1) + " ");
    if (this._richText || this._current[_symbol_utils.$acceptWhitespace]()) {
      this._current[_symbol_utils.$onText](text, this._richText);
      return;
    }
    if (this._whiteRegex.test(text)) {
      return;
    }
    this._current[_symbol_utils.$onText](text.trim());
  }
  onCdata(text) {
    this._current[_symbol_utils.$onText](text);
  }
  _mkAttributes(attributes, tagName) {
    let namespace = null;
    let prefixes = null;
    const attributeObj = Object.create({});
    for (const {
      name,
      value
    } of attributes) {
      if (name === "xmlns") {
        if (!namespace) {
          namespace = value;
        } else {
          (0, _util.warn)(`XFA - multiple namespace definition in <${tagName}>`);
        }
      } else if (name.startsWith("xmlns:")) {
        const prefix = name.substring("xmlns:".length);
        if (!prefixes) {
          prefixes = [];
        }
        prefixes.push({
          prefix,
          value
        });
      } else {
        const i = name.indexOf(":");
        if (i === -1) {
          attributeObj[name] = value;
        } else {
          let nsAttrs = attributeObj[_symbol_utils.$nsAttributes];
          if (!nsAttrs) {
            nsAttrs = attributeObj[_symbol_utils.$nsAttributes] = Object.create(null);
          }
          const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
          const attrs = nsAttrs[ns] ||= Object.create(null);
          attrs[attrName] = value;
        }
      }
    }
    return [namespace, prefixes, attributeObj];
  }
  _getNameAndPrefix(name, nsAgnostic) {
    const i = name.indexOf(":");
    if (i === -1) {
      return [name, null];
    }
    return [name.substring(i + 1), nsAgnostic ? "" : name.substring(0, i)];
  }
  onBeginElement(tagName, attributes, isEmpty) {
    const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);
    const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());
    const node = this._builder.build({
      nsPrefix,
      name,
      attributes: attributesObj,
      namespace,
      prefixes
    });
    node[_symbol_utils.$globalData] = this._globalData;
    if (isEmpty) {
      node[_symbol_utils.$finalize]();
      if (this._current[_symbol_utils.$onChild](node)) {
        node[_symbol_utils.$setId](this._ids);
      }
      node[_symbol_utils.$clean](this._builder);
      return;
    }
    this._stack.push(this._current);
    this._current = node;
  }
  onEndElement(name) {
    const node = this._current;
    if (node[_symbol_utils.$isCDATAXml]() && typeof node[_symbol_utils.$content] === "string") {
      const parser = new XFAParser();
      parser._globalData = this._globalData;
      const root = parser.parse(node[_symbol_utils.$content]);
      node[_symbol_utils.$content] = null;
      node[_symbol_utils.$onChild](root);
    }
    node[_symbol_utils.$finalize]();
    this._current = this._stack.pop();
    if (this._current[_symbol_utils.$onChild](node)) {
      node[_symbol_utils.$setId](this._ids);
    }
    node[_symbol_utils.$clean](this._builder);
  }
  onError(code) {
    this._errorCode = code;
  }
}
exports.XFAParser = XFAParser;

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Builder = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _setup = __w_pdfjs_require__(92);
var _template = __w_pdfjs_require__(80);
var _unknown = __w_pdfjs_require__(101);
var _util = __w_pdfjs_require__(2);
var _xfa_object = __w_pdfjs_require__(87);
class Root extends _xfa_object.XFAObject {
  constructor(ids) {
    super(-1, "root", Object.create(null));
    this.element = null;
    this[_symbol_utils.$ids] = ids;
  }
  [_symbol_utils.$onChild](child) {
    this.element = child;
    return true;
  }
  [_symbol_utils.$finalize]() {
    super[_symbol_utils.$finalize]();
    if (this.element.template instanceof _template.Template) {
      this[_symbol_utils.$ids].set(_symbol_utils.$root, this.element);
      this.element.template[_symbol_utils.$resolvePrototypes](this[_symbol_utils.$ids]);
      this.element.template[_symbol_utils.$ids] = this[_symbol_utils.$ids];
    }
  }
}
class Empty extends _xfa_object.XFAObject {
  constructor() {
    super(-1, "", Object.create(null));
  }
  [_symbol_utils.$onChild](_) {
    return false;
  }
}
class Builder {
  constructor(rootNameSpace = null) {
    this._namespaceStack = [];
    this._nsAgnosticLevel = 0;
    this._namespacePrefixes = new Map();
    this._namespaces = new Map();
    this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map(({
      id
    }) => id));
    this._currentNamespace = rootNameSpace || new _unknown.UnknownNamespace(++this._nextNsId);
  }
  buildRoot(ids) {
    return new Root(ids);
  }
  build({
    nsPrefix,
    name,
    attributes,
    namespace,
    prefixes
  }) {
    const hasNamespaceDef = namespace !== null;
    if (hasNamespaceDef) {
      this._namespaceStack.push(this._currentNamespace);
      this._currentNamespace = this._searchNamespace(namespace);
    }
    if (prefixes) {
      this._addNamespacePrefix(prefixes);
    }
    if (attributes.hasOwnProperty(_symbol_utils.$nsAttributes)) {
      const dataTemplate = _setup.NamespaceSetUp.datasets;
      const nsAttrs = attributes[_symbol_utils.$nsAttributes];
      let xfaAttrs = null;
      for (const [ns, attrs] of Object.entries(nsAttrs)) {
        const nsToUse = this._getNamespaceToUse(ns);
        if (nsToUse === dataTemplate) {
          xfaAttrs = {
            xfa: attrs
          };
          break;
        }
      }
      if (xfaAttrs) {
        attributes[_symbol_utils.$nsAttributes] = xfaAttrs;
      } else {
        delete attributes[_symbol_utils.$nsAttributes];
      }
    }
    const namespaceToUse = this._getNamespaceToUse(nsPrefix);
    const node = namespaceToUse?.[_namespaces.$buildXFAObject](name, attributes) || new Empty();
    if (node[_symbol_utils.$isNsAgnostic]()) {
      this._nsAgnosticLevel++;
    }
    if (hasNamespaceDef || prefixes || node[_symbol_utils.$isNsAgnostic]()) {
      node[_symbol_utils.$cleanup] = {
        hasNamespace: hasNamespaceDef,
        prefixes,
        nsAgnostic: node[_symbol_utils.$isNsAgnostic]()
      };
    }
    return node;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(nsName) {
    let ns = this._namespaces.get(nsName);
    if (ns) {
      return ns;
    }
    for (const [name, {
      check
    }] of Object.entries(_namespaces.NamespaceIds)) {
      if (check(nsName)) {
        ns = _setup.NamespaceSetUp[name];
        if (ns) {
          this._namespaces.set(nsName, ns);
          return ns;
        }
        break;
      }
    }
    ns = new _unknown.UnknownNamespace(++this._nextNsId);
    this._namespaces.set(nsName, ns);
    return ns;
  }
  _addNamespacePrefix(prefixes) {
    for (const {
      prefix,
      value
    } of prefixes) {
      const namespace = this._searchNamespace(value);
      let prefixStack = this._namespacePrefixes.get(prefix);
      if (!prefixStack) {
        prefixStack = [];
        this._namespacePrefixes.set(prefix, prefixStack);
      }
      prefixStack.push(namespace);
    }
  }
  _getNamespaceToUse(prefix) {
    if (!prefix) {
      return this._currentNamespace;
    }
    const prefixStack = this._namespacePrefixes.get(prefix);
    if (prefixStack?.length > 0) {
      return prefixStack.at(-1);
    }
    (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`);
    return null;
  }
  clean(data) {
    const {
      hasNamespace,
      prefixes,
      nsAgnostic
    } = data;
    if (hasNamespace) {
      this._currentNamespace = this._namespaceStack.pop();
    }
    if (prefixes) {
      prefixes.forEach(({
        prefix
      }) => {
        this._namespacePrefixes.get(prefix).pop();
      });
    }
    if (nsAgnostic) {
      this._nsAgnosticLevel--;
    }
  }
}
exports.Builder = Builder;

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceSetUp = void 0;
var _config = __w_pdfjs_require__(93);
var _connection_set = __w_pdfjs_require__(94);
var _datasets = __w_pdfjs_require__(95);
var _locale_set = __w_pdfjs_require__(96);
var _signature = __w_pdfjs_require__(97);
var _stylesheet = __w_pdfjs_require__(98);
var _template = __w_pdfjs_require__(80);
var _xdp = __w_pdfjs_require__(99);
var _xhtml = __w_pdfjs_require__(100);
const NamespaceSetUp = {
  config: _config.ConfigNamespace,
  connection: _connection_set.ConnectionSetNamespace,
  datasets: _datasets.DatasetsNamespace,
  localeSet: _locale_set.LocaleSetNamespace,
  signature: _signature.SignatureNamespace,
  stylesheet: _stylesheet.StylesheetNamespace,
  template: _template.TemplateNamespace,
  xdp: _xdp.XdpNamespace,
  xhtml: _xhtml.XhtmlNamespace
};
exports.NamespaceSetUp = NamespaceSetUp;

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
var _util = __w_pdfjs_require__(2);
const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id;
class Acrobat extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat", true);
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new _xfa_object.XFAObjectArray();
  }
}
class Acrobat7 extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat7", true);
    this.dynamicRender = null;
  }
}
class ADBE_JSConsole extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class ADBE_JSDebugger extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class AddSilentPrint extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addSilentPrint");
  }
}
class AddViewerPreferences extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addViewerPreferences");
  }
}
class AdjustData extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adjustData");
  }
}
class AdobeExtensionLevel extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adobeExtensionLevel", 0, n => n >= 1 && n <= 8);
  }
}
class Agent extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "agent", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.common = new _xfa_object.XFAObjectArray();
  }
}
class AlwaysEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "alwaysEmbed");
  }
}
class Amd extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "amd");
  }
}
class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "area");
    this.level = (0, _utils.getInteger)({
      data: attributes.level,
      defaultValue: 0,
      validate: n => n >= 1 && n <= 3
    });
    this.name = (0, _utils.getStringOption)(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class Attributes extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class AutoSave extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
  }
}
class Base extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "base");
  }
}
class BatchOutput extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "batchOutput");
    this.format = (0, _utils.getStringOption)(attributes.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class BehaviorOverride extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "behaviorOverride");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = new Map(this[_symbol_utils.$content].trim().split(/\s+/).filter(x => x.includes(":")).map(x => x.split(":", 2)));
  }
}
class Cache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "cache", true);
    this.templateCache = null;
  }
}
class Change extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "change");
  }
}
class Common extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "common", true);
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new _xfa_object.XFAObjectArray();
  }
}
class Compress extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compress");
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["imageOnly", "document"]);
  }
}
class CompressLogicalStructure extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressLogicalStructure");
  }
}
class CompressObjectStream extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressObjectStream");
  }
}
class Compression extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compression", true);
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }
}
class Config extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "config", true);
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new _xfa_object.XFAObjectArray();
  }
}
class Conformance extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "conformance", ["A", "B"]);
  }
}
class ContentCopy extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "contentCopy");
  }
}
class Copies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "copies", 1, n => n >= 1);
  }
}
class Creator extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "creator");
  }
}
class CurrentPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "currentPage", 0, n => n >= 0);
  }
}
class Data extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "data", true);
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new _xfa_object.XFAObjectArray();
    this.transform = new _xfa_object.XFAObjectArray();
  }
}
class Debug extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "debug", true);
    this.uri = null;
  }
}
class DefaultTypeface extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "defaultTypeface");
    this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class Destination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class DocumentAssembly extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "documentAssembly");
  }
}
class Driver extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "driver", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
}
class DuplexOption extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class DynamicRender extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
  }
}
class Embed extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "embed");
  }
}
class Encrypt extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encrypt");
  }
}
class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryption", true);
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }
}
class EncryptionLevel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Enforce extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "enforce");
  }
}
class Equate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equate");
    this.force = (0, _utils.getInteger)({
      data: attributes.force,
      defaultValue: 1,
      validate: n => n === 0
    });
    this.from = attributes.from || "";
    this.to = attributes.to || "";
  }
}
class EquateRange extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equateRange");
    this.from = attributes.from || "";
    this.to = attributes.to || "";
    this._unicodeRange = attributes.unicodeRange || "";
  }
  get unicodeRange() {
    const ranges = [];
    const unicodeRegex = /U\+([0-9a-fA-F]+)/;
    const unicodeRange = this._unicodeRange;
    for (let range of unicodeRange.split(",").map(x => x.trim()).filter(x => !!x)) {
      range = range.split("-", 2).map(x => {
        const found = x.match(unicodeRegex);
        if (!found) {
          return 0;
        }
        return parseInt(found[1], 16);
      });
      if (range.length === 1) {
        range.push(range[0]);
      }
      ranges.push(range);
    }
    return (0, _util.shadow)(this, "unicodeRange", ranges);
  }
}
class Exclude extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "exclude");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
  }
}
class ExcludeNS extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "excludeNS");
  }
}
class FlipLabel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class FontInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "fontInfo", true);
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new _xfa_object.XFAObjectArray();
    this.defaultTypeface = new _xfa_object.XFAObjectArray();
    this.neverEmbed = new _xfa_object.XFAObjectArray();
  }
}
class FormFieldFilling extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "formFieldFilling");
  }
}
class GroupParent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "groupParent");
  }
}
class IfEmpty extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class IncludeXDPContent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "includeXDPContent");
  }
}
class IncrementalLoad extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class IncrementalMerge extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalMerge");
  }
}
class Interactive extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "interactive");
  }
}
class Jog extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class LabelPrinter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "labelPrinter", true);
    this.name = (0, _utils.getStringOption)(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
}
class Layout extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
  }
}
class Level extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "level", 0, n => n > 0);
  }
}
class Linearized extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "linearized");
  }
}
class Locale extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "locale");
  }
}
class LocaleSet extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "localeSet");
  }
}
class Log extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "log", true);
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }
}
class MapElement extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "map", true);
    this.equate = new _xfa_object.XFAObjectArray();
    this.equateRange = new _xfa_object.XFAObjectArray();
  }
}
class MediumInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mediumInfo", true);
    this.map = null;
  }
}
class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "message", true);
    this.msgId = null;
    this.severity = null;
  }
}
class Messaging extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "messaging", true);
    this.message = new _xfa_object.XFAObjectArray();
  }
}
class Mode extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
  }
}
class ModifyAnnots extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "modifyAnnots");
  }
}
class MsgId extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "msgId", 1, n => n >= 1);
  }
}
class NameAttr extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "nameAttr");
  }
}
class NeverEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "neverEmbed");
  }
}
class NumberOfCopies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "numberOfCopies", null, n => n >= 2 && n <= 5);
  }
}
class OpenAction extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "openAction", true);
    this.destination = null;
  }
}
class Output extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "output", true);
    this.to = null;
    this.type = null;
    this.uri = null;
  }
}
class OutputBin extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputBin");
  }
}
class OutputXSL extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputXSL", true);
    this.uri = null;
  }
}
class Overprint extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
  }
}
class Packets extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "packets");
  }
  [_symbol_utils.$finalize]() {
    if (this[_symbol_utils.$content] === "*") {
      return;
    }
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
  }
}
class PageOffset extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageOffset");
    this.x = (0, _utils.getInteger)({
      data: attributes.x,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
    this.y = (0, _utils.getInteger)({
      data: attributes.y,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
  }
}
class PageRange extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageRange");
  }
  [_symbol_utils.$finalize]() {
    const numbers = this[_symbol_utils.$content].trim().split(/\s+/).map(x => parseInt(x, 10));
    const ranges = [];
    for (let i = 0, ii = numbers.length; i < ii; i += 2) {
      ranges.push(numbers.slice(i, i + 2));
    }
    this[_symbol_utils.$content] = ranges;
  }
}
class Pagination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class PaginationOverride extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class Part extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "part", 1, n => false);
  }
}
class Pcl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pcl", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }
}
class Pdf extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdf", true);
    this.name = attributes.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }
}
class Pdfa extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdfa", true);
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }
}
class Permissions extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "permissions", true);
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }
}
class PickTrayByPDFSize extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pickTrayByPDFSize");
  }
}
class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "picture");
  }
}
class PlaintextMetadata extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "plaintextMetadata");
  }
}
class Presence extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class Present extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "present", true);
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new _xfa_object.XFAObjectArray();
    this.labelPrinter = new _xfa_object.XFAObjectArray();
    this.pcl = new _xfa_object.XFAObjectArray();
    this.pdf = new _xfa_object.XFAObjectArray();
    this.ps = new _xfa_object.XFAObjectArray();
    this.submitUrl = new _xfa_object.XFAObjectArray();
    this.webClient = new _xfa_object.XFAObjectArray();
    this.zpl = new _xfa_object.XFAObjectArray();
  }
}
class Print extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "print");
  }
}
class PrintHighQuality extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printHighQuality");
  }
}
class PrintScaling extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
  }
}
class PrinterName extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printerName");
  }
}
class Producer extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "producer");
  }
}
class Ps extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ps", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }
}
class Range extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "range");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map(range => range.split("-").map(x => parseInt(x.trim(), 10))).filter(range => range.every(x => !isNaN(x))).map(range => {
      if (range.length === 1) {
        range.push(range[0]);
      }
      return range;
    });
  }
}
class Record extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "record");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
    const n = parseInt(this[_symbol_utils.$content], 10);
    if (!isNaN(n) && n >= 0) {
      this[_symbol_utils.$content] = n;
    }
  }
}
class Relevant extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "relevant");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/);
  }
}
class Rename extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "rename");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim();
    if (this[_symbol_utils.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[_symbol_utils.$content])) {
      (0, _util.warn)("XFA - Rename: invalid XFA name");
    }
  }
}
class RenderPolicy extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
  }
}
class RunScripts extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
  }
}
class Script extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "script", true);
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }
}
class ScriptModel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
  }
}
class Severity extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class SilentPrint extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "silentPrint", true);
    this.addSilentPrint = null;
    this.printerName = null;
  }
}
class Staple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "staple");
    this.mode = (0, _utils.getStringOption)(attributes.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class StartNode extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startNode");
  }
}
class StartPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startPage", 0, n => true);
  }
}
class SubmitFormat extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class SubmitUrl extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitUrl");
  }
}
class SubsetBelow extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "subsetBelow", 100, n => n >= 0 && n <= 100);
  }
}
class SuppressBanner extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "suppressBanner");
  }
}
class Tagged extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "tagged");
  }
}
class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "template", true);
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }
}
class Threshold extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class To extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class TemplateCache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "templateCache");
    this.maxEntries = (0, _utils.getInteger)({
      data: attributes.maxEntries,
      defaultValue: 5,
      validate: n => n >= 0
    });
  }
}
class Trace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "trace", true);
    this.area = new _xfa_object.XFAObjectArray();
  }
}
class Transform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "transform", true);
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }
}
class Type extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "uri");
  }
}
class Validate extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class ValidateApprovalSignatures extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validateApprovalSignatures");
  }
  [_symbol_utils.$finalize]() {
    this[_symbol_utils.$content] = this[_symbol_utils.$content].trim().split(/\s+/).filter(x => ["docReady", "postSign"].includes(x));
  }
}
class ValidationMessaging extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class Version extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class VersionControl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "VersionControl");
    this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, ["warn", "error"]);
    this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, ["update", "maintain"]);
  }
}
class ViewerPreferences extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "viewerPreferences", true);
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }
}
class WebClient extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "webClient", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
}
class Whitespace extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class Window extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "window");
  }
  [_symbol_utils.$finalize]() {
    const pair = this[_symbol_utils.$content].trim().split(/\s*,\s*/, 2).map(x => parseInt(x, 10));
    if (pair.some(x => isNaN(x))) {
      this[_symbol_utils.$content] = [0, 0];
      return;
    }
    if (pair.length === 1) {
      pair.push(pair[0]);
    }
    this[_symbol_utils.$content] = pair;
  }
}
class Xdc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdc", true);
    this.uri = new _xfa_object.XFAObjectArray();
    this.xsl = new _xfa_object.XFAObjectArray();
  }
}
class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdp", true);
    this.packets = null;
  }
}
class Xsl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xsl", true);
    this.debug = null;
    this.uri = null;
  }
}
class Zpl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "zpl", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
}
class ConfigNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConfigNamespace.hasOwnProperty(name)) {
      return ConfigNamespace[name](attributes);
    }
    return undefined;
  }
  static acrobat(attrs) {
    return new Acrobat(attrs);
  }
  static acrobat7(attrs) {
    return new Acrobat7(attrs);
  }
  static ADBE_JSConsole(attrs) {
    return new ADBE_JSConsole(attrs);
  }
  static ADBE_JSDebugger(attrs) {
    return new ADBE_JSDebugger(attrs);
  }
  static addSilentPrint(attrs) {
    return new AddSilentPrint(attrs);
  }
  static addViewerPreferences(attrs) {
    return new AddViewerPreferences(attrs);
  }
  static adjustData(attrs) {
    return new AdjustData(attrs);
  }
  static adobeExtensionLevel(attrs) {
    return new AdobeExtensionLevel(attrs);
  }
  static agent(attrs) {
    return new Agent(attrs);
  }
  static alwaysEmbed(attrs) {
    return new AlwaysEmbed(attrs);
  }
  static amd(attrs) {
    return new Amd(attrs);
  }
  static area(attrs) {
    return new Area(attrs);
  }
  static attributes(attrs) {
    return new Attributes(attrs);
  }
  static autoSave(attrs) {
    return new AutoSave(attrs);
  }
  static base(attrs) {
    return new Base(attrs);
  }
  static batchOutput(attrs) {
    return new BatchOutput(attrs);
  }
  static behaviorOverride(attrs) {
    return new BehaviorOverride(attrs);
  }
  static cache(attrs) {
    return new Cache(attrs);
  }
  static change(attrs) {
    return new Change(attrs);
  }
  static common(attrs) {
    return new Common(attrs);
  }
  static compress(attrs) {
    return new Compress(attrs);
  }
  static compressLogicalStructure(attrs) {
    return new CompressLogicalStructure(attrs);
  }
  static compressObjectStream(attrs) {
    return new CompressObjectStream(attrs);
  }
  static compression(attrs) {
    return new Compression(attrs);
  }
  static config(attrs) {
    return new Config(attrs);
  }
  static conformance(attrs) {
    return new Conformance(attrs);
  }
  static contentCopy(attrs) {
    return new ContentCopy(attrs);
  }
  static copies(attrs) {
    return new Copies(attrs);
  }
  static creator(attrs) {
    return new Creator(attrs);
  }
  static currentPage(attrs) {
    return new CurrentPage(attrs);
  }
  static data(attrs) {
    return new Data(attrs);
  }
  static debug(attrs) {
    return new Debug(attrs);
  }
  static defaultTypeface(attrs) {
    return new DefaultTypeface(attrs);
  }
  static destination(attrs) {
    return new Destination(attrs);
  }
  static documentAssembly(attrs) {
    return new DocumentAssembly(attrs);
  }
  static driver(attrs) {
    return new Driver(attrs);
  }
  static duplexOption(attrs) {
    return new DuplexOption(attrs);
  }
  static dynamicRender(attrs) {
    return new DynamicRender(attrs);
  }
  static embed(attrs) {
    return new Embed(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt(attrs);
  }
  static encryption(attrs) {
    return new Encryption(attrs);
  }
  static encryptionLevel(attrs) {
    return new EncryptionLevel(attrs);
  }
  static enforce(attrs) {
    return new Enforce(attrs);
  }
  static equate(attrs) {
    return new Equate(attrs);
  }
  static equateRange(attrs) {
    return new EquateRange(attrs);
  }
  static exclude(attrs) {
    return new Exclude(attrs);
  }
  static excludeNS(attrs) {
    return new ExcludeNS(attrs);
  }
  static flipLabel(attrs) {
    return new FlipLabel(attrs);
  }
  static fontInfo(attrs) {
    return new FontInfo(attrs);
  }
  static formFieldFilling(attrs) {
    return new FormFieldFilling(attrs);
  }
  static groupParent(attrs) {
    return new GroupParent(attrs);
  }
  static ifEmpty(attrs) {
    return new IfEmpty(attrs);
  }
  static includeXDPContent(attrs) {
    return new IncludeXDPContent(attrs);
  }
  static incrementalLoad(attrs) {
    return new IncrementalLoad(attrs);
  }
  static incrementalMerge(attrs) {
    return new IncrementalMerge(attrs);
  }
  static interactive(attrs) {
    return new Interactive(attrs);
  }
  static jog(attrs) {
    return new Jog(attrs);
  }
  static labelPrinter(attrs) {
    return new LabelPrinter(attrs);
  }
  static layout(attrs) {
    return new Layout(attrs);
  }
  static level(attrs) {
    return new Level(attrs);
  }
  static linearized(attrs) {
    return new Linearized(attrs);
  }
  static locale(attrs) {
    return new Locale(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }
  static log(attrs) {
    return new Log(attrs);
  }
  static map(attrs) {
    return new MapElement(attrs);
  }
  static mediumInfo(attrs) {
    return new MediumInfo(attrs);
  }
  static message(attrs) {
    return new Message(attrs);
  }
  static messaging(attrs) {
    return new Messaging(attrs);
  }
  static mode(attrs) {
    return new Mode(attrs);
  }
  static modifyAnnots(attrs) {
    return new ModifyAnnots(attrs);
  }
  static msgId(attrs) {
    return new MsgId(attrs);
  }
  static nameAttr(attrs) {
    return new NameAttr(attrs);
  }
  static neverEmbed(attrs) {
    return new NeverEmbed(attrs);
  }
  static numberOfCopies(attrs) {
    return new NumberOfCopies(attrs);
  }
  static openAction(attrs) {
    return new OpenAction(attrs);
  }
  static output(attrs) {
    return new Output(attrs);
  }
  static outputBin(attrs) {
    return new OutputBin(attrs);
  }
  static outputXSL(attrs) {
    return new OutputXSL(attrs);
  }
  static overprint(attrs) {
    return new Overprint(attrs);
  }
  static packets(attrs) {
    return new Packets(attrs);
  }
  static pageOffset(attrs) {
    return new PageOffset(attrs);
  }
  static pageRange(attrs) {
    return new PageRange(attrs);
  }
  static pagination(attrs) {
    return new Pagination(attrs);
  }
  static paginationOverride(attrs) {
    return new PaginationOverride(attrs);
  }
  static part(attrs) {
    return new Part(attrs);
  }
  static pcl(attrs) {
    return new Pcl(attrs);
  }
  static pdf(attrs) {
    return new Pdf(attrs);
  }
  static pdfa(attrs) {
    return new Pdfa(attrs);
  }
  static permissions(attrs) {
    return new Permissions(attrs);
  }
  static pickTrayByPDFSize(attrs) {
    return new PickTrayByPDFSize(attrs);
  }
  static picture(attrs) {
    return new Picture(attrs);
  }
  static plaintextMetadata(attrs) {
    return new PlaintextMetadata(attrs);
  }
  static presence(attrs) {
    return new Presence(attrs);
  }
  static present(attrs) {
    return new Present(attrs);
  }
  static print(attrs) {
    return new Print(attrs);
  }
  static printHighQuality(attrs) {
    return new PrintHighQuality(attrs);
  }
  static printScaling(attrs) {
    return new PrintScaling(attrs);
  }
  static printerName(attrs) {
    return new PrinterName(attrs);
  }
  static producer(attrs) {
    return new Producer(attrs);
  }
  static ps(attrs) {
    return new Ps(attrs);
  }
  static range(attrs) {
    return new Range(attrs);
  }
  static record(attrs) {
    return new Record(attrs);
  }
  static relevant(attrs) {
    return new Relevant(attrs);
  }
  static rename(attrs) {
    return new Rename(attrs);
  }
  static renderPolicy(attrs) {
    return new RenderPolicy(attrs);
  }
  static runScripts(attrs) {
    return new RunScripts(attrs);
  }
  static script(attrs) {
    return new Script(attrs);
  }
  static scriptModel(attrs) {
    return new ScriptModel(attrs);
  }
  static severity(attrs) {
    return new Severity(attrs);
  }
  static silentPrint(attrs) {
    return new SilentPrint(attrs);
  }
  static staple(attrs) {
    return new Staple(attrs);
  }
  static startNode(attrs) {
    return new StartNode(attrs);
  }
  static startPage(attrs) {
    return new StartPage(attrs);
  }
  static submitFormat(attrs) {
    return new SubmitFormat(attrs);
  }
  static submitUrl(attrs) {
    return new SubmitUrl(attrs);
  }
  static subsetBelow(attrs) {
    return new SubsetBelow(attrs);
  }
  static suppressBanner(attrs) {
    return new SuppressBanner(attrs);
  }
  static tagged(attrs) {
    return new Tagged(attrs);
  }
  static template(attrs) {
    return new Template(attrs);
  }
  static templateCache(attrs) {
    return new TemplateCache(attrs);
  }
  static threshold(attrs) {
    return new Threshold(attrs);
  }
  static to(attrs) {
    return new To(attrs);
  }
  static trace(attrs) {
    return new Trace(attrs);
  }
  static transform(attrs) {
    return new Transform(attrs);
  }
  static type(attrs) {
    return new Type(attrs);
  }
  static uri(attrs) {
    return new Uri(attrs);
  }
  static validate(attrs) {
    return new Validate(attrs);
  }
  static validateApprovalSignatures(attrs) {
    return new ValidateApprovalSignatures(attrs);
  }
  static validationMessaging(attrs) {
    return new ValidationMessaging(attrs);
  }
  static version(attrs) {
    return new Version(attrs);
  }
  static versionControl(attrs) {
    return new VersionControl(attrs);
  }
  static viewerPreferences(attrs) {
    return new ViewerPreferences(attrs);
  }
  static webClient(attrs) {
    return new WebClient(attrs);
  }
  static whitespace(attrs) {
    return new Whitespace(attrs);
  }
  static window(attrs) {
    return new Window(attrs);
  }
  static xdc(attrs) {
    return new Xdc(attrs);
  }
  static xdp(attrs) {
    return new Xdp(attrs);
  }
  static xsl(attrs) {
    return new Xsl(attrs);
  }
  static zpl(attrs) {
    return new Zpl(attrs);
  }
}
exports.ConfigNamespace = ConfigNamespace;

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionSetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id;
class ConnectionSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "connectionSet", true);
    this.wsdlConnection = new _xfa_object.XFAObjectArray();
    this.xmlConnection = new _xfa_object.XFAObjectArray();
    this.xsdConnection = new _xfa_object.XFAObjectArray();
  }
}
class EffectiveInputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class EffectiveOutputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Operation extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "operation");
    this.id = attributes.id || "";
    this.input = attributes.input || "";
    this.name = attributes.name || "";
    this.output = attributes.output || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class RootElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "rootElement");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SoapAction extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAction");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class SoapAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "uri");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class WsdlAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
}
class WsdlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }
}
class XmlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xmlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.uri = null;
  }
}
class XsdConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xsdConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.rootElement = null;
    this.uri = null;
  }
}
class ConnectionSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConnectionSetNamespace.hasOwnProperty(name)) {
      return ConnectionSetNamespace[name](attributes);
    }
    return undefined;
  }
  static connectionSet(attrs) {
    return new ConnectionSet(attrs);
  }
  static effectiveInputPolicy(attrs) {
    return new EffectiveInputPolicy(attrs);
  }
  static effectiveOutputPolicy(attrs) {
    return new EffectiveOutputPolicy(attrs);
  }
  static operation(attrs) {
    return new Operation(attrs);
  }
  static rootElement(attrs) {
    return new RootElement(attrs);
  }
  static soapAction(attrs) {
    return new SoapAction(attrs);
  }
  static soapAddress(attrs) {
    return new SoapAddress(attrs);
  }
  static uri(attrs) {
    return new Uri(attrs);
  }
  static wsdlAddress(attrs) {
    return new WsdlAddress(attrs);
  }
  static wsdlConnection(attrs) {
    return new WsdlConnection(attrs);
  }
  static xmlConnection(attrs) {
    return new XmlConnection(attrs);
  }
  static xsdConnection(attrs) {
    return new XsdConnection(attrs);
  }
}
exports.ConnectionSetNamespace = ConnectionSetNamespace;

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DatasetsNamespace = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id;
class Data extends _xfa_object.XmlObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "data", attributes);
  }
  [_symbol_utils.$isNsAgnostic]() {
    return true;
  }
}
class Datasets extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "datasets", true);
    this.data = null;
    this.Signature = null;
  }
  [_symbol_utils.$onChild](child) {
    const name = child[_symbol_utils.$nodeName];
    if (name === "data" && child[_symbol_utils.$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[_symbol_utils.$namespaceId] === _namespaces.NamespaceIds.signature.id) {
      this[name] = child;
    }
    this[_symbol_utils.$appendChild](child);
  }
}
class DatasetsNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (DatasetsNamespace.hasOwnProperty(name)) {
      return DatasetsNamespace[name](attributes);
    }
    return undefined;
  }
  static datasets(attributes) {
    return new Datasets(attributes);
  }
  static data(attributes) {
    return new Data(attributes);
  }
}
exports.DatasetsNamespace = DatasetsNamespace;

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocaleSetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
var _utils = __w_pdfjs_require__(84);
const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id;
class CalendarSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "calendarSymbols", true);
    this.name = "gregorian";
    this.dayNames = new _xfa_object.XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new _xfa_object.XFAObjectArray(2);
  }
}
class CurrencySymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["symbol", "isoname", "decimal"]);
  }
}
class CurrencySymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbols", true);
    this.currencySymbol = new _xfa_object.XFAObjectArray(3);
  }
}
class DatePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class DatePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePatterns", true);
    this.datePattern = new _xfa_object.XFAObjectArray(4);
  }
}
class DateTimeSymbols extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dateTimeSymbols");
  }
}
class Day extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "day");
  }
}
class DayNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dayNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.day = new _xfa_object.XFAObjectArray(7);
  }
}
class Era extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "era");
  }
}
class EraNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "eraNames", true);
    this.era = new _xfa_object.XFAObjectArray(2);
  }
}
class Locale extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "locale", true);
    this.desc = attributes.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }
}
class LocaleSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "localeSet", true);
    this.locale = new _xfa_object.XFAObjectArray();
  }
}
class Meridiem extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiem");
  }
}
class MeridiemNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiemNames", true);
    this.meridiem = new _xfa_object.XFAObjectArray(2);
  }
}
class Month extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "month");
  }
}
class MonthNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "monthNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.month = new _xfa_object.XFAObjectArray(12);
  }
}
class NumberPattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class NumberPatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPatterns", true);
    this.numberPattern = new _xfa_object.XFAObjectArray(4);
  }
}
class NumberSymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class NumberSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbols", true);
    this.numberSymbol = new _xfa_object.XFAObjectArray(5);
  }
}
class TimePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }
}
class TimePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePatterns", true);
    this.timePattern = new _xfa_object.XFAObjectArray(4);
  }
}
class TypeFace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFace", true);
    this.name = attributes.name | "";
  }
}
class TypeFaces extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFaces", true);
    this.typeFace = new _xfa_object.XFAObjectArray();
  }
}
class LocaleSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (LocaleSetNamespace.hasOwnProperty(name)) {
      return LocaleSetNamespace[name](attributes);
    }
    return undefined;
  }
  static calendarSymbols(attrs) {
    return new CalendarSymbols(attrs);
  }
  static currencySymbol(attrs) {
    return new CurrencySymbol(attrs);
  }
  static currencySymbols(attrs) {
    return new CurrencySymbols(attrs);
  }
  static datePattern(attrs) {
    return new DatePattern(attrs);
  }
  static datePatterns(attrs) {
    return new DatePatterns(attrs);
  }
  static dateTimeSymbols(attrs) {
    return new DateTimeSymbols(attrs);
  }
  static day(attrs) {
    return new Day(attrs);
  }
  static dayNames(attrs) {
    return new DayNames(attrs);
  }
  static era(attrs) {
    return new Era(attrs);
  }
  static eraNames(attrs) {
    return new EraNames(attrs);
  }
  static locale(attrs) {
    return new Locale(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }
  static meridiem(attrs) {
    return new Meridiem(attrs);
  }
  static meridiemNames(attrs) {
    return new MeridiemNames(attrs);
  }
  static month(attrs) {
    return new Month(attrs);
  }
  static monthNames(attrs) {
    return new MonthNames(attrs);
  }
  static numberPattern(attrs) {
    return new NumberPattern(attrs);
  }
  static numberPatterns(attrs) {
    return new NumberPatterns(attrs);
  }
  static numberSymbol(attrs) {
    return new NumberSymbol(attrs);
  }
  static numberSymbols(attrs) {
    return new NumberSymbols(attrs);
  }
  static timePattern(attrs) {
    return new TimePattern(attrs);
  }
  static timePatterns(attrs) {
    return new TimePatterns(attrs);
  }
  static typeFace(attrs) {
    return new TypeFace(attrs);
  }
  static typeFaces(attrs) {
    return new TypeFaces(attrs);
  }
}
exports.LocaleSetNamespace = LocaleSetNamespace;

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SignatureNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id;
class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(SIGNATURE_NS_ID, "signature", true);
  }
}
class SignatureNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (SignatureNamespace.hasOwnProperty(name)) {
      return SignatureNamespace[name](attributes);
    }
    return undefined;
  }
  static signature(attributes) {
    return new Signature(attributes);
  }
}
exports.SignatureNamespace = SignatureNamespace;

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StylesheetNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id;
class Stylesheet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(STYLESHEET_NS_ID, "stylesheet", true);
  }
}
class StylesheetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (StylesheetNamespace.hasOwnProperty(name)) {
      return StylesheetNamespace[name](attributes);
    }
    return undefined;
  }
  static stylesheet(attributes) {
    return new Stylesheet(attributes);
  }
}
exports.StylesheetNamespace = StylesheetNamespace;

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XdpNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _symbol_utils = __w_pdfjs_require__(78);
var _xfa_object = __w_pdfjs_require__(87);
const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id;
class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(XDP_NS_ID, "xdp", true);
    this.uuid = attributes.uuid || "";
    this.timeStamp = attributes.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new _xfa_object.XFAObjectArray();
    this.template = null;
  }
  [_symbol_utils.$onChildCheck](child) {
    const ns = _namespaces.NamespaceIds[child[_symbol_utils.$nodeName]];
    return ns && child[_symbol_utils.$namespaceId] === ns.id;
  }
}
class XdpNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XdpNamespace.hasOwnProperty(name)) {
      return XdpNamespace[name](attributes);
    }
    return undefined;
  }
  static xdp(attributes) {
    return new Xdp(attributes);
  }
}
exports.XdpNamespace = XdpNamespace;

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XhtmlNamespace = void 0;
var _symbol_utils = __w_pdfjs_require__(78);
var _namespaces = __w_pdfjs_require__(81);
var _html_utils = __w_pdfjs_require__(83);
var _utils = __w_pdfjs_require__(84);
var _xfa_object = __w_pdfjs_require__(87);
const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id;
const $richText = Symbol();
const VALID_STYLES = new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
const StyleMapping = new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", value => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", value => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", value => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (value, original) => {
  value = original.fontSize = (0, _utils.getMeasurement)(value);
  return (0, _html_utils.measureToString)(0.99 * value);
}], ["letter-spacing", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["line-height", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-bottom", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-left", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-right", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-top", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["text-indent", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["font-family", value => value], ["vertical-align", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]);
const spacesRegExp = /\s+/g;
const crlfRegExp = /[\r\n]+/g;
const crlfForRichTextRegExp = /\r\n?/g;
function mapStyle(styleStr, node, richText) {
  const style = Object.create(null);
  if (!styleStr) {
    return style;
  }
  const original = Object.create(null);
  for (const [key, value] of styleStr.split(";").map(s => s.split(":", 2))) {
    const mapping = StyleMapping.get(key);
    if (mapping === "") {
      continue;
    }
    let newValue = value;
    if (mapping) {
      newValue = typeof mapping === "string" ? mapping : mapping(value, original);
    }
    if (key.endsWith("scale")) {
      style.transform = style.transform ? `${style[key]} ${newValue}` : newValue;
    } else {
      style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
    }
  }
  if (style.fontFamily) {
    (0, _html_utils.setFontFamily)({
      typeface: style.fontFamily,
      weight: style.fontWeight || "normal",
      posture: style.fontStyle || "normal",
      size: original.fontSize || 0
    }, node, node[_symbol_utils.$globalData].fontFinder, style);
  }
  if (richText && style.verticalAlign && style.verticalAlign !== "0px" && style.fontSize) {
    const SUB_SUPER_SCRIPT_FACTOR = 0.583;
    const VERTICAL_FACTOR = 0.333;
    const fontSize = (0, _utils.getMeasurement)(style.fontSize);
    style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR);
    style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR);
  }
  if (richText && style.fontSize) {
    style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`;
  }
  (0, _html_utils.fixTextIndent)(style);
  return style;
}
function checkStyle(node) {
  if (!node.style) {
    return "";
  }
  return node.style.trim().split(/\s*;\s*/).filter(s => !!s).map(s => s.split(/\s*:\s*/, 2)).filter(([key, value]) => {
    if (key === "font-family") {
      node[_symbol_utils.$globalData].usedTypefaces.add(value);
    }
    return VALID_STYLES.has(key);
  }).map(kv => kv.join(":")).join(";");
}
const NoWhites = new Set(["body", "html"]);
class XhtmlObject extends _xfa_object.XmlObject {
  constructor(attributes, name) {
    super(XHTML_NS_ID, name);
    this[$richText] = false;
    this.style = attributes.style || "";
  }
  [_symbol_utils.$clean](builder) {
    super[_symbol_utils.$clean](builder);
    this.style = checkStyle(this);
  }
  [_symbol_utils.$acceptWhitespace]() {
    return !NoWhites.has(this[_symbol_utils.$nodeName]);
  }
  [_symbol_utils.$onText](str, richText = false) {
    if (!richText) {
      str = str.replaceAll(crlfRegExp, "");
      if (!this.style.includes("xfa-spacerun:yes")) {
        str = str.replaceAll(spacesRegExp, " ");
      }
    } else {
      this[$richText] = true;
    }
    if (str) {
      this[_symbol_utils.$content] += str;
    }
  }
  [_symbol_utils.$pushGlyphs](measure, mustPop = true) {
    const xfaFont = Object.create(null);
    const margin = {
      top: NaN,
      bottom: NaN,
      left: NaN,
      right: NaN
    };
    let lineHeight = null;
    for (const [key, value] of this.style.split(";").map(s => s.split(":", 2))) {
      switch (key) {
        case "font-family":
          xfaFont.typeface = (0, _utils.stripQuotes)(value);
          break;
        case "font-size":
          xfaFont.size = (0, _utils.getMeasurement)(value);
          break;
        case "font-weight":
          xfaFont.weight = value;
          break;
        case "font-style":
          xfaFont.posture = value;
          break;
        case "letter-spacing":
          xfaFont.letterSpacing = (0, _utils.getMeasurement)(value);
          break;
        case "margin":
          const values = value.split(/ \t/).map(x => (0, _utils.getMeasurement)(x));
          switch (values.length) {
            case 1:
              margin.top = margin.bottom = margin.left = margin.right = values[0];
              break;
            case 2:
              margin.top = margin.bottom = values[0];
              margin.left = margin.right = values[1];
              break;
            case 3:
              margin.top = values[0];
              margin.bottom = values[2];
              margin.left = margin.right = values[1];
              break;
            case 4:
              margin.top = values[0];
              margin.left = values[1];
              margin.bottom = values[2];
              margin.right = values[3];
              break;
          }
          break;
        case "margin-top":
          margin.top = (0, _utils.getMeasurement)(value);
          break;
        case "margin-bottom":
          margin.bottom = (0, _utils.getMeasurement)(value);
          break;
        case "margin-left":
          margin.left = (0, _utils.getMeasurement)(value);
          break;
        case "margin-right":
          margin.right = (0, _utils.getMeasurement)(value);
          break;
        case "line-height":
          lineHeight = (0, _utils.getMeasurement)(value);
          break;
      }
    }
    measure.pushData(xfaFont, margin, lineHeight);
    if (this[_symbol_utils.$content]) {
      measure.addString(this[_symbol_utils.$content]);
    } else {
      for (const child of this[_symbol_utils.$getChildren]()) {
        if (child[_symbol_utils.$nodeName] === "#text") {
          measure.addString(child[_symbol_utils.$content]);
          continue;
        }
        child[_symbol_utils.$pushGlyphs](measure);
      }
    }
    if (mustPop) {
      measure.popFont();
    }
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const children = [];
    this[_symbol_utils.$extra] = {
      children
    };
    this[_symbol_utils.$childrenToHTML]({});
    if (children.length === 0 && !this[_symbol_utils.$content]) {
      return _utils.HTMLResult.EMPTY;
    }
    let value;
    if (this[$richText]) {
      value = this[_symbol_utils.$content] ? this[_symbol_utils.$content].replaceAll(crlfForRichTextRegExp, "\n") : undefined;
    } else {
      value = this[_symbol_utils.$content] || undefined;
    }
    return _utils.HTMLResult.success({
      name: this[_symbol_utils.$nodeName],
      attributes: {
        href: this.href,
        style: mapStyle(this.style, this, this[$richText])
      },
      children,
      value
    });
  }
}
class A extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "a");
    this.href = (0, _html_utils.fixURL)(attributes.href) || "";
  }
}
class B extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "b");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.pushFont({
      weight: "bold"
    });
    super[_symbol_utils.$pushGlyphs](measure);
    measure.popFont();
  }
}
class Body extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "body");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const res = super[_symbol_utils.$toHTML](availableSpace);
    const {
      html
    } = res;
    if (!html) {
      return _utils.HTMLResult.EMPTY;
    }
    html.name = "div";
    html.attributes.class = ["xfaRich"];
    return res;
  }
}
class Br extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "br");
  }
  [_symbol_utils.$text]() {
    return "\n";
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.addString("\n");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    return _utils.HTMLResult.success({
      name: "br"
    });
  }
}
class Html extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "html");
  }
  [_symbol_utils.$toHTML](availableSpace) {
    const children = [];
    this[_symbol_utils.$extra] = {
      children
    };
    this[_symbol_utils.$childrenToHTML]({});
    if (children.length === 0) {
      return _utils.HTMLResult.success({
        name: "div",
        attributes: {
          class: ["xfaRich"],
          style: {}
        },
        value: this[_symbol_utils.$content] || ""
      });
    }
    if (children.length === 1) {
      const child = children[0];
      if (child.attributes?.class.includes("xfaRich")) {
        return _utils.HTMLResult.success(child);
      }
    }
    return _utils.HTMLResult.success({
      name: "div",
      attributes: {
        class: ["xfaRich"],
        style: {}
      },
      children
    });
  }
}
class I extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "i");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    measure.pushFont({
      posture: "italic"
    });
    super[_symbol_utils.$pushGlyphs](measure);
    measure.popFont();
  }
}
class Li extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "li");
  }
}
class Ol extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ol");
  }
}
class P extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "p");
  }
  [_symbol_utils.$pushGlyphs](measure) {
    super[_symbol_utils.$pushGlyphs](measure, false);
    measure.addString("\n");
    measure.addPara();
    measure.popFont();
  }
  [_symbol_utils.$text]() {
    const siblings = this[_symbol_utils.$getParent]()[_symbol_utils.$getChildren]();
    if (siblings.at(-1) === this) {
      return super[_symbol_utils.$text]();
    }
    return super[_symbol_utils.$text]() + "\n";
  }
}
class Span extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "span");
  }
}
class Sub extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sub");
  }
}
class Sup extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sup");
  }
}
class Ul extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ul");
  }
}
class XhtmlNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XhtmlNamespace.hasOwnProperty(name)) {
      return XhtmlNamespace[name](attributes);
    }
    return undefined;
  }
  static a(attributes) {
    return new A(attributes);
  }
  static b(attributes) {
    return new B(attributes);
  }
  static body(attributes) {
    return new Body(attributes);
  }
  static br(attributes) {
    return new Br(attributes);
  }
  static html(attributes) {
    return new Html(attributes);
  }
  static i(attributes) {
    return new I(attributes);
  }
  static li(attributes) {
    return new Li(attributes);
  }
  static ol(attributes) {
    return new Ol(attributes);
  }
  static p(attributes) {
    return new P(attributes);
  }
  static span(attributes) {
    return new Span(attributes);
  }
  static sub(attributes) {
    return new Sub(attributes);
  }
  static sup(attributes) {
    return new Sup(attributes);
  }
  static ul(attributes) {
    return new Ul(attributes);
  }
}
exports.XhtmlNamespace = XhtmlNamespace;

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnknownNamespace = void 0;
var _namespaces = __w_pdfjs_require__(81);
var _xfa_object = __w_pdfjs_require__(87);
class UnknownNamespace {
  constructor(nsId) {
    this.namespaceId = nsId;
  }
  [_namespaces.$buildXFAObject](name, attributes) {
    return new _xfa_object.XmlObject(this.namespaceId, name, attributes);
  }
}
exports.UnknownNamespace = UnknownNamespace;

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DatasetReader = void 0;
var _util = __w_pdfjs_require__(2);
var _core_utils = __w_pdfjs_require__(3);
var _xml_parser = __w_pdfjs_require__(71);
function decodeString(str) {
  try {
    return (0, _util.stringToUTF8String)(str);
  } catch (ex) {
    (0, _util.warn)(`UTF-8 decoding failed: "${ex}".`);
    return str;
  }
}
class DatasetXMLParser extends _xml_parser.SimpleXMLParser {
  constructor(options) {
    super(options);
    this.node = null;
  }
  onEndElement(name) {
    const node = super.onEndElement(name);
    if (node && name === "xfa:datasets") {
      this.node = node;
      throw new Error("Aborting DatasetXMLParser.");
    }
  }
}
class DatasetReader {
  constructor(data) {
    if (data.datasets) {
      this.node = new _xml_parser.SimpleXMLParser({
        hasAttributes: true
      }).parseFromString(data.datasets).documentElement;
    } else {
      const parser = new DatasetXMLParser({
        hasAttributes: true
      });
      try {
        parser.parseFromString(data["xdp:xdp"]);
      } catch {}
      this.node = parser.node;
    }
  }
  getValue(path) {
    if (!this.node || !path) {
      return "";
    }
    const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0);
    if (!node) {
      return "";
    }
    const first = node.firstChild;
    if (first?.nodeName === "value") {
      return node.children.map(child => decodeString(child.textContent));
    }
    return decodeString(node.textContent);
  }
}
exports.DatasetReader = DatasetReader;

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRef = void 0;
var _util = __w_pdfjs_require__(2);
var _primitives = __w_pdfjs_require__(4);
var _parser = __w_pdfjs_require__(16);
var _core_utils = __w_pdfjs_require__(3);
var _base_stream = __w_pdfjs_require__(5);
var _crypto = __w_pdfjs_require__(74);
class XRef {
  #firstXRefStmPos = null;
  constructor(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this._xrefStms = new Set();
    this._cacheMap = new Map();
    this._pendingRefs = new _primitives.RefSet();
    this._newPersistentRefNum = null;
    this._newTemporaryRefNum = null;
  }
  getNewPersistentRef(obj) {
    if (this._newPersistentRefNum === null) {
      this._newPersistentRefNum = this.entries.length || 1;
    }
    const num = this._newPersistentRefNum++;
    this._cacheMap.set(num, obj);
    return _primitives.Ref.get(num, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null) {
      this._newTemporaryRefNum = this.entries.length || 1;
    }
    return _primitives.Ref.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    this._newTemporaryRefNum = null;
  }
  setStartXRef(startXRef) {
    this.startXRefQueue = [startXRef];
  }
  parse(recoveryMode = false) {
    let trailerDict;
    if (!recoveryMode) {
      trailerDict = this.readXRef();
    } else {
      (0, _util.warn)("Indexing all PDF objects");
      trailerDict = this.indexObjects();
    }
    trailerDict.assignXref(this);
    this.trailer = trailerDict;
    let encrypt;
    try {
      encrypt = trailerDict.get("Encrypt");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
    }
    if (encrypt instanceof _primitives.Dict) {
      const ids = trailerDict.get("ID");
      const fileId = ids?.length ? ids[0] : "";
      encrypt.suppressEncryption = true;
      this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
    }
    let root;
    try {
      root = trailerDict.get("Root");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }
      (0, _util.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
    }
    if (root instanceof _primitives.Dict) {
      try {
        const pages = root.get("Pages");
        if (pages instanceof _primitives.Dict) {
          this.root = root;
          return;
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }
        (0, _util.warn)(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
      }
    }
    if (!recoveryMode) {
      throw new _core_utils.XRefParseException();
    }
    throw new _util.InvalidPDFException("Invalid Root reference.");
  }
  processXRefTable(parser) {
    if (!("tableState" in this)) {
      this.tableState = {
        entryNum: 0,
        streamPos: parser.lexer.stream.pos,
        parserBuf1: parser.buf1,
        parserBuf2: parser.buf2
      };
    }
    const obj = this.readXRefTable(parser);
    if (!(0, _primitives.isCmd)(obj, "trailer")) {
      throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
    }
    let dict = parser.getObj();
    if (!(dict instanceof _primitives.Dict) && dict.dict) {
      dict = dict.dict;
    }
    if (!(dict instanceof _primitives.Dict)) {
      throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
    }
    delete this.tableState;
    return dict;
  }
  readXRefTable(parser) {
    const stream = parser.lexer.stream;
    const tableState = this.tableState;
    stream.pos = tableState.streamPos;
    parser.buf1 = tableState.parserBuf1;
    parser.buf2 = tableState.parserBuf2;
    let obj;
    while (true) {
      if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
        if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
          break;
        }
        tableState.firstEntryNum = obj;
        tableState.entryCount = parser.getObj();
      }
      let first = tableState.firstEntryNum;
      const count = tableState.entryCount;
      if (!Number.isInteger(first) || !Number.isInteger(count)) {
        throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
      }
      for (let i = tableState.entryNum; i < count; i++) {
        tableState.streamPos = stream.pos;
        tableState.entryNum = i;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        const entry = {};
        entry.offset = parser.getObj();
        entry.gen = parser.getObj();
        const type = parser.getObj();
        if (type instanceof _primitives.Cmd) {
          switch (type.cmd) {
            case "f":
              entry.free = true;
              break;
            case "n":
              entry.uncompressed = true;
              break;
          }
        }
        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
          throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
        }
        if (i === 0 && entry.free && first === 1) {
          first = 0;
        }
        if (!this.entries[i + first]) {
          this.entries[i + first] = entry;
        }
      }
      tableState.entryNum = 0;
      tableState.streamPos = stream.pos;
      tableState.parserBuf1 = parser.buf1;
      tableState.parserBuf2 = parser.buf2;
      delete tableState.firstEntryNum;
      delete tableState.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) {
      throw new _util.FormatError("Invalid XRef table: unexpected first object");
    }
    return obj;
  }
  processXRefStream(stream) {
    if (!("streamState" in this)) {
      const streamParameters = stream.dict;
      const byteWidths = streamParameters.get("W");
      let range = streamParameters.get("Index");
      if (!range) {
        range = [0, streamParameters.get("Size")];
      }
      this.streamState = {
        entryRanges: range,
        byteWidths,
        entryNum: 0,
        streamPos: stream.pos
      };
    }
    this.readXRefStream(stream);
    delete this.streamState;
    return stream.dict;
  }
  readXRefStream(stream) {
    const streamState = this.streamState;
    stream.pos = streamState.streamPos;
    const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths;
    const entryRanges = streamState.entryRanges;
    while (entryRanges.length > 0) {
      const [first, n] = entryRanges;
      if (!Number.isInteger(first) || !Number.isInteger(n)) {
        throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
      }
      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
        throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
      }
      for (let i = streamState.entryNum; i < n; ++i) {
        streamState.entryNum = i;
        streamState.streamPos = stream.pos;
        let type = 0,
          offset = 0,
          generation = 0;
        for (let j = 0; j < typeFieldWidth; ++j) {
          const typeByte = stream.getByte();
          if (typeByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'type'.");
          }
          type = type << 8 | typeByte;
        }
        if (typeFieldWidth === 0) {
          type = 1;
        }
        for (let j = 0; j < offsetFieldWidth; ++j) {
          const offsetByte = stream.getByte();
          if (offsetByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'offset'.");
          }
          offset = offset << 8 | offsetByte;
        }
        for (let j = 0; j < generationFieldWidth; ++j) {
          const generationByte = stream.getByte();
          if (generationByte === -1) {
            throw new _util.FormatError("Invalid XRef byteWidths 'generation'.");
          }
          generation = generation << 8 | generationByte;
        }
        const entry = {};
        entry.offset = offset;
        entry.gen = generation;
        switch (type) {
          case 0:
            entry.free = true;
            break;
          case 1:
            entry.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new _util.FormatError(`Invalid XRef entry type: ${type}`);
        }
        if (!this.entries[first + i]) {
          this.entries[first + i] = entry;
        }
      }
      streamState.entryNum = 0;
      streamState.streamPos = stream.pos;
      entryRanges.splice(0, 2);
    }
  }
  indexObjects() {
    const TAB = 0x9,
      LF = 0xa,
      CR = 0xd,
      SPACE = 0x20;
    const PERCENT = 0x25,
      LT = 0x3c;
    function readToken(data, offset) {
      let token = "",
        ch = data[offset];
      while (ch !== LF && ch !== CR && ch !== LT) {
        if (++offset >= data.length) {
          break;
        }
        token += String.fromCharCode(ch);
        ch = data[offset];
      }
      return token;
    }
    function skipUntil(data, offset, what) {
      const length = what.length,
        dataLength = data.length;
      let skipped = 0;
      while (offset < dataLength) {
        let i = 0;
        while (i < length && data[offset + i] === what[i]) {
          ++i;
        }
        if (i >= length) {
          break;
        }
        offset++;
        skipped++;
      }
      return skipped;
    }
    const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g;
    const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
    const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
    const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
    const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    this._cacheMap.clear();
    const stream = this.stream;
    stream.pos = 0;
    const buffer = stream.getBytes(),
      bufferStr = (0, _util.bytesToString)(buffer),
      length = buffer.length;
    let position = stream.start;
    const trailers = [],
      xrefStms = [];
    while (position < length) {
      let ch = buffer[position];
      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
        ++position;
        continue;
      }
      if (ch === PERCENT) {
        do {
          ++position;
          if (position >= length) {
            break;
          }
          ch = buffer[position];
        } while (ch !== LF && ch !== CR);
        continue;
      }
      const token = readToken(buffer, position);
      let m;
      if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
        position += skipUntil(buffer, position, trailerBytes);
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else if (m = objRegExp.exec(token)) {
        const num = m[1] | 0,
          gen = m[2] | 0;
        const startPos = position + token.length;
        let contentLength,
          updateEntries = false;
        if (!this.entries[num]) {
          updateEntries = true;
        } else if (this.entries[num].gen === gen) {
          try {
            const parser = new _parser.Parser({
              lexer: new _parser.Lexer(stream.makeSubStream(startPos))
            });
            parser.getObj();
            updateEntries = true;
          } catch (ex) {
            if (ex instanceof _core_utils.ParserEOFException) {
              (0, _util.warn)(`indexObjects -- checking object (${token}): "${ex}".`);
            } else {
              updateEntries = true;
            }
          }
        }
        if (updateEntries) {
          this.entries[num] = {
            offset: position - stream.start,
            gen,
            uncompressed: true
          };
        }
        gEndobjRegExp.lastIndex = startPos;
        const match = gEndobjRegExp.exec(bufferStr);
        if (match) {
          const endPos = gEndobjRegExp.lastIndex + 1;
          contentLength = endPos - position;
          if (match[1] !== "endobj") {
            (0, _util.warn)(`indexObjects: Found "${match[1]}" inside of another "obj", ` + 'caused by missing "endobj" -- trying to recover.');
            contentLength -= match[1].length + 1;
          }
        } else {
          contentLength = length - position;
        }
        const content = buffer.subarray(position, position + contentLength);
        const xrefTagOffset = skipUntil(content, 0, xrefBytes);
        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
          xrefStms.push(position - stream.start);
          this._xrefStms.add(position - stream.start);
        }
        position += contentLength;
      } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
        trailers.push(position);
        const startPos = position + token.length;
        let contentLength;
        gStartxrefRegExp.lastIndex = startPos;
        const match = gStartxrefRegExp.exec(bufferStr);
        if (match) {
          const endPos = gStartxrefRegExp.lastIndex + 1;
          contentLength = endPos - position;
          if (match[1] !== "startxref") {
            (0, _util.warn)(`indexObjects: Found "${match[1]}" after "trailer", ` + 'caused by missing "startxref" -- trying to recover.');
            contentLength -= match[1].length + 1;
          }
        } else {
          contentLength = length - position;
        }
        position += contentLength;
      } else {
        position += token.length + 1;
      }
    }
    for (const xrefStm of xrefStms) {
      this.startXRefQueue.push(xrefStm);
      this.readXRef(true);
    }
    const trailerDicts = [];
    let isEncrypted = false;
    for (const trailer of trailers) {
      stream.pos = trailer;
      const parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream),
        xref: this,
        allowStreams: true,
        recoveryMode: true
      });
      const obj = parser.getObj();
      if (!(0, _primitives.isCmd)(obj, "trailer")) {
        continue;
      }
      const dict = parser.getObj();
      if (!(dict instanceof _primitives.Dict)) {
        continue;
      }
      trailerDicts.push(dict);
      if (dict.has("Encrypt")) {
        isEncrypted = true;
      }
    }
    let trailerDict, trailerError;
    for (const dict of [...trailerDicts, "genFallback", ...trailerDicts]) {
      if (dict === "genFallback") {
        if (!trailerError) {
          break;
        }
        this._generationFallback = true;
        continue;
      }
      let validPagesDict = false;
      try {
        const rootDict = dict.get("Root");
        if (!(rootDict instanceof _primitives.Dict)) {
          continue;
        }
        const pagesDict = rootDict.get("Pages");
        if (!(pagesDict instanceof _primitives.Dict)) {
          continue;
        }
        const pagesCount = pagesDict.get("Count");
        if (Number.isInteger(pagesCount)) {
          validPagesDict = true;
        }
      } catch (ex) {
        trailerError = ex;
        continue;
      }
      if (validPagesDict && (!isEncrypted || dict.has("Encrypt")) && dict.has("ID")) {
        return dict;
      }
      trailerDict = dict;
    }
    if (trailerDict) {
      return trailerDict;
    }
    if (this.topDict) {
      return this.topDict;
    }
    throw new _util.InvalidPDFException("Invalid PDF structure.");
  }
  readXRef(recoveryMode = false) {
    const stream = this.stream;
    const startXRefParsedCache = new Set();
    while (this.startXRefQueue.length) {
      try {
        const startXRef = this.startXRefQueue[0];
        if (startXRefParsedCache.has(startXRef)) {
          (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }
        startXRefParsedCache.add(startXRef);
        stream.pos = startXRef + stream.start;
        const parser = new _parser.Parser({
          lexer: new _parser.Lexer(stream),
          xref: this,
          allowStreams: true
        });
        let obj = parser.getObj();
        let dict;
        if ((0, _primitives.isCmd)(obj, "xref")) {
          dict = this.processXRefTable(parser);
          if (!this.topDict) {
            this.topDict = dict;
          }
          obj = dict.get("XRefStm");
          if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {
            this._xrefStms.add(obj);
            this.startXRefQueue.push(obj);
            this.#firstXRefStmPos ??= obj;
          }
        } else if (Number.isInteger(obj)) {
          if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) {
            throw new _util.FormatError("Invalid XRef stream");
          }
          dict = this.processXRefStream(obj);
          if (!this.topDict) {
            this.topDict = dict;
          }
          if (!dict) {
            throw new _util.FormatError("Failed to read XRef stream");
          }
        } else {
          throw new _util.FormatError("Invalid XRef stream header");
        }
        obj = dict.get("Prev");
        if (Number.isInteger(obj)) {
          this.startXRefQueue.push(obj);
        } else if (obj instanceof _primitives.Ref) {
          this.startXRefQueue.push(obj.num);
        }
      } catch (e) {
        if (e instanceof _core_utils.MissingDataException) {
          throw e;
        }
        (0, _util.info)("(while reading XRef): " + e);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) {
      return this.topDict;
    }
    if (recoveryMode) {
      return undefined;
    }
    throw new _core_utils.XRefParseException();
  }
  get lastXRefStreamPos() {
    return this.#firstXRefStmPos ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(i) {
    const xrefEntry = this.entries[i];
    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
      return xrefEntry;
    }
    return null;
  }
  fetchIfRef(obj, suppressEncryption = false) {
    if (obj instanceof _primitives.Ref) {
      return this.fetch(obj, suppressEncryption);
    }
    return obj;
  }
  fetch(ref, suppressEncryption = false) {
    if (!(ref instanceof _primitives.Ref)) {
      throw new Error("ref object is not a reference");
    }
    const num = ref.num;
    const cacheEntry = this._cacheMap.get(num);
    if (cacheEntry !== undefined) {
      if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
        cacheEntry.objId = ref.toString();
      }
      return cacheEntry;
    }
    let xrefEntry = this.getEntry(num);
    if (xrefEntry === null) {
      this._cacheMap.set(num, xrefEntry);
      return xrefEntry;
    }
    if (this._pendingRefs.has(ref)) {
      this._pendingRefs.remove(ref);
      (0, _util.warn)(`Ignoring circular reference: ${ref}.`);
      return _primitives.CIRCULAR_REF;
    }
    this._pendingRefs.put(ref);
    try {
      xrefEntry = xrefEntry.uncompressed ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption) : this.fetchCompressed(ref, xrefEntry, suppressEncryption);
      this._pendingRefs.remove(ref);
    } catch (ex) {
      this._pendingRefs.remove(ref);
      throw ex;
    }
    if (xrefEntry instanceof _primitives.Dict) {
      xrefEntry.objId = ref.toString();
    } else if (xrefEntry instanceof _base_stream.BaseStream) {
      xrefEntry.dict.objId = ref.toString();
    }
    return xrefEntry;
  }
  fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
    const gen = ref.gen;
    let num = ref.num;
    if (xrefEntry.gen !== gen) {
      const msg = `Inconsistent generation in XRef: ${ref}`;
      if (this._generationFallback && xrefEntry.gen < gen) {
        (0, _util.warn)(msg);
        return this.fetchUncompressed(_primitives.Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption);
      }
      throw new _core_utils.XRefEntryException(msg);
    }
    const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
    const parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    if (obj3.cmd !== "obj") {
      if (obj3.cmd.startsWith("obj")) {
        num = parseInt(obj3.cmd.substring(3), 10);
        if (!Number.isNaN(num)) {
          return num;
        }
      }
      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    xrefEntry = this.encrypt && !suppressEncryption ? parser.getObj(this.encrypt.createCipherTransform(num, gen)) : parser.getObj();
    if (!(xrefEntry instanceof _base_stream.BaseStream)) {
      this._cacheMap.set(num, xrefEntry);
    }
    return xrefEntry;
  }
  fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
    const tableOffset = xrefEntry.offset;
    const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
    if (!(stream instanceof _base_stream.BaseStream)) {
      throw new _util.FormatError("bad ObjStm stream");
    }
    const first = stream.dict.get("First");
    const n = stream.dict.get("N");
    if (!Number.isInteger(first) || !Number.isInteger(n)) {
      throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
    }
    let parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const nums = new Array(n);
    const offsets = new Array(n);
    for (let i = 0; i < n; ++i) {
      const num = parser.getObj();
      if (!Number.isInteger(num)) {
        throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`);
      }
      const offset = parser.getObj();
      if (!Number.isInteger(offset)) {
        throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
      }
      nums[i] = num;
      offsets[i] = offset;
    }
    const start = (stream.start || 0) + first;
    const entries = new Array(n);
    for (let i = 0; i < n; ++i) {
      const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;
      if (length < 0) {
        throw new _util.FormatError("Invalid offset in the ObjStm stream.");
      }
      parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
        xref: this,
        allowStreams: true
      });
      const obj = parser.getObj();
      entries[i] = obj;
      if (obj instanceof _base_stream.BaseStream) {
        continue;
      }
      const num = nums[i],
        entry = this.entries[num];
      if (entry && entry.offset === tableOffset && entry.gen === i) {
        this._cacheMap.set(num, obj);
      }
    }
    xrefEntry = entries[xrefEntry.gen];
    if (xrefEntry === undefined) {
      throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
    }
    return xrefEntry;
  }
  async fetchIfRefAsync(obj, suppressEncryption) {
    if (obj instanceof _primitives.Ref) {
      return this.fetchAsync(obj, suppressEncryption);
    }
    return obj;
  }
  async fetchAsync(ref, suppressEncryption) {
    try {
      return this.fetch(ref, suppressEncryption);
    } catch (ex) {
      if (!(ex instanceof _core_utils.MissingDataException)) {
        throw ex;
      }
      await this.pdfManager.requestRange(ex.begin, ex.end);
      return this.fetchAsync(ref, suppressEncryption);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
exports.XRef = XRef;

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;
var _util = __w_pdfjs_require__(2);
const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);
    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);
    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);
    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);
    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);
    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}
class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);
    this._onComObjOnMessage = event => {
      const data = event.data;
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this.#processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this.#createStreamSink(data);
        return;
      }
      action(data.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = new _util.PromiseCapability();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
      sourceName = this.sourceName,
      targetName = this.targetName,
      comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = new _util.PromiseCapability();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  #createStreamSink(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const self = this,
      action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = new _util.PromiseCapability();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },
      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: new _util.PromiseCapability(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
      streamSink = this.streamSinks[streamId];
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull?.());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        new Promise(function (resolve) {
          resolve(streamSink.onCancel?.(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
exports.MessageHandler = MessageHandler;

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorkerStream = void 0;
var _util = __w_pdfjs_require__(2);
class PDFWorkerStream {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
exports.PDFWorkerStream = PDFWorkerStream;
class PDFWorkerStreamReader {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;
    const readableStream = this._msgHandler.sendWithStream("GetReader");
    this._reader = readableStream.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(data => {
      this._isStreamingSupported = data.isStreamingSupported;
      this._isRangeSupported = data.isRangeSupported;
      this._contentLength = data.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: undefined,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
}
class PDFWorkerStreamRangeReader {
  constructor(begin, end, msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
      begin,
      end
    });
    this._reader = readableStream.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: undefined,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "WorkerMessageHandler", ({
  enumerable: true,
  get: function () {
    return _worker.WorkerMessageHandler;
  }
}));
var _worker = __w_pdfjs_require__(1);
const pdfjsVersion = '3.11.174';
const pdfjsBuild = 'ce8716743';
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.worker.js.map]]></content>
  </entry>
</search>
