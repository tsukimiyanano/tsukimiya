<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Less</title>
    <url>/tsukimiya.github.io/2024/06/01/CSS/Less/</url>
    <content><![CDATA[<h2 id="CSS的弊端"><a href="#CSS的弊端" class="headerlink" title="CSS的弊端"></a>CSS的弊端</h2><p>CSS是一门非程序的语言，没有变量、函数、作用域(SCOPE)等概念。</p>
<p>CSS在一定程度上，有下面这些弊端：</p>
<ol>
<li>冗余度较高 (特别是在选择器上嵌套的层次过多)</li>
<li>不方便维护及扩展，不利于复用</li>
<li>没有很好的计算能力 (虽然css3中引入了calc()函数，但是计算能力有限，并且效率不高)</li>
</ol>
<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>less（Leaner Style Sheets的缩写）是一门CSS扩展语言，也称为CSS预处理器。 可以理解为css的超集。<br>它在css的语法基础上，引入了变量、Mixin(混入)、运算以及函数等功能，使得css更加简洁，Write less, do more！</p>
<p>Less中文网址：<a href="http://lesscss.cn/">http://lesscss.cn/</a></p>
<p>常见的CSS预处理器：Sass、Less、Stylus</p>
<h3 id="Less编译"><a href="#Less编译" class="headerlink" title="Less编译"></a>Less编译</h3><p>本质上，Less包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的CSS文件。<br>所以我们需要把less文件，编译生成为css文件，html页面才能使用。</p>
<ul>
<li><p>Easy LESS插件<br>Easy LESS插件可以在我们保存less文件的时候自动编译less文件，并生成对应的css文件。<br>当我们修改less文件的时候，生成的css文件会自动更新。<br>我们只需要在页面引入生成的css文件即可。</p>
</li>
<li><p>Less文件中的注释是 &#x2F;&#x2F;<br>Less文件是通过js来解析的，所以注释是js的注释。而不是css的注释&#x2F;* <em>&#x2F;<br>Less文件生成的css文件，&#x2F;&#x2F;注释不会保留。<br>Less文件也支持多行注释 &#x2F;</em> *&#x2F;，且会保留在css文件中。</p>
</li>
</ul>
<h3 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">@变量名: 值;</span><br></pre></td></tr></table></figure>
<p>变量命名规范：</p>
<ul>
<li>变量名必须以@开头</li>
<li>不能包含特殊字符</li>
<li>不能以数字开头</li>
<li>区分大小写</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个粉色的变量</span></span><br><span class="line"><span class="variable">@color:</span> pink;</span><br><span class="line"><span class="comment">// 引用变量</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  backgroud-<span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Less嵌套"><a href="#Less嵌套" class="headerlink" title="Less嵌套"></a>Less嵌套</h3><p>Less支持嵌套写法</p>
<ol>
<li>子元素样式直接写到父元素里面</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果遇见 交集|伪类|伪元素选择器</li>
</ol>
<ul>
<li>内层选择器的前面没有 &amp; 符号，则它被解析为父选择器的后代</li>
</ul>
  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会被解析为：</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">a :hover&#123; // 就不是a的伪类的，而是a的子元素</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果有 &amp; 符号，则被解析为父元素自身或父元素的伪类</li>
</ul>
  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会被解析为：</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h3><p>任何数字、颜色或者变量都可以参与运算。就是Less提供了加(+)、减(-)、乘(*)、除(&#x2F;)算术运算。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">  <span class="variable">@border:</span> <span class="number">5px</span> + <span class="number">5</span>;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: (<span class="number">200px</span> - <span class="number">50</span>) * <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">height</span>: (<span class="number">200px</span> / <span class="number">2</span>); <span class="comment">// 除法运算，需要用()括起来</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@border</span> solid blue + <span class="number">222</span>; <span class="comment">// #666 - 222 = #444</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运算，我们在去写rem的时候就方便很多。比如：<br>html的<code>font-size: 50px;</code><br>某元素大小为<code>82px</code>，换成rem就直接写成 <code>82/50 rem</code> 就可以了，不用再去计算。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>运算符左右两侧必须有一个空格(现在可以不加空格了)</li>
<li>除法运算需要用()括起来</li>
<li>两个数参与运算，如果只有一个数有单位，则结果以这个单位为准</li>
<li>两个数参与运算，如果2个数都有单位，且是不一样的单位，则以第一个单位为准</li>
</ol>
<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>Sass中文网：<a href="https://www.sass.hk/">https://www.sass.hk/</a><br>Sass官网：<a href="https://sass.bootcss.com/index.html">https://sass.bootcss.com/index.html</a><br><a href="https://ruanyifeng.com/blog/2012/06/sass.html">Sass用法指南</a> - 阮一峰的网络日志</p>
<p>Sass和Less的区别：</p>
<ol>
<li>语法风格：<ul>
<li>Sass有两种语法风格，一种是使用缩进(类似Python)的缩写语法(.sass)，一种是SCSS(Sassy CSS)，它与CSS语法几乎完全相同，只是添加了额外的功能(使用.scss扩展名)。SCSS现在更为普遍。</li>
<li>Less语法更接近传统的css，使用大括号<code>&#123;&#125;</code>界定代码块，使得css开发正更易上手。</li>
</ul>
</li>
<li>编译环境：<ul>
<li>Sass 最初是基于Ruby的，需要Ruby环境来运行。尽管后来推出了Dart实现的dart-sass，它不依赖Ruby，但编译速度可能较慢。Sass通常作为开发流程的一部分在服务器端编译。</li>
<li>Less 是基于JavaScript的，可以借助Less.js在客户端（浏览器）直接处理，也可以在构建过程中服务器端编译。由于客户端处理可能会增加页面加载时间和CPU负担，生产环境中通常选择预先编译。</li>
</ul>
</li>
<li>变量和Mixin（混入）:<ul>
<li>在Sass 中，变量以 <code>$</code> 符号开始，Mixin 使用 <code>@mixin</code> 定义，提供了更强大的继承、占位符和模块化功能。</li>
<li>Less 也支持变量（以 <code>@</code> 开头）和Mixin，但Sass在高级功能（如嵌套、继承、函数）方面通常被认为更强大和灵活。</li>
</ul>
</li>
<li>循环和逻辑：<ul>
<li>Sass 支持 for、each、while 等循环以及条件语句，使数据驱动的样式生成更加灵活。</li>
<li>Less 虽然可以通过递归来模拟循环，但它原生并不支持除数值递增外的循环结构，这在复杂逻辑处理上可能不如Sass方便。</li>
</ul>
</li>
<li>扩展性和生态系统:<ul>
<li>Sass 拥有悠久的历史和庞大的社区，提供了如Compass这样的强大框架，以及丰富的插件和库。</li>
</ul>
</li>
<li>编译工具和集成:<ul>
<li>两者都有良好的集成工具和编译器，比如Grunt、Gulp、Webpack等前端构建工具都可以方便地集成Sass和Less的编译过程。</li>
</ul>
</li>
</ol>
<p>Sass和Less的选择往往取决于个人或团队的偏好、项目需求以及对特定特性的需求。Sass在功能和生态系统方面可能更成熟一些，提供了更多的功能和灵活性。而Less在学习曲线和即用性方面可能对新手更友好，且在一般情况下，Less足以满足我们的需求。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>Less</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Less</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块化</title>
    <url>/tsukimiya.github.io/2024/05/05/ES6/1.ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>ES6模块化 与 异步编程高级用法：<br>  E6的模块化语法<br>  使用Promise解决回调地狱的问题<br>  使用 async&#x2F;await 简化 Promise 的调用<br>  什么是 EventLoop<br>  宏任务 和 微任务 的执行顺序</p>
</blockquote>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol>
<li><p>node.js中如何实现模块化<br>node.js遵循了<strong>CommonJS</strong>的模块化规范。其中:</p>
<ul>
<li>导入其它模块使用<code>require()</code>方法</li>
<li>模块对外共享成员使用<code>module.exports</code>对象</li>
</ul>
</li>
<li><p><strong>模块化的好处</strong>：<br>大家都遵守同样的模块化规范写代码，<strong>降低了沟通的成本，极大方便了各个模块之间的相互调用</strong>，利人利己。</p>
</li>
</ol>
<h3 id="前端模块化规范的分类"><a href="#前端模块化规范的分类" class="headerlink" title="前端模块化规范的分类"></a>前端模块化规范的分类</h3><p>在<strong>ES6模块化规范诞生之前</strong>，JavaScript 社区已经尝试并提出了<strong>AMD、CMD、CommonJS</strong>等模块化规范。</p>
<blockquote>
<p>这几个规范不是官方的模块化标准，而是社区的开发者经过反复的实践与尝试，提出来的规范</p>
</blockquote>
<p>但是，这些由社区提出的模块化标准，还是存在一定的<strong>差异性与局限性</strong>、<strong>并不是</strong>浏览器与服务器<strong>通用的模块化标准</strong>，例如:</p>
<ul>
<li>AMD和CMD适用于<strong>浏览器端</strong>的Javascript模块化</li>
<li>CommonJS适用于<strong>服务器端</strong>的Javascript模块化</li>
</ul>
<p>太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，<strong>大一统的ES6模块化规范诞生了</strong>!</p>
<h3 id="ES6模块化规范"><a href="#ES6模块化规范" class="headerlink" title="ES6模块化规范"></a>ES6模块化规范</h3><p>ES6模块化规范是浏览器端与服务器端通用的模块化开发规范。</p>
<p>ES6模块化规范中定义:</p>
<ul>
<li>每个js文件都是一个独立的模块</li>
<li>导入其它模块成员使用<strong>import</strong>关键字</li>
<li>向外共享模块成员使用<strong>export</strong>关键字</li>
</ul>
<h3 id="在node-js中使用ES6模块化"><a href="#在node-js中使用ES6模块化" class="headerlink" title="在node.js中使用ES6模块化"></a>在node.js中使用ES6模块化</h3><p>node.js默认支持CommonJS模块化规范，如果要使用ES6模块化语法，需要配置：</p>
<ol>
<li>确保安装了v14.15.1或更高版本的node.js</li>
<li>在package.json的根节点中添加<code>&quot;type&quot;:&quot;module&quot;</code>节点</li>
</ol>
<h2 id="ES6模块化的基本语法"><a href="#ES6模块化的基本语法" class="headerlink" title="ES6模块化的基本语法"></a>ES6模块化的基本语法</h2><p>ES6的模块化主要包含如下3种用法:<br>    1. 默认导出与默认导入<br>    2. 按需导出与按需导入<br>    3. 直接导入并执行模块中的代码</p>
<ol>
<li><p>默认导出<br><code>export dufault 默认导出的成员</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> n2 = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  n1,</span><br><span class="line">  show</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>只允许默认导出一次</strong>(使用唯一的一次export default)</p>
</li>
<li><p>默认导入<br><code>import 接收名称 from &#39;模块标识符&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./1.默认导出.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1); <span class="comment">//&#123; n1: 10, show: [Function: show] &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>接收名称</strong>可以是任意名称，只要是<strong>合法的成员名称即可</strong>(只能以字符_$开头，不能以数字)</p>
</li>
<li><p>按需导出<br><code>export 按需导出的成员</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s1 = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> s2 = <span class="string">&#x27;ccc&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<strong>可以使用多次</strong>，可以和默认导出一起使用。</p>
</li>
<li><p>按需导入<br><code>import &#123;s1&#125; from &#39;模块标识符&#39;</code><br>导入多个模块成员<br><code>import &#123;s1,s2,s3&#125; from &#39;模块标识符&#39;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> info, &#123;s1, s2 <span class="keyword">as</span> str2, say&#125; <span class="keyword">from</span> <span class="string">&#x27;./3.按需导出.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1); <span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// console.log(s2); // 报错，未定义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2); <span class="comment">// ccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(say);<span class="comment">// [Function: say]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// info 接收的默认导出的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info); <span class="comment">// &#123; a:20 &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>按需导入的成员<strong>名称必须</strong>和按需导出的名称<strong>保持一致</strong></li>
<li>按需导入时，可以使用 <strong>as关键字</strong> 进行<strong>重命名</strong></li>
<li>按需导入可以和默认导入一起使用</li>
</ol>
</li>
<li><p><strong>直接导入并执行模块中的代码</strong><br>如果<strong>只想单纯地执行某个模块中的代码</strong>，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码，示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 05.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./5.直接运行模块中的代码.js&#x27;</span></span><br><span class="line"><span class="comment">// node testjs 结果 --  0 1 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>ES6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/tsukimiya.github.io/2024/05/06/ES6/2.Promise/</url>
    <content><![CDATA[<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><ol>
<li><p>回调地狱<br>多层回调函数的相互嵌套，就形成了回调地狱。示例代码如:</p>
<blockquote>
<p>回调地狱更多导致的问题还是：<strong>难以阅读和维护</strong>，通常出现在异步操作中<br>其和递归问题导致的栈溢出还是不同的，两者是不同的问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span>&#123; <span class="comment">//第1层回调函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;延时1秒后输出&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//第2层回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再延时2秒后输出&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//第3层回调函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;再延时3秒后输出&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>回调地狱的缺点:<br>代码耦合性太强，牵一发而动全身，<strong>难以维护</strong><br>大量冗余的代码相互嵌套，代码的<strong>可读性变差</strong></p>
</li>
<li><p>如何解决<br>为了解决回调地狱的问题，ES6 (ECMAScript 2015)中新增了<strong>Promise</strong>的概念。</p>
<blockquote>
<p>解决回调地狱的方法包括使用 Promise、async&#x2F;await 等异步编程技术，以及使用函数式编程的方式来组织代码，使其更具可读性和可维护性。</p>
</blockquote>
</li>
</ol>
<h2 id="Promise基本概念"><a href="#Promise基本概念" class="headerlink" title="Promise基本概念"></a>Promise基本概念</h2><ol>
<li><p><strong>Promise是一个构造函数</strong></p>
<ul>
<li>我们可以创建Promise 的实例 <code>const p = newPromise()</code></li>
<li>new出来的Promise 实例对象，<strong>代表一个异步操作</strong></li>
</ul>
</li>
<li><p><strong>Promise.prototype 上包含一个.then()方法</strong></p>
<ul>
<li>每一次new Promise()构造函数得到的实例对象，</li>
<li>都可以<strong>通过原型链的方式</strong>访问到.then()方法，例如<code>p.then()</code></li>
</ul>
</li>
<li><p><strong>.then()方法用来预先指定成功和失败的回调函数</strong></p>
<ul>
<li>p.then(<strong>成功的回调函数</strong>，<strong>失败的回调函数</strong>)</li>
<li>p.then(result,&#x3D;&gt; {}, error &#x3D;&gt; {})</li>
<li>调用.then()方法时，<strong>成功的回调函数是必选的</strong>、失败的回调函数是可选的</li>
</ul>
</li>
</ol>
<h2 id="基于-then-fs-异步的读取文件内容"><a href="#基于-then-fs-异步的读取文件内容" class="headerlink" title="基于 then-fs 异步的读取文件内容"></a>基于 then-fs 异步的读取文件内容</h2><ol>
<li><p>基于回调函数按顺序读取文件内容<br>虽然可以保证文件的读取顺序，但是形成了一个回调地狱的问题<br><img src="/tsukimiya.github.io/images/ES6/%E5%9F%BA%E4%BA%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="img"></p>
</li>
<li><p>基于 then-fs 读取文件内容<br><strong>fs模块仅支持 以回调函数的方式 读取文件，不支持Promise的调用方式</strong>。因此，需要先安装 then-fs 第三方包，从而支持基于Promise的方式读取文件的内容： <code>npm install then-fs</code></p>
</li>
</ol>
<ul>
<li><strong>then-fs 的基本使用</strong><br>调用 then-fs 提供的<strong>readFile()<strong>方法，可以异步地读取文件的内容，</strong>它的返回值是 Promise 的实例对象</strong>。因此可以<strong>调用.then()方法</strong>为每个 Promise 异步操作指定<strong>成功</strong>和<strong>失败</strong>之后的回调函数。示例代码如下:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于Promise的方式读取文件</span></span><br><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"><span class="comment">// .then()中的失败回调是可选的，这里省略了</span></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1);&#125;)</span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r2);&#125;)</span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r3);&#125;)</span><br></pre></td></tr></table></figure>
当前只是异步的去读文件，<strong>无法保证文件的读取顺序</strong>，多次执行读取顺序不一</li>
</ul>
<h2 id="基于Promise按顺序读取文件的内容"><a href="#基于Promise按顺序读取文件的内容" class="headerlink" title="基于Promise按顺序读取文件的内容"></a>基于Promise按顺序读取文件的内容</h2><ul>
<li><p><strong>.then方法的特性</strong><br>如果上一个.then()方法中<strong>返回了一个新的Promise实例对象</strong>，则可以通过下一个.then()继续进行处理。通过.then()方法的<strong>链式调用</strong>，就解决了回调地狱的问题。</p>
</li>
<li><p><strong>基于Promise</strong>按顺序读取文件的内容<br><strong>只要任何方法返回值是一个Promise实例对象，那就都可以继续调用.then()方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">// 返回值是Promise的实例对象</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123; <span class="comment">// 通过.then 为返回的promise实例指定成功之后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 .catch 捕获错误<br>在 Promise 的链式操作中如果发生了错误，可以使用Promise.prototype.catch方法进行捕获和处理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>) <span class="comment">// 文件不存在</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  &#125;) <span class="comment">// 只返回错误，没有读取的文件内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不希望前面的错误导致后续的.then无法正常执行，<strong>可以将.catch的调用提前</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;) <span class="comment">// 先打印错误，然后打印读取内容，r1为undefined，r2r3读取成功</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h2><p>Promise.all()方法会发起并行的Promise异步操作，等<strong>所有的异步操作全部结束后</strong>才会执行下一步的.then操作（等待机制）。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [</span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promiseArr).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [ &#x27;111&#x27;, &#x27;222&#x27;, &#x27;333&#x27; ]</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise示例的顺序，就是最终拿到的结果的顺序。如果有一个文件读取错误，所有数据都拿不到</p>
<h2 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a>Promise.race() 方法</h2><p>Promise.race()方法会发起并行的Promise异步操作，<strong>只要任何一个异步操作完成，就立即执行下一步的.then操作</strong>（赛跑机制）。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [</span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>), </span><br><span class="line">  thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promiseArr).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只会拿到一个文件的读取结果，读取最快的那个，无法保证读取的文件是哪个</p>
<h2 id="基于Promise封装异步读文件的方法"><a href="#基于Promise封装异步读文件的方法" class="headerlink" title="基于Promise封装异步读文件的方法"></a>基于Promise封装异步读文件的方法</h2><ul>
<li><p>方法的封装要求:</p>
<ol>
<li>方法的名称要定义为getFile</li>
<li>方法接收一个形参fpath，表示要读取的文件的路径</li>
<li>方法的返回值为Promise 实例对象</li>
</ol>
</li>
<li><p>getFile方法的基本定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>new Promise()</strong> 只是创建了一个<strong>形式上的异步操作</strong></p>
</li>
<li><p><strong>创建具体的异步操作</strong><br>如果想要创建具体的异步操作，则需要在new Promise()构造函数期间，<strong>传递一个function函数，将具体的<br>异步操作定义到function函数内部</strong>。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fpath,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err,dataStr</span>)=&gt;</span>&#123; &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取.then的两个实参<br>通过.then()指定的成功和失败的回调函数，可以在 function的形参中 进行接收，示例代码如下:<br><img src="/tsukimiya.github.io/images/ES6/%E8%8E%B7%E5%8F%96.then%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%9E%E5%8F%82.png" alt="img"></p>
</li>
<li><p>调用 resolve 和 reject 回调函数<br>Promise<strong>异步操作的结果</strong>，可以调用 <strong>resolve</strong> 或 <strong>reject</strong> 回调函数进行处理。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFile</span>(<span class="params">fpath</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fpath, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="title function_">reject</span>(err) <span class="comment">// 发生错误</span></span><br><span class="line">      <span class="title function_">resolve</span>(dataStr) <span class="comment">// 读取成功</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1)&#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);&#125;)</span><br><span class="line"><span class="comment">// 失败的回调函数可以省略不写，可以用catch进行捕获</span></span><br><span class="line"><span class="title function_">getFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(r1)&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>回调地狱</tag>
      </tags>
  </entry>
  <entry>
    <title>EventLoop</title>
    <url>/tsukimiya.github.io/2024/05/07/ES6/4.EventLoop/</url>
    <content><![CDATA[<h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>JS是一门<strong>单线程执行</strong>的编程语言。同一事件只能做一件事情。</p>
<p>JS的执行线程<br>↓<br>任务1 → 任务2 → 任务3 → 任务N（待执行的任务队列）</p>
<p>单线程执行队列的问题：<br>如果<strong>前一个任务非常耗时</strong>，则后续的任务就不得不一直等待，从而导致<strong>程序假死</strong>的问题。</p>
<h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><p>为了防止某个<strong>耗时任务</strong>导致<strong>程序假死</strong>的问题，JavaScript把待执行的任务分为了两类:</p>
<ol>
<li>同步任务 (synchronous)<ul>
<li>又叫做<strong>非耗时任务</strong>，指的是在主线程上排队执行的那些任务</li>
<li>只有前一个任务执行完毕，才能执行后一个任务</li>
</ul>
</li>
<li>异步任务 (asynchronous)<ul>
<li>又叫做<strong>耗时任务</strong>，异步任务由JavaScript<strong>委托给宿主环境</strong>进行执行</li>
<li>当异步任务执行完成后，会<strong>通知JavaScript主线程</strong>执行异步任务的<strong>回调函数</strong><blockquote>
<p>宿主环境就是JS的执行环境，在浏览器里面运行JS，浏览器就是JS的宿主环境，在Node.js…</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="同步任务和异步任务的执行过程"><a href="#同步任务和异步任务的执行过程" class="headerlink" title="同步任务和异步任务的执行过程"></a>同步任务和异步任务的执行过程</h2><p><img src="/tsukimiya.github.io/images/ES6/js%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="js执行过程"></p>
<h2 id="EventLoop的基本概念"><a href="#EventLoop的基本概念" class="headerlink" title="EventLoop的基本概念"></a>EventLoop的基本概念</h2><p><strong>JavaScript主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行</strong>。这个过程是循环不断的，所以整个的这种运行机<br>制又称为<strong>EventLoop</strong>(事件循环)。</p>
<ul>
<li><p>练习<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A0.png" alt="练习"></p>
</li>
<li><p>分享文章<br>面试必问之 JS 事件循环(Event Loop)，看这一篇足够(<a href="https://zhuanlan.zhihu.com/p/580956436">https://zhuanlan.zhihu.com/p/580956436</a>)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await</title>
    <url>/tsukimiya.github.io/2024/05/06/ES6/3.async-await/</url>
    <content><![CDATA[<h2 id="什么是-async-await"><a href="#什么是-async-await" class="headerlink" title="什么是 async &#x2F; await"></a>什么是 async &#x2F; await</h2><p><strong>async&#x2F;await</strong> 是 <strong>ES8</strong>(ECMAScript 2017)引入的新语法，用来<strong>简化Promise异步操作</strong>。在async&#x2F;await出现之前，开发者只能通过<strong>链式.then()的方式</strong>处理Promise异步操作。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">// 返回值是Promise的实例对象</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>) =&gt;</span> &#123; <span class="comment">// 通过.then 为返回的promise实例指定成功之后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>.then链式调用的<strong>优点</strong>：解决了回调地狱的问题<br>.then链式调用的<strong>缺点</strong>：代码冗余、阅读性差、不易理解</p>
<h2 id="async-await-的基本使用"><a href="#async-await-的基本使用" class="headerlink" title="async &#x2F; await 的基本使用"></a>async &#x2F; await 的基本使用</h2><p>使用async&#x2F; await简化 Promise异步操作的示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line"><span class="comment">// 按顺序读取文件 1 2 3 的内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllFile</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 如果不加await，它的返回值就是Promise实例，加了await，返回值就是最终读取到的文件中的内容</span></span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1) <span class="comment">// 111</span></span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2) <span class="comment">// 222</span></span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">await</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/3.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3) <span class="comment">// 333</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getAllFile</span>()</span><br></pre></td></tr></table></figure>
<p>如果<strong>某个方法的返回值是个Promise实例对象</strong>，那么我们就可以在前面<strong>用await</strong>来进行<strong>修饰</strong>，修饰完毕之后，这个<strong>返回值就不再是Promise实例</strong>，而是<strong>变成一个真正的值</strong>。<br>而且需要注意：<font color='red'>如果这个方法内部用到了await，那么这个方法必须被async来修饰</font></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><font color='green'>如果在 function 中使用了 await ，则 function <strong>必须</strong>被 async 修饰</font></li>
<li><font color='green'>在 async 方法中，<strong>第一个 await 之前的代码会同步执行</strong>，await之后的代码会异步执行</font><br>最终输出的顺序：A、B、C、111 222 333、D<br>碰到第一个await，主线程就退出了方法执行，立马输出了C，当1 2 3异步读取完成之后就按顺序输出，最后异步的输出了D<br><img src="/tsukimiya.github.io/images/ES6/async%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="async/await方法执行顺序"></li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title>宏任务和微任务</title>
    <url>/tsukimiya.github.io/2024/05/08/ES6/5.%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="什么是宏任务和微任务"><a href="#什么是宏任务和微任务" class="headerlink" title="什么是宏任务和微任务"></a>什么是宏任务和微任务</h2><p>JavaScript把异步任务又做了进一步的划分，异步任务又分为两类，分别是:</p>
<ol>
<li>宏任务( macrotask)<ul>
<li>异步Ajax请求、</li>
<li>setTimeout、setlnterval、</li>
<li>文件操作</li>
<li>其它宏任务</li>
</ul>
</li>
<li>微任务( microtask)<ul>
<li>Promise.then、.catch和.finally</li>
<li>process.nextTick</li>
<li>其它微任务</li>
</ul>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/ES6/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1.png" alt="宏任务和微任务"></p>
<h2 id="划分依据"><a href="#划分依据" class="headerlink" title="划分依据"></a>划分依据</h2><p>异步任务是根据<strong>任务的触发时机</strong>和<strong>任务队列的不同</strong>来分为宏任务和微任务的。下面是它们的依据：</p>
<ol>
<li><p><strong>触发时机</strong>：</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>：宏任务是由 JavaScript 引擎外部的任务触发的，比如 DOM 事件（如点击事件、鼠标移动事件）、<code>setTimeout</code>、<code>setInterval</code>、网络请求等。宏任务代表着一个独立的、顺序执行的任务单元，它们会被放入宏任务队列中等待执行。</li>
<li><strong>微任务（Micro Task）</strong>：微任务是在当前任务执行完成之后立即执行的任务，它们一般是由 JavaScript 引擎内部触发的，比如 Promise 的状态改变、<code>queueMicrotask</code> 函数等。微任务的执行时机是在当前宏任务执行结束、事件循环进入下一次循环之前。</li>
</ul>
</li>
<li><p><strong>任务队列</strong>：</p>
<ul>
<li><strong>宏任务队列</strong>：宏任务队列中存放着各种宏任务，包括了 DOM 事件、定时器、I&#x2F;O 操作等。在事件循环的每一轮中，只有一个宏任务会被执行。</li>
<li><strong>微任务队列</strong>：微任务队列中存放着微任务，它们的执行顺序是按照它们进入队列的顺序执行的。在每个宏任务执行结束后，会检查并执行所有的微任务，直到微任务队列为空。</li>
</ul>
</li>
</ol>
<p>因此，异步任务是根据触发时机和任务队列的不同而被分为宏任务和微任务的。这种分化使得 JavaScript 引擎能够灵活地处理异步任务，并根据执行上下文的情况来调度它们的执行顺序。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>宏任务和微任务是交替执行的。<br>在 JavaScript 中，<strong>执行完同步任务后</strong>，<strong>会先检查是否存在微任务</strong>，如果存在，则先执行微任务队列中的所有微任务。执行完所有微任务后，再去执行宏任务队列中的任务。<br><img src="/tsukimiya.github.io/images/ES6/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="宏任务微任务执行顺序"></p>
<ul>
<li><p>场景举例<br><img src="/tsukimiya.github.io/images/ES6/%E5%9C%BA%E6%99%AF.png" alt="场景"></p>
</li>
<li><p>练习<br>new Promise 是同步任务，其调用的.then是微任务<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A02.png" alt="练习2"></p>
</li>
<li><p>练习<br><img src="/tsukimiya.github.io/images/ES6/%E7%BB%83%E4%B9%A03.png" alt="练习3"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>宏任务和微任务</tag>
      </tags>
  </entry>
  <entry>
    <title>JS相等性比较陷阱揭秘：理解`[]==![]`为`true`背后的宽松相等运算符与类型转换</title>
    <url>/tsukimiya.github.io/2024/05/23/JS/JS%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E6%AF%94%E8%BE%83%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JavaScript是一门弱类型（或称动态类型）语言，这意味着<strong>变量的类型可以在运行时改变</strong>，为开发者提供了极大的灵活性。然而，这也引入了类型转换的概念，尤其是在使用宽松相等运算符&#x3D;&#x3D;进行比较时。宽松相等不仅比较值，还会在必要时自动转换类型以进行比较，这一特性有时会导致预期之外的结果。</p>
<hr>
<p>下面来看一组比较运算符的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == []  <span class="comment">// false</span></span><br><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line">[] == !&#123;&#125; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; == !&#123;&#125; <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == &#123;&#125;  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == ![] <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == []  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">(&#123;&#125; == !&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>提出问题：<strong>为什么[] &#x3D;&#x3D; ![]会得出true这样一个看似反直觉的结果？</strong><br>下面，我们将会逐步接近答案，揭开这个陷阱。</p>
<hr>
<h1 id="JavaScript中的比较运算符"><a href="#JavaScript中的比较运算符" class="headerlink" title="JavaScript中的比较运算符"></a>JavaScript中的比较运算符</h1><h2 id="严格相等与宽松相等"><a href="#严格相等与宽松相等" class="headerlink" title="严格相等与宽松相等"></a>严格相等与宽松相等</h2><ul>
<li>严格相等运算符 <code>===</code> 要求<font color="red">两边的值及其类型完全一致</font>才能返回 <code>true</code>，是最安全的比较方式。</li>
<li>宽松相等运算符 <code>==</code> 在比较前，<font color="red">如果两侧数据类型不匹配，会尝试将它们转换成相同类型后再比较</font>，这便是问题的根源所在。</li>
</ul>
<h2 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h2><p>类型转换发生在比较操作中，涉及多种类型间的转换逻辑，例如：</p>
<ul>
<li>布尔值转数字 (<code>true</code> 转换为 <code>1</code>, <code>false</code> 转换为 <code>0</code>)</li>
<li>字符串与数字之间的相互转换</li>
<li>对象转换为原始值（通常是字符串或数字）</li>
</ul>
<hr>
<h1 id="深入解析"><a href="#深入解析" class="headerlink" title="深入解析[] == ![]"></a>深入解析<code>[] == ![]</code></h1><h2 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符!"></a>逻辑非运算符<code>!</code></h2><p>首先，理解<code>![]</code>是如何工作的。逻辑非运算符<code>!</code>会对表达式求布尔值，然后取反。对于数组（即使是空数组<code>[]</code>），在布尔上下文中被视为<code>true</code>，因此<code>![]</code>的结果是<code>false</code>。在宽松比较的上下文中，<code>false</code>进一步被转换为数字<code>0</code>。</p>
<h2 id="数组到字符串再到数字"><a href="#数组到字符串再到数字" class="headerlink" title="数组到字符串再到数字"></a>数组到字符串再到数字</h2><p>接下来，考虑左侧的空数组<code>[]</code>。在宽松相等比较中，数组会首先转换为它的字符串表示形式，即<code>&quot;&quot;</code>（空字符串）。随后，空字符串在进一步的比较中会被转换为数字<code>0</code>。</p>
<h2 id="比较””-0"><a href="#比较””-0" class="headerlink" title="比较”” &#x3D;&#x3D; 0"></a>比较”” &#x3D;&#x3D; 0</h2><p>因此，<code>[] == ![]</code> 的比较实质上变为<code>&quot;&quot; == 0</code>。在JavaScript的宽松比较规则下，空字符串<code>&quot;&quot;</code>和数字<code>0</code>都被认为是“空”或“假”值，在比较时被视作相等。这解释了为什么<code>[] == ![]</code>的结果是<code>true</code>，尽管直观上两者看似完全不同。</p>
<hr>
<h1 id="宽松相等运算符的其他陷阱示例"><a href="#宽松相等运算符的其他陷阱示例" class="headerlink" title="宽松相等运算符的其他陷阱示例"></a>宽松相等运算符的其他陷阱示例</h1><p>除了<code>[] == ![]</code>，宽松相等还可能导致其他令人迷惑的结果，例如：</p>
<ul>
<li><code>0 == &#39;0&#39;</code>：数字<code>0</code>与字符串<code>&#39;0&#39;</code>在宽松比较中相等。</li>
<li><code>null == undefined</code>：这两种特殊的值在比较时也被认为是相等的。</li>
</ul>
<hr>
<h1 id="最佳实践与建议"><a href="#最佳实践与建议" class="headerlink" title="最佳实践与建议"></a>最佳实践与建议</h1><p>为了避免由宽松相等引发的潜在问题，建议采取以下措施：</p>
<ul>
<li><font color="red">首选严格相等运算符 “&#x3D;&#x3D;&#x3D;”：除非你明确知道并期望类型转换发生，否则总是使用严格相等。</font></li>
<li>显式类型转换：当你确实需要进行类型转换时，显式地进行，比如使用<code>Number()</code>, <code>String()</code>或<code>Boolean()</code>函数，以增强代码的可读性。</li>
<li>代码审查：团队内部实施代码审查，可以帮助识别并纠正潜在的比较陷阱。</li>
<li>单元测试：编写测试用例来验证比较逻辑的正确性，确保代码行为符合预期。</li>
</ul>
<hr>
<h1 id="再次回顾开始的问题"><a href="#再次回顾开始的问题" class="headerlink" title="再次回顾开始的问题"></a>再次回顾开始的问题</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == []  <span class="comment">// false</span></span><br><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line">[] == !&#123;&#125; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; == !&#123;&#125; <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == &#123;&#125;  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == ![] <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">&#123;&#125; == []  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;==&#x27;</span></span><br><span class="line">(&#123;&#125; == !&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以对它们挨个做出解释：</p>
<ul>
<li><p><code>[] == []  // false</code><br>这里两个空数组虽然内容相同，但在使用宽松相等<code>==</code>比较时，因为它们是两个不同的对象实例，所以结果为false。</p>
</li>
<li><p><code>[] == ![] // true</code><br>这个表达式实际上分两步理解：</p>
<ol>
<li><code>![]</code> 首先执行，<code>[]</code>转换为布尔值再取反，结果是false。</li>
<li><code>[]</code>会转换为<code>&quot;&quot;</code>，而<code>false</code>被转换为<code>0</code>。就成了<code>&quot;&quot; == 0</code>的比较。根据JavaScript的类型转换规则，空字符串和数字0在比较时被认为是相等的（因为都转为了相同的布尔值false），所以结果为true。</li>
</ol>
</li>
<li><p><code>[] == !&#123;&#125; // true</code><br><code>!&#123;&#125;</code>同样是非空对象转换为布尔值取反，与上面相同，结果为true。</p>
</li>
<li><p><code>&#123;&#125; == !&#123;&#125; 、&#123;&#125; == &#123;&#125; 、&#123;&#125; == ![] // Uncaught SyntaxError: Unexpected token &#39;==&#39;</code></p>
<blockquote>
<p>这里就不再是宽松相等比较类型转换的问题了<br>  这些表达式报错是因为在JS中，<font color="red">大括号 {} 既可以表示对象字面量也可以表示代码块。</font><br>  在这些情况下，解释器尝试将它们解释为代码块，但是紧接着的 <code>==</code> 或 <code>!=</code> 导致了语法错误，因为<strong>代码块后面直接跟比较操作符是不合法的</strong>。解决这个问题<strong>需要确保大括号用于创建对象时明确其意图</strong>，例如通过<strong>赋值或声明变量的方式</strong>：<code>(&#123;&#125; == !&#123;&#125;) // false</code>、<code>let obj = &#123;&#125;</code> 等。</p>
</blockquote>
</li>
<li><p><code>(&#123;&#125; == !&#123;&#125;) // false</code><br>这里就是合法的比较了，<code>!&#123;&#125;</code>同样转换为<code>false</code>，然后<code>&#123;&#125;</code>转换为原始值字符串<code>[object Object]</code><br>所以表达式变成了<code>[object Object] == false</code>，结果为false。</p>
</li>
</ul>
<hr>
<p>理解JavaScript的宽松相等运算符及其隐含的类型转换机制，是成为高效JavaScript开发者的关键之一。尽管这些特性有时可能引入意料之外的行为，但通过掌握它们，我们可以编写出更加健壮、易于维护的代码。面对<code>[] == ![]</code>这样的谜题，我们不再困惑，而是能清晰地解析其背后的逻辑，进而避免类似的陷阱。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>==</tag>
        <tag>比较运算符</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用emoji表情</title>
    <url>/tsukimiya.github.io/2024/05/07/Hexo/hexo%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<blockquote>
<p>本文章不对emoji的使用做太深入的研究，因为在写文章上是一个不太必要的需求，也是一个鲜少使用的东西，总之能用就行。</p>
</blockquote>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>直接给出结论：</p>
<ol>
<li><strong>将表情符号复制并粘贴到Markdown格式的文本中</strong> <font color="red">推荐</font></li>
<li>直接使用表情符号的Unicode编码，格式：<code>&amp;#x[Unicode编码];</code><br>例如，😊的 Unicode 编码是 U+1F60A —— 对应的 HTML 实体编码是 <code>&amp;#x1F60A;</code><br>直接在md文件的文本内容里面输入HTML实体编码即可<code>&amp;#x1F60A;</code>&#x1F60A;</li>
</ol>
<p>Tip1: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。<br>Tip2: 千万不要去折腾什么插件了！不需要插件！没错，就是我折腾了好久卸载了</p>
<ul>
<li><p>附上可供使用的工具：<br>Windows 10周年更新内置的 <strong>Emoji键盘</strong> <code>win + .</code>快捷键唤出 <font color="red">推荐👍</font></p>
<p>在线工具-Emoji表情符号(可搜索)：<a href="https://www.toolhelper.cn/Encoding/Emoji">https://www.toolhelper.cn/Encoding/Emoji</a> <font color="red">推荐</font></p>
<blockquote>
<p>最推荐，附有表情说明，及其Unicode编码</p>
</blockquote>
<p>Emoji大全(可搜索)：<a href="https://emoji6.com/emojiall/">https://emoji6.com/emojiall/</a> <font color="green">推荐</font></p>
<blockquote>
<p>可备用</p>
</blockquote>
<p>EMOJI中文网(可搜索)：<a href="https://www.emojiall.com/zh-hans">https://www.emojiall.com/zh-hans</a></p>
<blockquote>
<p>速度有点慢，东西也太多了，不太好用</p>
</blockquote>
</li>
<li><p><a href="https://markdown.com.cn/extended-syntax/emoji.html">Markdown 官方教程 - Markdown 使用 Emoji 表情</a></p>
<blockquote>
<p>发现MD还有官网，官方教程中有提到复制粘贴的方法</p>
</blockquote>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因为<strong>emoji表情符号也是Unicode字符的一种</strong>。</p>
<ol>
<li><p><strong>Markdown文件显示的原理</strong><br>像 VSCode 中通过插件预览 Markdown 文件的功能，以及其他类似的 Markdown 预览功能，通常也是<strong>通过 Markdown 渲染引擎生成的 HTML 页面</strong>来实现的。</p>
</li>
<li><p>emoji正常显示的原理<br>Markdown本身对于文本中的普通Unicode字符都有很好的支持，包括表情符号。<br>所以在Markdown文本中，你可以直接使用表情符号的Unicode编码，或者直接复制粘贴表情符号，当 Markdown 文件被渲染时，渲染引擎会将表情符号正确地转换为对应的图像，并在最终生成的 HTML 页面中显示出来。<br>通常情况下，Markdown 渲染引擎会将表情符号识别为 Unicode 字符，就像对待普通的文本文字一样，并不会对其做什么处理。<strong>这和直接在 HTML 页面中使用表情符号是一样的效果。</strong></p>
</li>
<li><p>Hexo渲染的HTML页面显示emoji<br>Hexo依赖于 hexo-renderer-marked 渲染引擎来解析 Markdown 文本，和vscode中预览是一样的原理，只是使用的渲染器不同而已</p>
</li>
</ol>
<h2 id="hexo中使用emoji的问题"><a href="#hexo中使用emoji的问题" class="headerlink" title="hexo中使用emoji的问题"></a>hexo中使用emoji的问题</h2><p>因为之前从未在md使用过emoji，突然有想要使用的念头，于是在不太了解的情况下试图找到方法。于是导致产生了一系列的问题。</p>
<ol>
<li><p><strong>误解</strong><br>由于一些误解性的信息导向，以至于我一度以为Hexo不支持使用emoji</p>
<ul>
<li><p>vscode的Markdown Preview Enhanced插件是支持emoji的</p>
</li>
<li><p>在搜索引擎搜索，hexo中使用emoji表情，很多都是这样说：</p>
<ul>
<li>Hexo 默认的 Markdown 渲染器是 hexo-renderer-marked，这个渲染器不支持 emoji 表情。</li>
<li>Hexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中</li>
</ul>
<p>然后教你安装 hexo-filter-github-emojis 插件，并启用配置</p>
</li>
</ul>
<p> 但是，他们几乎都是在说 使用 <a href="https://markdown.com.cn/extended-syntax/emoji.html"><strong>表情符号简码</strong></a> 的方式来 在Hexo中使用Emoji</p>
<blockquote>
<p>表情符号简码，通过键入表情符号短代码来插入表情符号，如：<code>:smile:</code>、<code>:punch:</code></p>
</blockquote>
</li>
<li><p>配置并使用 <code>hexo-filter-github-emojis</code> 插件<br> 在参考了这三篇文章之后，卸载了原渲染器插件，安装了<code>hexo-renderer-markdown-it</code>并添加了如下配置：</p>
<blockquote>
<p>参考文章 <a href="https://cloud.tencent.com/developer/article/2065824">文章1 - 22.8</a>、<a href="https://luckysusu.top/post/hexo_emoji.html">文章2 - 23.10</a>、<a href="https://blog.xaoxu.cn/archives/hexo-use-emoji">文章3 - 21.8</a><br> 文章2的苏苏的小屋博客做的不错，不过有点花过头了XD</p>
</blockquote>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## markdown 渲染引擎配置，默认是hexo-renderer-marked，这个插件渲染速度更快，且有新特性</span></span><br><span class="line"><span class="comment">## 因为不能支持原来的全局资源文件夹，引用图片，没找到解决的方法，故不使用，还是原配好啊</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span>  <span class="comment"># add emoji</span></span><br></pre></td></tr></table></figure>
<p> 然后发现，博客上发布的文章基本没有什么变化，样式上渲染的算是接受度很好，我一度想着会不会样式会变的太大，还得花事件去修整，这里算是放了大心。<br> 再然后，我发现页面上的图片引用都失效了！！！</p>
</li>
<li><p>图片引用的问题<br> 似乎是更换的插件不支持<strong>全局资源文件夹引用</strong>，但是又因为文章的链接索引有日期在，想要通过相对路径引用到就需要好多..&#x2F;，如果每次都要这么干绝对受不了，且一定会有更好的办法<br> 然后各种搜索，各种尝试，下载了好几个插件，设置什么的，但是都没有解决这个问题。<br> 折腾许久未果，果断卸载了<code>hexo-filter-github-emojis</code> 插件，重装回原来的<code>hexo-renderer-marked</code>插件<br> 于是，问题又变回了：如何使用emoji的问题</p>
<p> 期间想到了也许可以通过使用base64来解决这个问题，因为图片是可以转成base64格式的字符串的，那么emoji应该也可以，那么有没有一些在线，将emoji及其base64格式的字符整理的网页呢？</p>
<p> 但是搜索并没有找到什么现有可用的一些这样的东西，甚至找不到相关的文章</p>
<blockquote>
<p>github还真有这样一个项目！<a href="https://github.com/watson/base64-emoji">base64-emoji</a></p>
</blockquote>
<p> 不过后来知道了，才知道，emoji本身其实是一种unicode字符，并不是图片，所以并不应该转换成base64，而是可以直接使用的，也许因此才没有相关文章。</p>
<blockquote>
<p>不过一些表情包，emoji就是图片，也是因此才会更加误以为emoji其实也是一些小图片吧(如搜狗输入法上自带的，有的还是存在C盘哪里的？忘记了。才发现搜狗如果输入一些关键字，就会出现对应的emoji，选择它会把图片放到md的同目录下，并添加到md上)</p>
</blockquote>
<p> 最后，在各种尝试下，终于得出了使用emoji的方法，也即是文章开头的方法</p>
</li>
</ol>
<ul>
<li>那么问题来了，在html页面如何使用emoji表情？js如何使用emoji？ <a href="https://zhuanlan.zhihu.com/p/328516890">参考一篇文章</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="hexo全局资源文件夹引用"><a href="#hexo全局资源文件夹引用" class="headerlink" title="hexo全局资源文件夹引用"></a>hexo全局资源文件夹引用</h3><p><code>![img](/images/vue/组件生命周期.png)</code><br>该格式会被渲染器解析为img元素渲染到页面上<br>[]里的值会被解析为img元素的alt属性，即如果找不到图片会显示为img这个字符串<br>()里的则会解析为img元素的src属性</p>
<h3 id="表情符号简码"><a href="#表情符号简码" class="headerlink" title="表情符号简码"></a>表情符号简码</h3><p>对于表情符号，GitHub Markdown支持使用特定的简码来直接显示表情。当你在Markdown文本中使用表情符号的简码时，GitHub会自动将其解析并替换为对应的表情符号图像，从而在文档中显示出来。</p>
<p>这种自动替换是GitHub的一个特性，使得Markdown文本中的表情符号可以直观地显示出来，增强了文档的可读性和趣味性。</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>emoji</tag>
        <tag>markdown渲染器</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化与Webpack</title>
    <url>/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>了解工程化的前端开发方式<br>知道Webpack在实际开发中所起到的作用</p>
<blockquote>
<p>我们只需要了解webpack的工作原理，并不要求我们掌握如何配置，因为工作中我们会使用一些工具如Vue-CLI脚手架，它们已经帮我们配置好了</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>webpack 的基本使用</strong>：安装、webpack.config.js、修改打包入口<br><strong>webpack的两个插件</strong>(常用的plugin的基本使用)：<br>webpack-dev-server – (每次修改后自动进行项目的打包和构建)<br>html-webpack-plugin – (把src里面的首页在内存中复制一份，放到根目录中)<br><strong>常用的loader 的基本使用</strong>：协助webpack打包处理特定的文件模块。<br><strong>Source Map 的作用</strong>：精准定位到错误行并显示对应的源码，方便开发者调试源码中的错误</p>
</blockquote>
<h2 id="前端工程化相关概念"><a href="#前端工程化相关概念" class="headerlink" title="前端工程化相关概念"></a>前端工程化相关概念</h2><p>前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。<br>好处:前端开发自成体系，有一套标准的开发方案和流程。</p>
<p>实际的前端开发，是四个现代化：</p>
<ul>
<li><strong>模块化</strong> (js的模块化、css的模块化、资源的模块化) ———— js的复用</li>
<li><strong>组件化</strong> (复用现有的UI结构、样式、行为) ———— UI结构的复用</li>
<li><strong>规范化</strong> (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</li>
<li><strong>自动化</strong> (自动化构建、自动部署、自动化测试)</li>
</ul>
<h3 id="前端工程化解决方案"><a href="#前端工程化解决方案" class="headerlink" title="前端工程化解决方案"></a>前端工程化解决方案</h3><ul>
<li>早期的前端工程化解决方案:<ul>
<li>grunt (<a href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</li>
<li>gulp (<a href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</li>
</ul>
</li>
<li>目前主流的前端工程化解决方案:<ul>
<li>webpack (<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</li>
<li>parcel (<a href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>) ———— 开发第三方包会用到</li>
</ul>
</li>
</ul>
<h2 id="webpack-常见用法"><a href="#webpack-常见用法" class="headerlink" title="webpack 常见用法"></a>webpack 常见用法</h2><ol>
<li><p>什么是webpack？<br> 概念：webPack是<strong>前端项目工程化的具体解决方案</strong>。<br> 主要功能: 它提供了友好的<strong>前端模块化开发支持</strong>，以及<strong>代码压缩混淆</strong>(干掉注释和空格)、<strong>处理浏览器端JavaScript的兼容性</strong>、<strong>性能优化</strong>等强大的功能。<br> 好处:让程序员把<strong>工作的重心</strong>放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意:目前Vue，React等前端项目，基本上都是基于webpack进行工程化开发的。</p>
</li>
<li><p>创建列表隔行变色项目</p>
<ol>
<li>新建项目空白目录，并运行npm init -y命令，初始化包管理配置文件 package.json</li>
<li>新建src源代码目录</li>
<li>新建src -&gt; index.html首页和src -&gt; index.js 脚本文件</li>
<li>初始化首页基本的结构</li>
<li>运行npm install jquery -S命令，安装jQuery(-S明确告诉npm，包要记录到dependencies下，开发上线都会用到)</li>
<li>通过ES6模块化的方式导入jQuery，实现列表隔行变色效果</li>
</ol>
</li>
<li><p>在项目中安装webpack<br> 运行如下命令，安装webpack相关的两个包（-D告诉npm记录到devDependencies下，只在开发阶段会用到）<br> <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code></p>
</li>
<li><p>在项目中配置webpack</p>
<ol>
<li><p>在项目根目录中，创建名为<strong>webpack.config.js</strong>的webpack配置文件，并初始化如下的基本配置:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// mode 用来指定构建模式。可选值有 development和 production</span></span><br><span class="line">    <span class="comment">// 开发阶段选develement，上线改成production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在package.json的 scripts节点下，新增<strong>dev脚本</strong>如下:<br> 这个dev是可以随意命名的，后面的webpack是必须写webpack<br> scripts节点下有个默认的test脚本，删掉就行</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script 节点下的脚本，可以通过 npm run 执行。例如 npm run dev</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中运行npm run dev命令，启动 webpack进行项目的打包构建<br> 运行成功后，项目会多一个dist文件夹，里面的main.js就是webpack根据index.js帮我们自动生成的，做一下兼容性处理<br> 处理完以后，index.js还有兼容性问题，而main.js没有兼容性问题<br> 所以网页应该引入的是main.js文件<br> .<br> 由nodejs升级引起的构建错误：0308010C:digital envelope routines::unsupported<br> <a href="https://juejin.cn/post/7202639428132044858">https://juejin.cn/post/7202639428132044858</a><br> 报错原因可以看这篇文章<br> 解决设置（似乎还没有一个100%完全的解决方法，都会存在一些问题）:<br> <code>&quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack&quot;</code><br> .<br> 这个main.js是webpack帮我们把jquery.js和index.js文件进行了合并，但是并没有压缩，main.js中还有注释和代码缩进，如果要压缩，需要把webpack.config.js的mode设置为production，然后重新运行，整个文件的体积就被压缩的更小了，但是打包的时间更长了<br> .<br> 所以开发的时候，mode都设置成develement，只有上线的时候才会设置为production</p>
</li>
<li><p>webpack的默认约定 ———— 如何打包<br> 在webpack 4.x和5.的版本中，有如下的默认约定:</p>
<ol>
<li>默认的打包入口文件为src -&gt; index.js</li>
<li>默认的输出文件路径为dist -&gt; main.js</li>
</ol>
<p> 注意:可以在webpack.config.js中修改打包的默认约定<br> 如果找不到要处理的文件，就会报错</p>
</li>
<li><p>自定义打包的入口和出口<br> 在webpack.config.js 配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">&#x27;path&#x27;</span>) <span class="comment">//导入 node.js中专门操作路径的模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//打包入口文件的路径</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//输出文件的存放路径 </span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="comment">//输出文件的名称</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>这个时候，我们会发现，每次我们更改index.js的代码之后，都需要再次执行npm run dev更新生成的文件才行，这样非常麻烦，所以我们需要用到webpack的插件</p>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><p>最常用的webpack插件有两个：</p>
<ol>
<li>webpack-dev-server<ul>
<li>类似于node.js的nodemon工具</li>
<li>每当修改了源代码，webpack都会自动进行项目的打包和构建</li>
</ul>
</li>
<li>html-webpack-plugin<ul>
<li>webpack 中的HTML插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定制index.html页面的内容<hr></li>
</ul>
</li>
</ol>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol>
<li><p>安装webpack-dev-server<br> <code>npm i webpack-dev-server@3.11.2 -D</code><br> .<br> 在配置好之后，npm run dev 运行报错<br> Unable to load ‘@webpack-cli&#x2F;serve’ command<br> TypeError: options.forEach is not a function<br> .<br> 下载<code>npm install webpack@5.42.1 webpack-cli@4.10.0 -D</code></p>
</li>
<li><p>配置webpack-dev-server</p>
<ol>
<li>修改package.json -&gt; scripts中的dev命令如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script节点下的脚本，可以通过npm run 执行</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>再次运行npm run dev命令，重新进行项目的打包<br> 在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</li>
</ol>
<p> 注意:webpack-dev-server 会启动一个实时打包的http服务器</p>
</li>
</ol>
<p>注意，webpack-dev-server启动后，构建后的文件是在内存中的，不会实际生成具体的文件，所以我们打开的页面效果不会发生变化</p>
<p>我们执行npm run dev 命令，它执行的其实是webpack serve命令<br>这个命令执行成功后，第一行返回的是，<br><code>i ｢wds｣: Project is running at http://localhost:8080/</code><br>是整个项目运行在8080端口<br>所以，要看更新后的效果，要打开这个网址来查看，不能和以前一样的方法查看，因为之前查看的是file协议，不是当前的http协议</p>
<p>我们打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 网址，进入src，浏览器就会自动打开这个目录下的index文件，但是还是页面没有更改，我们再看第二行<br><code>i ｢wds｣: webpack output is served from /</code><br>告诉我们，输出在根目录，但是根目录并看不到bundle.js，但是其实它是有的，我们打开<a href="http://localhost:8080/bundle.js">http://localhost:8080/bundle.js</a> 可以访问到该文件</p>
<p><strong>webpack-dev-server这个插件，它把生成的bundle没有放到实际的物理磁盘上，而是放到了内存里面</strong><br>这是因为，如果频繁的修改文件，ctrl s，如果是把文件放到物理磁盘上，就会频繁的读写磁盘，对磁盘寿命性能都会有很大影响，所以要访问最新的bundle要访问内存里的bundle，所以应该<strong>在页面加载和引用内存里的bundle.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://localhost:8080/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// 也可以直接这样引用，看不见，但是可以引用的</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>但是由于我的vscode默认的使用5500端口，所以第二种引用会引用到5500端口，但是5500端口并不存在bundle.js，所以会报错,只能使用第一种引用</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>有一点不方便的是，打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 之后，我们还要点击一次src进入目录中，才能打开首页<br>我们希望一进入8080就能看到首页<br>html-webpack-plugin，这个插件可以把src里面的首页复制一份，放到根目录中<br>安装插件：<code>npm i html-webpack-plugin@5.3.2 -D</code></p>
<ul>
<li><p>配置 – 在webpack.config.js中配置<br>  把new出来的插件htmlPlugin 挂载&#x2F;添加到plugins插件的数组里面，这样webpack在运行的时候就会调用这个插件的实例，把src(template)里的页面复制一份放到根目录(filename)中<br>  不过也是复制出来的一个内存里的页面</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入HTML插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 2．创建HTML插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,<span class="comment">//指定原文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,<span class="comment">//指定生成的文件的存放路径</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> ,</span><br><span class="line">    <span class="comment">// 3．通过 plugins节点，使 htmlPlugin插件生效</span></span><br><span class="line">    <span class="attr">plugins</span>: [htmlPlugin], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个作用<br>  html-webpack-plugin插件除了帮我们复制页面，还会在复制出来的页面，自动注入一个脚本(js引用)，去引用内存里的bundle.js<br>  .<br>  我们npm run dev运行之后，如果把html页面的js引入注释掉，内存中页面样式是还在的，并没有消失。<br>  我们查看源码，可以发现它是有js引用的，而且是没有加.&#x2F;的同级目录引用，因为内存中的html和hundle.js在同一级目录</p>
</li>
</ul>
<p>配置完webpack之后，我们的开发体验会变的很好，但是配置过程又非常繁琐。<br>我不想自己配置，又想体验配置后的好处 ———— Vue-cli<br>这个工具已经帮我们配置好了webpack</p>
<h2 id="devServer-节点"><a href="#devServer-节点" class="headerlink" title="devServer 节点"></a>devServer 节点</h2><p>还有一个不爽的点(程序员的很多不爽XDD)，每次重新运行项目，都要手动打开8080页面，我们懒就要懒到底<br><strong>在npm run dev运行成功之后，自动打开浏览器展示网页</strong></p>
<ul>
<li>配置<br>  在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 初次打包完成后，自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 实时打包所使用的主机地址</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="comment">//实时打包所使用的端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="webpack中的loader（加载器）"><a href="#webpack中的loader（加载器）" class="headerlink" title="webpack中的loader（加载器）"></a>webpack中的loader（加载器）</h2><ol>
<li><p>loader概述<br> 在实际开发过程中，webpack默认只能打包处理以.js 后缀名结尾的模块。其他<strong>非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包</strong>，否则会报错!</p>
<p> loader加载器的作用:<strong>协助webpack打包处理特定的文件模块</strong>。比如:</p>
<ul>
<li>css-loader可以打包处理.css相关的文件</li>
<li>less-loader可以打包处理.less相关的文件</li>
<li>babel-loader可以打包处理webpack无法处理的高级JS语法</li>
</ul>
<p> 在webpack里面，一切都可以进行导入，一切皆模块，不建议程序员手动去引入样式和脚本(link，script)</p>
<p> 在js中也可以导入样式(ES6语法)<code>import &#39;./css/index.css&#39;</code></p>
</li>
<li><p>打包处理 css 文件</p>
<ol>
<li>运行<code>npm i style-loader@3.0.0 css-loader@5.2.6 -D</code>命令，安装处理css文件的loader</li>
<li>在webpack.config.js 的 module -&gt; rules 数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
 其中，<strong>test</strong>表示匹配的<strong>文件类型</strong>, <strong>use</strong>表示对应<strong>要调用的loader</strong><br> 注意:</li>
</ol>
<ul>
<li>use数组中指定的loader <strong>顺序是固定的</strong></li>
<li>多个loader的调用顺序是: <strong>从后往前调用</strong><br>  loader在调用的时候，是从后往前调的 <a href='#loader-调用过程'>loader调用过程</a></li>
</ul>
</li>
<li><p>打包处理 less文件</p>
<ol>
<li>运行<code>npm i less-loader@10.0.1 less@4.1.1 -D</code>命令</li>
<li>在webpack.config.js 的module -&gt; rules数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个less是内部依赖项，就是less-loader内部依赖于less，但是不需要手动的去声明less</li>
</ol>
</li>
<li><p>打包处理样式表中与url路径相关的文件</p>
<ol>
<li>运行<code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code>命令</li>
<li>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        <span class="comment">//如果需要调用的loader只有一个(use)，则只传递一个字符串也行，如果有多个loader，则必须指定数组</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,<span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&#x27;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中?之后的是 loader的参数项:</li>
</ol>
<ul>
<li>limit用来指定图片的大小，单位是字节(byte)</li>
<li>只有≤limit 大小的图片，才会被转为base64格式的图片</li>
</ul>
</li>
<li><p>打包处理js文件中的高级语法<br> webpack只能打包处理一部分高级的JavaScript语法。对于那些webpack无法处理的高级js语法，需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1．定义了名为info的装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">//2．为目标添加静态属性info</span></span><br><span class="line">    target.<span class="property">info</span> = <span class="string">&#x27;Person info&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3．为Person类应用info装饰器</span></span><br><span class="line">@info</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4．打印 Person 的静态属性info</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.1 运行如下的命令安装对应的依赖包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js的 module -&gt; rules数组中，添加loader规则如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span> , <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>exclude排除了node_modules文件夹，因为只需要处理我们自己写的代码就可以了，第三方的包没有兼容性问题，本身已经解决了，不需要处理(如果不排除也会对其进行处理影响性能)</p>
<p>5.2 配置babel-loader<br>打包处理js文件中的高级语法，比处理其他文件要多这么一步<br>在项目根目录下，创建名为 babel.config.js 的配置文件，定义Babel的配置项如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些配置从官方文档找到对应项直接粘过来就行了</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//声明babel 可用的插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考Babel的官网<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></p>
<h3 id="loader-调用过程"><a href="#loader-调用过程" class="headerlink" title="loader 调用过程"></a>loader 调用过程</h3><ol>
<li>webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</li>
<li>由于代码中包含了 index.css 这个文件，因此 webpack默认处理不了</li>
<li><strong>当webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器。</strong></li>
<li>webpack 把 index.css 这个文件，先转交给最后一个 loader 进行处理(先转交给css-loader) .</li>
<li>当 css-loader 处理完毕之后，会把处理的结果，转交给下一个 loader (转交给style-loader)</li>
<li>当 style-loader 处理完毕之后，发现没有下一个 loader 了，于是就把处理的结果，转交给了 webpack</li>
<li>webpack 把 style-loader 处理的结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。<br><img src="/tsukimiya.github.io/images/vue/loader%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="loader调用过程"></li>
</ol>
<h3 id="base64图片的优缺点"><a href="#base64图片的优缺点" class="headerlink" title="base64图片的优缺点"></a>base64图片的优缺点</h3><p>浏览器在拿到HTMl标签以后，需要再发送请求，拿到图片以后才能把图片渲染出来</p>
<p>但是使用用base64图片，在拿到img标签以后，就顺手的把图片对应的字符串也给请求下来了，可以防止发起一些不必要的网络请求</p>
<p>如果页面有许多小图标，就要发送很多次请求，对性能来讲非常不好，就可以把图片都转成base64格式的字符串</p>
<p>缺点：<br>图片转成base64，体积会增大一点点，所以大图片就不适合</p>
<p><strong>ES6 import导入图片得到的是一个base64字符串</strong>(可以打印看一下)<br>如 <code>import logo from &#39;./images/logo.png&#39;</code></p>
<h3 id="webpack处理样式的过程"><a href="#webpack处理样式的过程" class="headerlink" title="webpack处理样式的过程"></a>webpack处理样式的过程</h3><p>ES6在js文件导入样式<code>import &#39;./css/index.css&#39;</code><br>这种语法代表，只需要加载这个文件，把css样式给加载过来，不需要接收(接收的话，打印出来是undefined)</p>
<p>webpack加载和处理js文件，处理的结果会生成一个新的js文件(如bundle.js)，而且会在页面引用过去，在这个bundle.js里面，会包含我们import引入的样式，在这个bundle.js里面，css样式会被转成js的方式去运行</p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>我们如果要上线，应该拿到这些文件发给后端，让后端去部署上线<br>发布上线就是：<br>前端把项目生成一份最终的结果，有页面，配套的css js 图片等等<br>所有资源都在生成的文件夹里面，把所有内容打包发给后端<br>后端拿到结果去部署上线</p>
<p>现在我们要解决的问题是：页面和bundle.js放到内存里面了，需要把它生成到实际的物理磁盘上。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>在package.json文件的scripts节点下，新增build命令如下:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    “dev&quot; : &quot;webpack serve&quot;，//开发环境中，运行dev命令</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时，运行 build命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <code>--mode</code>是一个参数项，用来指定webpack的<strong>运行模式</strong>。production 代表生产环境，会对打包生成的文件进行<strong>代码压缩</strong>和<strong>性能优化</strong>。<br>    注意:通过<code>--mode</code>指定的参数项，会<strong>覆盖</strong>webpack.config.js 中的<code>--mode</code>选项。</p>
<p>这里的dev命令是webpack serve，就是我们装的插件，是把文件生成到内存中，可以监听文件的更改自动执行npm run dev<br>而这里build就是要执行webpack命令把文件生成到磁盘上，这里注意要改成<br>    <code>set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack --mode production</code></p>
<h3 id="优化图片和js文件存放路径"><a href="#优化图片和js文件存放路径" class="headerlink" title="优化图片和js文件存放路径"></a>优化图片和js文件存放路径</h3><ol>
<li>js文件<br>在webpack.js的output对象属性中，把filename前面加上个文件夹<br> <code>filename:&#39;js/bundle.js&#39;</code></li>
<li>图片<br>修改webpack.config.js 中的url-loader配置项，新增outputPath选项即可指定图片文件的输出路径: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jpg|png|gif$/</span> ,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">22228</span>,</span><br><span class="line">            <span class="comment">//明确指定把打包生成的图片文件，存储到dist目录下的 image 文件夹中</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者直接用?xx&#x3D;xx&amp;xx&#x3D;xx的方式在loader后面携带参数 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>, <span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&amp;outputPath=images&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置和使用clean-webpack-plugin插件自动删除dist目录"><a href="#配置和使用clean-webpack-plugin插件自动删除dist目录" class="headerlink" title="配置和使用clean-webpack-plugin插件自动删除dist目录"></a>配置和使用clean-webpack-plugin插件自动删除dist目录</h3><p><strong>webpack5已经默认封装(内置)了该插件，直接在配置文件里output设置属性clean:true即可</strong></p>
<hr>
<p>为了防止旧文件干扰我们的事件，在每次重新发布的时候会把生成的打包好的dist文件夹删掉。<br>为了在每次打包发布时自动清理掉dist目录中的旧文件，可以安装并配置dlean-webpack-plugin插件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1．安装清理dist目录的 webpack 插件</span></span><br><span class="line">npm install clean-webpack-plugin@<span class="number">3.0</span><span class="number">.0</span> -D</span><br><span class="line"><span class="comment">// 2．按需导入插件、得到插件的构造函数之后，创建插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanwebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanwebpackPlugin</span>()</span><br><span class="line"><span class="comment">// 3．把创建的 cleanPlugin 插件实例对象，挂载到plugins节点中</span></span><br><span class="line"><span class="attr">plugins</span>: [htmlPlugin,cleanPlugin],<span class="comment">//挂载插件 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检验是否是删除之后重新生产的方法</strong>：<br>可以在dist文件夹下新建如1.txt文件，重新打包，如果文件还在，说明是没有删除直接打包的，如果不再了，那就是删除之后重新打包。</li>
</ul>
<h3 id="企业级项目的打包发布"><a href="#企业级项目的打包发布" class="headerlink" title="企业级项目的打包发布"></a><font color="red">企业级项目的打包发布</font></h3><p>企业级的项目在进行打包发布时，远比刚才的方式要复杂的多，主要的发布流程如下:</p>
<ul>
<li>生成打包报告，根据报告分析具体的优化方案</li>
<li>Tree-Shaking</li>
<li>为第三方库启用CDN加载</li>
<li>配置组件的按需加载</li>
<li>开启路由懒加载</li>
<li>自定制首页内容</li>
</ul>
<h2 id="source-Map-–-开发阶段检错"><a href="#source-Map-–-开发阶段检错" class="headerlink" title="source Map – 开发阶段检错"></a>source Map – 开发阶段检错</h2><p>告诉你文件的报错位置，用于调试bug<br>开发阶段 npm run dev 检错的<br><strong>在发布项目的时候，处于安全性考虑，建议关闭SourceMap</strong>。防止一些人通过报错位置来拿到我们的源代码(通过修改页面代码来主动让页面某功能报错来拿到该功能位置的源码这样吗？)<br>新版本开发环境建议使用cheap-module-source-map？</p>
<ol>
<li>什么是 source Map<br> <strong>Source Map就是一个信息文件，里面储存着位置信息</strong>。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的<strong>转换前的位置</strong>。<br> 有了它，出错的时候，<strong>除错工具将直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</li>
</ol>
<p>即是：页面报错，控制台会显示错误以及错误文件及其报错位置，如果没有配置这个，它显示的就是打包压缩后的代码的位置</p>
<ol start="2">
<li><p>webpack <strong>开发环境下的</strong> Source Map<br> <strong>在开发环境下</strong>，webpack<strong>默认启用了</strong>Source Map功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。<br> 但是，开发环境下默认生成的Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</p>
</li>
<li><p>解决默认的Source Map的问题<br> 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="comment">// eval-source-map 仅限在&quot;开发模式&quot;下使用，不建议在&quot;生产模式&quot;下使用。</span></span><br><span class="line">    <span class="comment">//此选项生成的 Source Map 能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span></span><br><span class="line">    <span class="comment">// 在开发调试阶段，建议大家都把devtool的值设置为eval-source-map</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">//省略其它配置项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack <strong>生产环境下的</strong> Source Map<br>在生产环境下，如果省略了devtool选项，则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人</p>
</li>
<li><p><strong>只定位行数不暴露源码</strong> – 对调试和安全都比较友好<br>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以<strong>将devtool的值设置为nosources-source-map</strong>。<br>知道了行号，我们就可以定位到源码的行位置来解决bug</p>
</li>
<li><p>定位行数且暴露源码<br>在生产环境下，如果<strong>想在定位报错行数的同时，展示具体报错的源码</strong>。此时可以将devtool的值设置为source-map。<br>坚决不推荐。(但是这不是和eval-source-map一样吗？？)<br>这种方式会生成一个SourceMap(但是nosources-source-map也有，eval-soure-map应该也有吧)<br>可以看到在dist的js目录下，除了有bundle.js还有个bundle.js.map，这就是我们的SourceMap</p>
</li>
</ol>
<h3 id="Source-Map的最佳实践"><a href="#Source-Map的最佳实践" class="headerlink" title="Source Map的最佳实践"></a>Source Map的最佳实践</h3><ol>
<li>开发环境下:<ul>
<li>建议把devtool的值设置为<strong>eval-source-map</strong></li>
<li>好处: 可以精准定位到具体的错误行</li>
</ul>
</li>
<li>生产环境下:<ul>
<li>建议<strong>关闭Source Map</strong> 或 将devtool的值设置为<strong>nosources-source-map</strong></li>
<li>好处: 防止源码泄露，提高网站的安全性</li>
</ul>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="快速终止服务器"><a href="#快速终止服务器" class="headerlink" title="快速终止服务器"></a>快速终止服务器</h3><p><font color="red">两次 ctrl + c 可以直接结束 webpack serve，不需要再去输入y结束</font><br>Vue CLI也一样，因为它是内置了webpack</p>
<h3 id="webpack中-的原理和好处"><a href="#webpack中-的原理和好处" class="headerlink" title="webpack中 @ 的原理和好处"></a>webpack中 @ 的原理和好处</h3><p>这样一个场景：<br>src目录下 有一个info文件 js&#x2F;text&#x2F;info<br>而这个info文件要导入src目录下的msg.js文件<br>就需要这样导入: import msg from ‘..&#x2F;..&#x2F;msg’<br>如果info的文件层级再深一点，这个..&#x2F;会让人不知道翻了几层<br>所以<br><strong>建议大家都使用 @ 符号表示src源代码目录，从外往里查找，不要使用..&#x2F;从里往外查找</strong><br>import msg from ‘@&#x2F;msg.js’</p>
<p>在webpack里面，@不能直接用，需要先配置一下<br>在webpack.config.js中，module.exports中增加一个resolve属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 告诉webpack，程序员写的代码中，@符号表示src这一层目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在浏览器安装vue-devtools调试工具"><a href="#在浏览器安装vue-devtools调试工具" class="headerlink" title="在浏览器安装vue-devtools调试工具"></a>在浏览器安装vue-devtools调试工具</h3><p>edge扩展中直接搜，有一个vue.js-devtools<br><strong>在详情设置中，有个允许访问文件URL(文件网址)的设置，默认是关闭的状态，需要我们手动打开</strong></p>
<h2 id="实际开发中不需要自己配置webpack"><a href="#实际开发中不需要自己配置webpack" class="headerlink" title="实际开发中不需要自己配置webpack"></a><strong>实际开发中不需要自己配置webpack</strong></h2><ul>
<li>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</li>
<li>开箱即用，所有webpack配置项都是现成的!</li>
<li>我们只需要知道webpack 中的基本概念即可!</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Webpack</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 基本使用 &amp; 常用指令</title>
    <url>/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&amp;%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>使用Vue指令完成页面结构的渲染<br>使用Vue调试工具辅助Vue的开发</p>
</blockquote>
<blockquote>
<p><strong>掌握Vue的两个特性：数据驱动视图、双向数据绑定<br>    掌握Vue的底层原理 MVVM – model数据源、view视图&#x2F;页面结构、viewmodel vue实例<br>    掌握Vue六大类指令的使用</strong><br>    vue2指令新学到的东西：<br>    属性绑定指令中的：<a href="#obj">对象写法</a><br>    事件绑定指令中的：<a href="#param">参数问题</a>、<a href="#event">$event</a>、<a href="#modifier">事件修饰符</a>、<a href="#keyModifier">按键修饰符</a><br>    双向绑定指令中的：<a href="#v-model">v-model修饰符</a><br>    条件渲染指令中的：<a href="#if">v-if配套的v-else指令</a><br>    列表渲染指令中的：<a href="#key">key属性绑定</a></p>
</blockquote>
<blockquote>
<p>vscode插件推荐：Volar、Vue VSCode Snippets。 <a href="https://blog.csdn.net/weixin_40808668/article/details/134277604">简单说明</a>(CSDN)</p>
</blockquote>
<blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://v2.cn.vuejs.org/v2/guide/">Vue 2.x 官方文档</a>(已不再维护)<br>Vue是一套<strong>用于构建用户界面的前端框架</strong><br>构建用户界面：用vue往html页面填充数据<br>框架：一套现成的解决方案，程序员只能遵守框架的规范去编写业务功能</p>
<p>学习vue就是学习vue框架中规定的用法<br><strong>vue的指令、组件(是对UI结构的复用)、路由、Vuex、vue组件库</strong></p>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
<h3 id="vue的两个特性："><a href="#vue的两个特性：" class="headerlink" title="vue的两个特性："></a>vue的两个特性：</h3><ol>
<li><strong>数据驱动视图</strong><br> vue会监听数据的变化，自动重新渲染页面的结构<br> 注意：<span style="color:red;" >数据驱动视图是单向的数据绑定<span></li>
<li><strong>双向数据绑定</strong><br> 填写表单时，自动把内容同步到数据源中<blockquote>
<p>在网页中，form表单负责<font color='green'>采集数据</font>，Ajax负责<font color='green'>提交数据</font></p>
</blockquote>
</li>
</ol>
<h3 id="MVVM-–-vue的底层原理"><a href="#MVVM-–-vue的底层原理" class="headerlink" title="MVVM – vue的底层原理"></a>MVVM – vue的底层原理</h3><p><font color='red'>MVVM是 vue 实现数据驱动视图和双向数据绑定的核心原理。</font><br>MVVM 指的是 <strong>M</strong>odel(数据源)、<strong>V</strong>iew(视图) 和 <strong>V</strong>iew<strong>M</strong>odel(vue实例)，它把每个 HTML 页面都拆分成了这三个部分。</p>
<p>在MVVM概念中:<br><strong>Model</strong> 表示当前页面渲染时所依赖的<strong>数据源</strong>。<br><strong>View</strong> 表示当前页面所渲染的 DOM 结构。(<strong>页面结构，也即是视图</strong>)<br><strong>ViewModel</strong> 表示 <strong>vue 的实例</strong>，它是<strong>MVVM的核心</strong>。(也就是vue)<br><img src="/tsukimiya.github.io/images/vue/MVVM%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p>
<ul>
<li>MVVM的工作原理：<br>  ViewModel作为MVVM的核心，是它把当前页面的<font color="green">数据源</font>(Model)和<font color="green">页面的结构</font>(View)连接在了一起。<br>  <img src="/tsukimiya.github.io/images/vue/MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image"><br>  <strong>当数据源发生变化时</strong>，会被ViewModel监听到，VM会根据最新的数据源<strong>自动更新</strong>页面的结构<br>  <strong>当表单元素的值发生变化时</strong>，也会被VM监听到，VM会把变化过后最新的值<strong>自动同步</strong>到Model数据源中</li>
</ul>
<h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><p>当前，vue共有3个大版本，其中:<br>3.x版本的vue 于2020-09-19发布<br>2.x版本的vue 已于 2023 年 12 月 31 日停止维护<br>1.x版本的vue几乎被淘汰，不再建议学习与使用</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p>基本使用步骤</p>
<ol>
<li>导入VUE.js脚本文件<br> 可以借助 script 标签直接通过 CDN(提供 npm 包服务) 来使用 Vue：<br> <code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在页面声明一个将要被vue所控制的区域</li>
<li>创建vm实例对象(vue实例对象)</li>
</ol>
</li>
<li><p>基本代码与MVVM的对应关系<br> model：data指向的对象<br> view：el指向的选择器<br> ViewModel：new Vue()构造函数得到的实例对象</p>
</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。<br>指令是vue开发中最基础、最常用、最简单的知识点</p>
<p>vue的指令 <strong>按照不同用途</strong> 可以分为如下6大类：</p>
<ol>
<li><p>内容渲染指令：<code>v-text</code> 、<code>&#123;&#123;&#125;&#125;</code>  、 <code>v-html</code></p>
<blockquote>
<p>v-test 会覆盖默认文本内容，一般使用<code>&#123;&#123;&#125;&#125;</code>插值表达式<br> v-text和差值表达式只能渲染纯文本内容<br> v-html可以把带标签的字符串渲染成HTML内容</p>
</blockquote>
</li>
<li><p>属性绑定指令: <code>v-bind</code> &#x2F; <code>:xxx=</code> </p>
<blockquote>
<p>差值表达式只能用在元素的内容节点中，不能用在属性节点中<br> v-bind用法：<code>&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;</code><br> <strong>vue规定 <code>v-bind:</code> 指令可以简写为<code>:</code></strong></p>
</blockquote>
<blockquote>
<p>在vue提供的<strong>模版渲染语法中</strong>，除了支持绑定简单的数据值之外，还<font color="green">支持JS表达式的运算</font><br> 但是<font color="green">只能写简单的JS表达式，不能写if等复杂的JS语句</font>，如字符串拼接等：<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;number + <span class="number">1</span>&#125;&#125;、&#123;&#123;ok?<span class="string">&#x27;YES&#x27;</span>:<span class="string">&#x27;NO&#x27;</span>&#125;&#125;、&#123;&#123;msg.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reserve</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)&#125;&#125;<span class="comment">//反转字符串</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><font id="obj" color="red">v-bind的<strong>对象写法</strong></font><br> <code>&lt;xxx v-bind=&quot;&#123;x:100,y:200&#125;&quot;/&gt;</code> 等同于：<code>&lt;xxx :x=&quot;100&quot; :y=&quot;200&quot;/&gt;</code></li>
</ul>
</li>
<li><p>事件绑定指令：<code>v-on</code> &#x2F; <code>@</code></p>
<blockquote>
<p>语法如 <code>v-on:clock=&quot;add&quot;</code> 简写<code>@click=&quot;add&quot;</code><br> methods下的函数变量也支持简写：<code>add:function()&#123;&#125; --&gt; add()&#123;&#125;</code><br> 在处理函数中<strong>修改数据的值</strong>可以通过vm(接受vue实例的变量名)来修改：vm.count,但是不推荐，<strong>推荐用this</strong></p>
</blockquote>
<ul>
<li><p>绑定事件并传参</p>
<blockquote>
<p>在调用的地方传参 <code>@click=&quot;add(1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="param" color="red">参数问题</font></p>
<blockquote>
<ul>
<li>如果定义的函数变量是有参数的<br>1. <code>add(n)&#123;&#125; -- @click=&quot;add(1)&quot;</code> 正常传参 n&#x2F;&#x2F;1<br>2. <code>add(n)&#123;&#125; -- @click=&quot;add()&quot;</code> n&#x2F;&#x2F;undefined<br>3. <code>add(n)&#123;&#125; -- @click=&quot;add&quot;</code> n被认定为事件对象PointerEvent，通常我们会定义为e&#x2F;event</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果是多个参数，如<br>1. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1,2)&quot;</code> 正常传参 a&#x2F;&#x2F;1 b&#x2F;&#x2F;2<br>2. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1)&quot;</code> a&#x2F;&#x2F;1 b&#x2F;&#x2F;undefined<br>3. <code>add(a,b)&#123;&#125; -- @click=&quot;add()&quot;</code> a&#x2F;un b&#x2F;&#x2F;un<br>4. <code>add(a,b)&#123;&#125; -- @click=&quot;add&quot;</code> a&#x2F;&#x2F;事件对象PointerEvent ，b&#x2F;&#x2F;undefined</li>
</ul>
</blockquote>
</li>
<li><p><font id="event" color="red">事件对象$event</font>(不常用)</p>
<blockquote>
<p>vue提供了内置变量<code>$event</code>,它就是原生DOM的事件对象e<br>  在绑定事件的时候，如果不传参 <code>add(e)&#123;&#125; -- @click=&quot;add&quot;</code> , 我们会接受到一个事件对象e<br>  如果传参，<code>@click=&quot;add(1)&quot;</code>,我们就接收不到这个事件对象了<br>  <strong>我们既要传参，又要用到事件对象e</strong>，如想要从事件对象上拿到e.target(触发事件的事件源) ，这个时候就可以用<code>$event</code><br>  <strong><code>$event</code>使用：传<code>$event</code>作参数进去，拿形参接收</strong><br>  <code>add(n,e)&#123;&#125; --  @click=&quot;add(1,$event)&quot;</code><br>  或<code>add(e,n)&#123;&#125; --  @click=&quot;add($event,1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="modifier" color="red">事件修饰符</font></p>
<blockquote>
<p>在事件处理函数中，调用<code>event.preventDefault()</code>(阻止默认行为)或<code>event.stopPropagation()</code>(阻止冒泡)是非常常见的需求。<br>  因此，vue提供了<strong>事件修饰符</strong>的概念，辅助程序员更方便的<strong>对事件的触发进行控制</strong>。<br>  如 <code>@click.prevent=&quot;show&quot;</code>绑定了show事件，同时阻止了默认行为<br>  常见的5个事件修饰符如下：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>.prevent</strong></td>
<td><strong>阻止默认行为</strong>(例如：阻止a链接的跳转、表单的提交等)</td>
</tr>
<tr>
<td align="center"><strong>.stop</strong></td>
<td><strong>阻止事件冒泡</strong></td>
</tr>
<tr>
<td align="center">.capture</td>
<td>以 捕获模式 触发当前的 事件处理函数</td>
</tr>
<tr>
<td align="center">.once</td>
<td>绑定的事件只触发1次</td>
</tr>
<tr>
<td align="center">.self</td>
<td>只有在 event.target 是当前元素自身时 触发事件处理函数</td>
</tr>
</tbody></table>
<ul>
<li><font id="keyModifier" color="red">按键修饰符</font>(用的不是很多)<blockquote>
<p>在<strong>监听键盘事件</strong>时，经常需要<strong>判断详细的按键</strong>。<br>  此时，可以为键盘的相关事件添加<strong>按键修饰符</strong>，如：<br>  <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> – 只有在<code>key</code>是<code>Enter</code>时，调用<code>vm.submit()</code><br>  <code>&lt;input @keyup.esc=&quot;clearInput&quot;&gt;</code> – 只有在<code>key</code>是<code>Esc</code>时，调用<code>vm.clearInput()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>双向绑定指令 <code>v-model</code></p>
<blockquote>
<p>用来辅助程序员在<strong>不操作DOM</strong>的前提下，<strong>快速获取表单的数据</strong>。<br>     能够产生数据交互的只有表单元素，所以只有表单元素才能使用<code>v-model</code>,才有意义<br>     表单元素 input、textarea、select<br>     v-model内部会判断绑定元素的类型，根据元素类型来决定将绑定的值给哪个属性。如复选框checkbox就是给checked属性，如果是text框就是value属性</p>
</blockquote>
<ul>
<li><font id="v-model" color="red">v-model修饰符</font><blockquote>
<p>为了方便对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.number</td>
<td>自动将用户的输入值转为数值类型</td>
<td><code>&lt;input v-model.number=&quot;age&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.trim</td>
<td>自动过滤用户输入的首尾空白字符</td>
<td><code>&lt;input v-model.trim=&quot;msg&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.lazy</td>
<td>在”change”时而非”input”时更新</td>
<td><code>&lt;input v-model.lazy=&quot;msg&quot;/&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>lazy的作用是input事件(表单处于焦点时候)不更新，失去焦点触发change事件才更新</p>
</blockquote>
</li>
<li><p>条件渲染指令 <code>v-if</code>、<code>v-show</code></p>
<blockquote>
<p>辅助开发者<strong>按需控制DOM的显示与隐藏</strong><br> v-if动态的把元素DOM从页面添加和移除<br> v-show是通过css动态添加display：none样式来显示和隐藏<br> <strong>如果要频繁切换元素的显示状态，show的性能更好</strong><br> <strong>如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好</strong><br> 这个只是说给面试官听的，<font color="green">在实际开发中，绝大多数情况不用考虑性能问题，直接使用v-if就好了！</font><br> 因为在大多数情况下，这种性能差异是微不足道的，除非在处理大量组件或频繁切换时才会产生明显影响。</p>
</blockquote>
<ul>
<li><p><font color="green">页面的执行(一个v-if的好问题)</font></p>
<blockquote>
<p>Q：如果我们页面有一个<code>&lt;p v-if=&quot;flag&quot;&gt;&lt;/p&gt; -- flag=false</code>，因为页面是从上往下执行的，那么页面是先创建p标签再移除呢，还是一开始就不创建呢？<br>  A：<strong>当我们用了vue-cli以后，用到单文件组件(.vue文件)的时候，它是先编译，然后再去运行。</strong><br>  先把整个网页编译成js，然后完整的去执行。标签也是被当做js去运行的，去加载的，这个问题就不存在了<br>  在 Vue 中，会根据 <code>v-if</code> 指令来决定是否渲染 DOM 元素。当 <code>flag</code> 初始值为 <code>false</code> 时，<code>&lt;p&gt;</code> 标签不会被创建到 DOM 中，<strong>Vue 在编译阶段会将 <code>v-if</code> 条件为 <code>false</code> 的元素直接移除</strong>。<br>  具体的流程如下：<br>      1. Vue 开始解析模板，并执行编译步骤。<br>      2. 当解析到带有 <code>v-if</code> 指令的元素时，Vue 会根据条件的真假决定是否将该元素包含在虚拟 DOM 中。<br>      3. 如果 <code>flag</code> 的初始值为 <code>false</code>，则 Vue 不会将 <code>&lt;p&gt;</code> 标签添加到虚拟 DOM 中。<br>      4. 最终，Vue 将虚拟 DOM 渲染为真实的 DOM，此时 <code>&lt;p&gt;</code> 标签不会出现在页面上。<br>  因此，页面上不会先创建 <code>&lt;p&gt;</code> 标签再移除，而是在一开始就不会创建 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
</li>
<li><p><font id="if" color="green">v-if配套的指令 – <code>v-else</code></font></p>
<blockquote>
<p>多个元素按需展示<br>  注意：v-else指令<strong>必须配合v-if指令一起使用</strong>，否则不会被识别：<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表渲染指令 <code>v-for</code> 和 <code>:key</code> <font color="red">重要</font></p>
<blockquote>
<p>辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。<br>     v-for指令需要使用<code>item in items</code>形式的特殊语法<br>     v-for支持一个可选的第二个参数，即当前项的索引<code>(item,index) in items</code><br>     注意：v-for指令中的 item项 和 index索引 都是形参，可以根据需要命名</p>
</blockquote>
<ul>
<li><font id="key" color="red">强调v-for循环中key值的绑定</font><blockquote>
<p>官方推荐在用v-for的时候一定要绑定一个key属性，既提升性能、又防止列表状态紊乱。而且尽量把id作为key的值(id唯一)<br>  <font color="#000">官方对key的值类型有要求，只能是字符串或数字类型，并且key的值必须唯一，不能重复(相当于id)</font><br>  也不能以index为值，如果key以索引为值，会数据紊乱，<strong>key必须唯一且稳定，不唯一就会终端报错，唯一又不稳定就会数据紊乱。</strong><br>  <code>&lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</code><br>  如果使用v-for<strong>只是为了循环渲染出内容</strong>，<code>:key</code><strong>可以绑定为index索引</strong>，因为这个时候并没有实际的作用，只是<strong>为了不让报错</strong>而已<br>  <font color="green">不懂key到底有什么用的可以去了解下diff算法和虚拟dom？</font><br>  <font color="purple">key是元素的标识，具有唯一性，diff算法同层比较会根据key判断，dom是在原基础上更新，还是删除再重新创建，若key不唯一，会造成dom额外的删除再创建，消耗性能</font></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="lable复选框的for属性"><a href="#lable复选框的for属性" class="headerlink" title="lable复选框的for属性"></a>lable复选框的for属性</h3><p>下面这个示例中,如果要选中男，应该点击对应的复选框，点击男不行，这样用户的体验很不好，可操作区域非常窄。<br>应该把它的可操作区域给放大，点击复选框还是男都可以选中，此时就用到了for属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>for指向id，希望点这个lable让谁被选中，就for那个元素的id</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="a元素的JavaScript-伪协议"><a href="#a元素的JavaScript-伪协议" class="headerlink" title="a元素的JavaScript 伪协议"></a>a元素的JavaScript 伪协议</h3><p><code>&lt;a href=&quot;javascript:;&quot; @click=&quot;remove&quot;&gt;删除&lt;/a&gt;</code><br>这段代码是一个 HTML 锚点元素 <code>&lt;a&gt;</code> 的写法，其中<code>javascript:;</code> 是一个 JavaScript 伪协议，用于在点击链接时执行 JavaScript 代码或阻止默认行为。</p>
<p>通常情况下，当用户点击这个链接时，浏览器会执行 <code>JavaScript:;</code> 这里的 JavaScript 代码是空的，所以实际上不会发生任何操作。<br>这种写法通常用于创建一个占位符链接，或者作为一个“空链接”，<strong>用于在不跳转页面的情况下执行一些 JavaScript 操作，比如触发事件或者执行某些函数</strong>。</p>
<h3 id="JS-filter-方法-–-Array-prototype-filter"><a href="#JS-filter-方法-–-Array-prototype-filter" class="headerlink" title="JS - filter() 方法 – Array.prototype.filter()"></a>JS - filter() 方法 – Array.prototype.filter()</h3><p><code>filter()</code> 方法是 JavaScript 中数组的一个内置方法，用于过滤数组中的元素，并返回一个符合条件的新数组。<br>如：<br><code>let arr = [1,2,3].filter(item=&gt;item&gt;1) //[1,2]</code><br><code>let arr = [&#123;id:1,name:&quot;zs&quot;&#125;,&#123;id:2..&#125;].filter(item =&gt; item.id !=2) // [&#123;id:1,name:&quot;zs&quot;&#125;]</code></p>
<p>但是，除了数组外，<code>filter()</code> 方法还可以应用于类数组对象和可迭代对象。例如，字符串也可以通过 <code>filter()</code> 方法进行过滤操作。</p>
<p>下面是一个例子，演示如何在字符串中使用 <code>filter()</code> 方法来过滤出特定的字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filteredStr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(str, <span class="function"><span class="params">char</span> =&gt;</span> char !== <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredStr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// 输出：Heo Word!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先使用 <code>Array.prototype.filter.call()</code> 来调用 <code>filter()</code> 方法，并将字符串 <code>str</code> 当作第一个参数传入。然后，我们定义了一个过滤条件，即过滤掉所有的 ‘l’ 字符。最后，我们将过滤后的字符数组通过 <code>join()</code> 方法连接成一个新的字符串，并输出结果。</p>
<p>总之，虽然 <code>filter()</code> 方法通常用于数组，但通过一些技巧，我们也可以在其他类型的对象上使用它。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 过滤器、侦听器、计算属性、axios &amp; vue-cli</title>
    <url>/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&amp;vue-cli/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>在实际开发中合理运用过滤器、侦听器、计算属性解决问题<br>使用axios发起Ajax请求<br>使用vue-cli工具生成工程化的Vue项目</p>
</blockquote>
<p>[toc]</p>
<h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><blockquote>
<p>2020年9月 vue3发布。增加了很多新功能，但是也删掉了一些功能。 比如删掉了vue2中的过滤器filter功能。<br>与此同时，官方建议： <strong>用方法调用或计算属性替换过滤器</strong>。<br>filter过滤器能加工数据，computed计算属性和methods方法也都可以加工数据，这样的话，就功能重复了…(于是filter被开除了XDD)</p>
</blockquote>
<p>vue3已经把过滤器删掉了，只能在vue2中使用，会基础语法就行了。</p>
<ul>
<li><font color="green">过滤器要点</font><ol>
<li>必须被定义到 <code>filters节点</code> 之下，本质是一个函数</li>
<li>强调：过滤器中一定要有一个返回值</li>
<li>过滤器函数中的 形参<code>val</code>(随意命名)，永远都是管道符前面的那个值。(多个形参，则第一个外都是undefined)</li>
<li>过滤器函数 由 管道符 <code>|</code> 调用</li>
<li>过滤器只能在 <code>差值表达式</code> 或 <code>属性绑定指令v-bind</code> 中调用</li>
<li>最终得到的结果是过滤器的返回值</li>
</ol>
</li>
</ul>
<p><strong>过滤器常用于文本的格式化</strong>,应该被添加在JavaScript表达式的尾部，由“<strong>管道符</strong>”进行调用。示例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在花括号中通过管道符调用capitalize过滤器，对message的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中通过管道符调用formatId过滤器，对rawId的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="私有过滤器-和-全局过滤器"><a href="#私有过滤器-和-全局过滤器" class="headerlink" title="私有过滤器 和 全局过滤器"></a>私有过滤器 和 全局过滤器</h3><p><strong>在 <code>filters节点</code> 下定义的过滤器</strong>，称为“<strong>私有过滤器</strong>”，因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器，则可以按照如下的格式<strong>定义全局过滤器</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器–独立于每个vm实例之外 </span></span><br><span class="line"><span class="comment">// Vue.filter()方法接收两个参数:</span></span><br><span class="line"><span class="comment">// 第1个参数，是全局过滤器的&quot;名字”</span></span><br><span class="line"><span class="comment">// 第2个参数，是全局过滤器的&quot;处理函数&quot;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>( <span class="string">&#x27;capitalize&#x27;</span>, <span class="function">(<span class="params">str</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;~~&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果想要定义多个全局过滤器就再写一个</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capi2&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&#x27;--全局2&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">注意：如果私有过滤器和全局过滤器名字一致，此时按就近原则</font></p>
<h3 id="其他用法-–-连续调用、传参"><a href="#其他用法-–-连续调用、传参" class="headerlink" title="其他用法 – 连续调用、传参"></a>其他用法 – 连续调用、传参</h3><ol>
<li><p>连续调用多个过滤器 – 串联地调用<br>如：<code>&#123;&#123;message | filterA | filterB&#125;&#125;</code></p>
</li>
<li><p>过滤器传参</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | filterA(arg1,arg2)&#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;filterA&#x27;</span>,<span class="function">(<span class="params">msg,arg1,arg2</span>)=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器的兼容性<br>仅在vue 2.x 和 1.x中受支持<br>3.x建议使用 <strong>计算属性</strong> 或 <strong>方法</strong> 代替<br>具体的迁移指南参考官方文档给出的<a href="https://v3.vuejs.org/guide/migration/filters.html#migration-strategy">说明</a></p>
</li>
</ol>
<h2 id="Watch侦听器"><a href="#Watch侦听器" class="headerlink" title="Watch侦听器"></a>Watch侦听器</h2><p>Watch侦听器 <strong>监视数据的变化，做出特定操作</strong>，变量名与监听的值对应。语法格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">// 监视username变化</span></span><br><span class="line">        <span class="comment">// newVal - 变化后的新值，oldVal - 旧值</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">应用场景如：侦听用户输入的用户名，每次变化就去查找是否被占用</font></p>
<h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><ol>
<li>方法格式的侦听器<ul>
<li>缺点1: 无法在刚进入页面的时候，自动触发！！</li>
<li>缺点2: 如果侦听的是一个对象，对象中的属性发生了变化，不会触发侦听器！！</li>
</ul>
</li>
<li><strong>对象格式的侦听器</strong><ul>
<li>好处1: 可以通过<strong>immediate选项</strong>，让侦听器自动触发！！</li>
<li>好处2：可以通过<strong>deep选项</strong>，让侦听器深度监听对象中每个属性的变化！！</li>
</ul>
</li>
</ol>
<ul>
<li><font color="green">推荐：为了写起来方便，建议定义成方法格式，如果确实需要，再改成对象格式。</font></li>
</ul>
<h3 id="immediate选项"><a href="#immediate选项" class="headerlink" title="immediate选项"></a>immediate选项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// true表示一进入页面就触发，false是默认值，不写这个参数也是false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦听-–-deep选项"><a href="#深度侦听-–-deep选项" class="headerlink" title="深度侦听 – deep选项"></a>深度侦听 – deep选项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125; &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">info</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 对象里任意属性变化了，都会触发侦听器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要侦听的是对象的子属性的变化，则必须包裹一层单引号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>(newVal)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ol>
<li>什么是计算属性<br>计算属性指的是通过一系列运算之后，最终得到一个属性值。<br>这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</li>
<li>应用场景：<font color='red'>实现代码复用</font></li>
</ol>
<ul>
<li>计算属性的使用<ol>
<li>计算属性要定义到computed节点下，定义成方法格式</li>
<li>虽然声明的方法格式，但是要当做普通的属性来用<blockquote>
<p>打印出vue实例，可以发现定义的计算属性是被挂到属性上面的，和data节点上的属性一样</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>示例代码如下︰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">r</span>:<span class="number">0</span>,<span class="attr">g</span>:<span class="number">0</span>,<span class="attr">b</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 计算属性要定义到computed节点下，定义成方法格式</span></span><br><span class="line">        <span class="title function_">rgb</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rgb</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h2><blockquote>
<p>axios是一个<strong>专注于网络请求</strong>的库！它只负责发请求和拿数据<br>    中文官网地址：<a href="http://www.axios-js.com/">http://www.axios-js.com/</a></p>
</blockquote>
<ul>
<li><p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// url中的查询参数，get请求体传参，可选</span></span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用axios得到的返回值是一个 Promise 对象<br>axios在请求到数据之后，在真正的数据之外，套了一层壳,result得到的就是套完壳之后的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123; 真实的数据 &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">status</span>: xxx,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><font color='red'>结合async和await调用axios</font></strong><br>这个<code>.then</code>用起来有点麻烦，我们可以使用await来进行简化<br><font color='green'>如果调用某个方法的返回值是 Promise 实例，则前面可以添加await！（这样得到的就直接是result）</font><br><font color='red'>await 只能用在被 async 修饰 的方法中</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用解构赋值来获取data</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于axios-get和axios-post发起请求"><a href="#基于axios-get和axios-post发起请求" class="headerlink" title="基于axios.get和axios.post发起请求"></a>基于axios.get和axios.post发起请求</h3><ol>
<li>axois.get<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//GET参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure></li>
<li>axios.post<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意await要在async修饰的函数中使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">unit</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">    <span class="attr">contact</span>: <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">    <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">    <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-cli的安装和使用"><a href="#vue-cli的安装和使用" class="headerlink" title="vue-cli的安装和使用"></a>vue-cli的安装和使用</h2><p>中文官网：<a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<ol>
<li><p>什么是单页面应用程序？<br><strong>单页面应用程序</strong>（英文名: Single Page Application）简称SPA，顾名思义，<strong>指的是一个Web 网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p>
</li>
<li><p>什么是vue-cli<br><strong>vue-cli是Vue.js开发的标准工具</strong>。它简化了程序员基于webpack创建工程化的Vue项目的过程。</p>
</li>
<li><p>安装<br>vue-cli是npm上的一个全局包，使用<code>npm i</code>命令，即可方便的把它安装到自己电脑上：<code>npm i -g @vue/cli</code></p>
<ul>
<li><code>vue -V</code>查看安装的版本号</li>
</ul>
</li>
<li><p>使用<br>基于vue-cli快速生成工程化的Vue项目：<code>vue create 项目名称</code>(建议名称用不带空格的英文)<br> 在想要创建项目的文件夹执行此命令，即会生成项目文件夹，命名即为 项目名称</p>
<ul>
<li>选择预设(用方向键)<br>  <strong>初学者建议选择最后一项 – 手动选择要安装哪些功能</strong><br>  按空格选中要安装的预设<br>  一开始建议选择：<br>  Choose Vue version(新版没有这个)、Babel、CSS Pre-processors,其他的不要选<br>  下面接着选择vue版本为2.x，css预处理器为less</li>
</ul>
</li>
<li><p>vue项目中src目录的构成：</p>
<ol>
<li>assets 文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源</li>
<li>components 文件夹：程序员封装的、可复用的组件，都要放到components目录下。<br> 里面有一个默认组件HelloWorld.vue，给它删除</li>
<li>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</li>
<li>app.Vue 是项目的根组件。我们创建项目之后，看到的页面就是app.Vue，如果想重新换一个页面出来，只需要把它给清空掉。里面的template是一个模版结构。</li>
</ol>
</li>
<li><p>vue项目的运行流程<br> 在工程化的项目中，vue要做的事情很单纯: <strong>通过main.js把 App.vue渲染到index.html的指定区域中</strong>。<br> 其中：</p>
<ul>
<li><strong>App.vue</strong>用来编写待渲染的<strong>模板结构</strong></li>
<li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li>
<li><strong>main.js</strong> 把 App.vue渲染到了index.html所预留的区域中  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 vue 这个包，得到Vue构造函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入App.vue根组件，将来要把App.vue中的模板结构，渲染到HTML页面中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// 把 render 函数指定的组件渲染到HTML页面中，这里指定了App</span></span><br><span class="line">    <span class="comment">// 我们最终的结果是，把这个指定的组件，放到id为app的所在的这个位置，把它给替换掉了</span></span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// vue实例的$mount()方法，作用和el属性完全一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="字符串函数charAt"><a href="#字符串函数charAt" class="headerlink" title="字符串函数charAt()"></a>字符串函数charAt()</h3><p>接收索引值，从字符串中获取对应字符，如：<br><code>&#39;hello&#39;.charAt(4) //&#39;o&#39;</code></p>
<h3 id="将字符串第一个字符变为大写"><a href="#将字符串第一个字符变为大写" class="headerlink" title="将字符串第一个字符变为大写"></a>将字符串第一个字符变为大写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> first = str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="keyword">const</span> other = str.<span class="title function_">slice</span>(<span class="number">1</span>)<span class="comment">//从指定索引往后截取字符串，返回得到的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first+other)</span><br></pre></td></tr></table></figure>

<h3 id="ajax原生写法"><a href="#ajax原生写法" class="headerlink" title="ajax原生写法"></a>ajax原生写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>过滤器</tag>
        <tag>侦听器</tag>
        <tag>计算属性</tag>
        <tag>axios</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件与生命周期</title>
    <url>/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>目标：<br>掌握.vue单文件组件的基本用法<br>组件的props(自定义属性)：数组写法、对象写法<br>解决多个组件间的样式冲突 – scoped<br><a href="#deep"><strong>&#x2F;deep&#x2F;样式穿透</strong></a>应用场景：<strong>修改第三方组件库组件的默认样式</strong></p>
</blockquote>
<blockquote>
<p>掌握组件生命周期的执行顺序和应用场景：创建阶段、运行阶段、销毁阶段<br>vue 中常用的生命周期函数&#x2F;生命周期钩子：<strong>created、mounted</strong></p>
</blockquote>
<blockquote>
<p>能够掌握组件通讯的三种方式：父-&gt; 子（自定义属性）、子-&gt; 父（自定义事件）、兄弟组件（EventBus）</p>
</blockquote>
<p>[toc]</p>
<h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><ol>
<li><p>什么是组件化开发<br><strong>组件化开发</strong>指的是∶根据<strong>封装</strong>的思想，<strong>把页面上可重用的UI结构封装为组件</strong>，从而方便项目的开发和维护。</p>
</li>
<li><p>vue中的组件化开发<br>vue是一个<strong>支持组件化开发</strong>的前端框架。<br>vue中规定：<strong>组件的后缀名是.vue</strong><br>vue中，root就是根，而这个根就是el所控制的那个区域。在main.js文件里，vue实例中通过 render 函数指定组件渲染到HTML页面中，替换了el区域。即：<strong>render函数中，渲染的是哪个.vue组件，那么这个组件就叫做“根组件”</strong></p>
</li>
<li><p><font color='green'>vue组件的三个组成部分</font></p>
<ul>
<li><font color='green'>template -&gt; 组件的模板结构</font></li>
<li><font color='green'>script -&gt; 组件的JavaScript行为</font></li>
<li><font color='green'>style -&gt; 组件的样式</font></li>
</ul>
<p> 注意：<font color='red'>每个组件中必须包含template模板结构，而script行为和style样式是可选的组成部分</font></p>
</li>
</ol>
<p>简单示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 组件的模版结构中，应该包含一个根元素，这个最外层的div不能有兄弟元素 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span> &gt;</span>这是用户自定义的Test.vue -- &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">// 默认导出，固定写法！</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 注意：.vue组件中的data不能像之前一样，不能指向对象,必须是一个函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">// data数据源</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span>&#123;<span class="comment">// 这个return出去的对象中，可以定义数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">// 在组件中，this就表示当前组件的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">username</span> = <span class="string">&#x27;aaa&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.text-box</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">background-color</span>: pink;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">h3</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>组件之间的<font color='red'>父子关系</font><br>组件之间的父子关系、兄弟关系，<strong>是在使用时候才会产生的</strong><br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB.png" alt="image"></li>
</ol>
<h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的<strong>三个步骤</strong></h3><p><img src="/tsukimiya.github.io/images/vue/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt="image"><br><font color="green">注意：在components节点中，注册组件是一个对象的写法，前面是定义的名称，后面是要注册的组件。在对象里面，键名和值如果一样，可以省略值只写键名。如’Left’:Left可以简写成Left</font></p>
<ul>
<li><p>通过components注册的是<font color='red'>私有子组件</font><br>例如：<br>在组件A的components节点下，注册了组件F。<br>则组件F只能用在组件A中;不能被用在组件C中。</p>
</li>
<li><p>注册<font color='red'>全局组件</font><br>如果某个组件，使用非常频繁，好多组件中都要用到它，那么每次都要导入注册并使用，就很麻烦。所以可以注册全局组件</p>
<p>  <font color='green'>在vue项目的 main.js入口文件中，通过Vue.component()方法，可以注册全局组件。</font>示例代码如下:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Count</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Count.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：字符串格式，表示组件的“注册名称”</span></span><br><span class="line"><span class="comment">// 参数2：需要被全局注册的那个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyCount&#x27;</span>,<span class="title class_">Count</span>)</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：在自己的组件中，不能使用自己！</strong></p>
</li>
</ul>
<h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的<strong>自定义属性</strong>，<strong>在封装通用组件的时候</strong>，合理地使用 props 可以极大的<font color='red' size='5'>提高组件的复用性！</font><br>它的语法格式如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性,允许使用者指定初始值</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其它自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font fcolor='green'>props中的数据，可以直接在模板结构中被使用</font>。使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;init&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left.vue组件中，使用注册了的Count组件</span></span><br><span class="line"><span class="comment">// 指定初始值，但是这里传入的是一个字符串，并不是一个真正的数值</span></span><br><span class="line">&lt;<span class="title class_">Count</span> init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color='red'>结合v-bind使用自定义属性</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 这样就传入的是数值6了</span><br><span class="line"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color='green'>官网文档-&gt;即便 <code>9</code> 是静态的，我们仍然需要 <code>v-bind</code> 来告诉 Vue，这是一个 JavaScript 表达式而不是一个字符串</font></p>
</li>
<li><p><font color='red'>props对子组件是只读的 (父组件-&gt;子组件 单向数据传递)</font><br>Vue规定:组件中封装的自定义属性是只读的，程序员不能直接修改props的值。否则会直接报错。<br>注意：props是对定义该属性的子组件只读，<font color='red'>在父组件中，你可以通过v-bind绑定props的值，并且这个值是可以更改的。</font><strong>当父组件中的值改变时，Vue会自动将新值传递给子组件，并且子组件会根据新的值重新渲染</strong>。这种方式实际上是通过props属性进行了<strong>单向数据流</strong>，确保数据流动的可预测性和可维护性。<br><font color='red'>如果子组件需要修改传递过来的值，通常应该通过触发事件并将修改传递给父组件来实现。</font><br><font color='green'>props可以被作为初始值使用的，把它传给data的属性进行初始赋值使用：</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count+=1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>, &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Count</span> :init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="props的default默认值"><a href="#props的default默认值" class="headerlink" title="props的default默认值"></a>props的default默认值</h3><p>在声明自定义属性时，可以通过default来定义属性的默认值。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="comment">// 自定义属性：&#123; /* 配置选项 */ &#125;</span></span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="comment">// 如果外界使用Count组件，没有传递默认值，则默认值生效</span></span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props的-type-值类型"><a href="#props的-type-值类型" class="headerlink" title="props的 type 值类型"></a>props的 type 值类型</h3><p>在声明自定义属性时，<font color='red'>可以通过type来定义属性的值类型。</font>示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="comment">// 用type属性定义属性的值类型</span></span><br><span class="line">            <span class="comment">// init的值类型必须是Number数字</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>还可以通过数组形式，为当前属性定义多个可能的类型：<code>type: [Number, String]</code></font><br><font color='green'>如果是带有默认值的对象类型，对象或数组默认值必须从一个工厂函数获取：</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封面的信息对象</span></span><br><span class="line"><span class="attr">cover</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="comment">// 默认值是一个空对象</span></span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="props的-required-必填项"><a href="#props的-required-必填项" class="headerlink" title="props的 required 必填项"></a>props的 required 必填项</h3><p>加上required必填项之后，哪怕有默认值，不传也会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">require</span>: <span class="literal">true</span>,<span class="comment">//必填项校验</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props属性的命名规定"><a href="#props属性的命名规定" class="headerlink" title="props属性的命名规定"></a>props属性的命名规定</h3><p>Vue里面有一个规定，如果<strong>某一个属性</strong>在定义的时候，里面<strong>包含了一个大写的字符</strong>（是一个<strong>小驼峰</strong>），在进行<strong>绑定的时候</strong>，可以直接写成原名字，不过<strong>建议改成连字符格式</strong>，因为这样看起来会<strong>更舒服</strong>一些<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="attr">props</span>:[cmtCount]</span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;xxx :cmtCount=<span class="string">&quot;...&quot;</span>&gt;&lt;/xxx&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">xxx</span> <span class="attr">:cmt-count</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span> <span class="comment">// 建议</span></span><br></pre></td></tr></table></figure>


<h3 id="组件间的样式冲突-scoped"><a href="#组件间的样式冲突-scoped" class="headerlink" title="组件间的样式冲突 - scoped"></a>组件间的样式冲突 - scoped</h3><p>默认情况下，<strong>写在.vue组件中的样式会全局生效</strong>，因此很容易造成<strong>多个组件之间的样式冲突问题</strong>。<br>导致组件之间样式冲突的<strong>根本原因</strong>是:<br>    <font color='purple'>1. 单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</font><br>    <font color='purple'>2. 每个组件中的样式，都会影响整个index.html页面中的DOM元素</font></p>
<p>注意：单页面应用程序中，HTML页面是只有一个的，我们的所有组件都是在这个HTML中生效的</p>
<ul>
<li><p>解决方案 – <font color='red'>核心原理：css属性选择器</font><br>给当前页面标签都加一个固定的自定义属性，不同的组件之间的自定义属性不一样</p>
</li>
<li><p>vue简化：<strong>scoped属性</strong><br>只要给当前组件的style加上scoped的属性，vue底层在生成组件的时候，会自动给每个标签自动生成一个data-v-xxx</p>
</li>
</ul>
<h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="&#x2F;deep&#x2F;样式穿透"></a><font id='deep' color='red'>&#x2F;deep&#x2F;样式穿透</font></h4><p><font color='#00a86b'>作用：在父组件中改造子组件里的样式</font><br><font color='red'>应用场景：当使用第三方组件库的时候，如果有修改组件默认样式的需求，需要用到&#x2F;deep&#x2F;</font></p>
<ul>
<li><p>scoped有一个缺陷，场景：<br>Left 和 Right 都注册使用了 Count组件<br>Left加了scoped属性，而Right没加<br>如果想在Left中的style里修改Count里面的样式，会发现不起作用，而如果在Right中修改，会发现Left和Right里面的Count组件样式都变了。</p>
</li>
<li><p>原因：<br>在Left中修改，比如h5{..},因为加了scoped，所以会变成h5[data-v-xx]{..}，而count中的标签并没有data-v-xx属性，所以不会生效。<br>而在没有scoped属性的Right中修改，则产生的就是样式冲突</p>
</li>
<li><p>解决方案：&#x2F;deep&#x2F;样式穿透<br>&#x2F;deep&#x2F; h5{ … }<br>在选择器前面加个前缀+空格，在浏览器可以查看到，这个h5标签被加上了一个[data-v-xx] 的前缀<br><font color='red'>加上<code>/deep/</code>之后就不再是 <code>类名[data-v-xxx]</code> 的 选择特定属性的选择器 了，而是变成了 <code>[data-v-xxx] 类名</code> 的 后代选择器 。</font></p>
</li>
</ul>
<h2 id="Vue运行原理"><a href="#Vue运行原理" class="headerlink" title="Vue运行原理"></a><strong>Vue运行原理</strong></h2><p>在把app渲染到页面的过程中，不是把页面的模板结构直接丢到页面上，而是有个编译的过程。<br>浏览器能够直接解析HTML页面，但是不识别vue页面。<br>在<code>package.json</code>里面，<code>devDependencies</code>里面有个<code>vue-template-complier</code>包，就是vue模板编译器，作用就是把.vue文件编译成js交给浏览器解析运行。<br>在.vue中写的任何代码，要渲染到浏览器中，都依赖于这个包的解析与转换。</p>
<p>我们上面在页面上渲染了2次Count.vue组件，我们在页面上看到的两个Count组件，就是两个组件的实例。<br>实例，就是相当于new一个构造函数得到一个实例。我们编写的Count.vue，可以理解为它就是一个构造函数，new这个构造函数就会得到一个Count实例。<br>我们没有直接new，而是通过标签形式去用这个组件，这个用的过程可以理解为一个new的过程<br>所以说，<strong>这个组件，在定义的时候，它只是一个模板结构，当用标签的形式去使用的时候，才是在创建一个它的实例。</strong><br>如果在components下声明一个组件，不去用它不会创建组件实例。</p>
<blockquote>
<p><font color='red'>整个项目如何跑起来的：</font><br><font color='#00a86b'>webpack从main.js(入口文件)开始打包，发现main里面用到了app，于是把app创建一个实例出来。然后app里面又用到了Left和Right，然后这两个里面又用到了Count，就这样一直通过一个树的形式，把整个树都解析转换，最后编译成纯js代码。然后把js文件放到首页里面去，浏览器就会解析和执行这里面的代码，把组件都给渲染到页面上</font></p>
</blockquote>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol>
<li><p>生命周期 &amp; 生命周期函数<br><font color='red'>生命周期</font>(Life Cycle)是指一个组件从<font color='red'>创建-&gt;运行-&gt;销毁</font>的整个阶段，<font color='red'>强调的是一个时间段</font>。</p>
<p> <font color='red'>生命周期函数</font>:是由vue框架提供的<font color='red'>内置函数</font>，会伴随着组件的生命周期，<font color='red'>自动按次序执行</font>。<br> 注意:<font color='#00a86b'>生命周期</font>强调的是<font color='#00a86b'>时间段</font>，<font color='#00a86b'>生命周期函数</font>强调的是<font color='#00a86b'>时间点</font>。</p>
</li>
<li><p>组件生命周期函数(<strong>生命周期钩子</strong>)的分类<br>在生命周期里面，它会按顺序依次执行这些函数。<br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="img"></p>
</li>
<li><p>生命周期图示<br>可以官方给出的<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">“生命周期图示”</a>，<a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=106">进一步理解组件生命周期执行过程</a>。<br><a href="/tsukimiya.github.io/custom/pages/lifecycle.html" target="_blank"><font color='red'>中文详解图示</font></a></p>
</li>
</ol>
<ul>
<li><p><font color='green'>执行次数</font><br>创建阶段：1次<br>运行阶段：0-N次<br>销毁阶段：1次</p>
</li>
<li><p><font color='red'>最重要的生命周期钩子</font></p>
<ol>
<li><font color='red'>created</font><br> data、props、methods都是可用状态<br> 常用它发起ajax请求来拿数据，转存到data中，供template模板渲染时候使用。</li>
<li><font color='red'>mounted</font><br> 第一次把DOM元素结构渲染好，最早去操作DOM</li>
<li><font color='red'>updated</font><br> 可以操作最新的更新过后的DOM</li>
</ol>
<p>  其他的很少会用到，记不住也没关系</p>
</li>
</ul>
<h2 id="组件之间的通讯-数据共享"><a href="#组件之间的通讯-数据共享" class="headerlink" title="组件之间的通讯(数据共享)"></a>组件之间的通讯(数据共享)</h2><ol>
<li><p>组件之间的关系<br>最常见的：兄弟关系、父子关系<br>离的比较远的，也可以认为是一种变态的兄弟关系</p>
</li>
<li><p><strong>父向子传值</strong> – <strong>自定义属性</strong><br><font color='red'>再次注意: props是只读的！</font><br><img src="/tsukimiya.github.io/images/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.png" alt="image"></p>
</li>
<li><p><strong>子向父传值</strong> – <strong>自定义事件</strong><br>第一步是绑定了一个事件，这是个处理函数。<font color='red'><code>$emit</code>就代表触发这个事件</font>，谁触发这个事件，谁传一个值过来。<br><font color='#00a86b'>子向父传值：在子组件调用$emit，父组件<font color='red'>在子组件标签上</font>用@绑定(监听)这个自定义事件</font><br><font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。<br><img src="/tsukimiya.github.io/images/vue/%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<blockquote>
<p>vue在内部要想触发click事件，它也是用this或vm<br> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">method</span>:&#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">e</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">vm.$emit(<span class="string">&#x27;click&#x27;</span>,&#123;<span class="comment">//事件对象e</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">clientX</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">clientY</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">target</span>:dom元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p><strong>兄弟组件之间的数据共享</strong> – <strong>EventBus</strong><br>在<font color='red'>vue2.x</font>中，兄弟组件之间数据共享的方案是<font color='red'>EventBus</font>。</p>
<ul>
<li>EventBus使用步骤</li>
</ul>
<ol>
<li>创建<code>eventBus.js</code>模块，并向外共享一个<strong>Vue的实例对象</strong></li>
<li>在数据<strong>发送方</strong>，调用<code>bus.$emit(&#39;事件名称&#39;,要发送的数据)</code>方法<strong>触发自定义事件</strong></li>
<li>在数据<strong>接收方</strong>，调用<code>bus.$on(&#39;事件名称&#39;,事件处理函数)</code>方法<strong>注册一个自定义事件</strong><br> 数据在事件处理函数的形参中拿到。</li>
</ol>
<p> <font color='#00a86b'>依旧是发送方触发事件，发送数据，接收方绑定事件监听，接受数据。</font><br> 这里的<code>$on</code>就相当于jQuery的on绑定事件<br> <strong>为什么这里要用到一个共享的实例EventBus</strong> ？因为<font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。</p>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/vue/%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<p>注意：虽然可以使用EventBus来在父子组件之间传值，但是这不是Vue官方推荐的做法。<strong>props和自定义事件更适合处理父子组件之间的通信，因为它们更直观和易于理解</strong>。 Event Bus 通常更适用于非父子关系的组件之间的通信，例如兄弟组件之间。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="vscode插件-Path-Autocomplete-路径提示"><a href="#vscode插件-Path-Autocomplete-路径提示" class="headerlink" title="vscode插件 Path Autocomplete - @路径提示"></a>vscode插件 Path Autocomplete - @路径提示</h3><p>下载插件之后，要在自己配置项里面添加如下配置,添加在头部就行<br>设置 – setting.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入文件时是否携带文件的扩展名</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 配置 @ 的路径提示</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.pathMappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><font color="red">注意：只有vscode打开的文件夹根目录是项目根目录时才起作用！！</font></p>
<blockquote>
<p>总觉得这个功能vscode也集成进去了？一开始没装的时候，好像就触发了，也懒得验证了hh</p>
</blockquote>
<h3 id="Auto-Close-Tag插件"><a href="#Auto-Close-Tag插件" class="headerlink" title="Auto Close Tag插件"></a>Auto Close Tag插件</h3><p>输入<code>&lt;xx&gt;</code>标签前半部分，会自动补全后半部分<br>不过新版vscode好像已经集成了这个功能，没有安装也是这样，装了没啥变化</p>
<h3 id="方法简写形式"><a href="#方法简写形式" class="headerlink" title="方法简写形式"></a>方法简写形式</h3><p><strong>如果方法只有一行，可以简写到行内</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count += 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>先指令，后绑定，最后绑事件<br>这是一个子组件的绑定示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Goods</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    :state=<span class="string">&quot;item.goods_state&quot;</span></span><br><span class="line">    @state_change=<span class="string">&quot;getNewState&quot;</span></span><br><span class="line">&gt;&lt;/<span class="title class_">Goods</span>&gt;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>组件</tag>
        <tag>组件的porps</tag>
        <tag>生命周期</tag>
        <tag>组件通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>ref引用DOM元素和组件实例</title>
    <url>/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>能够使用<code>ref</code>获取页面上DOM或组件的引用：<br>给元素或组件添加<code>ref=&quot;xxx&quot;</code>的引用名称，通过<code>this.$refs.xxx</code>获取元素或组件的实例</p>
</blockquote>
<blockquote>
<p>能够知道<code>$nextTick</code>的应用场景并合理地使用：把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</p>
</blockquote>
<blockquote>
<p>通过<a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=127">“购物车案例”</a>巩固前4天所有学知识</p>
</blockquote>
<h2 id="ref引用-引用DOM元素-组件实例"><a href="#ref引用-引用DOM元素-组件实例" class="headerlink" title="ref引用 - 引用DOM元素 &#x2F; 组件实例"></a>ref引用 - 引用DOM元素 &#x2F; 组件实例</h2><blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<ol>
<li><p>什么是ref 引用<br> ref用来辅助开发者在<strong>不依赖于jQuery的情况下</strong>且<strong>在不调用DOM API的前提下</strong>，<strong>获取页面上DOM元素或组件的引用</strong>。</p>
<p> 每个vue的组件实例上，都包含一个<code>$refs</code>对象，里面存储着对应的DOM元素或组件的引用。<strong>默认情况下，组件的<code>$refs</code> 指向一个空对象</strong>。</p>
<blockquote>
<p>打印出vue实例对象this，可以看到，凡是$开头的，都是vue内置的一些成员。</p>
</blockquote>
</li>
<li><p>使用ref引用 DOM元素<br> 在标签上通过ref属性来指定一个名字，这个名字就指向这个标签，并添加到<code>$ref</code>对象中。如：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;myh1&quot;</span>&gt;</span>APP根组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">$refs</span>:&#123;<span class="comment">//vue实例上的$refs属性值</span></span><br><span class="line">    <span class="attr">myh1</span>: h1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myh1</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//操作DOM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ref引用 组件实例<br> 只要<strong>在引用的子组件的标签上，加一个ref</strong>，这个名字就指向了这个子组件的vue实例，就可以通过它来调用这个子组件的属性和方法。</p>
</li>
</ol>
<p><font color='red'>建议：只要是ref的引用，尽量都以Ref后缀结尾，这样一看名字就知道是个引用</font></p>
<h2 id="this-nextTick的应用场景"><a href="#this-nextTick的应用场景" class="headerlink" title="this.$nextTick的应用场景"></a><code>this.$nextTick</code>的应用场景</h2><ul>
<li><strong>问题</strong></li>
</ul>
<p>在app组件中，控制组件内按钮和输入框元素的切换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;inputVisible&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;showButton&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iptRef&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> @<span class="attr">click</span>=<span class="string">&quot;showinput&quot;</span>&gt;</span>显示输入框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们想要在切换到输入框的时候，直接进入输入框焦点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">showButton</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是<code>this.$refs.iptRef.focus()</code>这样却报错了<br><code>TypeError: Cannot read properties of undefined (reading &#39;focus&#39;)</code><br>这个错误代表说，我要调用一个focus方法，或我要访问一个focus属性，但是它前面那个东西是undefined<br>当我们打印<code>console.log(this.$refs.iptRef);</code>会发现它是<code>undefined</code>！</p>
<ul>
<li><strong>分析原因</strong></li>
</ul>
<p>在这个函数中，我们是更改inputVisible的值让文本框显示出来，但是现在页面上文本框还未显示出来，所以拿不到这个元素，因此是undefined<br>在Vue的生命周期中，当data里面的数据变化，会触发DOM元素的更新，根据最新的数据，重新渲染页面的UI结构。<strong>在updated之前，页面还没来得及重新渲染，所以数据是新的，但是页面的结构是旧的。</strong><br>所以<code>this.inputVisible = true;</code>这句执行之后，页面上还是按钮，文本框还未被展示，还需要一个更新的过程，需要一定的时间。如果立马去执行<code>this.$refs.iptRef.focus()</code>是拿不到文本框的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><font color='red'>总结：<code>this.inputVisible = true</code>这行代码执行完，只是数据是最新的，页面还没来得及重新渲染，没有文本框，拿不到它的引用，所以是undefined</font><br>要想不报错，<code>this.$refs.iptRef.focus()</code>这一行调用应该放在页面重新渲染完毕之后</p>
<ul>
<li><strong>解决</strong> – <code>this.$nextTick(cb)</code>方法<br>里面接收一个回调，cb是callback<br>代表：<strong>把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</strong><br>保证cb回调函数可以操作到最新的DOM元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>ref引用</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件高级用法 - 动态组件&amp;插槽&amp;自定义指令&amp;ESlint</title>
    <url>/tsukimiya.github.io/2024/05/01/Vue2/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&amp;%E6%8F%92%E6%A7%BD&amp;%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4&amp;ESlint/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>掌握keep-alive实现组件的缓存：keep-alive标签、include 属性<br>能够使用插槽提高组件的复用性：slot标签、具名插槽、<strong>作用域插槽</strong>(接收数据并使用)、后备内容<br><strong><code>v-slot</code>指令</strong>：<strong>把内容填充到指定名称的插槽中，只能被用在 组件components 或 template标签</strong><br><code>v-slot:</code> 简写 <code>#</code> 如：<code>&lt;template #title&gt;&lt;/template&gt;</code></p>
</blockquote>
<blockquote>
<p>能够知道如何自定义指令：<br>私有自定义指令<code>directives: &#123; &#125;</code><br>全局自定义指令<code>Vue.directive()</code></p>
</blockquote>
<blockquote>
<p>了解常见的ESLint语法规则、习惯在ESLint下进行开发<br>配置VSCode插件及设置，帮助我们规范代码格式，高效开发</p>
</blockquote>
<h2 id="动态组件的使用"><a href="#动态组件的使用" class="headerlink" title="动态组件的使用"></a>动态组件的使用</h2><p>动态组件指的是<strong>动态切换组件的显示与隐藏</strong>。实现不同组件的按需展示。</p>
<ol>
<li><p>如何实现动态组件的渲染<br> vue提供了一个内置的<code>component</code>组件，作用：组件的占位符。专门用来实现动态组件的渲染。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1．当前要渲染的组件名称</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">comName</span>: <span class="string">&#x27;Left&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;! -- <span class="number">2</span>．通过is属性，动态指定要渲染的组件--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>．点击按钮，动态切换组件的名称 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Left&#x27;&quot;</span>&gt;</span>展示 Left 组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Right&#x27;&quot;</span>&gt;</span>展示 Right组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内置标签keep-alive – 保持组件的状态</strong><br>每次切换组件都是上一个组件被销毁和下一个组件被创建-&gt;运行<br>如果再次创建同一个组件，它会重新初始化一遍数据，和上一个组件是没有关系的<br> 如果我们希望切换回来之后原来的数据状态还在，就可以使用<font color="red">keep-alive：防止组件被隐藏的时候被销毁</font></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 这样隐藏Left的时候不会移除这个组件，而是打上一个inactive标记(被缓存了)（未使用的、不活动的）<br> <font color="green">总结：keep-alive可以把内部的组件进行缓存，而不是销毁组件</font></p>
</li>
<li><p><strong>keep-alive 对应的生命周期函数</strong><br> 当组件<strong>被缓存</strong>时，会自动触发组件的<strong>deactivated</strong>生命周期函数。<br> 当组件<strong>被激活</strong>时，会自动触发组件的<strong>activated</strong>生命周期函数。</p>
</li>
<li><p><strong>keep-alive的include属性 – 指定哪些组件可以被缓存</strong><br> 只有名称匹配的组件会被缓存</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;Left,Right&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 除了include，还有个exclude属性，表示排除项<br> 注意：这两个属性不能同时使用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive exclude=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="了解组件-注册名称-和-组件声明时name-的区别"><a href="#了解组件-注册名称-和-组件声明时name-的区别" class="headerlink" title="了解组件 注册名称 和 组件声明时name 的区别"></a>了解组件 注册名称 和 组件声明时name 的区别</h2><p>如果在声明组件(定义组件模板结构)的时候，没有为组件指定 name 名称，则组件的名称默认就是“注册时候的名称”。当提供了name属性之后，组件的名称就是name属性的值。</p>
<ul>
<li><strong>对比</strong>(3、4 is my think):</li>
</ul>
<ol>
<li>组件的“<strong>注册名称</strong>”的主要应用场景是: 以<strong>标签</strong>的形式，把注册好的组件，渲染和使用到页面结构之中</li>
<li>组件声明时候的“<strong>name</strong>”名称的主要应用场景: <strong>结合keep-alive标签实现组件缓存功能</strong>;以及在<strong>调试工具</strong>中看到组件的 name <strong>名称</strong></li>
<li>一般情况下，注册名称可以将name属性完全替代，不去注册name属性</li>
<li><strong>name属性的独特应用场景：递归组件</strong>。指在组件的模板中，使用该组件自身的情况。(这样场景下，注册名称是替代不了name属性的)</li>
</ol>
<p>开发中，为了标准、方便，<strong>建议给每个组件起一个name名称</strong>。(虽然我还是不理解除了4的情况有什么必要)</p>
<h2 id="插槽的使用-默认插槽、具名插槽、作用域插槽"><a href="#插槽的使用-默认插槽、具名插槽、作用域插槽" class="headerlink" title="插槽的使用(默认插槽、具名插槽、作用域插槽)"></a>插槽的使用(默认插槽、具名插槽、作用域插槽)</h2><p><strong>插槽</strong>（Slot）是vue为<strong>组件的封装者</strong>提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。</p>
<p><font color="red">在组件的内容节点填写内容，然后把它给渲染出来</font><br><img src="/tsukimiya.github.io/images/vue/%E6%8F%92%E6%A7%BD.png" alt="image"></p>
<h3 id="v-slot指令-–-简写："><a href="#v-slot指令-–-简写：" class="headerlink" title="v-slot指令  – 简写：#"></a>v-slot指令  – 简写：#</h3><p><strong>vue官方规定：每一个 slot 插槽，都要有一个 name 名称</strong><br>如果省略了 slot 的 name 属性，则有一个<strong>默认名称</strong>叫做 <strong>default</strong></p>
<p>默认情况下，在使用组件的时候，提供的内容都会被填充到名字为default的插槽中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有一个插槽的话，name不写也可以</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color="green">如果要把内容填充到指定名称的插槽中，需要使用<code>v-slot：</code>这个指令</font><font color="red"> – 简写：#</font><br><font color="red">注意：v-slot指令，只能被用在 组件components 或 template标签</font><br>template是个虚拟的标签，只起到一个包裹性的作用，不会被渲染成任何真实的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    //或</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="插槽的默认内容-后备内容"><a href="#插槽的默认内容-后备内容" class="headerlink" title="插槽的默认内容&#x2F;后备内容"></a>插槽的默认内容&#x2F;后备内容</h3><p>官方的专业术语：后备内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>带有名字的插槽就叫做具名插槽。</p>
<p>它也是一个具名插槽，或者叫默认插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>在预留插槽的时候，声明数据项。在使用的时候可以接收数据并使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Left</span><br><span class="line"><span class="comment">&lt;!-- 在封装组件的时候，为预留的slot提供属性对应的值，这种用法叫做“作用域插槽” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;hello vue.js&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果插槽没有声明数据项，则形参scope是个空对象<br><font color="green">接收数据的形参建议用 scope(作用域) 来命名</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// app.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; scope.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽的解构赋值"><a href="#作用域插槽的解构赋值" class="headerlink" title="作用域插槽的解构赋值"></a>作用域插槽的解构赋值</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote>
<p>vue允许开发者自定义指令</p>
</blockquote>
<p>vue中的自定义指令分为两类，分别是:</p>
<ul>
<li>私有自定义指令</li>
<li>全局自定义指令</li>
</ul>
<h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>在每个vue 组件中，可以在 <strong>directives节点</strong>下声明<strong>私有自定义指令</strong>。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="comment">//为绑定到的 HTML 元素设置红色的文字</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el</span>)&#123; </span><br><span class="line">            <span class="comment">// 形参中的 el是绑定了此指令的、原生的DOM对象(固定的写法)</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当指令第一次被绑定到元素上的时候，会立即触发bind方法</span></span><br><span class="line">&lt;<span class="title class_">Left</span> v-color&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>binding.value</code>获取指令绑定的值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//官方推荐用binding</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Left</span> v-color=<span class="string">&quot;&#x27;green&#x27;&quot;</span>&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>update函数</strong><br><strong>bind</strong>函数<strong>只调用1次</strong>：当指令<strong>第一次绑定到元素时</strong>调用；当DOM更新时bind函数不会被触发。<br><strong>update</strong>函数会在<strong>每次DOM更新时被调用</strong>，绑定的时候不会触发：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//每次DOM更新时被调用，绑定的时候不会触发</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">          el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-color=<span class="string">&quot;color&quot;</span>&gt;<span class="variable constant_">APP</span>根组件&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;color=&#x27;red&#x27;&quot;</span>&gt;</span>变成红色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数简写形式</strong><br>如果 bind 和 update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 bind 和 update 时，会触发相同的业务逻辑</span></span><br><span class="line">    <span class="title function_">color</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>和定义过滤器filter一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1: 字符串，表示全局自定义指令的名字</span></span><br><span class="line"><span class="comment">// 参数2: 对象，用来接收指令的参数值</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,<span class="keyword">function</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//简写形式</span></span><br><span class="line">    el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象形式：</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,&#123; <span class="comment">//简写形式</span></span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ESLint工具"><a href="#ESLint工具" class="headerlink" title="ESLint工具"></a>ESLint工具</h2><p>可组装的JS和JSX检查工具 – 约束代码风格<br>在你的js代码里面 帮你发现问题，并且解决问题</p>
<p>两个中文官网 <a href="https://nodejs.cn/eslint/">官网1</a> <a href="https://eslint.nodejs.cn/docs/latest/">官网2</a></p>
<p>当在项目里面配置了ESLint以后，它就会去检查代码风格，有问题就会报错</p>
<ul>
<li><p>vscode 设置<br>缩进：设置 -  搜索 Editor:Tab Size 设置为2<br>保存：设置 - 文本编辑器 - 格式化 - Format on Save(保存时格式化文件) </p>
</li>
<li><p>使用ESLint – 创建新的vue项目<br>在选择预设的时候，加上一个Linter &#x2F; Formatter(默认被选上的)<br>然后后面的选项中就多了一项：选择要安装的ESLint的语法规范<br>选择倒数第二项 – Standard config 标准配置<br>然后选择：<br>Lint on save（ctrl s保存的时候进行检查）<br>Lint and fix on commit（提交代码的时候进行代码规范的检查，并且把检查到的问题自动修复）<br>只勾选第一项默认的就行，第二项不建议勾选。</p>
</li>
<li><p>ESLint配置文件 eslintrc.js<br>这里是定义的一些规则：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">//固定格式 只在发布阶段会报一个黄色警告，开发阶段不会</span></span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们可以去 <a href="https://eslint.nodejs.cn/">官网</a> 的开发文档的规则参考部分来查看这些规则的作用：<br>  no-console 禁止使用console，no-debugger 禁止使用debugger</p>
</li>
</ul>
<h3 id="ESLint-规则"><a href="#ESLint-规则" class="headerlink" title="ESLint 规则"></a>ESLint 规则</h3><p>不符合规则会报对应的错误，以及错误所在的行列数<br>具体报错规则可以去 <a href="https://nodejs.cn/eslint/">ESLint 中文文档</a> 直接搜索</p>
<ol>
<li>不能出现连续的空行</li>
<li>在文件的末尾必须要有空行</li>
<li>不能有多余的空格</li>
<li>字符串要用单引号</li>
<li>对象和属性之间，需要有一个空格分隔</li>
<li>要求或禁止末尾逗号</li>
<li>在注释中的 <code>//</code> 或 <code>/*</code> 后强制使用一致的间距<blockquote>
<p>&#x2F;&#x2F; 这里是正确注释，<code>//</code>后最少要有一个空格</p>
</blockquote>
</li>
<li>强制一致的缩进（该缩进的要缩进，不该缩进的不能缩进）</li>
<li><code>import</code>导入模块的语句必须声明在文件的顶部</li>
<li>定义变量而没有使用会报错</li>
<li>方法的形参之前需要保留一个空格<blockquote>
<p>show () {} 括号前后都要有一个空格</p>
</blockquote>
</li>
</ol>
<h3 id="禁用某规则"><a href="#禁用某规则" class="headerlink" title="禁用某规则"></a>禁用某规则</h3><p>如果不想遵守某个规则，和ESLint反着来，可以禁止这个规则<br>在官方文档中，找到这个规则，会说明如何更改，直接复制想要更改的规则呢么的代码即可<br>配置如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="comment">// 在方法的形参 () 之前，是否必须有空格</span></span><br><span class="line">    <span class="comment">// always代表需要这个空格，不满足这个规则会报一个warn警告</span></span><br><span class="line">    <span class="string">&quot;space-before-function-paren&quot;</span>: [<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：只要修改了配置文件，都需要重启服务器</p>
<h3 id="配置VSCode"><a href="#配置VSCode" class="headerlink" title="配置VSCode"></a>配置VSCode</h3><p>我们不能保证写的代码完全符合ESLint的要求，所以可以装一些插件，在保存文件的时候自动对文件进行格式化。</p>
<ul>
<li><p>ESLint插件<br>装过之后需要再配置文件中加一下配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 -- settingsjson</span></span><br><span class="line"><span class="comment">// ESLint 插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 老师是这样的</span></span><br><span class="line">    <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 搜的一个是这样</span></span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prettier - Code formatter 插件<br>在<code>C:\Users\lenovo</code>目录下新建<code>.prettierrc</code>配置文件<br>填入 <code>&#123;&quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;printWidth&quot;: 300, &quot;bracketSpacing&quot;: true&#125;</code><br>然后在vscode设置 – settings.json里面添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\lenovo\\.prettierrc&quot;</span>,</span><br><span class="line"><span class="string">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"><span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 每行文字个数超过此限制将会被迫换行</span></span><br><span class="line"><span class="string">&quot;prettier.printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line"><span class="comment">// 使用单引号替换双引号</span></span><br><span class="line"><span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line"><span class="comment">// 设置vue文件中，HTML代码的格式化插件</span></span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line"><span class="string">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;printWidth&quot;</span>: <span class="number">300</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ESLint 插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：</p>
<ol>
<li>开发哪个项目，就用vscode直接打开该项目目录(保证两个插件能够正常生效)</li>
<li>在vue文件 – ctrl + s 能够格式化文件<blockquote>
<p>前提：在.vue文件右键 – 选择“使用..格式化文档&#x2F;格式化文档的方式” – 点击 配置默认格式化程序，点击 Prettier 将其设置为默认值<br>问题：设置默认格式后保存出现逗号的，在setting.json文件中 通过ctrl+f 搜索找到editor.formatOnSave，将其注释就可以解决这个问题</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a><font color="red">项目初始化</font></h3><p>每次新建项目，如果开启了ESLint，一定要进行下面配置，便于我们开发：</p>
<ol>
<li>配置默认格式化程序为prettier<br> 在项目中，任意某文件中 右键 – 使用…格式化文档 – 配置默认格式化程序 – prettier</li>
<li>ESLint配置文件添加配置以下两条规则： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 方法名 和 括号 之间不强制加空格</span></span><br><span class="line">    <span class="comment">// 注意这里none不是正确的值，应该是never！！！</span></span><br><span class="line">    <span class="string">&#x27;space-before-function-paren&#x27;</span>: [<span class="string">&#x27;warn&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="comment">// 组件名可以使用单个单词</span></span><br><span class="line">    <span class="string">&#x27;vue/multi-word-component-names&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于不符合ESLint格式的显示标记问题</strong>，如果我们添加的规则，值的格式错误，或者输入的是没有的值，会不起作用。如none就不是正确的值。</p>
</blockquote>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="自定义事件使用-event"><a href="#自定义事件使用-event" class="headerlink" title="自定义事件使用$event"></a>自定义事件使用$event</h3><p>内置变量<code>$event</code>，是在我们需要向绑定事件传递参数时候，用来接收事件对象e使用的<br><code>@click=&quot;add(1,$event)&quot; --- add(n,e)&#123;&#125;</code></p>
<p><font color="green">只要自定义事件里面接收到的值被覆盖了，就可以考虑使用<code>$event</code></font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Count</span> @num-change=<span class="string">&quot;getNewNum(item,$event)&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自定义事件</span></span><br><span class="line"><span class="title function_">getNewNum</span>(<span class="params">item,val</span>)&#123; </span><br><span class="line">    item.<span class="property">goods_count</span> = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于main-js中的小提示"><a href="#关于main-js中的小提示" class="headerlink" title="关于main.js中的小提示"></a>关于main.js中的小提示</h3><p>main.js的第四行：<br><code>Vue.config.productionTip = false</code><br>默认是false，改为true会在终端给出一个温馨提示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br><span class="line">See more tips at https://vuejs.org/guide/deployment.html</span><br></pre></td></tr></table></figure>
<p>把这句代码删了就相当于是true</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>动态组件</tag>
        <tag>插槽</tag>
        <tag>自定义指令</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>路由(vue-router)</title>
    <url>/tsukimiya.github.io/2024/05/02/Vue2/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>目标:<br>能够在项目中安装和配置路由：<code>createRouter</code>、<code>app.use(router)</code><br>能够使用路由实现单页面应用程序的开发<br>能够使用嵌套路由：通过<code>children</code>属性进行路由嵌套<br>能够实现动态路由匹配：使用冒号声明参数项、<code>this.$route.params</code>、<code>props: true</code><br>能够使用编程式导航：<code>this.$router.push</code>、<code>this.$router.go</code><br>能够使用导航守卫控制路由的访问权限：<br><code>路由实例.beforeEach((to, from, next) =&gt; &#123; /* 必须调 next 函数*/ &#125;)</code></p>
</blockquote>
<h2 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用"></a>axios的使用</h2><ol>
<li><p>首先安装axios包<br><code>npm i axios</code> ，结果报错<code>ERR! ERESOLVE could not resolve ERESOLVE could not resolve</code><br>解决办法是在后面加 <code>--legacy-peer-deps</code> 即可<br><code>npm install axios -save --legacy-peer-deps</code><br>报错的原因是由于npm不同版本库之间命令不兼容。</p>
</li>
<li><p>在left组件发送get请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;getInfo&quot;</span>&gt;发起<span class="title class_">Get</span>请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在right组件发送post请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;postInfo&quot;</span>&gt;发起 <span class="title class_">Post</span> 请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">postInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="考虑问题-–-优化"><a href="#考虑问题-–-优化" class="headerlink" title="考虑问题 – 优化"></a>考虑问题 – 优化</h3><ul>
<li><p>问题</p>
<ol>
<li>每个组件中，都可能会有发请求的需求，都需要先导入axios，然后调用这些方法，每次用都很麻烦</li>
<li>每次请求地址都需要写完整地址，但是我们的请求根路径都完全一样。如果将来后端把根路径改了，我们就需要修改每一个组件，不利于后期维护。</li>
</ol>
</li>
<li><p>思考<br>每一个.vue组件都相当于一个vue实例，我们可以理解为：每一个.vue组件都是new Vue()这个构造函数得到的</p>
</li>
<li><p>优化1 – <strong>在Vue的原型链上挂载一个axios</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 一般我们不叫axios，而是$http</span></span><br><span class="line"><span class="comment">// 因为vue内置的一些成员都是以$开头的(模仿内置成员)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span> = axios</span><br></pre></td></tr></table></figure>
<p>这样我们<strong>在每一个组件中</strong>，就不需要再导入axios，<strong>直接通过this&#x2F;原型访问</strong></p>
</li>
<li><p>优化2 – <strong>全局配置 axios 的请求根路径</strong><br>在往原型上挂之前，通过axios做一下局域的配置：<br><code>axios.defaults.baseURL = &#39;请求根路径&#39; // axios自带的属性</code><br>组件使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点<br><strong>无法实现api接口的复用</strong>：如果这个api在多个页面都需要被用到，每一次都需要重新调这个api接口</p>
</li>
</ul>
<h3 id="axios最优使用-–-实现api接口的复用"><a href="#axios最优使用-–-实现api接口的复用" class="headerlink" title="axios最优使用 – 实现api接口的复用"></a>axios最优使用 – 实现api接口的复用</h3><p>使用axios的最优解 —— <strong>封装！</strong>（也就是模块化）</p>
<blockquote>
<p>将axios接口作为可导入的工具包进行封装</p>
</blockquote>
<p><font color="green">推荐：将其放在utils文件夹下(工具类的意思)</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils/request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// 指定请求根路径</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://applet-base-api-t.itheima.net&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request</span><br></pre></td></tr></table></figure>

<p>需要几个服务器的接口，就封装几个，用哪个就导入哪个。如：request1封装TB的接口，2封装JD的接口</p>
<h3 id="进一步的封装-模块化"><a href="#进一步的封装-模块化" class="headerlink" title="进一步的封装&#x2F;模块化"></a>进一步的封装&#x2F;模块化</h3><p>如果有多个组件，都要调用request的articles接口，那么每个组件都要这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span>,  <span class="comment">// 页码值</span></span><br><span class="line">      <span class="attr">limit</span>: <span class="number">10</span> <span class="comment">// 每页显示多少条数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initArticleList</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 封装获取文章列表数据的方法</span></span><br><span class="line">    <span class="keyword">async</span> initArticleList () &#123;</span><br><span class="line">      <span class="comment">// 发起get请求，获取文章的列表数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/articles&#x27;</span>, &#123;</span><br><span class="line">         <span class="comment">// 请求参数，一般会把参数值定义在data结点，在这里传进去</span></span><br><span class="line">         <span class="comment">// 具体是否需要传参，是什么参数取决于后端API</span></span><br><span class="line">        <span class="attr">params</span>: &#123; <span class="attr">_page</span>: page, <span class="attr">_limit</span>: limit &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await后面返回的是一个Promise类型的值，所以我们可以把这一块单独拿出去<br>可以将其<strong>进一步的封装</strong><br>所有的API调用都可以放进 API 文件夹<br>封装的API文件都以API的命名结尾，可以一眼看出这是个API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// API/articleAPI.js</span></span><br><span class="line"><span class="comment">// 文章相关的API接口，都封装到这个模块中</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不是默认导出，是按需导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getArticleListAPI = <span class="keyword">function</span> (<span class="params">_page, _limit</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> request.<span class="title function_">get</span>(<span class="string">&#x27;/articles&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; _page, _limit &#125; <span class="comment">// 请求参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后每个组件都可以这样调用接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getArticleListAPI &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/articleAPI&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span>,  <span class="comment">// 页码值</span></span><br><span class="line">      <span class="attr">limit</span>: <span class="number">10</span> <span class="comment">// 每页显示多少条数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initArticleList</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 封装获取文章列表数据的方法</span></span><br><span class="line">    <span class="keyword">async</span> initArticleList () &#123;</span><br><span class="line">      <span class="comment">// 发起get请求，获取文章的列表数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="title function_">getArticleListAPI</span>(<span class="variable language_">this</span>.<span class="property">page</span>, <span class="variable language_">this</span>.<span class="property">limit</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">这样才达到了axios真正的用法</font></p>
<h2 id="路由的基本配置与使用"><a href="#路由的基本配置与使用" class="headerlink" title="路由的基本配置与使用"></a>路由的基本配置与使用</h2><ol>
<li><p>什么是路由<br>路由(router) 就是 <strong>对应关系</strong></p>
</li>
<li><p>SPA(单页面应用程序) 与 前端路由<br>SPA指的是一个web网站只有唯一的一个HTML页面，<strong>所有组件的展示与切换</strong>都在这唯一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</li>
<li><p>什么是前端路由<br>通俗易懂的概念：<strong>Hash地址</strong>(就是#锚链接) 与 <strong>组件</strong> 之间的 <strong>对应关系</strong><br>不同的哈希，会展示出不同的组件页面</p>
</li>
<li><p><strong>前端路由的工作方式</strong></p>
<ol>
<li>用户点击了页面上的路由链接</li>
<li>导致了URL地址栏中的Hash值发生了变化</li>
<li>前端路由监听了到Hash地址的变化</li>
<li>前端路由把当前Hash地址对应的组件渲染都浏览器中</li>
</ol>
<p> <font color="green">结论：前端路由，指的是 Hash地址 与 组件之间 的 对应关系</font><br> <img src="/tsukimiya.github.io/images/vue/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.png" alt="image"></p>
</li>
</ol>
<h3 id="vue-router的基本使用"><a href="#vue-router的基本使用" class="headerlink" title="vue-router的基本使用"></a>vue-router的基本使用</h3><blockquote>
<p>前端路由的底层原理是监听了浏览器的onhashchange事件，自己去封装前端路由是非常麻烦的一件事，我们可以用现成的包去实现前端路由的处理 – vue-router(vue项目中的一个路由的包，只能在vue项目中用)</p>
</blockquote>
<ol>
<li><p>什么是vue-router<br><strong>vue-router</strong>是vue.js官方给出的<strong>路由解决方案</strong>。它只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换。<br>vue-router 的官方文档地址: <a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p>
</li>
<li><p><strong>vue-router 安装和配置的步骤</strong></p>
<ol>
<li><p>安装vue-router包：<code>npm i vue-router@3.5.2 -S</code><br>   如果因为ESLint安装报错，可以加上后缀：<code>npm i vue-router@3.5.2 -S --legacy-peer-deps</code><br>   vue-router最新版本Vue Router 4 是为 Vue 3 设计的，不兼容Vue2。<br>   所以想在 Vue 2 中使用 Vue Router，安装包的时候需要指定 Vue Router 3 的版本</p>
</li>
<li><p>创建路由模块<br>   在src源代码目录下，新建router&#x2F;index.js路由模块，并初始化如下代码：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js 就是当前项目的路由模块</span></span><br><span class="line"><span class="comment">// 1. 导入 Vue 和 VueRouter 的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外共享路由的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入并挂载路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由模块，目的：拿到路由的实例对象</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="comment">// 在 Vue 项目中，要想把路由用起来，必须把路由实例对象，通过下面的方式进行挂载</span></span><br><span class="line">  <span class="comment">// router：路由的实例对象</span></span><br><span class="line">  router <span class="comment">// 这里是简写</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 导入路由的时候，index.js可以省略 – <code>import router from &#39;@/router&#39;</code><br> <font color="green">在模块化导入的时候，如果只给了一层路径，默认会导入和加载路径下面名字叫index.js的文件</font></p>
</li>
<li><p>声明路由链接和占位符&#x2F;<strong>声明路由的对应关系(路由规则)</strong><br> 声明占位符：<br> <font color="red">App.vue甚至不需要导入组件，只需要声明一个占位符即可，通过a链接切换对应的组件</font></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/left&quot;</span>&gt;</span>left <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/right&quot;</span>&gt;</span> right<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只要在项目中安装和配置了 vue-router，则就可以使用 router-view 这个组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用：占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在路由模块声明路由的对应关系 – <strong>路由规则</strong>：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Left</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Left-item.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Right</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Right-item.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用router-link代替a链接<br>   router-link本质上也会被渲染成a链接</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当安装和配置了 vue-router 后，就可以使用 router-link来替代普通的a链接 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 优势：不用写前面的#，它会在点这个router-link的时候自动在前面加上# --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="路由重定向-–-redirect"><a href="#路由重定向-–-redirect" class="headerlink" title="路由重定向 – redirect"></a>路由重定向 – redirect</h2><p><strong>路由重定向</strong>指的是:用户在访问<strong>地址A</strong>的时候，<strong>强制用户跳转</strong>到地址C，从而展示特定的组件页面。通过路由规则的<strong>redirect</strong>属性，指定一个新的路由地址，可以很方便地设置路由的重定向:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 在routers数组中，声明路由的匹配规则</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span>&#125;, </span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>通过路由实现<strong>组件的嵌套展示</strong>，叫做嵌套路由。</p>
<p>如果某个组件本身就是通过路由的方式呈现出来的，在这个组件里又放一些路由规则，这样就形成了路由嵌套。<br><img src="/tsukimiya.github.io/images/vue/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt="image"></p>
<ul>
<li><p>声明子级路由标签和占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Right.vue</span><br><span class="line"><span class="comment">&lt;!-- 子级路由链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子级路由占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明嵌套路由的规则 – 路由对应关系</strong><br>通过<strong>Children</strong>属性声明<strong>子路由规则</strong><br>在src&#x2F;router&#x2F;index.js路由模块中，导入需要的组件，并通过children属性声明子路由规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tab1</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab2</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">      <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：子路由规则，不要以斜线开头！</font></p>
</li>
<li><p>嵌套路由的路由重定向<br>在right的路由规则中加上redirect即可，这样路径&#x2F;right就直接跳转到了&#x2F;right&#x2F;tab2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">  &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/right/tab2&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认子路由</strong><br>除了使用redirect路由重定向，还可以使用默认子路由<br>默认子路由：如果children数组中，某个路由规则的path值为空字符串，则这条路由规则，叫做“默认子路由”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // right页面的路由规则(父级路由规则)</span><br><span class="line">  path: &#x27;/right&#x27;,</span><br><span class="line">  component: Right,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; path: &#x27;&#x27;, component: Tab1 &#125;,</span><br><span class="line">    &#123; path: &#x27;tab1&#x27;, component: Tab1 &#125;,//也可以不写这条规则，而是把tab1的路由标签改为/right</span><br><span class="line">    &#123; path: &#x27;tab2&#x27;, component: Tab2 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认子路由和重定向都可以展示出children里面的某一个子组件。</strong></p>
</li>
</ul>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>思考：有如下3个路由链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义如下3个路由规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/3&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：路由规则的复用性差</strong></p>
<ol>
<li><p>动态路由的概念<br>动态路由指的是:把 Hash地址 中<strong>可变的部分</strong>定义为<strong>参数项</strong>，从而<strong>提高路由规则的复用性</strong>。<br>在vue-router中使用<strong>英文的冒号</strong>( <strong>:</strong> )来定义路由的参数项。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由中的动态参数以︰进行声明，冒号后面的是动态参数的名称</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>将多个路由规则，合并成了一个，提高了路由规则的复用性</strong><br><font color="red">注意：路由链接的跳转地址是不能出现冒号<code>:</code>的！<code>&lt;router-link to=&quot;/movie/1&quot;&gt;电影1&lt;/router-link&gt;</code></font></p>
</li>
<li><p>在组件中拿到动态参数项的值<br>  <code>this.$route</code>是路由的<strong>“参数对象”</strong><br>  <code>this.$router</code>是路由的<strong>“导航对象”</strong><br>  要想拿到上面movie的id值应该通过：<code>this.$route.params.id</code></p>
</li>
</ol>
<h3 id="为路由规则开启prop传参"><a href="#为路由规则开启prop传参" class="headerlink" title="为路由规则开启prop传参"></a>为路由规则开启prop传参</h3><p>简化拿参数的方式。这种方式和<code>this.$route.params.id</code>是彼此独立的，想用哪个就用哪个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="comment">// 为当前这条路由规则开启props传参</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// movie.vue</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>] <span class="comment">// 这样就拿到了</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展-query-和-fullPath"><a href="#拓展-query-和-fullPath" class="headerlink" title="拓展 query 和 fullPath"></a>拓展 query 和 fullPath</h3><ol>
<li><p>在 hash 地址中，&#x2F; 后面的参数项，叫做 “路径参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.params</code> 来访问路径参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 hash 地址中，？后面的参数项，叫做 “查询参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.query</code> 来访问查询参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2?name=zs age=20&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>this.$route</code>中，path只是路径部分; fullPath是完整的地址<br>  <code>/movie/2</code> 是 path 的值<br>  <code>/movie/2?name=zs age=20</code> 是 fullPath 的值</p>
</li>
</ol>
<h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>导航就是跳转的意思，组件之间的切换，它专业的术语叫导航。</p>
<h3 id="声明式导航-编程式导航"><a href="#声明式导航-编程式导航" class="headerlink" title="声明式导航 &amp; 编程式导航"></a>声明式导航 &amp; 编程式导航</h3><ul>
<li><p>在浏览器中，<strong>点击链接</strong>实现导航的方式，叫做<strong>声明式导航</strong>。<br>例如：<br>普通网页中点击a链接、vue 项目中点击router-link都属于声明式导航</p>
</li>
<li><p>在浏览器中，<strong>调用API方法</strong>实现导航的方式，叫做<strong>编程式导航</strong>。<br>例如<br>普通网页中调用<code>location.href</code>跳转到新页面的方式，属于编程式导航</p>
</li>
</ul>
<h4 id="vue-router-中的编程式导航API"><a href="#vue-router-中的编程式导航API" class="headerlink" title="vue-router 中的编程式导航API"></a>vue-router 中的编程式导航API</h4><p>vue-router(导航对象)提供了许多编程式导航的API，其中最常用的导航API分别是:</p>
<ol>
<li><p><code>this.$router.push(&#39;hash地址&#39;)</code><br>  跳转到指定 hash 地址，并<strong>增加</strong>一条历史记录</p>
</li>
<li><p><code>this.$router.replace(&#39;hash地址&#39;)</code><br>  跳转到指定的hash地址，并<strong>替换掉当前的</strong>历史记录</p>
</li>
<li><p><code>this.$router.go(数值n)</code><br>  n可以是正数也可以是负数，在浏览历史里面进行<strong>前进和后退</strong></p>
</li>
<li><p><code>$router.go</code>的简化用法<br>在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法:<br>  (1) <code>$router.back()</code>：在历史记录中，<strong>后退</strong>到上一个页面<br>  (2) <code>$router.forward()</code>：在历史记录中，<strong>前进</strong>到下一个页面</p>
</li>
</ol>
<p><font color="red">注意：在行内使用编程式导航跳转的时候，this必须要省略，否则会报错！</font></p>
<h3 id="路由导航守卫-–-控制路由的访问权限"><a href="#路由导航守卫-–-控制路由的访问权限" class="headerlink" title="路由导航守卫 – 控制路由的访问权限"></a>路由导航守卫 – 控制路由的访问权限</h3><p><strong>导航守卫</strong>可以<strong>控制路由的访问权限</strong>。</p>
<p>假设规定，当前项目中，main这个后台主页只有登陆以后才允许被访问(前提)<br>怎么证明你有没有登陆————token<br>可以读你的localStorage，看里面有没有token值，如果有就认为你已经是登录了，没有就认为你没有登陆。</p>
<p><img src="/tsukimiya.github.io/images/vue/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB.png" alt="image"></p>
<ol>
<li><p>全局前置守卫<br>  前置：比如从a跳到b，还没跳过去，就会触发守卫。<br>  每次发生路由的<strong>导航跳转</strong>时，都会触发<strong>全局前置守卫</strong>。因此，在全局前置守卫中，程序员可以<strong>对每个路由进行访问权限的控制</strong>:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"><span class="comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫”</span></span><br><span class="line"><span class="comment">//每次发生路由导航跳转的时候，都会自动触发 fn 这个“回调函数”</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(fn)</span><br></pre></td></tr></table></figure>
</li>
<li><p>守卫方法的3个形参<br>  全局前置守卫的回调函数中接收3个形参，格式为:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局前置守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ro 是将要访问的路由的信息对象</span></span><br><span class="line">  <span class="comment">// from 是将要离开的路由的信息对象</span></span><br><span class="line">  <span class="comment">// next 是一个函数，调用next() 表示放行，允许这次路由导航</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>next函数的3种调用方式<br>具体使用哪一种，看自己的需求<br><img src="/tsukimiya.github.io/images/vue/next%E5%87%BD%E6%95%B0%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="image"></p>
</li>
</ol>
<ul>
<li>全局前置守卫控制访问权限简单示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为router实例对象，声明全局前置导航守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 分析：</span></span><br><span class="line">  <span class="comment">// 1. 要拿到用户将要访问的hash地址 </span></span><br><span class="line">  <span class="comment">// 2. 判断hash地址是否等于/main</span></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; <span class="comment">// 等于 /main ，证明需要登陆之后才能访问成功，</span></span><br><span class="line">    <span class="comment">// 需要读取 localStorage 中的 token值</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() <span class="comment">// 有token值，则已登录 放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 无 token值 则强制跳转到login登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不等于则访问的不是后台主页,不需要登陆 直接放行 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
vue的导航守卫中除了全局前置守卫之外，还有全局解析守卫、全局后置钩子、路由独享的守卫、组件内的守卫，共5种<br>其中，<strong>全局前置守卫的用法是最常见的</strong>，后面的几种后续会进行补充</li>
</ul>
<h2 id="案例练习"><a href="#案例练习" class="headerlink" title="案例练习"></a>案例练习</h2><ul>
<li><p><a href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=87.0&p=193">路由应用案例</a></p>
<blockquote>
<p>后台管理案例</p>
</blockquote>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=204">黑马头条</a></p>
<blockquote>
<p>SPA单页面应用程序 移动端 简单案例<br>  实现下拉刷新、上拉加载更多功能、Vant组件库的使用</p>
</blockquote>
<p>  配置：Babel、Router、CSS Pre-processors、Linter &#x2F; Formatter、Vue 2.x<br>  选择路由模式 – Use history mode for router？ – N</p>
<blockquote>
<p>history mode for router 需要和后端配合使用，兼容性比较差<br>#开头的hash值所表示的路由，通用性更强，低级还是高级的浏览器都支持</p>
</blockquote>
<p>  css预处理器 – less<br>  ESLint – Standard config 标准配置<br>  Lint on save 在保存的时候进行格式的检查</p>
<p>  项目结构：<br>  views文件夹</p>
<blockquote>
<p>如果某个组件，是通过路由进行动态展示和切换的，这种组件要放到views里面<br>  如果某个组件不是通过路由切换的，是一个可复用的组件，那么这个组件要放到components里面</p>
</blockquote>
</li>
</ul>
<h3 id="Vant组件库"><a href="#Vant组件库" class="headerlink" title="Vant组件库"></a>Vant组件库</h3><p>轻量、可靠的移动端组件库<br><a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">Vant2官方文档</a>(适用于 Vue2 开发) <a href="https://vant-ui.github.io/vant/#/zh-CN/">Vant4官方文档</a>(适用于 Vue3 开发)</p>
<ol>
<li><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Vue 3 项目，安装最新版 Vant：</span><br><span class="line">npm i vant -S</span><br><span class="line"></span><br><span class="line"># Vue 2 项目，安装 Vant 2：</span><br><span class="line">npm i vant@latest-v2 -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入组件<br>我们选择最便捷的方式 – 导入所有组件</p>
<blockquote>
<p>虽然官方推荐的做法是：自动按需引入组件。但是配起来太复杂了，成本太高了<br>引入所有组件会增加代码包体积，但是开发的时候我们怎么快怎么来，不用考虑体积的问题<br>在发布的时候，我们可以进行项目体积的优化，可以直接把Vant从项目里面抽出去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vant</span> <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vant</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br>查阅官方文档即可<br><a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">Vant2官方文档</a>(适用于 Vue2 开发)<br><a href="https://vant-ui.github.io/vant/#/zh-CN/">Vant4官方文档</a>(适用于 Vue3 开发)<br><font color="red">注意：在使用Vant组件的时候，如果某个组件的某个属性默认值是false，希望把它改成true，直接把这个属性写上就可以了</font><br>如：<code>&lt;van-nav-bar title=&quot;标题&quot; fixed placeholder /&gt;</code><br>相当于<code>&lt;van-nav-bar title=&quot;标题&quot; :fixed=&#39;ture&#39; :placeholder=&#39;true&#39; /&gt;</code><br>这里给属性值类型是布尔值，所以要用v-bind绑定，否则是字符串</p>
</li>
<li><p><strong>覆盖Vant组件的样式</strong>： <a href="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F#deep-%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F"><strong>&#x2F;deep&#x2F; 样式穿透</strong></a></p>
<p> 还可以通过Vant组件库提供的定制主题，来直接改变组件的样式，这样在每个组件使用该组件都不需要再去修改。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main.js中 引入全部样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="comment">// 这个文件是 vue-cli 创建出来的项目的配置文件</span></span><br><span class="line"><span class="comment">// 在vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">          <span class="attr">modifyVars</span>: &#123;</span><br><span class="line">            <span class="comment">// 直接覆盖变量</span></span><br><span class="line">            <span class="comment">// 这里是覆盖了 NavBar 导航栏 的背景色</span></span><br><span class="line">            <span class="string">&#x27;nav-bar-background-color&#x27;</span>: <span class="string">&#x27;red&#x27;</span> <span class="comment">// #007bff</span></span><br><span class="line">            <span class="comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            <span class="comment">// hack: `true; @import &quot;your-less-file-path.less&quot;;`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 缺点：需要修改配置文件，必须重启打包服务器，太过麻烦，所以了解即可，实际开发不会这么使用<br> 而是通过 less 文件覆盖进行主题的定制：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">hack</span>: <span class="string">`true; @import &quot;your-less-file-path.less&quot;;`</span></span><br></pre></td></tr></table></figure>
<p> <strong>好处：不用重启打包服务器，直接改就能生效</strong></p>
</li>
</ol>
<h3 id="通过less文件覆盖进行主题定制"><a href="#通过less文件覆盖进行主题定制" class="headerlink" title="通过less文件覆盖进行主题定制"></a>通过less文件覆盖进行主题定制</h3><p>如：在src目录下新建一个theme.less</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在theme.less文件中，覆盖Vant官方的less变量值</span></span><br><span class="line"><span class="variable">@blue:</span> <span class="number">#007bff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖 Navbar 的 less 样式</span></span><br><span class="line"><span class="variable">@nav-bar-background-color:</span> <span class="variable">@blue</span>;</span><br></pre></td></tr></table></figure>
<p>然后配置vue.config.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个文件是 vue-cli 创建出来的项目的配置文件</span></span><br><span class="line"><span class="comment">// 在vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack在进行打包的时候，底层用到了node .js</span></span><br><span class="line"><span class="comment">// 因此，在vue.config.js 配置文件中，可以导入并使用node.js中的核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> themePath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;/src/theme.less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。</span></span><br><span class="line">        <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">          <span class="attr">modifyVars</span>: &#123;</span><br><span class="line">            <span class="comment">// 通过 less 文件覆盖（文件路径为绝对路径）</span></span><br><span class="line">            <span class="attr">hack</span>: <span class="string">`true; @import &quot;<span class="subst">$&#123;themePath&#125;</span>&quot;;`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h2><p>这个文件是 vue-cli 创建出来的项目的配置文件<br>在这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</p>
<p>项目开发完成之后，可以npm run build进行打包<br>最终项目里面会有个dist文件夹，里面有个index.html首页</p>
<p>但是有个问题：我们直接进入dist目录，双击这个首页打开，是看不到效果的。<br>因为：默认情况下，我们运行npm run build打包生成的dist，里面的这些文件，只能发布到服务器上，通过http协议才可以正常被打开。而双击打开的是file协议，所以看不到效果</p>
<p>如果想要看到效果，需要做一下打包发布的配置：<a href="https://cli.vuejs.org/zh/config/#publicpath">vue.config.js-publicPath</a><br>在vue.config.js配置文件中设置publicPath为’.&#x2F;‘，再次打包文件，即可在文件夹中双击打开</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">  <span class="attr">css</span>: &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>publicPath</strong><br>部署应用包时的基本 URL。<br>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <a href="https://www.my-app.com/">https://www.my-app.com/</a><br><strong>如果应用被部署在一个子路径上</strong>，你就需要<strong>用这个选项指定这个子路径</strong>。例如，如果你的应用被部署在 <a href="https://www.my-app.com/my-app/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AE">https://www.my-app.com/my-app/，则设置</a> publicPath 为 &#x2F;my-app&#x2F; 。</p>
<p>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘.&#x2F;‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p>
<p>相对路径的 publicPath 有一些使用上的限制。在以下情况下，应当避免使用相对 publicPath:</p>
<ul>
<li>当使用基于 HTML5 history.pushState 的路由时；</li>
<li>当使用 pages 选项构建多页面应用时。</li>
</ul>
</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="hash地址注意点"><a href="#hash地址注意点" class="headerlink" title="hash地址注意点"></a>hash地址注意点</h3><p>hash地址里面字母都要是小写，<font color="red">url地址里面不要出现大写字符或字母</font>。<br>除非是一些 搜索关键字 可以出现大写</p>
<h3 id="有权限的hash地址"><a href="#有权限的hash地址" class="headerlink" title="有权限的hash地址"></a>有权限的hash地址</h3><p>在导航守卫 – 全局前置守卫中<br>这个if是判断我们访问的是否是一个有权限的hash地址：<code>if (to.path === &#39;/main&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们项目中有多个页面，都需要访问权限，这一个判断肯定满足不了我们的需求<br>我们可以在后面加 或 <code>|</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home/users&#x27;</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是条件会变的越来越长</p>
<p>我们还可以通过数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pathArr = [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> (pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>后面有任何的地址，都可以放到数组里面去<br>如果觉得多了以后，数组也会变的特别长，可以把这个数组单独处理为js文件，需要的时候再导入过来。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/pathArr.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="keyword">import</span> pathArr <span class="keyword">from</span> <span class="string">&#x27;@/router/pathArr.js&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//不需再声明</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>)!=-<span class="number">1</span>)&#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用meta属性进行权限处理"><a href="#使用meta属性进行权限处理" class="headerlink" title="使用meta属性进行权限处理"></a><font color="green">使用meta属性进行权限处理</font></h3><p><font color="red">可以配置meta属性，使用前置守卫进行判断是否需要进行权限处理，会方便很多</font></p>
<ol>
<li><p>配置 <code>meta</code> 属性<br>  在路由配置中，可以在每个路由的 <code>meta</code> 属性中指定需要进行权限处理的信息。例如:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Admin</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">requiresAuth</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] <span class="comment">// 用于指定可以访问特定路由的用户的角色</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他路由...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>/admin</code> 路由需要进行权限处理，只有具有 <code>admin</code> 角色的用户才能访问。</p>
</li>
<li><p>使用前置守卫<br>  在 Vue Router 中，使用 <code>beforeEach</code> 前置守卫来拦截导航并执行权限检查：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span>) &#123;<span class="comment">// 检查是否需要进行权限处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isAuthenticated</span>()) &#123;<span class="comment">// 检查用户是否已登录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasRequiredRoles</span>(to.<span class="property">meta</span>.<span class="property">roles</span>))&#123; <span class="comment">// 检查用户是否具有所需的权限</span></span><br><span class="line">          <span class="title function_">next</span>()<span class="comment">// 允许导航</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">&#x27;/no-access&#x27;</span>) <span class="comment">// 无权限，重定向到无权限页面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)<span class="comment">// 未登录，重定向到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不需要权限处理，允许导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  其中，isAuthenticated() 和 hasRequiredRoles() 是自定义函数，用于检查用户是否已登录以及是否具有所需的权限。</p>
</li>
</ol>
<ul>
<li><p><strong>isAuthenticated()函数 ：用于检查用户是否已登录</strong><br><strong>通常用于判断用户是否携带有效的 token</strong>。<br>实际应用中，可以根据自己的后端 API 设计来实现 isAuthenticated() 函数：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的 token。</li>
<li>向后端 API 发送一个请求，携带用户的 token。</li>
<li>后端 API 验证 token 的有效性。</li>
<li>如果 token 有效，后端 API 返回成功响应。</li>
<li>isAuthenticated() 函数返回 true，表示用户已登录。</li>
<li>否则，isAuthenticated() 函数返回 false，表示用户未登录或 token 无效。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isAuthenticated</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取 token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;<span class="comment">// 如果 token 存在，向后端 API 发送请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/verify-token&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;  <span class="comment">// &#x27;data&#x27; 是一个 JavaScript 对象，包含从服务器接收到的 JSON 数据</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果 token 有效，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 无效，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 不存在，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>.then(res =&gt; res.json())</code> 是 JavaScript Promise 链中的一个回调函数。<br>作用: 将服务器返回的 HTTP 响应对象 (res)————服务器响应的主体部分（JSON 字符串） 转换为一个纯 JavaScript 对象，并将其传递给下一个 .then() 回调函数。<br>注意：<br>只有当服务器响应的 Content-Type 头部设置为 <code>application/json</code> 时，<code>res.json()</code> 方法才能正常工作。<br>如果服务器响应的主体部分不是有效的 JSON 字符串，<code>res.json()</code> 方法会抛出一个错误。</li>
</ol>
</li>
<li><p><strong>hasRequiredRoles() 函数用于检查用户是否具有访问特定路由所需的权限。</strong><br>它的实现方式取决于你的具体应用程序和后端 API 设计。<br>一种常见的方法：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的角色。</li>
<li>将用户的角色与路由配置中指定的所需角色进行比较。</li>
<li>如果用户具有所有必需的角色，则返回 true，表示用户具有访问权限。</li>
<li>否则，返回 false，表示用户没有访问权限。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userRoles = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;roles&#x27;</span>)<span class="comment">// 从本地存储中获取用户的角色</span></span><br><span class="line">  <span class="comment">// 将用户的角色与所需的权限进行比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; requiredRoles.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!userRoles.<span class="title function_">includes</span>(requiredRoles[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果用户具有所有必需的角色，返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>另一种方法：<br>向后端 API 发送一个请求，携带用户的 token 和路由的所需角色。后端 API 检查用户的权限并返回一个响应，指示用户是否具有访问权限。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取用户的 token</span></span><br><span class="line">  <span class="comment">// 向后端 API 发送请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/check-permissions&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">requiredRoles</span>: requiredRoles</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果用户具有访问权限，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果用户没有访问权限，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h3><p><a href="https://less.bootcss.com/">Less</a> 是一种可编程的样式语言。</p>
<p><code>@</code>是在less语法里面，专门定义变量的一种格式<br>支持我们以编程的方式来写CSS代码</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@width:</span> <span class="number">10px</span>;</span><br><span class="line"><span class="variable">@height:</span> <span class="variable">@width</span> + <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Less</tag>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>axios</tag>
        <tag>路由</tag>
        <tag>路由重定向</tag>
        <tag>路由嵌套</tag>
        <tag>动态路由</tag>
        <tag>路由导航</tag>
        <tag>Vant</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的API接口案例</title>
    <url>/tsukimiya.github.io/2024/05/08/Node/API%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="API接口案例"><a href="#API接口案例" class="headerlink" title="API接口案例"></a>API接口案例</h2><p>基于<strong>MySQL数据库 + Express</strong>对外提供<strong>用户列表</strong>的API接口服务</p>
<ol>
<li>技术栈：<ul>
<li>第三方包express、mysql2</li>
<li>ES6模块化</li>
<li>Promise</li>
<li>async&#x2F;await</li>
</ul>
</li>
<li>主要实现步骤<ol>
<li>搭建项目的基本结构</li>
<li>创建基本的服务器</li>
<li>创建db数据库操作模块</li>
<li>创建user_ctrl 业务模块</li>
<li>创建user_router路由模块</li>
</ol>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li><p>初始化包管理配置文件package.json —— <code>npm init -y</code></p>
</li>
<li><p>启用ES6模块化支持</p>
<ul>
<li>在package.json中声明<code>&quot;type&quot;: &quot;module&quot;</code></li>
</ul>
</li>
<li><p>安装第三方依赖包</p>
<ul>
<li>运行<code>npm install express@4.17.1 mysql2@2.2.5</code></li>
</ul>
</li>
<li><p>创建最基本的web服务器</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Express server running at http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>创建db数据库操作模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db/index.js</span></span><br><span class="line"><span class="keyword">import</span> mysql <span class="keyword">from</span> <span class="string">&#x27;mysql2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pool = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// 指定操作哪台电脑</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>, <span class="comment">// 指定端口号，一般mysql数据库的端口号都是3306</span></span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;my_db_01&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;ayu123+&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果导出pool，它不支持以promise API的形式来操作数据库</span></span><br><span class="line"><span class="comment">// 此时我们需要调用pool提供的.promise()，把返回值导出出去</span></span><br><span class="line"><span class="comment">// 外界拿到数据库的连接对象之后，就可以以Promise的方式来操作数据库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pool.<span class="title function_">promise</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>创建user_ctrl 业务模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller/user_ctrl.js</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&#x27;../db/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的按需导出语法，将getALLUser语法导出出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllUser</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">  <span class="comment">// 数组中，索引为0的那一项，是最终需要的数据，所以解构赋值出一个rows</span></span><br><span class="line">  <span class="keyword">const</span> [rows] = <span class="keyword">await</span> db.<span class="title function_">query</span>(<span class="string">&#x27;select id,username,nickname from users&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">messages</span>: <span class="string">&#x27;获取用户列表数据成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: rows,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建user_router路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/user_router.js</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getAllUser &#125; <span class="keyword">from</span> <span class="string">&#x27;../controller/user_ctrl.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, getAllUser)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在app.js注册路由</span></span><br><span class="line"><span class="keyword">import</span> userRouter <span class="keyword">from</span> <span class="string">&#x27;./router/user_router.js&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure></li>
<li><p>使用try…catch捕获异常<br>当报错之后，使用catch进行处理，程序不会发生崩溃</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller/user_ctrl.js</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&#x27;../db/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的按需导出语法，将getALLUser语法导出出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAllUser</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">  <span class="comment">// 数组中，索引为0的那一项，是最终需要的数据，所以解构赋值出一个rows</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [rows] = <span class="keyword">await</span> db.<span class="title function_">query</span>(<span class="string">&#x27;select id,username,nickname,xxx from users&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">messages</span>: <span class="string">&#x27;获取用户列表数据成功！&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: rows,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">messages</span>: <span class="string">&#x27;获取用户数据失败！&#x27;</span>,</span><br><span class="line">      <span class="attr">desc</span>: err.<span class="property">messages</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex - 组件全局状态(数据)管理机制</title>
    <url>/tsukimiya.github.io/2024/05/08/Vue2/8.vuex/</url>
    <content><![CDATA[<blockquote>
<p>总结：<br>组件全局状态(数据)管理机制<strong>Vuex</strong>的安装、<strong>导入及使用</strong>：<br><strong>四大核心概念使用</strong>：<br>    1. <strong>State 存储数据</strong><br>    (1) <code>this.$store.state.全局数据名称</code><br>    (2) <code>import &#123; mapState &#125; from &#39;vuex&#39;</code> —— <code>computed: &#123; ...mapState([&#39;count&#39;]) &#125;</code><br>    2. <strong>Mutation 修改数据</strong>（同步）<br>    (1) <code>this.$store.commit(&#39;addN&#39;, 3) // 触发时，携带参数</code><br>    (2) <code>import &#123; mapMutations &#125; from &#39;vuex&#39;</code> —— <code>methods: &#123; ...mapMutations([&#39;add&#39;,&#39;addN&#39;]) &#125;</code><br>    3. <strong>Action 处理异步逻辑</strong>，并触发 Mutation 以间接更新 State<br>    (1) <code>this.$store.dispatch(&#39;addNAsync&#39;, 3) // 携带参数</code><br>    (2) <code>import &#123; mapActions &#125; from &#39;vuex&#39;</code> —— <code>methods: &#123; ...mapAction([&#39;addAsync&#39;,&#39;addNAsync&#39;]) &#125;</code><br>    4. <strong>Getter 提供数据加工</strong><br>    (1) <code>this.$store.getters.名称</code><br>    (2) <code>import &#123; mapGetters &#125; from &#39;vuex&#39;</code> —— <code>computed: &#123; ...mapGetters([&#39;showNum&#39;]) &#125;</code></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>组件之间共享数据的方式<br> 父向子：porps自定义属性<br> 子向父：自定义事件<code>$.emit</code>、<code>v-on/@</code><br> 兄弟组件之间：EventBus<code>$.emit</code>、<code>$.on</code></p>
<p> 这三种的方式，<strong>只适合在小范围内来进行数据的共享</strong><br> 如果需要频繁的，或者大范围的来实现数据的共享，这三种方案就有些力不从心</p>
</li>
<li><p><strong>Vuex</strong><br><strong>Vuex</strong>是<strong>实现组件全局状态(数据)管理</strong>的一种机制，可以方便的实现组件之间<strong>数据的共享</strong>。<br><img src="/tsukimiya.github.io/images/vue/vuex.png" alt="vuex"><br>Vuex就相当于在这些组件旁边定义了<strong>一个共享的数据状态对象Store</strong></p>
</li>
<li><p>使用Vuex统一管理状态的<strong>好处</strong></p>
<ul>
<li>能够在vuex中<strong>集中管理共享的数据</strong>，易于开发和后期维护   </li>
<li>能够<strong>高效</strong>地实现组件之间的<strong>数据共享</strong>，提高开发效率</li>
<li>存储在vuex中的数据都是响应式的，能够<strong>实时</strong>保持数据与页面的<strong>同步</strong></li>
</ul>
</li>
<li><p>什么样的数据适合存储到Vuex中<br> 一般情况下，<strong>只有组件之间共享的数据</strong>，<strong>才有必要存储到vuex中</strong>;对于组件中的私有数据，依旧存储在组件自身的data中即可。</p>
</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>安装vuex依赖包：<code>npm i vuex -S</code></li>
<li>导入vuex包<br> <code>import Vuex from &#39;vuex&#39;</code><br> <code>Vue.use(Vuex)</code></li>
<li>创建store对象 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// state中存放的就是全局共享的数据</span></span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>将store对象挂载到vue实例中 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(app),</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 将创建的共享数据对象，挂载到Vue实例中</span></span><br><span class="line">  <span class="comment">// 所有的组件，就可以直接从store中获取全局的数据了</span></span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>创建vue项目时，如果添加了vuex的配置，会自动帮我们配置好这些</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Vuex中主要的核心概念如下：</p>
<ul>
<li>State</li>
<li>Mutation</li>
<li>Action</li>
<li>Getter</li>
</ul>
<p>总结来说，<strong>State 存储数据</strong>，<strong>Getter 提供数据加工</strong>，<strong>Mutation 修改数据（同步）</strong>，而 <strong>Action 处理异步逻辑</strong>并触发 Mutation 以间接更新 State。这四者共同构成了 Vuex 的核心机制，帮助开发者更好地管理和维护应用的状态。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State<strong>提供唯一的公共数据源</strong>，所有共享的数据都要统一放到Store的State中进行存储。</p>
<ul>
<li><p><strong>组件访问State中数据</strong>的<strong>方式一</strong>：<strong>直接访问</strong><br><code>this.$store.state.全局数据名称</code>，如<code>this.$store.state.count</code></p>
</li>
<li><p>组件访问State中数据的<strong>方式二</strong>：<strong>使用mapState辅助函数</strong></p>
<ol>
<li>从vuex中按需导入mapState函数<br>  <code>import &#123; mapState &#125; from &#39;vuex&#39;</code></li>
<li>通过mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者使用对象展开语法进行更细致的映射： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">localCount</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>使用方式建议</strong></p>
<ul>
<li>只需要<strong>访问一两个State属性</strong>，且<strong>不频繁</strong>使用 —— <strong>直接访问</strong></li>
<li><strong>访问多个State属性</strong>，或者需要<strong>对State数据</strong>进行一些<strong>转换处理</strong> —— <strong>mapState辅助函数</strong><blockquote>
<p>更加清晰和高效，使代码更模块化，易于阅读和维护。</p>
</blockquote>
</li>
<li>项目<strong>使用了TS</strong> —— <strong>mapState辅助函数</strong><blockquote>
<p>mapState配合类型注解可以提供更好的类型安全性。</p>
</blockquote>
</li>
</ul>
<p>总的来说，选择哪种方式取决于具体场景和个人偏好，但通常<strong>推荐使用mapState</strong>，因为它可以让你的<strong>代码更加整洁、易于维护</strong>，并且在<strong>处理复杂逻辑时更为灵活</strong>。</p>
</li>
</ul>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><blockquote>
<p>在组件中，虽然可以<code>this.$store.state.count = 1</code>直接修改全局的数据，且不报错，<br>但是在Vuex中，它<font color="red"><strong>不允许组件直接去修改Store的数据</strong></font>，而是推荐使用Mutation</p>
</blockquote>
<p>Mutation用于变更Store中的数据。<br>通过这种方式虽然操作稍微繁琐一些，但是<strong>可以集中监控所有数据的变化</strong></p>
<blockquote>
<p>通过<code>this.$store.state.count = 1</code>修改数据，如果想看一下是谁修改的，需要挨个组件去翻，不利于后期维护。<br>通过<code>Mutation</code>里面的函数修改数据，如果发现数据修改有问题，可以直接找对应的Mutation</p>
</blockquote>
<h4 id="定义Mutations"><a href="#定义Mutations" class="headerlink" title="定义Mutations"></a>定义Mutations</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++ <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>传递参数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state, step</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> += step <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="触发方式一"><a href="#触发方式一" class="headerlink" title="触发方式一"></a>触发方式一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">handlel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 注意这里是**小写**store！！！</span></span><br><span class="line">    <span class="comment">// commit的作用，就是调用某个mutation函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>, <span class="number">3</span>) <span class="comment">// 触发时，携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="触发方式二"><a href="#触发方式二" class="headerlink" title="触发方式二"></a>触发方式二</h4><ol>
<li>从Vuex中按需导入 mapMutations 函数：<br><code>import &#123; mapMutations &#125; from &#39;vuex&#39;</code><blockquote>
<p>注意是<strong>小写</strong>的<strong>vuex</strong></p>
</blockquote>
</li>
<li><strong>通过mapMutations函数</strong>，将需要的mutations函数，<strong>映射为当前组件的methods方法</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用</span></span><br><span class="line">&lt;button @click=<span class="string">&quot;add&quot;</span>&gt;count +<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addN(3)&quot;</span>&gt;</span>count +3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> <span class="comment">// 携带参数</span></span><br><span class="line"><span class="comment">// 也可以在方法中调用 -- 推荐</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>]),</span><br><span class="line">  <span class="title function_">btnHandle1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">add</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">btnHandle2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addN</span>(<span class="number">3</span>) <span class="comment">// 携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote>
<p>在Mutations函数中，不能写异步的代码(setTimeout、setIterval等)，虽然页面效果没有问题，但是数据没有传到state，会导致在devtools提交更新后，页面的数据又恢复原来的了</p>
</blockquote>
<p><strong>Action 用于处理异步任务</strong><br>但是在Action中，还是要通过触发Mutation的方式间接变更数据</p>
<h4 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">// 只有mutations函数中，才有权利修改state中的数据</span></span><br><span class="line">    <span class="comment">// 在actions中，必须通过context.commit()触发某个mutation才行</span></span><br><span class="line">    <span class="title function_">addAsync</span>(<span class="params">context</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>传参</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state, step</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">addNAsync</span>(<span class="params">context,step</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>,step)</span><br><span class="line">      &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="触发Action-方式一"><a href="#触发Action-方式一" class="headerlink" title="触发Action - 方式一"></a>触发Action - 方式一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的dispatch函数，站门用来触发action</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">addN</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addNAsync&#x27;</span>, <span class="number">3</span>) <span class="comment">// 携带参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="触发Action-方式二"><a href="#触发Action-方式二" class="headerlink" title="触发Action - 方式二"></a>触发Action - 方式二</h4><blockquote>
<p>和Mutations一样</p>
</blockquote>
<ol>
<li>从Vuex中按需导入 mapActions 函数：<br><code>import &#123; mapActions &#125; from &#39;vuex&#39;</code><blockquote>
<p>注意是<strong>小写</strong>的vuex</p>
</blockquote>
</li>
<li><strong>通过mapActions函数</strong>，将需要的actions函数，<strong>映射为当前组件的methods方法</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>([<span class="string">&#x27;addAsync&#x27;</span>,<span class="string">&#x27;addNAsync&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter用于对Store中的<strong>数据进行加工处理</strong>形成新的数据。起到一个<strong>包装数据</strong>的作用，<strong>类似计算属性</strong>computed</p>
<ul>
<li>定义Getter<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">showNum</span>: <span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span> + state.<span class="property">count</span> +<span class="string">&#x27;】&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Getters的使用同样<strong>和State一致</strong></p>
<ul>
<li><p>使用Getter方式一<br><code>this.$store.getters.名称</code>如：<code>this.$store.getters.showNum</code></p>
</li>
<li><p>使用Getter方式二 —— mapGetters</p>
<ol>
<li>从vuex中按需导入mapGetters函数<br>  <code>import &#123; mapGetters &#125; from &#39;vuex&#39;</code></li>
<li>通过mapGetters函数，将当前组件需要的getters，映射为当前组件的computed计算属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="关于核心概念的使用方式"><a href="#关于核心概念的使用方式" class="headerlink" title="关于核心概念的使用方式"></a>关于核心概念的使用方式</h2><p>就像state中说到的那样：</p>
<ul>
<li>使用<strong>不频繁</strong> —— <strong>直接访问</strong></li>
<li><strong>访问多次</strong>，或者需要进行<strong>转换处理</strong> —— <strong>mapXXX辅助函数</strong><blockquote>
<p>更加清晰和高效，使代码更模块化，易于阅读和维护。</p>
</blockquote>
</li>
<li>项目<strong>使用了TS</strong> —— <strong>mapXXX辅助函数</strong><blockquote>
<p>mapXXX辅助函数配合类型注解可以提供更好的类型安全性。</p>
</blockquote>
</li>
</ul>
<p>总的来说，选择哪种方式取决于具体场景和个人偏好，但通常<strong>推荐使用mapXXX辅助函数</strong>，因为它可以让你的<strong>代码更加整洁、易于维护</strong>，并且在<strong>处理复杂逻辑时更为灵活</strong>。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue2</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue2</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js简单实现后端服务器</title>
    <url>/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>该示例没有用到数据库，是通过创建POST表单路由进行处理数据，将数据保存到文件中，以及数据校验<br>用到的npm包&#x2F;第三方模块：<br>Express：<code>npm i express@4.17.1</code> – Web 开发框架，快速创建 Web 服务器<br>Joi：<code>npm install joi --save</code> – hapijs 自带的数据校验模块<br>@escook&#x2F;express-joi中间件: <code>npm i @escook/express-joi</code> – 实现自动对表单数据进行验证的功能<br>cors： <code>npm i cors</code> – 配置cors跨域<br>dayjs： <code>npm install dayjs --save</code> – 格式化时间</p>
</blockquote>
<blockquote>
<p>全局安装了nodemon工具，可以监听文件的更改，自动重新执行</p>
</blockquote>
<blockquote>
<p>这个是航空文化馆项目的后端，还没写完<br>没有用到mysql模块：<code>npm i mysql</code><br>也没有用到express-session中间件：<code>npm i express-session</code>（这个干吗用的？）</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0">
<li>如果是拿被别人写好的项目，第一步是导入这个项目所用的包，<code>npm i</code>命令</li>
<li>创建后端项目文件夹如serve</li>
<li>初始化文件夹<code>npm init -y</code><br> 在空项目的根目录中初始化一个package.json的包管理配置文件</li>
<li>安装必要的包&#x2F;依赖<br> 安装Express —— <code>npm i express@4.17.1</code></li>
<li>创建服务器文件，命名如app.js</li>
</ol>
<h2 id="创建简单的web服务器-及其-模块化"><a href="#创建简单的web服务器-及其-模块化" class="headerlink" title="创建简单的web服务器 及其 模块化"></a>创建简单的web服务器 及其 模块化</h2><ol>
<li><p>创建基本的express框架 – eser(vscode快捷生成代码&#x2F;&#x2F;自己配置 – 文件–首选项–配置用户代码片段)</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Express server running at http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)      </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由<br> 可以先在当前文件尝试是否成功，之后再分离到对应模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建express路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// 提交预约表单</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/form&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用postman测试请求是否成功<br> 向 <a href="http://127.0.0.1:8080/form">http://127.0.0.1:8080/form</a> 发送post请求<br> 响应函数中打印出来的req.body结果是undefined，这是因为我们没有配置解析表单的中间件</p>
</li>
<li><p>配置解析表单的中间件<br> &#x2F;&#x2F; 配置解析表单数据的中间件,注意：这个中间件，只能解析applicaton&#x2F;x-www-form-urlencoded格式的表单数据<br> <code>app.use(express.urlencoded(&#123;extended:false&#125;))</code><br> 再次发送请求，我们就得到了表单提交的数据</p>
</li>
<li><p>分离到路由模块<br> 创建router文件夹，创建如user.js文件&#x2F;&#x2F;处理用户路由<br> 将路由部分写到这个地方，然后把router暴露出去<br> <code>module.exports = router</code><br> 然后在app.js中导入并使用路由模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
<li><p>分离处理函数到路由处理模块，同5操作<br> 创建router_handler文件夹，在该目录下创建对应的用户路由处理文件user.js<br> 把处理函数暴露出去</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">formSubmit</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在路由模块导入导入用户路由处理函数对应的模块<br> <code>const user_handler = require(&#39;../router_handler/user&#39;)</code><br> 路由的响应函数换成对应的user_handler.formSubmit</p>
</li>
</ol>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>这里使用joi模块来进行数据验证<br>Joi 是 hapijs 自带的数据校验模块，他已经高度封装常用的校验功能。</p>
<ol>
<li><p>安装joi包，为表单中携带的每个数据项，定义验证规则</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install joi --save</span><br><span class="line"><span class="comment">// ES6写法 import Joi from &#x27;joi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>安装 @escook&#x2F;express-joi 中间件，来实现自动对表单数据进行验证的功能：<br> <code>npm i @escook/express-joi</code></p>
</li>
<li><p>joi验证规则</p>
<ul>
<li>string() 值必须是字符串</li>
<li>number() 值必须是数字</li>
<li>alphanum() 值只能是包含 a-zA-Z0-9 的字符串</li>
<li>min(length) 最小长度</li>
<li>max(length) 最大长度</li>
<li>required() 值是必填项，不能为 undefined</li>
<li>pattern(正则表达式) 值必须符合正则表达式的规则</li>
<li>any() 任意</li>
<li>date() 日期</li>
<li>time() 时间</li>
<li>iso() 要求字符串值采用有效的 ISO 8601 日期格式。</li>
</ul>
</li>
<li><p>新建 &#x2F;schema&#x2F;user.js 用户信息验证规则模块，并初始化代码如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单校验规则</span></span><br><span class="line"><span class="keyword">const</span> unit = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> contact = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> phone = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[1][\d]&#123;10&#125;$/</span>).required()</span><br><span class="line"><span class="keyword">const</span> numVisitors = joi.<span class="title function_">number</span>().<span class="title function_">min</span>(<span class="number">16</span>).required()</span><br><span class="line"><span class="keyword">const</span> guide = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/yes|no|是|否/</span>).required()</span><br><span class="line"><span class="keyword">const</span> date = joi.<span class="title function_">date</span>().<span class="title function_">min</span>(<span class="string">&#x27;now&#x27;</span>).<span class="title function_">iso</span>().required()</span><br><span class="line"><span class="keyword">const</span> time = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[\d]&#123;2&#125;[\s]*:[\s]*[\d]&#123;2&#125;$/</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单的验证规则对象</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">form_schema</span> =&#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        unit,</span><br><span class="line">        contact,</span><br><span class="line">        phone,</span><br><span class="line">        numVisitors,</span><br><span class="line">        guide,</span><br><span class="line">        date,</span><br><span class="line">        time,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由模块添加数据校验</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入需要验证的规则</span></span><br><span class="line"><span class="keyword">const</span> &#123;form_schema&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 在表单提交的路由中，声明局部中间件，对当前请求中携带的数据进行验证<br> 数据验证通过后，会把这次请求流转给后面的路由处理函数<br> 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理<br> <code>router.post(&#39;/form&#39;,expressJoi(form_schema), user_handler.formSubmit)</code></p>
</li>
<li><p>在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端<br> 在路由注册之后声明错误级别中间件，注意这里需要在app.js导入joi</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    <span class="comment">//数据验证失败</span></span><br><span class="line">    <span class="keyword">if</span>(err <span class="keyword">instanceof</span> joi.<span class="property">ValidationError</span>) <span class="keyword">return</span> res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 未知错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> postman测试成功</p>
</li>
</ol>
<h2 id="配置cors-跨域"><a href="#配置cors-跨域" class="headerlink" title="配置cors 跨域"></a>配置cors 跨域</h2><p>之前我们都是在postman发送请求测试，如果我们在自己写的页面发送请求会发现报错<br>这是因为我们的页面打开的是file协议，而服务器则是http协议，</p>
<p>使用<strong>cors中间件</strong>解决跨域问题<br>cors 是Express的一个第三方中间件。通过安装和配置cors 中间件，可以很方便地解决跨域问题。<br>使用步骤分为如下3步:<br>    1. 运行<code>npm install cors</code>安装中间件<br>    2. 使用<code>const cors = require(&#39;cors&#39;)</code>导入中间件<br>    3. 在路由之前调用<code>app.use(cors())</code>配置中间件</p>
<p>注意：<strong>一定要在路由之前配置cors中间件，从而解决接口跨域的问题</strong></p>
<ul>
<li>前端发送axios请求：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        unit : <span class="string">&quot;00&quot;</span>,</span><br><span class="line">        contact : <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">        <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">        <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">        <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
注意：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的，然而我们没有配置解析JSON表单数据的中间件，所以后端能够接收到请求，但是拿不到参数</li>
</ul>
<p>配置解析JSON格式表单数据的中间件：<code>app.use(express.json())</code><br>再次在页面发送axois请求，测试成功</p>
<h2 id="处理数据-–-date时间格式化"><a href="#处理数据-–-date时间格式化" class="headerlink" title="处理数据 – date时间格式化"></a>处理数据 – date时间格式化</h2><blockquote>
<p>在路由处理模块，我们通过<code>const userInfo = req.body</code>接收了获取的数据<br>    但是打印userInfo出来发现，<code>date: 2025-05-15T00:00:00.000Z,</code>，和我们传入的<code>2025-05-15</code>并不一致<br>    遍历对象打印date又变成了：<code>date: Thu May 15 2025 08:00:00 GMT+0800 (中国标准时间)</code><br>    这也许是因为数据校验调用了date()导致<code>const date = joi.date().min(&#39;now&#39;).iso().required()</code><br>    所以我们需要手动处理一下接收到的date的格式</p>
</blockquote>
<ol>
<li><p>下载dayjs组件库，并引入到路由处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载 dayjs 组件库</span></span><br><span class="line">npm install dayjs --save</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进行引用</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&#x27;dayjs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理data<br>我们可以通过forEach遍历，并打印出每一项的数据（需要把对象的键值对包装成数组）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()方法 把对象中的 每个键值对 包装成一对数组 最后返回一个数组</span></span><br><span class="line"><span class="comment">// 返回如[ [key1,value,],[key2,value2] ,.. ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(userInfo).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] == <span class="string">&#x27;date&#x27;</span>)&#123;</span><br><span class="line">        item[<span class="number">1</span>] = <span class="title function_">dayjs</span>(item[<span class="number">1</span>]).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>date数据处理完毕</p>
</li>
</ol>
<h2 id="将数据保存到文件中"><a href="#将数据保存到文件中" class="headerlink" title="将数据保存到文件中"></a>将数据保存到文件中</h2><ol>
<li><p>导入fs文件处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>向form.txt文件中追加每一项数据,不需要我们手动去创建txt文件，如果没有会自动创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的路径，是以执行的文件为基准的,这里是暴露出去的函数，是在路由里面执行的</span></span><br><span class="line"><span class="comment">// 而路由是注册在app.js文件的，所以以app.js为基准</span></span><br><span class="line"><span class="comment">//这里是追加内容的函数，和写入函数writeFile使用一样，如果该文件不存在则会创建该文件</span></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./form.txt&#x27;</span>,data, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就成功向form.txt文件写入数据了，但是数据是没有换行的</p>
</li>
<li><p>写入数据换行 – 换行符常量 <code>os.EOL</code><br>先引入os模块：<code>const os = require(&#39;os&#39;)</code><br>然后修改追加的data数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里插入数据依旧插入的英文名称，没有进行更改对应中文处理</span></span><br><span class="line"><span class="keyword">let</span> data = item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>] + os.<span class="property">EOL</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;<span class="comment">// 每一次插入前，都多空上一行 和加上一行分隔符</span></span><br><span class="line">    data = os.<span class="property">EOL</span> + <span class="string">&quot;####预约申请表####&quot;</span> + os.<span class="property">EOL</span> + data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="增加msg路由模块"><a href="#增加msg路由模块" class="headerlink" title="增加msg路由模块"></a>增加msg路由模块</h2><blockquote>
<p>比form路由简单些，不需要进行太多数据验证，只需要保证数据不为空就行</p>
</blockquote>
<p>这里直接贴出代码</p>
<ul>
<li><p>路由模块 msg.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入express模块，并创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> msgRouter = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由处理模块</span></span><br><span class="line"><span class="keyword">const</span> msg_hander = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入数据校验模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; msg_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msgRouter.<span class="title function_">post</span>(<span class="string">&#x27;/msg&#x27;</span>,<span class="title function_">expressJoi</span>(msg_schema),msg_hander.<span class="property">msgSubmit</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = msgRouter</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由处理模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msgSubmit</span> = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = req.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">&#x27;####留言####&#x27;</span> + os.<span class="property">EOL</span> + msg.<span class="property">msg</span> + os.<span class="property">EOL</span> + os.<span class="property">EOL</span>;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./msg.txt&#x27;</span>,data,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送留言数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据校验模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>);</span><br><span class="line"><span class="comment">// 校验规则 msg不少于10个字符，且是必填项</span></span><br><span class="line"><span class="keyword">const</span> msg = joi.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">10</span>).required();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msg_schema</span> = &#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        msg,<span class="comment">//注意必须写在body属性中，因为数据在req.body中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：记得要在app.js主程序页面配置路由<code>app.use(msgRouter)</code></strong></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode开发uniapp小程序，text、view标签报红错误提示</title>
    <url>/tsukimiya.github.io/2024/05/18/uni-app/view%E6%A0%87%E7%AD%BE%E6%8A%A5%E7%BA%A2%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p><img src="/tsukimiya.github.io/images/uniapp/%E6%A0%87%E7%AD%BE%E6%8A%A5%E7%BA%A2.png" alt="标签报红"></p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a><font color="violet">2.解决方案</font></h2><p>添加 @uni-helper&#x2F;uni-app-types 的类型依赖，然后在 tsconfig 里配置一下。</p>
<blockquote>
<p>亲测有效</p>
</blockquote>
<p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @uni-helper/uni-app-types</span><br></pre></td></tr></table></figure>

<p>在 tsconfig.json 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vueCompilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@uni-helper/uni-app-types/volar-plugin&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="3-另外一种解决方案"><a href="#3-另外一种解决方案" class="headerlink" title="3.另外一种解决方案"></a>3.另外一种解决方案</h2><p>直接使用div标签替换view标签，span标签替换text标签。这样就不会报错了。<br>uniapp会帮我们把div和span转换成view和text。</p>
<blockquote>
<p>uni-app官方文档中明确说明：</p>
<ul>
<li>小程序平台如果使用 <code>&lt;div&gt;</code> ，编译时会被转换为 <code>&lt;view&gt;</code>。</li>
<li>App平台 Vue2 项目在节点非常多时可以尝试使用 <code>&lt;div&gt;</code> 替换 <code>&lt;view&gt;</code> 以提升渲染性能。</li>
</ul>
<p>地址：<a href="https://uniapp.dcloud.io/component/view?id=view">https://uniapp.dcloud.io/component/view?id=view</a></p>
</blockquote>
<p>不过，还是推荐使用<code>&lt;view&gt;</code>和<code>&lt;text&gt;</code>，因为它们是平台原生支持的，符合小程序的开发规范。具有较高可读性，也更能保证多端兼容。</p>
<blockquote>
<p>view和text是uni-app为了保持多端一致性而提供的原生组件，它们分别对应于微信小程序、H5以及其他小程序平台的原生视图容器和文本显示元素。使用它们可以确保你的应用在不同平台（如微信小程序、H5、App等）有一致的表现和性能。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/q/1010000044860981?utm_source=sf-similar-question">https://segmentfault.com/q/1010000044860981?utm_source=sf-similar-question</a></p>
<p><a href="https://segmentfault.com/q/1010000044527776?utm_source=sf-similar-question">https://segmentfault.com/q/1010000044527776?utm_source=sf-similar-question</a></p>
]]></content>
      <categories>
        <category>uni-app</category>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>vscode</tag>
        <tag>vue3</tag>
        <tag>ts</tag>
        <tag>标签报红</tag>
      </tags>
  </entry>
  <entry>
    <title>Trouble Set</title>
    <url>/tsukimiya.github.io/2024/05/31/Problem/Trouble%20Set/</url>
    <content><![CDATA[<h2 id="axios请求刷新页面的问题"><a href="#axios请求刷新页面的问题" class="headerlink" title="axios请求刷新页面的问题"></a>axios请求刷新页面的问题</h2><p>axios请求会导致页面刷新，这是vscode的live server插件的bug<br>不知道什么原因，但是只要在文件夹打开页面就可以了。</p>
]]></content>
      <categories>
        <category>Problem</category>
      </categories>
      <tags>
        <tag>Problem</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3内容介绍</title>
    <url>/tsukimiya.github.io/2024/05/08/vue3/1.vue3%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>Vue3内容：<br>    1. <font color="red"><strong>核心</strong></font>：<font color="red">ref、reactive、computed、watch、生命周期……</font><br>    2. <font color="green"><strong>常用</strong></font>：<font color="green">hooks、自定义ref、路由、pinia、mitt……</font><br>    3. <strong>面试</strong>：<strong>组件通信、响应式相关API……</strong></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue是一套<strong>用于构建用户界面的前端框架</strong>。它为构建用户界面提供了一整套的解决方案(俗称Vue全家桶)：</p>
<ul>
<li>vue (核心库)</li>
<li>vue-router (路由方案)</li>
<li>vuex (状态管理方案)</li>
<li>vue 组件库 (快速搭建页面U效果的方案)</li>
</ul>
<p>以及<strong>辅助vue项目开发</strong>的一系列工具:</p>
<ul>
<li>vue-cli (npm 全局包: 一键生成工程化的vue 项目 - 基于webpack、大而全)</li>
<li>vite (npm 全局包: 一键生成工程化的vue项目 – 小而巧)</li>
<li>vue-devtools (浏览器插件: 辅助调试的工具)</li>
<li>vetur (vscode插件: 提供语法高亮和智能提示)</li>
</ul>
<p><img src="/tsukimiya.github.io/images/vue/vue3.png" alt="vue3"></p>
<h2 id="版本更新"><a href="#版本更新" class="headerlink" title="版本更新"></a>版本更新</h2><blockquote>
<p>2020.9.18，Vue.js发布 3.0版本，代号：One Piece(海贼王)（尤雨溪老二次元了XD）<br>官方发布地址：Release v3.0.0 One Piece·vuejs&#x2F;core</p>
</blockquote>
<p>vue3.x中<strong>兼容vue2.x中绝大多数的API与特性</strong>，同时，<strong>新增了3.x所特有的功能</strong>、并<strong>废弃了某些2.x中的旧功能</strong>:</p>
<ul>
<li><p>新增的功能例如:<br><strong>组合式API</strong>、多根节点组件、更好的TypeScript支持等</p>
</li>
<li><p>废弃的旧功能如下︰<br><strong>过滤器</strong>、不再支持$on，$off和$once实例方法等</p>
</li>
</ul>
<p>详细的变更信息，请参考官方文档给出的<strong>迁移指南</strong>: <a href="https://v3-migration.vuejs.org/zh/">https://v3-migration.vuejs.org/zh/</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>编码语言：JS、<strong>TS</strong><blockquote>
<p>实际工作中，Vue3往往搭配着TS一起使用</p>
</blockquote>
</li>
<li>代码风格：<strong>组合式API</strong>(最新的)、选项式API(传统的)<blockquote>
<p>官方明确表示，推荐使用组合式API</p>
</blockquote>
</li>
<li>简写形式：<strong>setup语法糖</strong></li>
</ol>
<ul>
<li><font color="red"><strong>核心</strong></font>：<br><font color="red">ref、reactive、computed、watch、生命周期……</font></li>
<li><font color="green"><strong>常用</strong></font>：<br><font color="green">hooks、自定义ref、路由、pinia、mitt……</font></li>
<li><strong>面试</strong>：<br><strong>组件通信、响应式相关API……</strong></li>
</ul>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><ul>
<li><p>组合式API —— setup语法糖 —— <strong>弱化this</strong></p>
<blockquote>
<p>因为vue3里面，在setup语法糖中几乎不去碰this，所以完全可以写<strong>箭头函数</strong>(箭头函数的this指向定义箭头函数时所在上下文的this，而普通函数this指向取决于函数的调用上下文)</p>
</blockquote>
</li>
<li><p>子组件的标签</p>
<ol>
<li><strong>可以写多个</strong>(vue2只能写一个)</li>
<li>写法：<code>&lt;Person/&gt;</code>，<strong>支持自闭合标签的写法</strong>，也支持双标签写法<blockquote>
<p>vue2是双标签写法<code>&lt;Person&gt;&lt;/Person&gt;</code></p>
</blockquote>
</li>
</ol>
</li>
<li><p>根标签<br>vue3里面，<strong>根标签不是必须的</strong>，在template标签里可以有多个子级标签</p>
</li>
<li><p>setup语法糖底层弄了async<br>可以直接在<code>&lt;scrpit setup&gt;&lt;/scrpit&gt;</code>中写await：<code>let xxx = await axios.get(&#39;xxxx&#39;)</code></p>
<blockquote>
<p>但是在组件中使用了异步任务，组件内容就无法正常显示了，必须在父组件中，包裹一个<a href="/tsukimiya.github.io/2024/05/18/vue3/8.vue3%E6%96%B0%E7%BB%84%E4%BB%B6/#Suspense">Suspense元素</a></p>
</blockquote>
</li>
</ul>
<h2 id="vue-devtools调试工具"><a href="#vue-devtools调试工具" class="headerlink" title="vue-devtools调试工具"></a><strong>vue-devtools调试工具</strong></h2><p>vue-devtools有 vue2.x 和 vue3.x(带Beta标记的版本) 两个版本，<strong>不能交叉使用</strong>!<br>如何安装：<a href="https://juejin.cn/post/7125983116396593165">掘金</a>、<a href="https://blog.csdn.net/ashin8032/article/details/122600345">CSDN</a></p>
<p>但是，<strong>vite</strong>似乎<strong>集成了vue-devtools</strong>，不需要在浏览器安装插件，在创建项目的时候配置上 该调试工具即可使用。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3介绍&amp;Vite创建工程</title>
    <url>/tsukimiya.github.io/2024/05/10/vue3/2.vue3%E4%BB%8B%E7%BB%8D&amp;Vite%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Vue3简介"><a href="#Vue3简介" class="headerlink" title="Vue3简介"></a>Vue3简介</h1><ul>
<li>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code></li>
<li>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></li>
<li>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core</a></li>
<li>截止2023年10月，最新的公开版本为：<code>3.3.4</code>  <img width="50%" style="margin-left:0;" src="/tsukimiya.github.io/images/vue3/版本.png" alt="版本"></li>
</ul>
<h2 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h2><ul>
<li><p>打包大小减少<code>41%</code>。</p>
</li>
<li><p>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</p>
</li>
<li><p>内存减少<code>54%</code>。</p>
</li>
</ul>
<h2 id="源码的升级"><a href="#源码的升级" class="headerlink" title="源码的升级"></a>源码的升级</h2><ul>
<li><p>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</p>
</li>
<li><p>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</p>
</li>
</ul>
<h2 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h2><ul>
<li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li>
</ul>
<h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><ol>
<li><p><code>Composition API</code>（组合<code>API</code>）：</p>
<ul>
<li><p><code>setup</code></p>
</li>
<li><p><code>ref</code>与<code>reactive</code></p>
</li>
<li><p><code>computed</code>与<code>watch</code></p>
<p>……</p>
</li>
</ul>
</li>
<li><p>新的内置组件：</p>
<ul>
<li><p><code>Fragment</code></p>
</li>
<li><p><code>Teleport</code></p>
</li>
<li><p><code>Suspense</code></p>
<p>……</p>
</li>
</ul>
</li>
<li><p>其他改变：</p>
<ul>
<li><p>新的生命周期钩子</p>
</li>
<li><p><code>data</code> 选项应始终被声明为一个函数</p>
</li>
<li><p>移除<code>keyCode</code>支持作为<code> v-on</code> 的修饰符</p>
<p>……</p>
</li>
</ul>
</li>
</ol>
<h1 id="创建Vue3工程"><a href="#创建Vue3工程" class="headerlink" title="创建Vue3工程"></a>创建Vue3工程</h1><h2 id="基于-vue-cli-创建"><a href="#基于-vue-cli-创建" class="headerlink" title="基于 vue-cli 创建"></a>基于 vue-cli 创建</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p>
<blockquote>
<p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue <span class="literal">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli </span></span><br><span class="line">npm install <span class="literal">-g</span> @vue/<span class="built_in">cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行创建命令</span></span><br><span class="line">vue create vue_test</span><br><span class="line"></span><br><span class="line"><span class="comment">##  随后选择3.x</span></span><br><span class="line"><span class="comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span></span><br><span class="line"><span class="comment">##  &gt; 3.x</span></span><br><span class="line"><span class="comment">##    2.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于-vite-创建-推荐"><a href="#基于-vite-创建-推荐" class="headerlink" title="基于 vite 创建 (推荐)"></a>基于 vite 创建 (推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p>
<ul>
<li>轻量快速的热重载（<code>HMR</code>），能实现<strong>极速的服务启动</strong>。</li>
<li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li>
<li>真正的<strong>按需编译</strong>，不再等待整个应用编译完成。</li>
<li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：<br>webpack是处理完所有模块才启动工程，而vite是直接启动，后续按需加载(比较像懒加载)</li>
</ul>
<p><img src="/tsukimiya.github.io/images/vue3/webpack构建.png" alt="webpack构建" title="webpack构建" style="display:inline;width:49.8%;margin:0;box-shadow:0 0 10px black" />	<img src="/tsukimiya.github.io/images/vue3/vite构建.png" alt="vite构建" title="vite构建" style="display:inline;width:49.3%;margin:0;box-shadow:0 0 10px black" /></p>
<ul>
<li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.创建命令</span></span><br><span class="line">npm create vue@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.具体配置</span></span><br><span class="line"><span class="comment">## 配置项目名称 // 不能出现中文和特殊字符，最好用 纯小写字母+数字+下划线</span></span><br><span class="line">√ Project name: vue3_test</span><br><span class="line"><span class="comment">## 是否添加TypeScript支持</span></span><br><span class="line">√ Add TypeScript?  Yes</span><br><span class="line"><span class="comment">## 是否添加JSX支持</span></span><br><span class="line">√ Add JSX Support?  No</span><br><span class="line"><span class="comment">## 是否添加路由环境</span></span><br><span class="line">√ Add Vue Router <span class="keyword">for</span> Single Page Application development?  No</span><br><span class="line"><span class="comment">## 是否添加pinia环境</span></span><br><span class="line">√ Add Pinia <span class="keyword">for</span> state management?  No</span><br><span class="line"><span class="comment">## 是否添加单元测试</span></span><br><span class="line">√ Add Vitest <span class="keyword">for</span> Unit Testing?  No</span><br><span class="line"><span class="comment">## 是否添加端到端测试方案</span></span><br><span class="line">√ Add an <span class="keyword">End</span><span class="literal">-to-End</span> Testing Solution? » No</span><br><span class="line"><span class="comment">## 是否添加ESLint语法检查</span></span><br><span class="line">√ Add ESLint <span class="keyword">for</span> code quality?  Yes</span><br><span class="line"><span class="comment">## 是否添加Prettiert代码格式化</span></span><br><span class="line">√ Add Prettier <span class="keyword">for</span> code formatting?  No</span><br></pre></td></tr></table></figure>
<ul>
<li>项目文件<br>  一开始打开项目文件，会有很多文件报红，这是因为项目文件找不到依赖，可以发现我们没有<code>node_modules</code>文件夹，我们需要<code>npm i</code>安装所有的依赖，再重新打开项目文件，就好了<ul>
<li><p><code>.vscode/extensions.json</code>：配置了插件，如果vscode一个插件都没安装，会给你一个提示</p>
</li>
<li><p><code>public</code>：脚手架的根目录，只放了一个页签图标<code>favicon.ico</code>，就是网页标签的图标</p>
</li>
<li><p><code>env.d.ts</code>: <code>/// &lt;reference types=&quot;vite/client&quot; /&gt;</code><br>  ts不认识.jpg、.txt等文件，这个文件的作用就是让ts去认识这些文件</p>
<blockquote>
<p>比如，如果删掉这行代码，在a.ts文件中引入一个txt：<code>import b from &#39;./b.txt&#39;</code>，会发现ts不认识<br>  ctrl点进这个<code>vite/client</code>，这个文件中，常用的文件都配在这里了，包括各种图片视频图标等等</p>
</blockquote>
</li>
<li><p><code>index.html</code>：入口文件<br>  它引入了<code>src/main.ts</code>，它支撑着整个应用跑起来</p>
<blockquote>
<p>这点vite和webpack就有区别了，入口文件不是main.js，也不是mian.ts</p>
</blockquote>
</li>
<li><p>运行；<code>npm run dev</code></p>
</li>
</ul>
</li>
</ul>
<p>自己动手编写一个App组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好啊！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span> <span class="comment">//组件名</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.app</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>安装官方推荐的<code>vscode</code>插件：</p>
<img src="/tsukimiya.github.io/images/vue3/volar.png" alt="volar" style="width:30%;margin:0;display:inline" /> 

<img src="/tsukimiya.github.io/images/vue3/ts-volar.png" alt="ts-volar" style="width:30%;margin:0;display:inline" /> 

<blockquote>
<p>TS版本的volar现在已经启用，而是新的vue-offical将volar 和 TS volar两个插件的功能集合到了一起，但是好像目前很垃圾，评价很差</p>
</blockquote>
<p>总结：</p>
<ul>
<li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li>
<li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li>
<li><code>Vue3</code>中是通过<code>createApp</code> 函数创建一个应用实例。</li>
</ul>
<h2 id="一个简单的效果"><a href="#一个简单的效果" class="headerlink" title="一个简单的效果"></a>一个简单的效果</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">tel</span>:<span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zhang-san&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">tel</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这种写法就是<strong>vue2的选项式API</strong>(也叫<strong>配置式</strong>)，name、data、methods就是一个<strong>选项</strong>，或者说一个<strong>配置项</strong>。<br>这些东西写多了，就<strong>会出现一些问题</strong>，<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#why-composition-api">官网有明确的说明</a>，这里在下一篇文章通过动态图作说明→</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>Vite</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3路由</title>
    <url>/tsukimiya.github.io/2024/05/13/vue3/4.vue3%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<center style="margin:-30px 0 -60px;transform:translateY(-30px)">
<a href="https://router.vuejs.org/zh/introduction.html">Vue Router官方文档</a>
</center>

<h1 id="对路由的理解"><a href="#对路由的理解" class="headerlink" title="对路由的理解"></a>对路由的理解</h1><img src="/tsukimiya.github.io/images/vue3/路由的理解.png" alt="路由的理解" style="zoom:20%;border-radius:40px" /> 

<h1 id="基本切换效果"><a href="#基本切换效果" class="headerlink" title="基本切换效果"></a>基本切换效果</h1><ul>
<li><p><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</p>
</li>
<li><p>路由配置文件代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/News.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/About.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由器</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">	<span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),<span class="comment">// 路由器工作模式：hash模式/history模式</span></span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>main.ts</code>代码如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入路由器</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>) <span class="comment">// 创建一个应用</span></span><br><span class="line">app.<span class="title function_">use</span>(router) <span class="comment">// 使用路由器 </span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 挂载整个应用到app容器中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><code>App.vue</code>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Vue路由测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/news&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 展示区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;<span class="title class_">RouterLink</span>,<span class="title class_">RouterView</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="两个注意点"><a href="#两个注意点" class="headerlink" title="两个注意点"></a>两个注意点</h1><blockquote>
<ol>
<li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p>
</li>
<li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p>
</li>
</ol>
</blockquote>
<h1 id="路由器工作模式"><a href="#路由器工作模式" class="headerlink" title="路由器工作模式"></a>路由器工作模式</h1><blockquote>
<p>一般，后台管理项目，不需要考虑seo，直接用hash模式<br>前台项目，to C的，直接给客户用的，用history模式</p>
</blockquote>
<ol>
<li><code>history</code>模式</li>
</ol>
<blockquote>
<p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p>
<p>缺点：后期<strong>项目上线</strong>，<strong>需要服务端配合处理路径问题</strong>，否则刷新会有<code>404</code>错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  	<span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">//history模式</span></span><br><span class="line">  	<span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li><code>hash</code>模式</li>
</ol>
<blockquote>
<p>优点：兼容性更好，因为不需要服务器端处理路径。</p>
<p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code><strong>优化方面相对较差</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  	<span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(), <span class="comment">//hash模式</span></span><br><span class="line">  	<span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="to的两种写法"><a href="#to的两种写法" class="headerlink" title="to的两种写法"></a>to的两种写法</h1><p>字符串形式 和 <strong>对象形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种：to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种：to的对象写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>大部分项目，不是这么写路由的，而是直接 <strong>遍历的动态路由</strong>，<strong>这个时候对象尤其重要的</strong></p>
<h1 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h1><p>作用：可以简化路由跳转及传参（后面就讲）。</p>
<p>给路由规则命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>跳转路由：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><ol>
<li><p>编写<code>News</code>的子路由：<code>Detail.vue</code></p>
</li>
<li><p>配置路由规则，使用<code>children</code>配置项：</p>
 <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转路由（记得要加完整路径）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail&quot;</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;news-list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">v-for</span>=<span class="string">&quot;news in newsList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;news.id&quot;</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;news.name&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-detail&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RouterView</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="路由传参-动态路由"><a href="#路由传参-动态路由" class="headerlink" title="路由传参 &#x2F; 动态路由"></a>路由传参 &#x2F; 动态路由</h1><h2 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h2><ol>
<li><p>传递参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;</span>&gt;</span></span><br><span class="line">	跳转</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span></span></span><br><span class="line"><span class="string"><span class="tag">    path:&#x27;/news/detail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id:news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title:news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content:news.content</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印query参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h2><blockquote>
<p>用这种方式传参会被同事骂？因为它的字符串写法可读性很差？XDD<br>不过对象写法和query参数也没大差吧？而且开启路由传参也比较方便，为什么呢？<br>不过需要占位，这里也比query要麻烦，而且如果是可以不传的参数还要加？号</p>
</blockquote>
<ol>
<li><p>传递参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;`/news/detail/001/新闻001/内容001`&quot;</span>&gt;</span>&#123;&#123;news.title&#125;&#125;<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    name:&#x27;xiang&#x27;, //用name跳转,不能用path，会报错</span></span></span><br><span class="line"><span class="string"><span class="tag">    params:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">      id:news.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">      title:news.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">      content:news.title</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印params参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>需要提前在路由规则占位 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是可传可不传的参数，需要在规则中加？，否则会报错 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content 可不传</span></span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content?&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p>
<p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p>
</blockquote>
<h1 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h1><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）<br>写法：params参数用 布尔值写法； query参数用 函数写法</p>
<blockquote>
<p>一般组件是直接写标签的，可以直接传递props<br>  路由组件(这里是Detail)都没有机会写标签，所以通过这种方式来传props</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>, <span class="comment">// params参数的占位规则写法</span></span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">Detail</span>, <span class="comment">// 这里就相当于 底层写了一个 &lt;Detail/&gt;</span></span><br><span class="line">  <span class="comment">// 下面的prop配置就相当于 &lt;Detail :id=?? :title=?? :content=?? /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一种写法：</span></span><br><span class="line">  <span class="comment">// props的布尔值写法，作用：把收到了每一组 params参数 ，作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// 只能处理params参数，也推荐params时候使用这种方式</span></span><br><span class="line">  <span class="comment">// props:true </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二种写法：</span></span><br><span class="line">  <span class="comment">// props的函数写法，返回一个对象</span></span><br><span class="line">  <span class="comment">// 作用：把 返回的对象中 每一组key-value 作为 props 传给Detail组件</span></span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>)&#123; <span class="comment">// 可以随意命名，但都是route对象</span></span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span> <span class="comment">// 或params</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三种写法： （极少用）</span></span><br><span class="line">  <span class="comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:&#123;a:1,b:2,c:3&#125;,  // 把参数写死了，没有意义，所以写的非常少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h1><ol>
<li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p>
</li>
<li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p>
<ul>
<li><code>push</code>是追加历史记录（默认值）。</li>
<li><code>replace</code>是替换当前记录。（登陆页面应该会用这个）</li>
</ul>
</li>
<li><p>开启<code>replace</code>模式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">replace</span>&gt;</span>News<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="声明式导航-编程式导航"><a href="#声明式导航-编程式导航" class="headerlink" title="声明式导航&amp;编程式导航"></a>声明式导航&amp;编程式导航</h1><p>编程式路由导航：脱离<code>&lt;RouterLink&gt;</code>实现路由跳转 （<strong>开发常用</strong>）<br>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">声明式</th>
<th align="center">编程式</th>
</tr>
</thead>
<tbody><tr>
<td>导航到不同的位置</td>
<td align="center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td align="center"><code>router.push(...)</code></td>
</tr>
<tr>
<td>替换当前位置</td>
<td align="center"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td align="center"><code>router.replace(...)</code></td>
</tr>
<tr>
<td>横跨历史</td>
<td align="center"><center>\</center></td>
<td align="center"><code>router.go(n)</code></td>
</tr>
</tbody></table>
<ul>
<li><code>router.go(n)</code>：横跨历史。采用一个整数作为参数，表示在历史堆栈中<strong>前进或后退多少步</strong>，类似于 <code>window.history.go(n)</code>。</li>
<li><code>n = 1</code>时，等同于：<code>router.forward()</code></li>
<li><code>n = -1</code>时，等同于：<code>router.back()</code></li>
</ul>
<blockquote>
<p><code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code> 的翻版，它们确实模仿了 <code>window.history</code> 的 API。<br>值得一提的是，无论在创建路由器实例时传递什么 history 配置(history模式，和hash模式 的路由器工作模式)，Vue Router 的导航方法 (push、replace、go) 都能始终正常工作。</p>
</blockquote>
<p>应用场景：</p>
<ol>
<li>符合某些条件才跳转，不是说一点就跳转<blockquote>
<p>到了10点整，自动跳到秒杀路由；只有登陆成功，自动跳转到个人中心</p>
</blockquote>
</li>
<li>鼠标滑过一个东西跳转(不点)</li>
<li>还有手机摇一摇跳转</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">parmas</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">push</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">replace</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/news&#x27;</span>) <span class="comment">// to能咋写，push就能咋写 // 1. 字符串写法 2. 对象写法</span></span><br></pre></td></tr></table></figure>

<p>点击button按钮进行路由跳转：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 导航区 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;news in newsList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;news.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showNewsDetail(news)&quot;</span>&gt;</span>查看新闻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RouterLink</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;...&#125;&quot;</span>&gt;</span>&#123;&#123;news.title&#125;&#125;<span class="tag">&lt;/<span class="name">RouterLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 展示区 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">RouterView</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterView</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;News&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;<span class="title class_">RouterView</span>,<span class="title class_">RouterLink</span>,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> newsList = <span class="title function_">reactive</span>([...])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 定义一个接口</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  interface <span class="title class_">NewsInter</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">id</span>:string,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">title</span>:string,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">content</span>:string</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 直接写news会报错：参数news隐式具有any类型(就是不知道news是什么)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果想图方便简单，可以直接：news:any</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">showNewsDetail</span>(<span class="params">news:NewsInter</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    router.<span class="title function_">replace</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">query</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>:news.<span class="property">id</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">title</span>:news.<span class="property">title</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">content</span>:news.<span class="property">content</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在vue2中，编程式路由导航，如果重复跳转是报错的，但是vue3里面不会报错</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>作用：将特定的路径，重新定向到已有路由。</p>
<ul>
<li>具体编码：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">  <span class="attr">redirect</span>:<span class="string">&#x27;/news/detail&#x27;</span>, <span class="comment">// 嵌套子路由重定向</span></span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,<span class="attr">path</span>:<span class="string">&#x27;detail/:id?/:title?/:content?&#x27;</span>,<span class="attr">component</span>: <span class="title class_">Detail</span>,</span><br><span class="line">      <span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> route.<span class="property">params</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由进阶"><a href="#路由进阶" class="headerlink" title="路由进阶"></a>路由进阶</h1><p>导航守卫、路由元信息、路由懒加载、路由故障等等<br>参考<a href="https://router.vuejs.org/zh/introduction.html">官方文档</a></p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>
<ol>
<li>全局前置守卫<br>  当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时<strong>导航在所有守卫 resolve(解析) 完之前一直处于等待中</strong>。<ul>
<li>参数：<ul>
<li>to: 即将要进入的目标</li>
<li>from: 当前导航正要离开的路由<blockquote>
<p>新版Vue Router移除了next参数，但仍支持使用，因为其是常见的错误来源<br>  确保 next 在任何给定的导航守卫中都被严格调用一次，否则钩子永远都不会被解析或报错。</p>
</blockquote>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>false：取消导航，如果浏览器的 URL 改变了，URL 地址会重置到 from 路由对应的地址。</li>
<li>一个路由地址：如同调用 router.push()，且可以传入诸如 replace: true 或 name: ‘home’ 之类的选项。<br>它会中断当前的导航，同时用相同的 from 创建一个新导航。</li>
<li>如果什么都没有，undefined 或返回 true，则导航是有效的，并调用下一个导航守卫<blockquote>
<p>即：<br>return  true 或 undefined(没有返回值默认 为un) ，正常跳转<br>return false，阻止跳转<br>return 字符串 或 对象 （就和router.push()传参一样，也即使和to传参一样）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;路由前置守卫&quot;</span>,to,<span class="keyword">from</span>);</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&#x27;/about&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;路由前置守卫触发，从about跳转到news/detail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/news/detail&#x27;</span> <span class="comment">// 字符串形式，值是path地址，将用户重定向到新闻</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;news/detail&#x27;</span> &#125; <span class="comment">// 将用户重定向到新闻页面，对象形式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由前置守卫触发，false取消当前的导航，不跳转&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由前置守卫触发，return 对象形式 并传参&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">      <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;路由前置守卫跳转&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>:<span class="string">&#x27;跳转成功&#x27;</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>全局前置守卫</strong>是<strong>最常用</strong>的导航守卫，其余还有：全局解析守卫、全局后置钩子、路由独享的守卫、组件内的守卫等，具体使用查看<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">官方文档 - 导航守卫</a></p>
</blockquote>
<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">完整的导航解析流程</a></h2><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>路由</tag>
        <tag>路由重定向</tag>
        <tag>动态路由</tag>
        <tag>Vue3</tag>
        <tag>命名路由</tag>
        <tag>嵌套路由</tag>
        <tag>路由的props配置</tag>
        <tag>编程式导航</tag>
        <tag>路由器工作模式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3核心语法</title>
    <url>/tsukimiya.github.io/2024/05/12/vue3/3.vue3%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>组合式API setup语法糖（name属性 – vite插件简化）</li>
<li>响应式数据的创建：ref、reactive</li>
<li>计算属性：computed（get、set）</li>
<li>监听器：watch (能够监听的4种数据、监听的 5种情况)</li>
<li>标签的ref属性</li>
<li>props（接收+限制类型+指定默认值+限制必要性）</li>
<li>vue生命周期（整体可分为四个阶段、八个钩子）<ul>
<li>vue解析流程、父子组件生命周期顺序</li>
</ul>
</li>
<li>hooks（封装）</li>
</ul>
</blockquote>
<h1 id="OptionsAPI-与-CompositionAPI"><a href="#OptionsAPI-与-CompositionAPI" class="headerlink" title="OptionsAPI 与 CompositionAPI"></a>OptionsAPI 与 CompositionAPI</h1><ul>
<li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li>
<li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li>
</ul>
<h2 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h2><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，<strong>不便于维护和复用</strong>。</p>
<img src="/tsukimiya.github.io/images/vue3/options劣势1.gif" alt="options劣势1.gif" style="display:inline;height:300px;margin:0;border-radius:20px" />
<img src="/tsukimiya.github.io/images/vue3/options劣势2.gif" alt="options劣势2.gif" style="display:inline;height:300px;margin:0;border-radius:20px" />

<h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p>
<img src="/tsukimiya.github.io/images/vue3/comp优势1.gif" alt="comp优势1.gif" style="display:inline;height:300px;border-radius:10px"  />
<img src="/tsukimiya.github.io/images/vue3/comp优势2.gif" alt="comp优势2.gif" style="display:inline;height:300px;border-radius:10px"  />

<blockquote>
<p>说明：以上四张动图原创作者：大帅老猿(掘金)</p>
</blockquote>
<h1 id="拉开序幕的-setup"><a href="#拉开序幕的-setup" class="headerlink" title="拉开序幕的 setup"></a>拉开序幕的 setup</h1><h2 id="setup-概述"><a href="#setup-概述" class="headerlink" title="setup 概述"></a>setup 概述</h2><p><strong>setup</strong>是<code>Vue3</code>中一个<strong>新的配置项，值是一个函数</strong>，它是 <code>Composition API</code> <strong>“表演的舞台”</strong>，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在<code>setup</code>中。</p>
<p>特点如下：</p>
<ul>
<li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li>
<li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li>
<li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，<strong>它是“领先”所有钩子执行的</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//setup中的this是undefined，vue3中已经弱化this了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> age = <span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">let</span> tel = <span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 方法，原来写在methods中</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        name = <span class="string">&#x27;zhang-san&#x27;</span> <span class="comment">//注意：此时这么修改name页面是不变化的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        age += <span class="number">1</span> <span class="comment">//注意：此时这么修改age页面是不变化的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(tel)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 返回一个对象，对象中的内容，模板中可以直接使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;name,age,tel,changeName,changeAge,showTel&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="setup-的返回值"><a href="#setup-的返回值" class="headerlink" title="setup 的返回值"></a>setup 的返回值</h2><ul>
<li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用（<strong>重点关注</strong>）。</li>
<li>若返回一个<strong>函数</strong>：则可以自定义渲染内容，代码如下：<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// setup的返回值也可以是一个渲染函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="string">&#x27;你好啊！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="setup-与-Options-API-的关系"><a href="#setup-与-Options-API-的关系" class="headerlink" title="setup 与 Options API 的关系"></a>setup 与 Options API 的关系</h2><ul>
<li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>……）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li>
<li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>……）。<blockquote>
<p>因为<code>setup</code>是最早的生命周期，所以setup可以被其他选项摸到，而它摸不到其他选项。</p>
</blockquote>
</li>
<li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。<blockquote>
<p>虽然他们可以共存，但是vue3不要写vue2的data、method，不到万不得已。</p>
</blockquote>
</li>
</ul>
<h2 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h2><blockquote>
<p>每次我们在setup中定义了数据，并使用，都需要把它return出去，这就很麻烦，大量的编写应用，就很容易忘记去return。所以有更简单的写法 —— <strong>setup语法糖</strong><br>多写一个script标签，写上setup属性<code>&lt;script setup&gt;&lt;/script&gt;</code><br>这样，这个里面的东西就相当于，写到setup(){}函数里面，而且它还会<strong>自动return</strong></p>
</blockquote>
<p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Person&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的写法是setup语法糖 --&gt;</span><br><span class="line">&lt;!--  &lt;script&gt; and &lt;script setup&gt; 必须是相同的语法类型，否则报错，这里都是ts类型 --&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  console.log(this) //undefined</span><br><span class="line">  </span><br><span class="line">  // 数据（注意：此时的name、age、tel都不是响应式数据）</span><br><span class="line">  let name = &#x27;张三&#x27;</span><br><span class="line">  let age = 18</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changName()&#123;</span><br><span class="line">    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function changAge()&#123;</span><br><span class="line">    console.log(age)</span><br><span class="line">    age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所以对于vue3的项目，有<strong>两个script标签</strong>，<strong>一个是专门配置组合式API的</strong>，<strong>一个是专门配置组件名字的</strong>。但是写两个难受了，还不能合到一块，我们可以借助插件完成↓</p>
<p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p>
<ol>
<li><p>第一步：<code>npm i vite-plugin-vue-setup-extend -D</code></p>
</li>
<li><p>第二步：<code>vite.config.ts</code></p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueSetupExtend</span> <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-vue-setup-extend&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="title class_">VueSetupExtend</span>() ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></p>
</li>
</ol>
<h1 id="ref-创建：基本类型的响应式数据"><a href="#ref-创建：基本类型的响应式数据" class="headerlink" title="ref 创建：基本类型的响应式数据"></a>ref 创建：基本类型的响应式数据</h1><blockquote>
<p>在<strong>vue2中</strong>，只要将<strong>数据</strong>定义到<strong>data节点</strong>里面，这个数据就<strong>自动是响应式</strong>的了，其他它在<strong>背后</strong>是做了<strong>数据代理和数据劫持</strong><br><strong>vue3</strong>有两个东西去<strong>定义响应式数据</strong>：<strong>ref、reactive</strong>(这个<code>ref</code>和vue2中的<code>$ref</code>不是一个东西)</p>
</blockquote>
<ul>
<li><strong>作用：</strong>定义响应式变量。</li>
<li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li>
<li><strong>返回值：</strong>一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li>
<li><strong>注意点：</strong><ul>
<li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li>
<li>对于<code>let name = ref(&#39;张三&#39;)</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>年龄+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showTel&quot;</span>&gt;</span>点我查看联系方式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// tel就是一个普通的字符串，不是响应式的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> tel = <span class="string">&#x27;13888888888&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// JS中操作ref对象时候需要.value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    name.<span class="property">value</span> = <span class="string">&#x27;李四&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// name = ref(&#x27;zhang-san&#x27;)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// JS中操作ref对象时候需要.value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    age.<span class="property">value</span> += <span class="number">1</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">showTel</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(tel)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="reactive-创建：对象类型的响应式数据"><a href="#reactive-创建：对象类型的响应式数据" class="headerlink" title="reactive 创建：对象类型的响应式数据"></a>reactive 创建：对象类型的响应式数据</h1><ul>
<li><strong>作用：</strong>定义一个<strong>响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）<blockquote>
<p>reactive只能定义 对象类型的响应式数据</p>
</blockquote>
</li>
<li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li>
<li><strong>返回值：</strong> 一个<code>Proxy</code>的实例对象，简称：响应式对象。</li>
<li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。<ul>
<li>该对象的<strong>所有子属性</strong>（不论嵌套多深）都会被转换为<strong>响应式的</strong>。</li>
<li>即使是后来<strong>新增的属性</strong>，由于使用了Proxy代理，Vue也能确保这些新属性自动成为<strong>响应式的</strong></li>
<li>当<strong>删除一个属性</strong>时，Vue的响应式系统也能<strong>感知到</strong>这一变化，并<strong>相应地处理依赖更新</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>游戏列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCarPrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeFirstGame&quot;</span>&gt;</span>修改第一游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123; <span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;原神&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeCarPrice</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  car.<span class="property">price</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  games[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;流星蝴蝶剑&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="ref-创建：对象类型的响应式数据"><a href="#ref-创建：对象类型的响应式数据" class="headerlink" title="ref 创建：对象类型的响应式数据"></a>ref 创建：对象类型的响应式数据</h1><ul>
<li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li>
<li>若<code>ref</code>接收的是<strong>对象类型的时候</strong>，<strong>内部</strong>其实也是<strong>调用了</strong><code>reactive</code>函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>游戏列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCarPrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeFirstGame&quot;</span>&gt;</span>修改第一游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> car = <span class="title function_">ref</span>(&#123; <span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> games = <span class="title function_">ref</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span> &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#123; <span class="attr">id</span>: <span class="string">&#x27;ahsgdyfa03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;原神&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(car)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeCarPrice</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  car.<span class="property">value</span>.<span class="property">price</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  games.<span class="property">value</span>[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;流星蝴蝶剑&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="ref-对比-reactive"><a href="#ref-对比-reactive" class="headerlink" title="ref 对比 reactive"></a>ref 对比 reactive</h1><p>宏观角度看：</p>
<blockquote>
<ol>
<li><p><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</p>
</li>
<li><p><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</p>
</li>
</ol>
</blockquote>
<ul>
<li>区别：</li>
</ul>
<blockquote>
<ol>
<li><p><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。<br> 设置 – 扩展 – Volar(老版的TS volar插件)<br>   设置 – 扩展 – Vue(新版的vue-offical插件)</p>
<img src="/tsukimiya.github.io/images/vue3/自动补充value.png" alt="自动补充value" style="zoom:60%;border-radius:20px;margin:0;transform:translateY(-30px)" /> 
</li>
<li><p><code>reactive</code><strong>重新分配一个新对象</strong>，<strong>会失去响应式</strong>（可以使用<code>Object.assign</code>去整体替换）。（官方文档将其叫做：<strong>reactive的局限性</strong>）</p>
</li>
</ol>
</blockquote>
<ul>
<li><p><font color="red"><strong>一个注意点：.value的问题</strong></font><br><code>ref</code>创建的变量，必须使用<code>.value</code><br><code>reactive</code>创建的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>:<span class="title function_">ref</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> , obj.<span class="property">b</span> , obj.<span class="property">c</span>)</span><br></pre></td></tr></table></figure>
<p>虽然c是一个响应式的数据，数字3 ，， 但是不需要<code>.value</code>,如果<code>.value</code>得到的事undefined<br><code>c</code>是一个<strong>响应式的数据</strong>，但是它是<strong>放在一个响应式对象里面的</strong>，也就是说，当你去触碰<code>obj.c</code>的时候，它<strong>自动就解包</strong>了(自动已经开始读取value了)</p>
</li>
<li><p>重新分配一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;汽车信息：一辆&#123;&#123;car.<span class="property">brand</span>&#125;&#125;车，价值&#123;&#123;car.<span class="property">price</span>&#125;&#125;万&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePrice&quot;</span>&gt;</span>修改汽车价格<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>换一辆车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> <span class="comment">// 点击按钮不起作用 -- 失去响应式</span></span><br><span class="line"><span class="comment">// 重新分配一个对象</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changePrice</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car.<span class="property">price</span> += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发换车事件后，由于失去响应式，修改价格也不会再生效</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car = &#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;</span><br><span class="line">  car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;) <span class="comment">// 即便是用reactive包裹，依旧一样会失去响应式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以通过ES6的assign方法来修改，会将后面所有对象的属性加到car中，同名则覆盖</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(car,&#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="title function_">ref</span>(&#123;<span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  car.<span class="property">value</span> = &#123;<span class="attr">brand</span>:<span class="string">&#x27;奥拓&#x27;</span>,<span class="attr">price</span>:<span class="number">1</span>&#125; <span class="comment">// 如果是ref，就可以直接整体改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>这种写法经常是无法避免的，比如后端返回一个对象，有二十多个属性，我们是不可能一个一个修改属性值的，肯定是要重新分配一个对象</p>
</blockquote>
<ul>
<li><strong>使用原则</strong>：</li>
</ul>
<blockquote>
<ol>
<li>若需要一个<strong>基本类型</strong>的响应式数据，必须使用<code>ref</code>。</li>
<li>若需要一个<strong>响应式对象</strong>，<strong>层级不深</strong>，<code>ref</code>、<code>reactive</code>都可以。</li>
<li>若需要一个<strong>响应式对象</strong>，且<strong>层级较深</strong>，推荐使用<code>reactive</code>。<blockquote>
<p>做表单相关的，做收集数据、表单数据回显，推荐使用reactive<br>如果一个表单里面有非常多数据，大量的使用ref，最终的代码就会一堆.value，不是很合适<br>ref代理对象还是调的reactive,所以<strong>reactive代理对象性能更好</strong></p>
</blockquote>
</li>
</ol>
</blockquote>
<h1 id="toRefs-与-toRef"><a href="#toRefs-与-toRef" class="headerlink" title="toRefs 与 toRef"></a>toRefs 与 toRef</h1><blockquote>
<p><strong>toRefs</strong>应该会更<strong>常用</strong>些，毕竟写法更简单，而且也可以获取单个属性</p>
</blockquote>
<ul>
<li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。<blockquote>
<p>如果嵌套的过多，每次都要去<code>.</code>很多东西，就很麻烦，直接取出来可以更方便</p>
</blockquote>
</li>
<li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li>
<li>语法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 模板中也可以直接写解构出来的响应式数据，如 &#123;&#123; name &#125;&#125;*/&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;person.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别：&#123;&#123;person.gender&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeGender&quot;</span>&gt;</span>修改性别<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,reactive,toRefs,toRef&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRef、toRefs得到的都是ObjectRefImpl对象，修改得到的响应式数据的值，对象中的属性值也同时被修改</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;name,gender&#125; = <span class="title function_">toRefs</span>(person)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 通过toRef将person对象中的age属性取出，且依然保持响应式的能力</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">toRef</span>(person,<span class="string">&#x27;age&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这样写是不一样的！！！得到的都是RefImpl对象，而不是ObjectRefImpl对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这两个写法都是把person的age这个基本数据的值取了出来，作为定义的响应式数据的初始值，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 不会影响到person.age</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">toRef</span>(person.<span class="property">age</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(person.<span class="property">age</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果是这种写法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 由于ref(person)得到的是一个RefImpl对象，想要解构出name、gender属性，必须.value才行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 最终取到的值，只是普通的基本类型数据，所以结构得到的name、gender是非响应式数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;name,gender&#125; = <span class="title function_">ref</span>(person).<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    name.<span class="property">value</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    age.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeGender</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    gender.<span class="property">value</span> = <span class="string">&#x27;女&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p>
<img src="/tsukimiya.github.io/images/vue3/computed.gif" style="zoom:20%; margin:0" />  

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;ref,computed&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let firstName = ref(&#x27;zhang&#x27;)</span><br><span class="line">  let lastName = ref(&#x27;san&#x27;)</span><br><span class="line"></span><br><span class="line">  // 计算属性——只读取，不修改</span><br><span class="line">  // 这么定义出来的fullname是个`ComputedRefImpl`对象</span><br><span class="line">  // 所以打印fullname的值应该.value，但是不能修改</span><br><span class="line">  /* let fullName = computed(()=&gt;&#123;</span><br><span class="line">    // 计算属性是有缓存的，方法是没有缓存的</span><br><span class="line">    // 它在第一次算完之后，再次使用的时候，数据没变，就直接拿上一次的计算结果来用</span><br><span class="line">    console.log(1) // 模版中使用多次计算属性，只会打印一个1</span><br><span class="line">    return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 计算属性——既读取又修改</span><br><span class="line">  let fullName = computed(&#123;</span><br><span class="line">    // 读取</span><br><span class="line">    get()&#123;</span><br><span class="line">      return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改</span><br><span class="line">    set(val)&#123; // 这里的val就是.value接收的值 -- li-si</span><br><span class="line">      console.log(&#x27;有人修改了fullName&#x27;,val)</span><br><span class="line">      firstName.value = val.split(&#x27;-&#x27;)[0]</span><br><span class="line">      lastName.value = val.split(&#x27;-&#x27;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function changeFullName()&#123;</span><br><span class="line">    // 这里没有修改任何东西，只是引起了fullname的set调用</span><br><span class="line">    fullName.value = &#x27;li-si&#x27;</span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><ul>
<li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li>
<li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：<blockquote>
<ol>
<li><code>ref</code>定义的数据。</li>
<li><code>reactive</code>定义的数据。</li>
<li>一个函数，返回一个值（相当于一个<code>getter</code>函数）。</li>
<li>一个包含上述内容的数组。</li>
</ol>
</blockquote>
</li>
</ul>
<p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p>
<h2 id="情况一-常用"><a href="#情况一-常用" class="headerlink" title="* 情况一(常用)"></a>* 情况一(常用)</h2><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况一：监视【ref】定义的【基本类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>点我sum+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    sum.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况一：监视【ref】定义的【基本类型】数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> stopWatch = <span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(newValue &gt;= <span class="number">10</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">stopWatch</span>() <span class="comment">// 解除监视 ，函数名就是定义的名称</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="* 情况二"></a>* 情况二</h2><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p>
<blockquote>
<p>注意：</p>
<ul>
<li><p>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</p>
</li>
<li><p>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了，去访问的时候都是已经改变过的值了。</p>
<blockquote>
<p>实际开发中，大多数情况下，我们是不管这个旧值的</p>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况二：监视【ref】定义的【对象类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson&quot;</span>&gt;</span>修改整个人<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">ref</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span>.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span>.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 通过字面量的形式，缔造一个全新的对象赋值给value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">value</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">90</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* </span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第一个参数是：被监视的数据</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第二个参数是：监视的回调</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    watch的第三个参数是：配置对象（deep、immediate等等.....） </span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">  */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>,<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// deep属性，开启深度监视，属性值改变也会触发</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// immediate属性，代表立即监视，一上来先执行一次，这个时候新的值是当前这个，旧的值是undefined</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况三"><a href="#情况三" class="headerlink" title="*  情况三"></a>*  情况三</h2><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况三：监视【reactive】定义的【对象类型】数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson&quot;</span>&gt;</span>修改整个人<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试：&#123;&#123;obj.a.b.c&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>修改obj.a.b.c<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">b</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">c</span>:<span class="number">666</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 地址值根本没有发生变化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 只能说批量的去修改了里面的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(person,&#123;<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">80</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span> = <span class="number">888</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 并且这里的深度监视是不能关闭的，这叫隐式的创建了深层的监听</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(obj,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Obj变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况四-常用"><a href="#情况四-常用" class="headerlink" title="* 情况四(常用)"></a>* 情况四(常用)</h2><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p>
<ol>
<li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li>
<li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，<strong>建议写成函数</strong>。<blockquote>
<p>如果直接监听，只能监听到属性改变，但是整体改变后监听就失效了<br> 写成函数监听，就和ref的对象数据监听一样了</p>
</blockquote>
</li>
</ol>
<p>结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC1&quot;</span>&gt;</span>修改第一台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC2&quot;</span>&gt;</span>修改第二台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>修改整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">car</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c1</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c2</span>:<span class="string">&#x27;宝马&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC1</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c1</span> = <span class="string">&#x27;奥迪&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC2</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c2</span> = <span class="string">&#x27;大众&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span> = &#123;<span class="attr">c1</span>:<span class="string">&#x27;雅迪&#x27;</span>,<span class="attr">c2</span>:<span class="string">&#x27;爱玛&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">  &#125;) */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">car</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.car变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="情况五-有几率"><a href="#情况五-有几率" class="headerlink" title="* 情况五(有几率)"></a>* 情况五(有几率)</h2><p>监视上述的多个数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>情况五：监视上述的多个数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123; person.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeAge&quot;</span>&gt;</span>修改年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC1&quot;</span>&gt;</span>修改第一台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeC2&quot;</span>&gt;</span>修改第二台车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar&quot;</span>&gt;</span>修改整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">age</span>:<span class="number">18</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">car</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c1</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">c2</span>:<span class="string">&#x27;宝马&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">age</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC1</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c1</span> = <span class="string">&#x27;奥迪&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeC2</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span>.<span class="property">c2</span> = <span class="string">&#x27;大众&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    person.<span class="property">car</span> = &#123;<span class="attr">c1</span>:<span class="string">&#x27;雅迪&#x27;</span>,<span class="attr">c2</span>:<span class="string">&#x27;爱玛&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 监视，情况五：监视上述的多个数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">name</span>,person.<span class="property">car</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.car变化了&#x27;</span>,newValue,oldValue)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h1><ul>
<li><p>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p>
</li>
<li><p><code>watch</code>对比<code>watchEffect</code></p>
<blockquote>
<ol>
<li><p>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</p>
</li>
<li><p><code>watch</code>：要明确指出监视的数据</p>
</li>
<li><p><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</p>
<blockquote>
<p>全自动的监视</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>需求：水温达到50℃，或水位达到20cm，则联系服务器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>水温：&#123;&#123;temp&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>水位：&#123;&#123;height&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePrice&quot;</span>&gt;</span>水温+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>水位+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref,watch,watchEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> temp = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> height = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changePrice</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    temp.<span class="property">value</span> += <span class="number">10</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    height.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用watch实现，需要明确的指出要监视：temp、height</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">watch</span>([temp,height],<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 从value中获取最新的temp值、height值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> [newTemp,newHeight] = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 室温达到50℃，或水位达到20cm，立刻联系服务器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(newTemp &gt;= <span class="number">50</span> || newHeight &gt;= <span class="number">20</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用watchEffect实现，不用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> stopWtach = <span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 室温达到50℃，或水位达到20cm，立刻联系服务器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(temp.<span class="property">value</span> &gt;= <span class="number">50</span> || height.<span class="property">value</span> &gt;= <span class="number">20</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>)?.<span class="property">innerText</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 水温达到100，或水位达到50，取消监视</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(temp.<span class="property">value</span> === <span class="number">100</span> || height.<span class="property">value</span> === <span class="number">50</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理了&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">stopWtach</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="标签的-ref-属性"><a href="#标签的-ref-属性" class="headerlink" title="标签的 ref 属性"></a>标签的 ref 属性</h1><p>作用：用于注册模板引用。</p>
<blockquote>
<ul>
<li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p>
</li>
<li><p><strong>用在组件标签上</strong>，获取的是<strong>组件实例对象</strong>。</p>
</li>
</ul>
</blockquote>
<p>用在普通<code>DOM</code>标签上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;title1&quot;</span>&gt;</span>尚硅谷<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">ref</span>=<span class="string">&quot;title2&quot;</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">ref</span>=<span class="string">&quot;title3&quot;</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;inpt&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showLog&quot;</span>&gt;</span>点我打印内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 创建一个title1，用于存储ref标记的内容</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 名称必须和标记的名称一致</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title1 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title2 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title3 = <span class="title function_">ref</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如果直接打印出来，由于setup执行是最早的，元素还没有渲染，所以是undefined</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title1.<span class="property">value</span>); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">showLog</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过id获取元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> t1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;title1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 打印内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>((t1 <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>((&lt;<span class="title class_">HTMLElement</span>&gt;t1).<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(t1?.<span class="property">innerText</span>)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过ref获取元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title1.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title2.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title3.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用在组件标签上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件<span class="title class_">App</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">ref</span>=<span class="string">&quot;ren&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Person.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> ren = <span class="title function_">ref</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ren.<span class="property">value</span>.<span class="property">name</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ren.<span class="property">value</span>.<span class="property">age</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>子组件<code>Person.vue</code>中要使用<code>defineExpose</code>宏命令<strong>暴露内容</strong><br>在app组件中直接打印出组件的实例对象，是看不到组件内的数据的，这是一种保护措施</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3最新版本已经内置了defineExpose,不需要引入了，是宏命令</span></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup name=<span class="string">&quot;Person&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;ref,defineExpose&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">	<span class="comment">// 数据</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line">  <span class="comment">/****************************/</span></span><br><span class="line">  <span class="comment">// 使用defineExpose将组件中的数据交给外部</span></span><br><span class="line">  <span class="title function_">defineExpose</span>(&#123;name,age&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TS接口</span></span><br><span class="line"><span class="comment">// 定义一个接口，限制每个Person对象的格式</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PersonInter</span> &#123;</span><br><span class="line"> <span class="attr">id</span>:string,</span><br><span class="line"> <span class="attr">name</span>:string,</span><br><span class="line"> <span class="attr">age</span>:number,</span><br><span class="line"> x?:number <span class="comment">// x是可有可无，有的话必须为number类型</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// TS 自定义类型 &amp; 泛型</span></span><br><span class="line"><span class="comment">// 定义一个自定义类型Persons</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Persons</span> = <span class="title class_">Array</span>&lt;<span class="title class_">PersonInter</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>中代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">:list</span>=<span class="string">&quot;persons&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;App&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Person</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Person.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 最新的规范，为了与值做区分，导入的类型要加type</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;type <span class="title class_">Persons</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 虽然let persons&lt;Persons&gt; = reactive([...])这样写没有报错，但是这种写法并没有使得规范生效</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// reactive对象，是支持泛型的</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> persons = reactive&lt;<span class="title class_">Persons</span>&gt;([</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e12&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e13&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">   &#123;<span class="attr">id</span>:<span class="string">&#x27;e98219e14&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王五&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">x</span>:<span class="number">9</span>&#125;</span></span><br><span class="line"><span class="language-javascript">  ])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Person.vue</code>中代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 新版vue3似乎也内置了defineProps和withDefaults,不需要引入</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//defineXXX，这种的一般都属于宏函数，在vue3里面不用引入</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;defineProps&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;type <span class="title class_">PersonInter</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;@/types&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第一种写法：仅接收</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// defineProps返回值是一个Proxy对象，包含所有你接收的东西</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// defineProps参数必须是字符串的数组，命名必须和传入的值保持一致(否则为undefined)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;list&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第二种写法：接收+限制类型（而且还是个必要传的值）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;<span class="attr">list</span>:<span class="title class_">Persons</span>&#125;&gt;()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 第三种写法：接收+限制类型+指定默认值+限制必要性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;&#123;list?:<span class="title class_">Persons</span>&#125;&gt;(),&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">list</span>:<span class="function">()=&gt;</span>[&#123;<span class="attr">id</span>:<span class="string">&#x27;asdasg01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;小猪佩奇&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// vue2中直接把props属性定义为对象类型default:xxx，就很简单</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul>
<li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，<strong>这些特定的函数统称为</strong>：<strong>生命周期钩子</strong></p>
<blockquote>
<p>生命周期、生命周期函数、生命周期钩子，都是指的生命周期</p>
</blockquote>
</li>
<li><p>规律：</p>
<blockquote>
<p><strong>生命周期</strong>整体分为<strong>四个阶段</strong>，<strong>八个钩子</strong>：<font color="red"><strong>创建、挂载、更新、销毁</strong></font>，<font color="green">每个阶段都有两个钩子</font>，一前一后。</p>
</blockquote>
<blockquote>
<p>这些是vue最为常用、最为基本的生命周期。<br>虽然vue的钩子(生命周期)不止8个，像是nextTick，路由守卫，缓存路由组件的钩子，但是只要掌握基本的这8个，其他的都可以现用现查现写</p>
</blockquote>
</li>
<li><p><code>Vue2</code>的生命周期</p>
<blockquote>
<p>创建阶段：<code>beforeCreate</code>、<code>created</code></p>
<p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p>
<p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p>
<p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p>
</blockquote>
</li>
<li><p><code>Vue3</code>的生命周期</p>
<blockquote>
<p><strong>创建阶段</strong>：<code>setup</code></p>
<p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p>
<p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p>
<p><strong>卸载阶段</strong>：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p>
</blockquote>
</li>
<li><p><strong>常用的钩子</strong>：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123; sum &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeSum&quot;</span>&gt;</span>点我sum+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue3写法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    sum.<span class="property">value</span> += <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setup&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 生命周期钩子</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeMount</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;挂载之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;挂载完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeUpdate</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onUpdated</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onBeforeUnmount</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;卸载完毕&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>vue解析流程</strong>：<br>任何一个组件都有生命周期，这就涉及到了父与子之间的生命周期顺序:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// App.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Person</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>父创建</code> – <code>父挂载前</code> – 子创建 – 子挂载前 – 子挂载完毕 – <code>父挂载完毕</code></p>
<blockquote>
<p>父 和 子 ， 子组件先挂载完<br>  解析流程：<br>  入口文件<code>index.html</code> 引入了<code>main.ts</code>，<code>main.ts</code>要把<code>App</code>挂到页面上，于是解析<code>App组件</code>。<br>  解析的时候发现<code>App组件</code>里面用到了<code>Person子组件</code>，它马上去忙<code>Person</code>，等把<code>Person</code>里面所有的东西都忙完了，然后就算<code>&lt;Person/&gt;</code>这一行解析完了(证明该调的钩子都调完了)<br>  <code>App</code>整个解析完了，就是<code>h1</code>这块解析完了</p>
</blockquote>
<p>  子是先执行的，父是最后的。所以<strong>App组件永远是最后挂载的</strong></p>
</li>
</ul>
<h1 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h1><ul>
<li><p>什么是<code>hook</code>？—— 把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</p>
<blockquote>
<p><strong>本质是一个函数</strong>，一个 .js&#x2F;.ts文件<br>  作用：<strong>封装</strong>，高内聚，低耦合。让一个功能的数据和方法贴在一起(不用hooks和vue2写法没太大区别)<br>正是有了hooks，组合式才发挥出来了威力！</p>
</blockquote>
</li>
<li><p>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</p>
</li>
<li><p>命名规范：useXXX</p>
</li>
<li><p>返回值: 返回值没有强制要求必须是对象，但是为了更好地组织和管理状态，以及提高代码的可读性，建议在组合函数中返回一个对象</p>
</li>
</ul>
<p>示例代码：</p>
<ul>
<li><p><code>useSum.ts</code>中内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出的必须是一个函数，并且没有名字！</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// hooks里面能写钩子！</span></span><br><span class="line">    <span class="title function_">increment</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据，写数组[]，甚至map容器都行，但是推荐写对象。</span></span><br><span class="line">  <span class="keyword">return</span> &#123;sum,increment,decrement&#125;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>useDog.ts</code>中内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios,&#123;<span class="title class_">AxiosError</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dogList = reactive&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDog</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发请求</span></span><br><span class="line">      <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)</span><br><span class="line">      <span class="comment">// 维护数据</span></span><br><span class="line">      dogList.<span class="title function_">push</span>(data.<span class="property">message</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      <span class="keyword">const</span> err = &lt;<span class="title class_">AxiosError</span>&gt;error</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载钩子</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">getDog</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;dogList,getDog&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中具体使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>点我-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-for</span>=<span class="string">&quot;(u,index) in dogList.urlList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;(u as string)&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;dogList.isLoading&quot;</span>&gt;</span>加载中......<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getDog&quot;</span>&gt;</span>再来一只狗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;defineComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> useSum <span class="keyword">from</span> <span class="string">&#x27;./hooks/useSum&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> useDog <span class="keyword">from</span> <span class="string">&#x27;./hooks/useDog&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;sum,increment,decrement&#125; = <span class="title function_">useSum</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> &#123;dogList,getDog&#125; = <span class="title function_">useDog</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="拓展-–-mixin"><a href="#拓展-–-mixin" class="headerlink" title="拓展 – mixin"></a>拓展 – mixin</h1><p>mixin是vue2的一种<strong>设计模式</strong>，用于<strong>实现组件间的代码复用</strong><br>通常会定义一组可复用的组件配置，如数据，计算属性，方法，生命周期钩子等，将其<strong>封装</strong>到一个如<code>myMixin.js</code>的文件中</p>
<p>工作原理：将 mixin 对象中的选项与组件自身的选项进行合并。如果 mixin 和组件中存在相同的选项，如 methods、data、computed 等，Vue 会按照一定的规则进行合并处理。例如：</p>
<ul>
<li>对于 data，mixin 中的数据会被合并到组件的数据对象中，如果有同名属性，则组件自身的 data 优先级更高，会覆盖 mixin 中的同名属性。</li>
<li>对于 methods、computed、watch 等，如果存在同名函数或属性，它们会被合并，不会覆盖，如果同名方法都存在，则两个方法都会执行（对于生命周期钩子，会将它们合并成数组，依次调用）。</li>
<li>对于生命周期钩子，如果 mixin 和组件都定义了同一个钩子函数，则这些函数会被合成一个数组，当生命周期事件触发时，这些函数会按照它们被发现的顺序依次调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 mixin</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello from mixin!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">showMsg</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在需要使用的vue组件中引入该文件：<code>import myMixin from &#39;./myMixin.js&#39;;</code><br>并挂载到mixin选项上：<code>mixins: [myMixin], // 引入mixin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单文件组件（.vue文件）中使用 mixin</span></span><br><span class="line"><span class="comment">// 或者是，在一个独立的JavaScript模块文件（如myComponent.js）中：</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> myMixin <span class="keyword">from</span> <span class="string">&#x27;./myMixin.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMsg</span>(); <span class="comment">// 使用来自mixin的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>侦听器</tag>
        <tag>计算属性</tag>
        <tag>生命周期</tag>
        <tag>Vue3</tag>
        <tag>组合式API</tag>
        <tag>setup语法糖</tag>
        <tag>ref</tag>
        <tag>reactive</tag>
        <tag>toRefs</tag>
        <tag>computed</tag>
        <tag>watch</tag>
        <tag>props</tag>
        <tag>hooks</tag>
        <tag>mixin设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinia - 符合直觉的Vue.js状态管理库</title>
    <url>/tsukimiya.github.io/2024/05/14/vue3/5.Pinia/</url>
    <content><![CDATA[<p>集中式状态(数据)管理，把需要共享的数据交给pinia管理</p>
<h1 id="准备一个效果"><a href="#准备一个效果" class="headerlink" title="准备一个效果"></a>准备一个效果</h1><img src="/tsukimiya.github.io/images/vue3/pinia_example.gif" alt="pinia_example" style="zoom:30%;border:3px solid" /> 

<h1 id="搭建-pinia-环境"><a href="#搭建-pinia-环境" class="headerlink" title="搭建 pinia 环境"></a>搭建 pinia 环境</h1><p>第一步：<code>npm install pinia</code></p>
<p>第二步：操作<code>src/main.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引入createPinia，用于创建pinia */</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建pinia */</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用插件 / 安装pinia */</span> </span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此时开发者工具中已经有了<code>pinia</code>选项</p>
<img src="/tsukimiya.github.io/images/vue3/pinia.png" style="zoom:80%;border:1px solid black;border-radius:10px" />

<h1 id="存储-读取数据"><a href="#存储-读取数据" class="headerlink" title="存储+读取数据"></a>存储+读取数据</h1><ol>
<li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p>
</li>
<li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p>
</li>
<li><p>具体编码：<code>src/store/count.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="comment">// 推荐和定义hooks一样用use命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体编码：<code>src/store/talk.ts</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">talkList</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada01&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,</span><br><span class="line">     		&#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada02&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada03&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中使用<code>state</code>中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123; sumStore.sum &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 引入对应的useXxxxxStore	</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;useSumStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/sum&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 调用useXxxxxStore得到对应的store</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> sumStore = <span class="title function_">useSumStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 虽然sumStore里面的sum是个ObjectRefImpl对象，但是这里，不能.value，会报错</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如let obj = reactive(&#123;a:1,b:1,c:ref(9)&#125;)，</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这里的c就应该直接obj.c，而不能加.value，因为外面已经帮我们处理好了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumStore.<span class="property">sum</span>) <span class="comment">// 直接拿</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumStore.<span class="property">$state</span>.<span class="property">sum</span>) <span class="comment">// 也可以这样，但是没必要</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;talk in talkStore.talkList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;talk.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; talk.content &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123;useTalkStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/talk&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> talkStore = <span class="title function_">useTalkStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="修改数据-三种方式"><a href="#修改数据-三种方式" class="headerlink" title="修改数据(三种方式)"></a>修改数据(三种方式)</h1><ol>
<li><p>第一种修改方式，<strong>直接修改</strong>(vuex中不允许直接修改，要借助mutation)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">666</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种修改方式：<strong>批量修改</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">  <span class="attr">sum</span>:<span class="number">999</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">value:number</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sum</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//操作countStore中的sum</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">value:number</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sum</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> -= value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中调用<code>action</code>即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用countStore</span></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应action</span></span><br><span class="line">countStore.<span class="title function_">incrementOdd</span>(n.<span class="property">value</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h1><blockquote>
<p>在组件中，我们每次使用store里的值，都需要在模版中如<code>&#123;&#123;countStore.sum&#125;&#125;</code>,每次使用都需要前面这一大长串。于是我们可以想到解构赋值:<br><code>const &#123; sum, school &#125; = countStore</code> ，但是这样数据就失去了响应式！<br>虽然可以借助<code>toRefs：const &#123; sum, school &#125; = Refs(countStore)</code><br>但是我们打印一下这个<code>Refs(countStore)</code>，可以发现它把整个store里面所有的属性(数据和方法)都打成了<strong>ref</strong>，虽然实现了，但是<strong>代价有点大</strong><br>所以，我们可以使用 —— <code>storeToRefs</code></p>
</blockquote>
<ul>
<li><p>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</p>
</li>
<li><p>注意：<code>pinia</code>提供的<code>storeToRefs</code><strong>只会将数据做转换</strong>，不会对方法进行ref包裹；而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中所有数据。</p>
</li>
<li><p>所取属性的数据类型：</p>
<ul>
<li>基本类型需要包裹，脚本文件中.value使用</li>
<li><strong>对象类型</strong>可以直接解构出来(还是响应式的)，也可以包裹(脚本文件中.value使用)<br>直接解构：<code>const &#123; talkList &#125; = talkStore</code>，然后直接talkList使用<br>包裹解构：<code>const &#123; talkList &#125; = storeToRefs(talkStore)</code>，在脚本文件中需要<code>talkList.value</code>使用</li>
</ul>
<blockquote>
<p>和toRefs基本一致？</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Count&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; useCountStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/count&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* 引入storeToRefs */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="comment">/* 得到countStore */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/* 使用storeToRefs转换countStore，随后解构 */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> &#123;sum&#125; = <span class="title function_">storeToRefs</span>(countStore)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h1><ol>
<li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p>
</li>
<li><p>追加<code>getters</code>配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">/************/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">   <span class="comment">// 如果不用this，这里就可以写成 箭头函数</span></span><br><span class="line">    <span class="attr">bigSum</span>:(state):<span class="function"><span class="params">number</span> =&gt;</span> state.<span class="property">sum</span> *<span class="number">10</span>,</span><br><span class="line">    <span class="title function_">upperSchool</span>():string&#123;</span><br><span class="line">     <span class="comment">// this就是store</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">school</span>.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">printThis</span>:<span class="function">()=&gt;</span><span class="variable language_">this</span>, <span class="comment">// 得到的是undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;increment,decrement&#125; = countStore</span><br><span class="line"><span class="keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="title function_">storeToRefs</span>(countStore)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="subscribe"><a href="#subscribe" class="headerlink" title="$subscribe"></a>$subscribe</h1><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p>
<ul>
<li>mutate：本次修改的信息</li>
<li>state：真正的数据</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line">talkStore.$subscribe(<span class="function">(<span class="params">mutate,state</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LoveTalk&#x27;</span>,mutate,state)</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(talkList.<span class="property">value</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// as 是断言，能取出来的字符串</span></span><br><span class="line">    <span class="comment">// 第一次是null，应该给个空数组默认值</span></span><br><span class="line">    <span class="attr">talkList</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> string) || []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h1><blockquote>
<p>就和setup语法糖很像</p>
</blockquote>
<ul>
<li><p>数据直接用ref、reactive去定义</p>
</li>
<li><p>直接写函数，就是actions函数</p>
</li>
<li><p>getters直接写computed</p>
</li>
<li><p><strong>必须return出去</strong></p>
</li>
<li><p><strong>缺点</strong>：页面数据多的时候，一堆return</p>
</li>
<li><p><strong>优点</strong>：不用写那么多层次和结构，清晰一点，易于维护</p>
<blockquote>
<p>选项式优点：易于理解和迁移，与传统的Vuex风格相似<br>缺点：代码量增加，不够简洁，尤其是在大型项目中</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// talkList就是state</span></span><br><span class="line">  <span class="keyword">const</span> talkList = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> <span class="built_in">string</span>) || []</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getATalk函数相当于action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getATalk</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:&#123;<span class="attr">content</span>:title&#125;&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 把请求回来的字符串，包装成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(),title&#125;</span><br><span class="line">    <span class="comment">// 放到数组中</span></span><br><span class="line">    talkList.<span class="title function_">unshift</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;talkList,getATalk&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>Pinia</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3其它 API</title>
    <url>/tsukimiya.github.io/2024/05/18/vue3/7.vue3%E5%85%B6%E4%BB%96API/</url>
    <content><![CDATA[<blockquote>
<p>使用场景不是很多，了解一下常用的</p>
</blockquote>
<h1 id="shallowRef-与-shallowReactive"><a href="#shallowRef-与-shallowReactive" class="headerlink" title="shallowRef 与 shallowReactive"></a>shallowRef 与 shallowReactive</h1><p>作用：提升性能</p>
<h2 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h2><ol>
<li><p>作用：创建一个响应式数据，但<strong>只对顶层属性进行响应式处理</strong>。</p>
<blockquote>
<p>如果是对象类型的数据，不再关注对象内部的属性，只关注对象整体(地址值是否变化)</p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(initialValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p>
</li>
<li><p>应用场景：只关心对象是否被整体替换，如服务器承诺每次返回的都是一个新的对象。</p>
<blockquote>
<p><strong>这个时候</strong>用shallowRef<strong>效率更高</strong>一些</p>
</blockquote>
</li>
</ol>
<h2 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h2><ol>
<li><p>作用：创建一个<strong>浅层响应式</strong>对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p>
<blockquote>
<p>属性值为非对象的，保持响应式 </p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来<strong>绕开深度响应</strong>。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可<strong>提升性能</strong>。</p>
</blockquote>
<h1 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h1><p><strong>作用：保护数据</strong></p>
<blockquote>
<p>readonly用的更多一点</p>
</blockquote>
<h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h2><ol>
<li><p>作用：用于创建一个对象的<strong>深只读副本</strong>。 &#x2F;&#x2F; 维护住关联关系，会跟着源对象变化</p>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> readOnlyCopy = <span class="title function_">readonly</span>(original); <span class="comment">// 参数只接收一个响应式对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ul>
<li>对象的所有嵌套属性都将变为只读。<blockquote>
<p>不过修改源对象，生成的对象也会同步修改(但是不能直接修改生成的只读对象)</p>
</blockquote>
</li>
<li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li>创建不可变的状态快照。</li>
<li>保护全局状态或配置不被修改。</li>
</ul>
</li>
</ol>
<h2 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h2><ol>
<li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p>
<blockquote>
<p>只处理浅层次的只读</p>
</blockquote>
</li>
<li><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> shallowReadOnlyCopy = <span class="title function_">shallowReadonly</span>(original);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ul>
<li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p>
</li>
<li><p>适用于只需保护对象顶层属性的场景。</p>
</li>
</ul>
</li>
</ol>
<h1 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h1><h2 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h2><ol>
<li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。<br>对原始对象修改，toRaw的对象也会同步修改</p>
<blockquote>
<p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。<strong>不建议保存对原始对象的持久引用，请谨慎使用</strong>。</p>
</blockquote>
<blockquote>
<p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以<strong>确保它们收到的是普通对象</strong></p>
</blockquote>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* toRaw */</span></span><br><span class="line"><span class="comment">// 响应式对象</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">let</span> rawPerson = <span class="title function_">toRaw</span>(person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citysd = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(person))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(rawPerson))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys2))</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h2><ol>
<li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p>
<blockquote>
<p>例如使用<code>mockjs</code>等第三方库时，为了防止误把<code>第三方库</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code>&#x2F;<code>第三方库</code></p>
<blockquote>
<p>如果误把mockjs变成响应式对象，会导致对里面任何一个小属性的修改都会被vue发现，有一定效率上的问题<br>mockjs 后端的接口还没有出现的时候，我们可以借助mockjs库去模拟接口</p>
</blockquote>
</blockquote>
</li>
<li><p>编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citys = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="customRef-自定义Ref"><a href="#customRef-自定义Ref" class="headerlink" title="customRef&#x2F;自定义Ref"></a>customRef&#x2F;自定义Ref</h1><blockquote>
<p>公司一般会 <strong>把自定义Ref封装成一个hooks</strong></p>
</blockquote>
<p>作用：创建一个<strong>自定义的</strong><code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p>
<blockquote>
<p>其实就是在原生ref基础上，加上自己的一些逻辑(比如延迟1s再更新数据)</p>
</blockquote>
<p><strong>核心</strong>：如何理解<code>track()</code>和<code>trigger()</code></p>
<ul>
<li>track()：监视msg的更新，<strong>一旦变化就更新页面</strong><blockquote>
<p>页面模板中，是取的msg的值，触发的是get</p>
</blockquote>
</li>
<li>trigger(): 通知Vue数据msg变化了(于是就会更新页面)<blockquote>
<p>msg被修改，就会触发set的调用</p>
</blockquote>
</li>
</ul>
<p>实现防抖效果（<code>useSumRef.ts</code>）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新页面(监视msg的更新)</span></span><br><span class="line">        <span class="keyword">return</span> initValue</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          initValue = value</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">//通知Vue数据msg变化了</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useSumRef <span class="keyword">from</span> <span class="string">&quot;@/hooks/useSumRef&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;msg&#125; = <span class="title function_">useSumRef</span>(<span class="string">&#x27;123&#x27;</span>,<span class="number">500</span>) <span class="comment">// msg初始值为&#x27;123&#x27;, 500毫秒后才更新页面</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3组件通信&amp;插槽</title>
    <url>/tsukimiya.github.io/2024/05/15/vue3/6.vue3%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1&amp;%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p>
<ul>
<li>移出事件总线，使用<code>mitt</code>代替。</li>
</ul>
<ul>
<li><code>vuex</code>换成了<code>pinia</code>。</li>
<li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li>
<li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li>
<li><code>$children</code>被砍掉了。</li>
</ul>
<p><font color="red"><strong>9个组件通信方式用处 及 选择:</strong></font></p>
<table>
<thead>
<tr>
<th></th>
<th>通信方式</th>
<th>通信类型、关系</th>
<th>特点</th>
<th>使用建议</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><font color="red">props</font></td>
<td>简单父&lt;&#x3D;&gt;子通信</td>
<td>传递数据或事件简单直接</td>
<td>更为直观和易于理解。<font color="red">推荐</font></td>
</tr>
<tr>
<td>2</td>
<td><font color="red">自定义事件</font></td>
<td>子-&gt;父</td>
<td>事件对象$event: 是调用emit时所提供的数据，可以是任意类型！使用v-on监听自定义事件</td>
<td>事件名推荐使用肉串命名(kebab-case形式)。<font color="red">推荐</font></td>
</tr>
<tr>
<td>3</td>
<td>mitt</td>
<td>任意组件通信</td>
<td>接收数据的组件提前绑好事件，提供数据的组件在合适的时候触发事件</td>
<td>和Event Bus相似，事件管理分散，难以跟踪事件流，<strong>难以维护</strong></td>
</tr>
<tr>
<td>4</td>
<td>v-model</td>
<td>父&lt;&#x3D;&gt;子通信</td>
<td><strong>本质：props传参+自定义事件</strong>，<strong>简化双向数据同步</strong></td>
<td>UI组件库底层使用</td>
</tr>
<tr>
<td>5</td>
<td>$attrs</td>
<td>祖&lt;&#x3D;&gt;孙(子为中介)</td>
<td>需要子组件作为中介，会自动排除子组件props中声明过的属性</td>
<td>影响组件封装性、属性重复定义以及影响渲染性能等。谨慎使用，不推荐</td>
</tr>
<tr>
<td>6</td>
<td>$refs、$parent</td>
<td>$refs：父→子、、 $parent：子→父</td>
<td>获取组件实例，可以操作暴露出去的数据</td>
<td>尽量少用，破坏封装</td>
</tr>
<tr>
<td>7</td>
<td>provide、inject</td>
<td>祖&lt;&#x3D;&gt;孙直接通信</td>
<td>对子组件0打扰</td>
<td>适合祖先到后代的数据传递，但谨慎防过度使用，不便于维护</td>
</tr>
<tr>
<td>8</td>
<td><a href="/tsukimiya.github.io/2024/05/14/vue3/5.Pinia/"><font color="red">pinia</font></a></td>
<td>任意组件通信</td>
<td>集中式状态(数据)管理</td>
<td>比vuex更优化，特别适合复杂状态共享。<font color="red">推荐使用</font></td>
</tr>
<tr>
<td>9</td>
<td>插槽slot</td>
<td><strong>本质 父&lt;&#x3D;&gt;子通信</strong></td>
<td>对结构复用，支持自定义结构，提高组件的可重用性和灵活性</td>
<td>UI组件库作用域插槽用的非常多，<strong>适合 父 控制 子 部分布局或内容的场景</strong></td>
</tr>
</tbody></table>
<p><strong>常见搭配形式：</strong></p>
<img src="/tsukimiya.github.io/images/vue3/组件通信.png" alt="组件通信" style="zoom:60%;" /> 

<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><blockquote>
<p>props是单向数据流，从父组件传递给子组件，而不能从子组件传递给父组件。<br>vue3与vue2的props不同的点在于：<strong>vue3可以传函数</strong><br>所以，vue2中，自定义属性props只能父传子，而子传父就需要借助自定义函数<br>但是，<strong>vue3中，自定义事件props不仅能够父传子，还能够子传父</strong>（通过 调用父的函数传参 的形式）</p>
</blockquote>
<p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p>
<ul>
<li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。 ———— 父给子，<strong>直接传值</strong></li>
<li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。 ———— 子给父，<strong>传参形式调用父的函数</strong>(父要先给子传一个函数)</li>
</ul>
<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>儿子给的玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:car</span>=<span class="string">&quot;car&quot;</span> <span class="attr">:getToy</span>=<span class="string">&quot;getToy&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> car = <span class="title function_">ref</span>(<span class="string">&#x27;奔驰&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> toy = <span class="title function_">ref</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">getToy</span>(<span class="params">value:string</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    toy.<span class="property">value</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我的玩具：&#123;&#123; toy &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>父给我的车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getToy(toy)&quot;</span>&gt;</span>玩具给父亲<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Child&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> toy = <span class="title function_">ref</span>(<span class="string">&#x27;奥特曼&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;car&#x27;</span>,<span class="string">&#x27;getToy&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ol>
<li>概述：自定义事件常用于：<strong>子 &#x3D;&gt; 父。</strong></li>
<li>注意区分好：原生事件、自定义事件。</li>
</ol>
<ul>
<li>原生事件：<ul>
<li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）	</li>
<li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li>
</ul>
</li>
<li>自定义事件：<ul>
<li>事件名是任意名称（<a href="https://cn.vuejs.org/guide/components/events.html#emitting-and-listening-to-events">官方<strong>推荐使用 kebab-case 形式</strong>(也叫<strong>肉串命名</strong>)来编写监听器&#x2F;自定义事件</a>）（<a href="https://v2.cn.vuejs.org/v2/guide/components-custom-events.html">vue2时候就已经有这个规矩了</a>）</li>
<li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！</strong ></li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;toy = $event&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件中，触发事件：</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;send-toy&#x27;</span>, 具体数据)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）、vue2的<code>$bus</code>功能类似，可以实现任意组件间通信。<br>mitt体积非常小，200byte，用不用项目体积几乎没有变化<br>因为vue3中没有全局事件总线，所以用这种插件替代</p>
<blockquote>
<p>他们都是一个套路：<br>接收数据的：提前绑好事件（提前订阅消息）<br>提供数据的：在合适的时候触发事件（发布消息）</p>
</blockquote>
<p>尽量不要使用全局事件总线vue2 - $bus，vue3 - mitt，会变得<strong>难以维护</strong>，provide&#x2F;inject也是一样尽量不要用</p>
<p><strong>语法</strong>：</p>
<ul>
<li>all：拿到所有绑定的事件<ul>
<li>clean：<code>emitter.all.clear()</code>，清空，清空所有绑定的事件</li>
</ul>
</li>
<li>emit：触发某一个事件</li>
<li>off：解绑某一个事件</li>
<li>on：绑定某一个事件</li>
</ul>
<p><strong>安装</strong><code>mitt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure>

<p>新建文件：<code>src\utils\emitter.ts</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter，emitter能绑定事件、触发事件</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure>
<p>在main.ts引入emitter<br>全局引入emitter？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/utils/emitter&#x27;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter，emitter能绑定事件、触发事件</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 绑定事件</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 触发事件</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;abc&#x27;,666)</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;xyz&#x27;,777)</span></span><br><span class="line"><span class="comment">  &#125;, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 清理事件</span></span><br><span class="line"><span class="comment">    emitter.all.clear()</span></span><br><span class="line"><span class="comment">  &#125;, 3000); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure>

<p><strong>接收数据的组件</strong>中：<strong>绑定事件</strong>、同时在<strong>销毁前解绑事件</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send-toy事件被触发&#x27;</span>,value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件卸载时，解绑事件，，如果不解绑，对内存不友好</span></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 解绑事件</span></span><br><span class="line">  emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>【第三步：<strong>提供数据的组件</strong>，在合适的时候<strong>触发事件</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;emitter.emit(&#x27;send-toy&#x27;,toy)&quot;</span>&gt;给弟弟玩具&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>,toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote>
<p>和vue2相比有一些变化<br>UI组件库底层，大量使用v-model进行通信</p>
</blockquote>
<ol>
<li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p>
</li>
<li><p>前序知识 —— <code>v-model</code>的<strong>本质</strong>（v-model用在HTML标签上 – 表单元素上）<br> v-model的底层，是一个动态的value值，<code>:value</code>,配合上<code>input事件</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用v-model指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-model的本质是下面这行代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;userName&quot;</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ts会爆红，因为$event可能为null —— 通过js new Event()出来的</span></span><br><span class="line"><span class="comment">加上&lt;&gt;是断言，告诉它就是个HTML输入类型的元素 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组件标签上</strong>的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p>
<blockquote>
<p>也就是绑定了一个props传参 + 一个自定义事件(接收每次修改的值)</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件标签上使用v-model指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件标签上v-model的本质 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- vue2用的是:value、@input=&quot;&quot;，Vue3是:modelValue、@update:modelValue // 它就是一个自定义事件，只是它命名里面带了冒号: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">:modelValue</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">update:model-value</span>=<span class="string">&quot;userName = $event&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- userName = $event的作用，和(val)=&gt;username = val是一样的 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于原生事件，$event就是事件对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于自定义事件，$event接收的就是触发事件时，传递过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AtguiguInput</code>组件中：</p>
<blockquote>
<p>这些，就是UI组件库底层做的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;AtguiguInput&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 接收props</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 声明事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:model-value&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p>
<blockquote>
<p>如果直接写<code>v-model=&quot;xxx&quot;</code> , 底层默认就是<code>:modelValue</code> + <code>update:modelValue</code><br> 当然也可以改这个名字，比如改成abc，就需要我们这样写：<code>v-model:abc=&quot;xxx&quot;</code>，<br> 在底层，就变成了<code>:abc=&quot;xxx&quot;</code>、<code>@update:abc=&quot;xxx = $event&quot;</code><br> 在组件中，封装的就不再是拿modelValue接收，而是拿<code>abc</code> 和 <code>update:abc</code>：<br> <code>defineProps([&#39;abc&#39;])</code>、<code>const emit = defineEmits([&#39;update:abc&#39;])</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 也可以更换value，例如改成abc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:abc</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上面代码的本质如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">:abc</span>=<span class="string">&quot;userName&quot;</span> @<span class="attr">update:abc</span>=<span class="string">&quot;userName = $event&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AtguiguInput</code>组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">:value</span>=<span class="string">&quot;abc&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       @<span class="attr">input</span>=<span class="string">&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;AtguiguInput&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 接收props</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">defineProps</span>([<span class="string">&#x27;abc&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 声明事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:abc&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>value</code>可以更换，那么就可以在组件标签上<strong>多次使用</strong><code>v-model</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AtguiguInput</span> <span class="attr">v-model:abc</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">v-model:xyz</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h2><ol>
<li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p>
</li>
<li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p>
<blockquote>
<p> 注意：<code>$attrs</code><strong>会自动排除</strong><code>props</code>中<strong>声明过的属性</strong>(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p>
</blockquote>
</li>
</ol>
<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">:a</span>=<span class="string">&quot;a&quot;</span> <span class="attr">:b</span>=<span class="string">&quot;b&quot;</span> <span class="attr">:c</span>=<span class="string">&quot;c&quot;</span> <span class="attr">:d</span>=<span class="string">&quot;d&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123;x:100,y:200&#125;&quot;</span> <span class="attr">:updateA</span>=<span class="string">&quot;updateA&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> b = <span class="title function_">ref</span>(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> c = <span class="title function_">ref</span>(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> d = <span class="title function_">ref</span>(<span class="number">4</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">updateA</span>(<span class="params">value</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    a.<span class="property">value</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GrandChild</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Child&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">GrandChild</span> <span class="keyword">from</span> <span class="string">&#x27;./GrandChild.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>孙组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grand-child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>孙组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>a：&#123;&#123; a &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>b：&#123;&#123; b &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>c：&#123;&#123; c &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>d：&#123;&#123; d &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>x：&#123;&#123; x &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>y：&#123;&#123; y &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateA(666)&quot;</span>&gt;</span>点我更新A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;GrandChild&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">defineProps</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;updateA&#x27;</span>])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="refs、-parent"><a href="#refs、-parent" class="headerlink" title="$refs、$parent"></a><code>$refs</code>、<code>$parent</code></h2><ol>
<li><p>概述：</p>
<ul>
<li><code>$refs</code>用于 ：<strong>父→子。</strong></li>
<li><code>$parent</code>用于：<strong>子→父。</strong></li>
</ul>
</li>
<li><p>原理如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$refs</code></td>
<td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td>
</tr>
<tr>
<td><code>$parent</code></td>
<td>值为对象，当前组件的父组件实例对象。</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li><p><code>$refs</code>使用 – 父-&gt;子<br><code>$refs</code>本身就是一个响应式的对象，里面再去读取ref( 组件实例c1 c2(响应式对象)身上的响应式对象toy、computer )，就不需要<code>.value</code><br>响应式对象<code>$refs</code>，里面包含 每一个组件实例(也是响应式对象)，每一个组件实例身上包含 暴露给父组件的响应式对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child1</span> ref=<span class="string">&quot;c1&quot;</span>/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Child2</span> <span class="attr">ref</span>=<span class="string">&quot;c2&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeToy&quot;</span>&gt;</span>修改Child1的玩具<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeComputer&quot;</span>&gt;</span>修改Child2的电脑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getAllChild($refs)&quot;</span>&gt;</span>让所有孩子的书变多<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child1</span> <span class="keyword">from</span> <span class="string">&#x27;./Child1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child2</span> <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref,reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">let</span> c2 = <span class="title function_">ref</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  c1.<span class="property">value</span>.<span class="property">toy</span> = <span class="string">&#x27;小猪佩奇&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeComputer</span>(<span class="params"></span>)&#123;</span><br><span class="line">  c2.<span class="property">value</span>.<span class="property">computer</span> = <span class="string">&#x27;华为&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要告诉程序，ref是对象，对象又是字符串的键，值不知道是什么 -- 否则飘红(ts)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAllChild</span>(<span class="params">refs:&#123;[key:string]:any&#125;</span>)&#123; <span class="comment">// 这里也可以直接any</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(refs)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> refs)&#123;</span><br><span class="line">    refs[key].<span class="property">book</span> += <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 子组件需要把数据交给外部</span></span><br><span class="line"><span class="comment">// child1把数据交给外部</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;toy,book&#125;)</span><br><span class="line"><span class="comment">// child2把数据交给外部</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;computer,book&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$parent</code>使用 – 子-&gt;父<br><code>$parent</code>也是一个响应式的对象，里面再去读取ref也不需要<code>.value</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;minusHouse($parent)&quot;</span>&gt;干掉父亲的一套房产&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minusHouse</span>(<span class="params">parent:any</span>)&#123;</span><br><span class="line">  parent.<span class="property">house</span> -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件同样将数据需要暴露出去</span></span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;house&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h2><ol>
<li><p>概述：实现<strong>祖孙组件</strong>直接通信</p>
</li>
<li><p>具体使用：</p>
<ul>
<li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li>
<li>在后代组件中通过<code>inject</code>配置来声明接收数据</li>
</ul>
</li>
<li><p>具体编码：</p>
<p>【第一步】父组件中，使用<code>provide</code>提供数据<br> 注意：不要去<code>.value</code>，因为你一旦<code>.value</code>，就是在取值了，这样就是把具体的值传进去，而不是传进去响应式的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>资产：&#123;&#123; money &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>汽车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;money += 1&quot;</span>&gt;</span>资产+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;car.price += 1&quot;</span>&gt;</span>汽车价格+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Father&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref,reactive,provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> money = <span class="title function_">ref</span>(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">brand</span>:<span class="string">&#x27;奔驰&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">price</span>:<span class="number">100</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 用于更新money的方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">updateMoney</span>(<span class="params">value:number</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    money.<span class="property">value</span> += value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 提供数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">provide</span>(<span class="string">&#x27;moneyContext&#x27;</span>,&#123;money,updateMoney&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p>
</blockquote>
<p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grand-child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是孙组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>资产：&#123;&#123; money &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>汽车：&#123;&#123; car &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateMoney(6)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;GrandChild&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 注入数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">let</span> &#123;money,updateMoney&#125; = <span class="title function_">inject</span>(<span class="string">&#x27;moneyContext&#x27;</span>,&#123;<span class="attr">money</span>:<span class="number">0</span>,<span class="attr">updateMoney</span>:<span class="function">(<span class="params">x:number</span>)=&gt;</span>&#123;&#125;&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果模版中写的是 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &lt;h4&gt;汽车 品牌&#123;&#123; car.<span class="property">brand</span> &#125;&#125; 金额 &#123;&#123; car.<span class="property">price</span> &#125;&#125;&lt;/h4&gt;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 这里的两个car.xxx就会飘红，但是不会报错，这里是因为它没有推断好</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果想要不爆红，可以通过默认值的形式，去帮助它推断：</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>,&#123;<span class="attr">brand</span>:<span class="string">&#x27;未知&#x27;</span>,<span class="attr">price</span>:<span class="number">0</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 如果没有传，那就是默认值，传了就不是 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h2><p>参考之前<code>pinia</code>部分的讲解</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p><img src="/tsukimiya.github.io/tsukimiya.github.io/images/vue3/default_slot.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">    &lt;<span class="title class_">Category</span> title=<span class="string">&quot;今日热门游戏&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Category</span>&gt;</span><br><span class="line">子组件中：</span><br><span class="line">    &lt;template&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 默认插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">    &lt;<span class="title class_">Category</span> title=<span class="string">&quot;今日热门游戏&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:s1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">s2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>更多<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Category</span>&gt;</span><br><span class="line">子组件中：</span><br><span class="line">    &lt;template&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;s2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>UI组件库用作用域插槽用的非常多，如：对话框、表格</p>
</blockquote>
<p>也就是，把数据传给组件的使用者。</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">   &lt;<span class="title class_">Game</span> v-slot=<span class="string">&quot;params&quot;</span>&gt;</span><br><span class="line">   &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">Game</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;params&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in params.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Game</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">子组件中：</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今日游戏榜单<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span> <span class="attr">a</span>=<span class="string">&quot;哈哈&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Category&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;英雄联盟&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王者荣耀&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;红色警戒&#x27;</span>&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#123;<span class="attr">id</span>:<span class="string">&#x27;asgdytsa04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;斗罗大陆&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     ])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3新组件</title>
    <url>/tsukimiya.github.io/2024/05/18/vue3/8.vue3%E6%96%B0%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><ul>
<li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li>
</ul>
<p>场景：<br>点击button按钮，会出现弹窗，我们想要弹窗fixed定位出现在视口中央位置<br>如果我们给父元素添加了一个filter滤镜样式，会发现定位失效了，它变成了相对父元素的定位，但是又不能删掉filter，这个时候，就可以用teleport</p>
<blockquote>
<p>当然，影响这个position: fixed的不仅仅有filter</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// to的意思是，modal弹出来的时候，塞到哪里去</span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&#x27;body&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是弹窗中的一些内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终，在页面呈现的时候，modal元素会从App里面出来，被放到主页面最下面，，而且它的逻辑不会拎出去</p>
<h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><ul>
<li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验 </li>
<li>使用步骤： <ul>
<li>异步引入组件</li>
<li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li>
</ul>
</li>
<li>使用场景：子组件在setup里面写了着异步任务，并且异步任务所提供的数据需要使用，想让它网速慢的时候也能呈现一些东西，就可以用Suspense</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span> // 底层是用插槽实现的</span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span> // 异步任务OK了才出现</span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span> // 异步任务没有做完的时候出现</span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.......<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>react路由懒加载时候 就是用suspense包裹 fallback定义loading</p>
</blockquote>
<h2 id="全局API转移到应用对象"><a href="#全局API转移到应用对象" class="headerlink" title="全局API转移到应用对象"></a>全局API转移到应用对象</h2><blockquote>
<p>这些都是vue2的一些全局API，vue3转移到了app实例对象身上（vue3里面是没有Vue构造函数的）<br>原来的<code>Vue.xxx</code>都变成了<code>app.xxx</code></p>
</blockquote>
<ul>
<li><code>app.component</code>：注册全局组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello</span> <span class="keyword">from</span> <span class="string">&#x27;./hello.vue&#x27;</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;Hello&#x27;</span>,<span class="title class_">Hello</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>app.config</code>：配置对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="comment">// 比如这个,x在任意组件都是可用的</span></span><br><span class="line"><span class="comment">// 不过不推荐使用这个globalProperties，污染全局</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">x</span> = <span class="number">99</span></span><br><span class="line"><span class="comment">// 不过在使用的时候会爆红，不过不会报错，因为组件文件里没有x</span></span><br><span class="line"><span class="comment">// 可以配置如下来解决： // vue文档有</span></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vue&#x27;</span> &#123;</span><br><span class="line">  interface <span class="title class_">ComponentCustomProperties</span>&#123;</span><br><span class="line">    <span class="attr">x</span>:number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>app.directive</code>：注册全局指令<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;beauty&#x27;</span>,<span class="function">(<span class="params">element,&#123;value&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  element.<span class="property">innerText</span> += value</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;h2 v-beauty=<span class="string">&quot;啊啊啊啊&quot;</span>&gt;好开心&lt;<span class="regexp">/h2&gt; /</span>/ 使用 --- 页面显示 黄色的 好开心啊啊啊啊</span><br></pre></td></tr></table></figure></li>
<li><code>app.mount</code>：挂载应用</li>
<li><code>app.unmount</code>：卸载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  app.<span class="title function_">unmount</span>() <span class="comment">// 2s后，页面没了</span></span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>app.use</code>：安装插件</li>
</ul>
<h2 id="其他-Vue3的非兼容性改变"><a href="#其他-Vue3的非兼容性改变" class="headerlink" title="其他 - Vue3的非兼容性改变"></a>其他 - <font color="red">Vue3的非兼容性改变</font></h2><blockquote>
<p>意思是：Vue3里面，做了哪些和Vue2里面不一样的 &#x2F;&#x2F; <a href="https://v3-migration.vuejs.org/zh/breaking-changes/">vue官方文档 - 从vue2迁移</a><br>也就是 ———— <strong>Vue2 和 Vue3的区别</strong>，所有人都得知道！</p>
</blockquote>
<ul>
<li><p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p>
</li>
<li><p><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</p>
<blockquote>
<p>vue2中可以@keyup.13，vue3中不允许了</p>
</blockquote>
</li>
<li><p><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></p>
<blockquote>
<p>vue2中可以 :a.sync&#x3D;’sum’，vue3中整合到v-model里了</p>
</blockquote>
</li>
<li><p><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</p>
<blockquote>
<p>vue2中，v-if和v-for不可以用在一个标签上，因为v-for优先级更高<br>  vue3中，可以在同一个元素使用，并且v-if的优先级提的更高了</p>
</blockquote>
</li>
<li><p>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</p>
</li>
<li><p>移除了过滤器 <code>filter</code>。</p>
</li>
<li><p>移除了<code>$children</code> 实例 <code>propert</code>。</p>
<p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/tsukimiya.github.io/hello%20world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello Front-end</title>
    <url>/tsukimiya.github.io/index.html</url>
    <content><![CDATA[<p>Welcome to my study blog! This is my continuously make up a main post. If you get any problems when using my blog, you can send the email to <a href="mailto:&#x68;&#x61;&#x72;&#x69;&#105;&#x6a;&#105;&#x63;&#x6f;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#46;&#x63;&#x6f;&#109;">&#x68;&#x61;&#x72;&#x69;&#105;&#x6a;&#105;&#x63;&#x6f;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#46;&#x63;&#x6f;&#109;</a></p>
<h2 id="Study-Guide"><a href="#Study-Guide" class="headerlink" title="Study Guide"></a>Study Guide</h2><center>Here provide you some study sources and study route.</center>
<!-- This is [main tech](#Main-Line) -->
<center>This is <a href='#Main-Line'>main tech</a></center>


<h3 id="Guide-Docs"><a href="#Guide-Docs" class="headerlink" title="Guide Docs"></a>Guide Docs</h3><ul>
<li>JS<ul>
<li><a href="https://wangdoc.com/javascript/">JavaScript 教程 - 阮一峰 | 网道</a></li>
<li>ECMAScript 6 教程– 阮一峰 <a href="https://es6.ruanyifeng.com/"><font color='red'>官方</font></a> <a href="https://wangdoc.com/es6/">网道镜像</a> <blockquote>
<p>网道(<a href="https://wangdoc.com/">https://wangdoc.com/</a>) 是一个文档网站，提供互联网开发文档。<br>  网道 PC显示更佳。阮一峰博客的移动端显示更佳</p>
</blockquote>
</li>
</ul>
</li>
<li>TS<ul>
<li><a href="https://wangdoc.com/typescript/">TypeScript 教程 - 阮一峰 | 网道</a></li>
<li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TypeScript入门教程 - xcatliu</a></li>
</ul>
</li>
<li>Vue<ul>
<li><a href="https://cn.vuejs.org/guide/introduction.html"><font color='red'>Vue.js 官方文档</font></a></li>
</ul>
</li>
<li>Git<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰</a></li>
</ul>
</li>
</ul>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><ul>
<li><p><a href="https://caniuse.com/">caniuse 浏览器兼容性查询</a></p>
</li>
<li><p><a href="https://gitee.com/">码云Gitee</a></p>
</li>
<li><p><a href="https://cn.vuejs.org/guide/introduction.html"><font color='red'>Vue.js 官方文档</font></a> </p>
</li>
<li><p><a href="https://www.iconfont.cn/">阿里巴巴矢量他图标库</a>(<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a>) <font color='red'> 推荐 </font></p>
</li>
<li><p><a href="https://regexr-cn.com/">正则表达式测试工具</a>(<a href="https://regexr-cn.com/">https://regexr-cn.com/</a>)</p>
</li>
<li><p>JQuery API 中文在线文档&#x2F;速查表</p>
<ul>
<li><p>by Shifone <a href="https://www.bejson.com/apidoc/jquery/">地址1</a> 地址2(<a href="https://jquery.cuishifeng.cn/">失效了</a>)（不过看过的一些API的解释和案例都写的不好）</p>
</li>
<li><p>by hemin <a href="http://hemin.cn/jq/"><font color='red'>地址</font></a> (解释和案例写的比较好)</p>
</li>
</ul>
</li>
<li><p><a href="https://www.lodashjs.com/">Loadsh 中文文档</a>(鲁大师) <font color='red'> 推荐 </font></p>
<blockquote>
<p>鲁大师 提供了许多牛逼的函数 节流、防抖、操作数组、对象的一系列函数（对象的深拷贝、浅拷贝）<br>轶事：lodash为什么叫lodash? lodash可以理解为low dash，dash就是中划线-，比较low的dash就是下划线_，因为之前有一个underscore类库，也是用下划线表示，开发一个新类，沿用以前的传统，所以就用了一个同义词lodash(low dash)。</p>
</blockquote>
</li>
<li><p><a href="https://quickref.cn/">Quick Reference</a></p>
</li>
<li><p><a href="https://base64.us/">Base64 在线编码解码</a>(<a href="https://base64.us/">https://base64.us/</a>)</p>
<blockquote>
<p>也可以选择图片文件来获取它的 Base64 编码的 DataURI 形式</p>
</blockquote>
</li>
<li><p><a href="https://www.bitbug.net/">比特虫 制作ico图标</a></p>
</li>
<li><p><a href="https://www.w3school.com.cn/html/html_entities.asp">HTML实体字符 - W3C</a></p>
</li>
<li><p><a href="https://www.xuanfengge.com/funny/html5/element/">HTML5元素周期表</a>(<a href="https://www.xuanfengge.com/funny/html5/element/">https://www.xuanfengge.com/funny/html5/element/</a>)</p>
</li>
</ul>
<h3 id="Necessary-Tech"><a href="#Necessary-Tech" class="headerlink" title="Necessary Tech"></a>Necessary Tech</h3><h4 id="Main-Line"><a href="#Main-Line" class="headerlink" title="Main Line"></a><font id='Main-Line' color='red'>Main Line</font></h4><ol>
<li><p>前端三剑客基础 HTML5 – CSS3 – JS5&#x2F;ES5</p>
<blockquote>
<p>H5引入了许多新特性和API，如语义化元素、表单控件、图形和多媒体元素，以及各种Web API等等<br>CSS3的新特性：如圆角(border-radius)、阴影(box-shadow、text-shadow)、渐变(gradient)、动画(animation)、过渡(transition)、弹性布局(flex)等</p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">黑马JS最新教程</a> (2023.1.31 | 60:10:24)<br> Pink老师最新版JS课程，主要讲解JS核心知识，包含最新ES6语法、API、js高级等<br> <a href="https://www.bilibili.com/video/BV1Y84y1L7Nn">https://www.bilibili.com/video/BV1Y84y1L7Nn</a></p>
</blockquote>
</li>
<li><p>三剑客进阶 移动Web&#x2F;<font color='red'>web API</font> – Less – Sass – <font color='red'>ES6</font></p>
<blockquote>
<p>移动web要学习一些web API、布局来更好的适配页面，如Flex 或是em vw vh等</p>
</blockquote>
<blockquote>
<p>Less、Sass可以说是css的超类</p>
</blockquote>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br> Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
<blockquote>
<p>ES6对JS进行了语法改进，还增加了<strong>类和继承、Promise等特性</strong>，最重要的是<strong>制定了模块化标准</strong>，为开发者提供了更好的开发工具和语言特性，使得JS变的更加现代化、强大灵活<br> <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">黑马ES6教程</a> (19.7.31 | 91-122p)<br> 阮一峰es6教程 – <a href="https://es6.ruanyifeng.com/"><font color="red">官方</font></a> | <a href="https://wangdoc.com/es6/intro">网道镜像</a> </p>
</blockquote>
</li>
<li><p>前端库&#x2F;工具 jQuery – bootStrap – ajax</p>
<blockquote>
<p>bootStrap开始是用jQuery库 + less 来实现的，后来慢慢移除了对jQuery的依赖，改用原生js来实现，也从less转成了sass</p>
</blockquote>
</li>
<li><p>版本管理工具 git</p>
<blockquote>
<p>不过一开始应该不会用到，可以在学过node之后再学更好些</p>
</blockquote>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">黑马Git教程</a>(17.1.16 | 75-101p | 4h5min)</p>
<blockquote>
<p>很细，可以结合下面的文章补充<br>  建议先看廖雪峰的教程到git安装的地方，再开始学这个，然后廖雪峰教程跟进<br>  <a href="https://www.bilibili.com/video/BV1zs411h74a?t=8.1&p=75">https://www.bilibili.com/video/BV1zs411h74a?t=8.1&amp;p=75</a></p>
</blockquote>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a> – 廖雪峰 </p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a><br>  因为是文章，所以会有地方不如视频直观明了，也有一些没说到的地方，但是也有很多视频中没有的东西</p>
</blockquote>
</li>
</ul>
</li>
<li><p>JS运行环境 ———— <font color='red'>Node.js</font></p>
<blockquote>
<p>Node.js是一个基于Chrome V8引擎的JS运行时环境，用于构建快速、可扩展的网络应用程序。之后，开发者就可以用JS来写服务端程序。</p>
<blockquote>
<p>node主要学习npm包管理器及各种包(工具)的使用<br> 学习node之后会让你更顺利的学习各种框架以及git<br> 学习node也会加深你对前后端交互以及后端的理解<br>Node.js采用非阻塞I&#x2F;O模型，能够高效处理大量并发请求，从响应效率上比同时代PHP更有优势</p>
</blockquote>
</blockquote>
<ul>
<li><strong>KoaJS</strong>(2013)<blockquote>
<p>Koa是Express的下一代框架，旨在解决Express中一些设计上的限制和缺陷，使得异步编程更加优雅、代码更加清晰、应用更急啊灵活</p>
</blockquote>
</li>
</ul>
</li>
<li><p>目前主流框架 <font color='red'>Vue(2014 尤雨溪) &#x2F; React(2013 Facebook)</font> &#x2F; <font color='#555'>Angular(2009 Google)</font></p>
<blockquote>
<ol>
<li><strong>Angular</strong>（不必要学，很多银行国企在用）(2009)<br>  2009年 由Google发布，引入了许多新概念，如双向数据绑定、依赖注入和模板化，为Web开发带来了革命性的变化，也为后续的SPA框架(单页面应用程序)发展奠定了基础。<br>  然而AngularJS是典型的“精英”框架，用后端思维设计的前端框架，直接沿用了MVC思想，加上很多首创的概念，比较晦涩难懂，因此不怎么流行<br>  angularjs和.net在国内同等命运，先进但无人问津，招人困难所以转vue+java</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>Vue</strong>(2014)<br>  Vue结合了Angular和React的优点，同时提供了更简洁的API和更灵活的设计，Vue的开发方式更像之前的套模版，使得开发者无缝过度，深受喜爱。<br>  Vue极为接地气，组件了活跃的社区，由社区编写了各语种的开发文档，每项说明都配上实例，还提供了各种应用场景的代码 DEMO<blockquote>
<p>Vue支持Webpack构建工具的使用<br>  原生Vue组件在js文件中的使用、Vue Cli脚手架、Element UI<br>  vue的核心原理（MVVM）、了解vue生命周期、组件传值、路由、vuex</p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>2.1 <strong>Nuxt.js</strong>(2016)<br>     在Next.js的启发下，Vue阵营出现了Nuxt，功能和Next几乎一模一样，给Vue提供了开箱即用的丰富功能和工具，使得Vue开发应用更加高效便捷<br>2.2 <strong>Uni-App</strong>(2018)（uni,unique,是统一的意思）<br>     是一款 使用Vue.js开发所有前端应用的 跨平台应用开发框架，开发者编写一套代码 基于Vue开发应用，可发布到iOS、Android、Web（响应式）&#x2F;H5、以及各种小程序、快应用等多个平台。<br>2.3 <strong>Vue3</strong>(2020)<br>     Vue3增加了组合式开发模式、增加了TS支持、引入了全新的Composition API，更加适应现代化前端的开发模式。同时，尤雨溪还推出了现代化前端构建工具Vite。<br>2.4 <strong>Vite</strong>(2020)<br>     Vite利用模块 热更新、按需编译等特性，为开发者提供了一种快速、轻量级、现代化的前端构建工具，填补了Webpack的性能瓶颈。</p>
</blockquote>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>React</strong>(2013)<br>  React引入了虚拟DOM的概念、组件化开发、单向数据流、使用JSX语法等等，极大的改变了前端的开发方式，推动了前端开发向组件化、高性能、高效率的方向发展。</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>3.1 <strong>React Native</strong>(2015)<br>     基于React开发的框架，使用JS和React的语法来构建原生移动应用。通过它，开发者可以使用相同的代码库构建同时运行在ios和Android平台上的原生应用。<br>3.2 <strong>Next.JS</strong>(2016)<br>     Next.JS是一个基于React的轻量级框架，提供了服务器端渲染、静态导出等功能，简化了React应用的开发和部署，使得React应用更易于优化和扩展，同时提供了更好的性能和SEO支持，成为构建现代Web应用的流行选择。 </p>
<blockquote>
<p>3.2.1 <strong>Server Actions</strong>(2023)<br>     2023年，Next.js14版本推出Server Actions，允许开发者直接在组件编写服务端代码,这张图被称作“科技圈最讨厌图片”，不少开发者困惑，这不就是PHP吗，因此Next.js也被戏称为Next.php<br>     <img width='300px' src='./images/Server%20Actions.png' /></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.3 <strong>Taro</strong>（2018）<br>     Taro除了是基于react之外，其他的功能与UniApp一模一样<br>     <code>2019年疫情爆发，人员统计、表单收集、健康码等等都是临时性、紧迫性的业务需求，没有现成的产品使用，过去呢种动辄上月甚至数年的开发周期显然不能满足，此时小程序承载了这一巨任，经常会有数天开发周期的小程序出现供防疫工作使用。在这里头UniApp和Taro充分发挥了它们的作用，尽管小程序是畸形发展的产物、UniApp和Taro开发会出现数不尽的兼容问题，但不可否认，这三年，它们对防疫工作的贡献是巨大的。</code></p>
</blockquote>
</blockquote>
<blockquote>
<ol start="4">
<li>React与Vue的对比<ol>
<li>国内比较推崇vue，而国外则比较偏爱React。目前国内中小公司仍以vue为主，不过部分也开始转向React，大公司则比较倾向React。</li>
<li>Vue使用模版语法，对元素实行绑定，是传统的HTML、CSS、JS分离式编程</li>
<li>React将用户界面抽象为组件的集合，强调组件之间的高度重用性，采用了反直觉的将HTML、CSS、JS封装在一起</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="PC-or-408-or-ELSE"><a href="#PC-or-408-or-ELSE" class="headerlink" title="PC or 408 or ELSE"></a>PC or 408 or ELSE</h4><ul>
<li><p>理解 OSI 模型和 TCP&#x2F;IP 协议族</p>
</li>
<li><p>学习 SSL&#x2F;TLS 协议和加密通信技术，保障网络通信的安全性。</p>
</li>
<li><p>掌握常见的安全协议如 HTTPS、SSH 等的原理和使用方法。</p>
</li>
<li><p><font color='red'>XXS 跨站脚本</font></p>
<blockquote>
<p>学习 XSS 攻击的基本原理，包括攻击者向网站注入恶意脚本代码，以及受害者浏览网站时执行恶意脚本的过程。</p>
</blockquote>
<blockquote>
<p>学习如何发现网站中的 XSS 漏洞，包括手动审查源代码、使用自动化工具进行漏洞扫描等方法。</p>
</blockquote>
<blockquote>
<p>学习反射型 XSS、存储型 XSS 和 DOM 型 XSS 等不同类型的 XSS 攻击，了解它们的区别和特点。</p>
</blockquote>
<blockquote>
<p>了解攻击者利用 XSS 漏洞进行的一些常见攻击，如窃取用户信息、会话劫持、网站篡改等。</p>
</blockquote>
</li>
<li><p>DDOS 分布式拒绝服务攻击</p>
<blockquote>
<p>网络攻击，旨在使目标系统或网络资源不可用，通常是通过使目标系统或网络过载或崩溃来实现的。攻击者利用大量的合法或非法的网络流量向目标系统发送请求，导致目标系统无法处理正常的用户请求，从而使其服务不可用。</p>
</blockquote>
</li>
</ul>
<h4 id="Else-Tech"><a href="#Else-Tech" class="headerlink" title="Else Tech"></a>Else Tech</h4><p>一些分支以及完全不是前端的技术</p>
<ul>
<li><p>构建工具 <strong>Webpack</strong>(2012)、Parcel</p>
<blockquote>
<p>在2016年，在ES6&#x2F;ES 2015的一剂强心丸的影响下，Webpack支持ES Module，Webpack开始在前端社区迅速流行。特别是在React和Vue等流行框架的支持下，Webpack的使用逐渐成为前端开发的标配</p>
</blockquote>
</li>
<li><p>包管理器<strong>npm</strong>、Yarn</p>
</li>
<li><p><strong>TypeScript</strong>（TS）(2012)</p>
<blockquote>
<p>2012年问世，由于JS是动态语言，意味着JS基本与大型项目无缘，或者需要承担巨大的维护代价，而TS的出现，使得JS可以像静态语言一样开发项目，赋予JS无限的可能。</p>
</blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV14Z4y1u7pi?t=27.0">黑马TS教程</a>(2020年 时长11:46:00)</li>
<li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TS入门教程</a> – (博客作者xcatliu) <font color='red'>推荐</font></li>
</ul>
</li>
<li><p>Electron(2013 GitHub)</p>
<blockquote>
<p>基于Chromium和Node.js的跨平台桌面应用程序开发框架，允许开发者使用Web技术来构建原生桌面应用</p>
</blockquote>
</li>
<li><p>Svelte(2016)</p>
<blockquote>
<p>Svelte 和 Vue、React一样都是现代化前端框架。<br>      不同的是，Svelte没有采用虚拟DOM技术，使得其更加轻巧。近年来，随着开发者对其性能优势和开发体验的认可，Svelte逐渐成为前端开发中备受推崇的框架之一。</p>
</blockquote>
<p>  SvelteKit(2021 Svelte官方)</p>
<blockquote>
<p>和Next、Nuxt相同功能的框架，极大丰富了Svelte生态系统</p>
</blockquote>
</li>
<li><p><strong>Tailwind CSS</strong>(2017)</p>
<blockquote>
<p>在React和Vue等组件化开发框架的发展下，DOM的复用不再是难题，在大型项目下，CSS的复用已经名存实亡，于是Tailwind CSS出现了。<br>  Tailwind CSS的设计理念是提供一组原子类，以快速构建样式，而不需要编写自定义的CSS，这一开发方式深受开发者喜爱，并成为Next框架的默认组件。至此，Sass、Less完成了它们的历史使命。</p>
</blockquote>
</li>
<li><p>Flutter(2017 Google)</p>
<blockquote>
<p>Flutter是一种用于构建跨平台移动应用的框架。可以同时在IOS、Android、Web和桌面平台运行。</p>
</blockquote>
</li>
<li><p>NestJS(2017)</p>
<blockquote>
<p>NestJS设计灵感来源于 Angular 框架，借鉴了其模块化、依赖注入和装饰器等概念，用于构建高效且可扩展的服务端应用程序，弥补了Node生态中的一些框架空白，加上对TS的支持，为JS开发大型后端应用打下基础</p>
</blockquote>
</li>
<li><p>ArkTS语言(2022 华为)</p>
<blockquote>
<p>华为确定改语言用于鸿蒙APP开发。是基于TS扩展的语言，意味着如果会Web前端，也就会鸿蒙应用开发。<br>  华为使用ArkTS语言，意味着瞬间拥有了大量的开发者基础，同时很可能促进所有的终端开发都采用JS，而那时前端技术将迎来大一统</p>
</blockquote>
</li>
<li><p>PHP(后端服务器)</p>
<blockquote>
<p>PHP是世界上最好的语言。</p>
</blockquote>
</li>
<li><p>Python(爬虫、脚本、大数据分析)</p>
</li>
<li><p>Java – Java框架 –Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud&#x2F;&#x2F;Sprint家族</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Pulled Post</title>
    <url>/tsukimiya.github.io/PulledPost/index.html</url>
    <content><![CDATA[<blockquote>
<p><code>Here are many posts pulling for you, hope you&#39;ll gain something.</code></p>
</blockquote>
<h1 id="Pulled-Bloger-or-Community"><a href="#Pulled-Bloger-or-Community" class="headerlink" title="Pulled Bloger or Community"></a>Pulled Bloger or Community</h1><ol>
<li><p><a href="https://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></p>
</li>
<li><p><a href="https://juejin.cn/">掘金</a></p>
</li>
<li><p>沧沧凉凉 – <a href="https://juejin.cn/user/1380642337065421">掘金</a> | <a href="https://www.zhihu.com/people/hatsune-87/posts">知乎</a></p>
</li>
<li><p>CS_Joe – <a href="https://juejin.cn/user/1398234518156301">掘金</a></p>
<blockquote>
<p>three.js</p>
</blockquote>
</li>
<li><p>小满zs – <a href="https://juejin.cn/user/2463384809252397">掘金</a> | <a href="https://space.bilibili.com/99210573">b站</a></p>
</li>
<li><p>CUGGZ – <a href="https://juejin.cn/user/3544481220801815">掘金</a></p>
</li>
<li><p>前端双越老师 – <a href="https://juejin.cn/user/1714893868765373">掘金</a></p>
</li>
<li><p><a href="https://javabetter.cn/blog.html">沉默王二的技术博客</a>（Java）</p>
</li>
<li><p>freecodecamp编程免费教学慈善组织 – <a href="https://www.freecodecamp.org/chinese/learn">官网</a> | <a href="https://www.freecodecamp.org/chinese/news/">专栏</a> | <a href="https://forum.freecodecamp.org/c/chinese/533">论坛</a></p>
<blockquote>
<p>官方支持中文，专栏和论坛有很多优质文章</p>
</blockquote>
</li>
<li><p><a href="https://www.xuanfengge.com/">轩枫阁</a></p>
<blockquote>
<p>前端大神的个人博客！腾讯微信前端工程师！ orz_<br> <a href="https://www.xuanfengge.com/funny/">SOME NB H5&amp;C3&amp;Animation orz_</a>(H5元素周期表就出自这里)<br> look older，but niubility build from 2013</p>
</blockquote>
</li>
</ol>
<h1 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h1><center><font>`工欲善其事，必先利其器`</font></center>

<ul>
<li><p><a href="https://u.tools/">uTools</a></p>
<blockquote>
<p>本地搜索、聚合翻译、OCR文字识别、MD笔记、文件批量重命名。一切皆插件，效率利器！</p>
</blockquote>
</li>
<li><p>Snipaste</p>
<blockquote>
<p>Windows截图工具，尚硅谷张天禹老师用的，可以缩放图片，比qq自带的强大！</p>
</blockquote>
</li>
<li><p>Xmind</p>
<blockquote>
<p>思维导图，黑马老师有用过</p>
</blockquote>
</li>
<li><p>Pxcook</p>
<blockquote>
<p>用来做一些网页样式设计图，可以测量尺寸和吸取颜色，渡一老师有用过</p>
</blockquote>
</li>
<li><p>windows自带剪切板 win + v</p>
<blockquote>
<p>剪切板历史记录，足够用了<br>更多的需求可以看看<strong>Ditto</strong>，除了丑该有的功能都有，而且安装之后只有15M<br>MAC的话，可以试试<strong>Paste</strong></p>
</blockquote>
</li>
<li><p>windows内置emoji键盘 win + .快捷键唤出</p>
</li>
</ul>
<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><ul>
<li><p><a href="https://blog.csdn.net/weixin_40004212/article/details/113627387">VSCode 的快捷键及常用插件总结</a></p>
<blockquote>
<p>快速复制当前代码到下一行、移动行、新建窗口、行缩进<br>ctrl + alt + ↓ 在下一行末尾增加一个光标</p>
</blockquote>
</li>
<li><p>ctrl + i ———— <strong>唤起代码提示</strong></p>
</li>
<li><p>复制链接 + 选中文字 + Ctrl v ———— <font color="red"><strong>vscode快速生成链接文字</strong></font></p>
</li>
</ul>
<h1 id="MD"><a href="#MD" class="headerlink" title="MD"></a>MD</h1><ul>
<li><p><a href="https://markdown.com.cn/extended-syntax/">Markdown官方教程</a><font color="red">Pull!!</font></p>
</li>
<li><p><a href="https://keatonlao.gitee.io/a-study-note-for-markdown/syntax/">markdown语法</a> <font color="red">Pull!!</font></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_40896997/article/details/106551767">markdown表情大全</a> <font color="red">Pull!!</font> – emoji表情，及其表情符号简码</p>
<blockquote>
<p><a href="https://www.toolhelper.cn/Encoding/Emoji"><font color="red">在线工具-Emoji表情符号(可搜索)</font></a> – 附有表情说明，及其Unicode编码</p>
</blockquote>
</li>
<li><p><a href="https://www.runoob.com/markdown/md-table.html">markdown表格语法</a>(菜鸟教程)</p>
</li>
</ul>
<h1 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h1><ul>
<li><p>推荐书籍</p>
<ol>
<li>JavaScript高级程序设计</li>
<li>JavaScript权威指南</li>
<li>你不知道的JavaScript</li>
</ol>
<ul>
<li><a href="https://wangdoc.com/javascript/">JavaScript 教程 - 阮一峰 | 网道</a></li>
<li>ECMAScript 6 教程 - 阮一峰 <a href="https://es6.ruanyifeng.com/"><font color='red'>官方</font></a> <a href="https://wangdoc.com/es6/">网道镜像</a> </li>
<li><a href="https://wangdoc.com/typescript/">TypeScript 教程 - 阮一峰 | 网道</a></li>
<li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TypeScript入门教程 - xcatliu</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰</a></li>
</ul>
</li>
</ul>
<ol>
<li><a href="https://www.xuanfengge.com/fe-books.html">Web前端开发推荐阅读书籍、学习课程下载</a> <font color="green">推荐书籍可参考!!</font>(轩枫阁)<blockquote>
<p>可惜太老了，15年的推荐，可以参考一下一些推荐的书籍</p>
</blockquote>
</li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol>
<li><a href="https://cloud.tencent.com/developer/article/1682440">谈谈HTML中锚点及其使用</a>(腾讯云)<blockquote>
<p>深度理解a元素 超文本锚点</p>
</blockquote>
</li>
</ol>
<h3 id="H5页面应用"><a href="#H5页面应用" class="headerlink" title="H5页面应用"></a>H5页面应用</h3><ol>
<li><a href="https://www.xuanfengge.com/funny/html5/spider/">逼真的蜘蛛</a>(轩枫阁)<blockquote>
<p>感觉和之前见到的一个博客磁吸线条成网的背景原理相似<br>又见到一个，不过这个不太明显 -&gt; <a href="https://www.cnblogs.com/wwj007/p/14308569.html">这里</a></p>
</blockquote>
</li>
</ol>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li><a href="https://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html">只要一行代码，实现五种 CSS 经典布局</a>（阮一峰 | 20.8.10）</li>
</ol>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol>
<li><a href="https://juejin.cn/post/7371716384847364147?share_token=47e2d958-ced3-4c78-8d58-f2790fa85d3b">log打印美化</a>（掘金 | 24.5.22）</li>
</ol>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><ol>
<li><a href="https://juejin.cn/post/7075162881498562590">Varlet，被尤雨溪推荐，这款开箱即用的Vue3组件库做对了什么</a>(掘金22&#x2F;3&#x2F;15)<blockquote>
<p>Varlet：一个基于 Vue3 开发的 Material 风格移动端组件库</p>
</blockquote>
</li>
</ol>
<h1 id="Blog-Build"><a href="#Blog-Build" class="headerlink" title="Blog Build"></a>Blog Build</h1><ul>
<li><a href="https://iknowwang.com/">如何架設網站：一個完全免費的教學（Blog推薦 + 網頁製作軟體 ）</a>(Wordpress)<blockquote>
<p>讲到了很多建设网站的东西</p>
</blockquote>
</li>
</ul>
<h2 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/37896471">WordPress搭建教程：手把手教你搭建WordPress博客</a>(知乎)<blockquote>
<p>域名推荐在 <a href="https://www.namesilo.com/?rid=d27fa32do">Namesilo</a> 购买，价格便宜，赠送永久免费的隐私保护。(0.99$&#x2F;第一年)<br>注册账户。注册信息建议如实填写，并勾选“Keep my information private”默认使用隐私保护。<br> 设置域名续费规则、注册时长等。在“Have a Coupon……”处输入优惠码 okoff 或者 go2think，点击“Submit”应用，优惠一美元。<br> 完成后点击“CONTINUE”付款，支持支付宝和 Paypal 等。</p>
</blockquote>
</li>
</ol>
<h2 id="Hexo-Next"><a href="#Hexo-Next" class="headerlink" title="Hexo + Next"></a>Hexo + Next</h2><ul>
<li><a href="https://hexo-next.readthedocs.io/zh-cn/latest/">Hexo-NexT官网文档</a></li>
</ul>
<ol>
<li><p><a href="https://cloud.tencent.com/developer/article/2065803">Hexo图标样式参考</a>(腾讯云)</p>
<blockquote>
<p>Hexo 支持FontAwesome图标，就是在代码中出现名字以fa fa开头的类名，本文介绍具具体图标来源和使用方法。</p>
</blockquote>
</li>
<li><p>post页面图片引用(self) </p>
<blockquote>
<p>hexo + next 似乎并不支持@作为索引根目录或source目录，至少试了不起作用<br> 可以将图片放到source的images文件下，然后用markdown引用<br> <code>![img](/images/xxx.png)</code><br> 在images前面有一个&#x2F;,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,如果想要更改可以修改_config.yml下的source_dir参数</p>
</blockquote>
<ul>
<li>参考文章 – <a href="https://blog.csdn.net/Miracle_ps/article/details/114791335">Hexo 添加图片</a>(CSDN)</li>
</ul>
</li>
<li><p>博客字体修改</p>
<blockquote>
<p>NexT默认使用微软雅黑，这里我将blog title修改为了 <a href="https://fonts.google.com/selection/embed">Miniver</a> 字体，size: 1.5<br> 详细请参考该文章：<a href="https://blog.csdn.net/sailist/article/details/104114578">Hexo-Next主题更改字体</a><br> 文中提到的字体网站：<a href="https://fonts.google.com/">Google Fonts</a></p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">添加自定义html页面</a>(CSDN)</p>
</li>
</ol>
<h1 id="408"><a href="#408" class="headerlink" title="408"></a>408</h1><h2 id="计算机网络原理"><a href="#计算机网络原理" class="headerlink" title="计算机网络原理"></a>计算机网络原理</h2><ul>
<li><p>计算机网络原理 谢希仁（第8版）课后习题 及 参考答案</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126150861">第一章–分组交换 &#x2F; 时延 &#x2F; 性能指标 &#x2F; OSI七层模型和TCP&#x2F;IP五层模型–网络体系结构</a>(CSDN&#x2F;答案不全)<br>  不全的部分参考这个 <a href="https://cloud.tencent.com/developer/article/2055618">Post</a> (腾讯云&#x2F;Q10开始排版不好)</li>
<li><a href="https://blog.csdn.net/weixin_62985813/article/details/134105653">第二章–物理层</a>(CSDN)</li>
<li><a href="https://blog.csdn.net/weixin_45773137/article/details/126276788">第三章–数据链路层</a>(CSDN)<ul>
<li><a href="https://blog.csdn.net/qq_51646682/article/details/124768543"><font color="green">单元测试(习题+答案+图文解析)</font></a>(CSDN)</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/qq_56919740/article/details/128908573">第四章–网络层</a>(CSDN)<ul>
<li><a href="https://blog.csdn.net/qq_51646682/article/details/125360799"><font color="green">单元测试(习题+答案+图文解析)</font></a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/qq_56919740/article/details/129649988">第五章–运输层</a>(CSDN&#x2F;答案不全)<br>  <a href="https://zhuanlan.zhihu.com/p/496603918?eqid=c1eba5ff0000988f00000006648b3851">参考这个，答案解释的比较详细</a>(知乎)<ul>
<li><a href="https://blog.csdn.net/qq_51646682/article/details/125858505">单元测试(习题+答案+图文解析)</a>(CSDN) – 这个测试题就和学的不一样了</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/qq_51344334/article/details/121409933">第六章–应用层</a>(CSDN)<ul>
<li><a href="https://blog.csdn.net/qq_51646682/article/details/126301611"><font color="green">单元测试(习题+答案+图文解析)</font></a>(CSDN)  </li>
<li><a href="https://blog.csdn.net/qq_43518425/article/details/111828744">在浏览器输入http://xxx并按回车，直到网站显示在浏览器中。按照TCP/IP参考模型，从应用层到网络接口层都用到了哪些协议，作用是什么？简要描述该过程。</a>(CSDN)</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/weixin_51261234/article/details/121876379"><font color="red">计算机网络重点回顾</font></a>(CSDN&#x2F;总结) —— 作者: <a href="https://blog.csdn.net/weixin_51261234?type=blog">高稚气菌</a></p>
</li>
</ul>
<h1 id="ELSE"><a href="#ELSE" class="headerlink" title="ELSE"></a>ELSE</h1><ol>
<li><a href="https://www.wangeditor.com/">wangEditor – 开源 Web 富文本编辑器</a> – <a href="https://www.wangeditor.com/demo/index.html">demo</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/tsukimiya.github.io/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Array API | 数组方法 | 数组函数</title>
    <url>/tsukimiya.github.io/custom/api.html</url>
    <content><![CDATA[
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <title>API | Ayu's Study Blog</title> -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.js"></script>
    <style>
        ul{
            list-style: decimal;
        }
        .nav-level-3::marker{
            display: none;
        }
        h3{
            margin-left: -30px;
        }
    </style>
</head>

<body>
    <div id="app">
        <button @click="toggleMode(1)">按照首字母排序</button>
        <button @click="toggleMode(2)">按照功能归类排序</button>
        <!-- 让带有h3标题的mode2在上，好让hexo解析不带::marker的h3标题 -->
        <ul v-show="mode==2">
            <ul v-for="(t,i) in types">
                <h3 :id="'t' + (i+1)" v-text="i+1 + '. ' + t">这里是功能排序</h3>
                <!-- 为了让id正确，必须过滤一下符合type的方法，否则是按照原来api对象的位置索引 -->
                <li v-for="(item,index) in apioftype(t)">
                    <h4 v-text="item.name" v-if="false"></h4>
                    <details><summary><span :id="'t' + (i+1) +'f' + (index+1)" class="h4List1" v-text="item.name"></span>&nbsp;&nbsp;&nbsp;<a :href="item.address" target="_blank">more in MDN</a></summary>
                        <pre><span v-html="item.describe"></span><br v-if="item.describe"><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.use"></code><br v-if="item.use"><br v-if="item.use"><span v-if="item.syntax">语法:<br></span><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.syntax"></code><br v-if="item.syntax"><span v-if="item.param">参数:</span><p v-if="item.param" v-text="item.param"></p><span v-if="item.return">返回值：</span><span v-text="item.return"></span></pre>
                    </details>
                </li>
            </ul>
        </ul>

        <ul v-show="mode==1">
            <!-- <h3>字母排序</h3> -->
            <li v-for="(item,index) in apiofletter()">
                <!-- hexo不支持插值表达式 -->
                <!-- h4是为了让hexo解析出来 .nav-level-4 层级的目录，并不让它出现在页面上 -->
                <!-- 因为把mode2放在了上面，所以不需要这里再有了 -->
                <!-- <h4 v-text="item.name" v-if="false" :id="'n' + index"></h4> -->
                <details><summary><span :id="'n' + (index+1)" class="h4List1" v-text="item.name"></span>&nbsp;&nbsp;&nbsp;<a :href="item.address" target="_blank">more in MDN</a></summary>
                    <pre><span v-html="item.describe"></span><br v-if="item.describe"><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.use"></code><br v-if="item.use"><br v-if="item.use"><span v-if="item.syntax">语法:<br></span><code class="language-javascript" style="background-color: rgb(255, 255, 255);"  v-html="item.syntax"></code><br v-if="item.syntax"><span v-if="item.param">参数:</span><p v-if="item.param" v-text="item.param"></p><span v-if="item.return">返回值：</span><span v-text="item.return"></span></pre>
                </details>
            </li>
        </ul>
        <!-- <div style="width:100%;height:1600px;background-color: red;"></div> -->
    </div>


    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="./api.js"></script>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/tsukimiya.github.io/custom/api.js</url>
    <content><![CDATA[let vm = new Vue({
    el: '#app',
    data: {
        mode: 1,//值为1 和 2 代表两个种类
        types:[ // 这个依旧按照首字母排序
            "过滤 | 筛选",
            '循环 | 遍历',
            "查找 | 查询",
            "判断",
            "累加器",   
        ],
        node1:'',
        node2:'',
        // forEach 遍历
        api: {
            //这个模板可以删掉，只是方便添加数据，不影响页面
            like: {
                type: '',
                name: '',
                address: '',
                describe: ``,
                use:
                    ``,
                syntax:
                    ``,
                param:
                    ``,
                return: '',
            },
            every: {
                type: '循环 | 遍历 | 判断',
                name: 'Array.prototype.every()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every',
                describe: '每一项都满足判断条件就得到true，只要有任何一项不满足就是false，后面的元素都不会再执行。<br>不会对空数组进行检测，不会改变原始数组',
                use:
`[1,2,3,4,5].every((num)=>num<10) // true
[1,2,3,4,5].every((num)=>num>1) // false`,
                syntax:
`every(callbackFn)
every(callbackFn(element,index,array), thisArg)`,
                param:
                    ``,
                return: '布尔值 true/false',
            },
            filter: {//按照首字母排序
                type:'过滤 | 筛选',
                name: 'Array.prototype.filter()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter',
                describe: 
`filter()方法创建给定数组一部分的浅拷贝 -- 返回一个新数组
filter对空数组不会进行检测，不会改变原始数组。`,
                use:
`[1,2,3,4,5].filter((num)=>num>3) // [4, 5]
[1,2,3,4,5].filter((num)=>true) // [1,2,3,4,5]`,
                syntax: 
`filter(callbackFn)
filter(callbackFn(element,index,array), thisArg)`,
                param: 
`1. callbackFn: 为数组中的每个元素执行的函数。它应该返回一个真值以将元素保留在结果数组中，否则返回一个假值。
    该函数被调用时将传入以下参数：
    element: 数组中当前正在处理的元素。
    index: 正在处理的元素在数组中的索引。
    array: 调用了 filter() 的数组本身。
2. thisArg(可选): 执行 callbackFn 时用作 this 的值。参见迭代方法。`,
                return: '返回给定数组的一部分的浅拷贝，其中只包括通过提供的函数实现的测试的元素。如果没有元素通过测试，则返回一个空数组。',
            },
            forEach: {
                type: '循环 | 遍历',
                name: 'Array.prototype.forEach()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach',
                describe: 
`forEach() 方法对数组的每个元素执行一次给定的函数。是一个迭代方法。
不会改变其调用的数组，不过可以在callbackFn函数中操作原数组参数array来实现修改
除非抛出异常，否则没有办法停止或中断 forEach() 循环。`,
                use:
`let arr = [1,2,3,4,5]
arr.forEach((num)=>{ num++ })
arr // [1,2,3,4,5],不会改变原数组

arr.forEach((num,index,arr)=>{ arr[index]=index; })
arr // [0,1,2,3,4] , 可以这样来修改原数组`,
                syntax:
`forEach(callbackFn)
forEach(callbackFn(element,index,array), thisArg)`,
                param:
                    ``,
                return: 'undefined',
            },
            reduce: {
                type: '累加器',
                name: 'Array.prototype.reduce()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce',
                describe: `累加器。<br>可以用来计算一组数据的和，每次循环return的值，都会作为下次循环的初始值`,
                use:
`[1,2,3,4,5].reduce( (total,num)=>total+num ) // 15 -- 所有数值的累加和 循环4次
[1,2,3,4,5].reduce((total,num)=>total+num),20) // 35 -- 从初始值20开始累加 循环5次

[1,2,3,4,5].reduce((total,num)=>{
    //没有初始值，第一个数值被赋值给了total作为初始值，函数执行4次
    console.log(total + ' ' + num); // 1 2, 3 3, 6 4 , 10 5
    return total + num;
}) // 15
[1,2,3,4,5].reduce((total,num)=>{
    //传了初始值，函数执行5次
    console.log(total + ' ' + num); // 20 1, 21 2, 23 3, 26 4, 30 5
    return total + num;
},20) // 35

// reduce()函数还可以进行一些复杂的处理，如：融合对象
// 简单的示例：
let c = {c:'c'}; 
[{a:'a'},{b:'b'}].reduce((mix,item)=>Object.assign(mix,item),c)
// 这里作用等同于
Object.assign(c,...[{a:'a'},{b:'b'}]) // c: {a:'a',b:'b',c:'c'}
更复杂的实例参考：
ES6 - 对象的新增方法 - Object.getOwnPropertyDescriptors方法最后一个例子
https://es6.ruanyifeng.com/#docs/object-methods#Object-getOwnPropertyDescriptors`,
                syntax:
`array.reduce(callbackFn(total,currentValue)) //必选的参数
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`,
                param:
                    ``,
                return: '返回最终的累加值 total',
            },
            some: {
                type: '循环 | 遍历 | 查找 | 查询 | 判断',
                name: 'Array.prototype.some()',
                address: 'https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some',
                describe: `forEach虽然能实现我们的需求，但是性能比较差，不能被终止。<br>从数组里面找元素用some比较合适，因为some找到那一项之后，就可以终止后续的循环`,
                use:
`[1,2,3,4,5].some((item,index)=>{
    console.log(item);// 1 2 3
    if(item == 3){
        return true;//在找到对应的项之后，可以通过 return true 固定语法终止some循环
    }
}) // 这里函数会返回个true，是因为找到了3执行了我们写的return true
[1,2,3,4,5].some(item=>item==3)  
[1,2,3,4,5].some(item=>item>6) //这里返回的false，是数组中没找到符合的元素`,
                syntax: 
`forEach(callbackFn)
forEach(callbackFn(element,index,array), thisArg)`,
                param: 
``,
                return: '可以认为返回true就是找到了，false就是没找到.因为基本上是会给一个判断来查找数组元素的',
            },
            like: {
                type: '',
                name:'',
                address:'',
                describe:``,
                use: 
``,                
                syntax: 
``,
                param:
``,
                return:'',
            },
            like: {
                type: '',
                name: '',
                address: '',
                describe: ``,
                use:
                    ``,
                syntax:
                    ``,
                param:
                    ``,
                return: '',
            },
        }
    },
    computed: {
        
    },
    methods: {
        apioftype(type) {
            return Object.values(this.api).filter((obj) => obj.type.includes(type));
        },
        apiofletter() {
            return Object.values(this.api).filter((obj) => obj.name !='');
        },
        initNavList(){
            // 1. 获取nav列表第三级别的li元素 和 第四级别的li
            let list3 = document.querySelector('.nav-level-3');
            let list4 = document.querySelector('.nav-level-4');
            // 这里只有一个四级子元素，用于后面克隆用
            let originList3 = list3.cloneNode(true);
            
            // 2.获取列表的nav父元素,等后面往里面添加生成的div节点，包住li目录
            let nav = list3.parentNode;
            // console.log(nav);
            // 包着两个列表的div，用来控制显示
            this.node1 = document.createElement('div');
            this.node2 = document.createElement('div');

            // 3. 生成按照功能排序的列表内容，并将其封装到node2中
            this.types.forEach((item, index1) => {
                // console.log(item + ' ' + index);
                let index = index1 + 1;//让索引从零开始
                if(index == 1){// 第一个，修改得到的list3的值
                    this.changeTypeList(list3, index, item);
                    this.node2.append(list3);
                } else {//克隆一份修改
                    let cloneList = originList3.cloneNode(true);
                    this.changeTypeList(cloneList, index, item);
                    this.node2.append(cloneList);
                }
            })
            // 4. 生成按照字母排序的列表内容，并将其封装到node1中
            // 过滤得到所有的存在name的方法，遍历
            Object.values(this.api).filter((obj) => obj.name).forEach((obj, i) => {
                let index = i + 1; // 所以从1开始
                // 这里就不需要分情况了，直接全部克隆自 list4(因为这是list3下的)
                let cloneList = list4.cloneNode(true);
                this.changeList(cloneList, index, obj.name, 'n');
                // 直接添加到node1节点中
                this.node1.append(cloneList);
            })

            // 5. 将nav中的原来的列表移除，然后把node1 node2节点添加进去
            nav.innerHTml = '';
            nav.append(this.node1,this.node2);
            this.toggleDisplay(1);//默认是node1显示
        },
        changeTypeList(node,index,item){//完成每一个type目录及其子目录的初始化
            // 这里只修改了三级索引的值,t是三级的type
            // 如果传入的是t，返回里面的四级li子元素
            let child = this.changeList(node, index, item, 't');
            let id = 't'+index;//用来做这个类下方法的id前缀，防止每个类下的id重复(第一个都是f1)
            // 过滤得到所有的该item分类的方法
            Object.values(this.api).filter((obj) => obj.type.includes(item)).forEach((obj,index) => {
                index++;//索引从1开始
                if (index == 1) {//修改值
                    this.changeList(child, index, obj.name, id+'f');
                } else {//克隆一份再修改
                    let cloneList = child.cloneNode(true);
                    this.changeList(cloneList, index, obj.name, id +'f');
                    // 添加到node节点的第二个子元素ol中
                    node.children[1].append(cloneList);
                }
            })
        },
        // id传 t、f、n三种，对应功能排序的三级、四级 和 字母排序的四级
        changeList(node,index,name,id){//修改List的内容
            let a = node.children[0];
            a.href = '#' + id + index; 
            // console.log();
            let number = a.children[0];
            let text = a.children[1];
            number.textContent = index + '.';
            text.textContent = name;
            if(id == 't'){// 返回三级索引子元素
                return node.children[1].children[0];
            }
        },
        toggleDisplay(m){
            // m = 1，node1显示，node2消失
            // m = 2，node1消失，node2显示
            let show = ['none','block','none']
            this.node1.style.display = show[m];
            this.node2.style.display = show[m-1];
        },
        toggleMode(m){
            if(this.mode == m) // 已经是当前模式，直接return
            return ;
            this.mode = m;
            this.toggleDisplay(m);
        }
    },
    mounted(){
        this.initNavList();
        // console.log(this.node1);
    }
})]]></content>
  </entry>
  <entry>
    <title>Cuntom Page</title>
    <url>/tsukimiya.github.io/custom/index.html</url>
    <content><![CDATA[<blockquote>
<p>Take a look at some of the pages created by me.<br>  <font color=violet>Tips: Unrendered pages are not searchable.</font></p>
</blockquote>
<ol start="0">
<li><p><a href="api.html">Array API | 数组方法 | 数组函数</a></p>
</li>
<li><p><a href="./npmAPI.html">npm - 常用包 | 第三方模块</a></p>
</li>
<li><p><a href="pages/ClickCopyTool.html" target='_blank'>点击文字复制工具 &amp; 按行切分</a></p>
<blockquote>
<p>点击文本，即可复制到剪切板<br>需要添加功能：提供一个输入框，把输入的内容按照行分割，然后生成对应的可复制文本块<br>添加个一键复制的功能，按照顺序把每块内容复制到剪切板(依次触发click事件)</p>
</blockquote>
</li>
<li><p>根据数据生成数据折线图</p>
<blockquote>
<p>输入对应的数据，可以生成对应的数据折线图<br>   修改某个数据，折线图会动态更新，且附带动画过渡效果<br>   可以设置折线图的颜色：线条、背景、节点圆圈<br>用vue2 + echarts?实现？ –<br>先用vue2+js实现，再考虑用vue3+echarts重构吧</p>
</blockquote>
<blockquote>
<p>另外可以用数据直接生成直线图，饼状图等统计图</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/tsukimiya.github.io/guestbook/index.html</url>
    <content><![CDATA[<h1 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的博客！</h1><blockquote>
<p>欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的。目前留言板块尚未配置完全，暂时无法使用，如有问题请邮箱：<br><a href="mailto:&#104;&#97;&#x72;&#105;&#x69;&#106;&#x69;&#99;&#111;&#x40;&#111;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#x6f;&#109;">&#104;&#97;&#x72;&#105;&#x69;&#106;&#x69;&#99;&#111;&#x40;&#111;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#x6f;&#109;</a><br><a href="mailto:&#x31;&#x38;&#51;&#x32;&#55;&#x31;&#x35;&#x38;&#51;&#56;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#x31;&#x38;&#51;&#x32;&#55;&#x31;&#x35;&#x38;&#51;&#56;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a><br>欢迎给我发送邮件</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>常用包 | 第三方模块</title>
    <url>/tsukimiya.github.io/custom/npmAPI.html</url>
    <content><![CDATA[<blockquote>
<p>Here are some common Node package.<br>    在这里 -&gt; <a href="https://www.npmjs.com/">https://www.npmjs.com</a> 可以查询包及其用法</p>
</blockquote>
<h2 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h2><blockquote>
<p>全局包会被安装到C:\Users\用户目录\AppData\Roaming\npm\node _modules目录下。<br>    <code>npm i 包名 -g</code> #全局安装指定的包<br>    <code>npm uninstall 包名 -g</code> #卸载全局安装的包</p>
</blockquote>
<ul>
<li>npm i xxx</li>
</ul>
<h2 id="项目包-开发依赖包"><a href="#项目包-开发依赖包" class="headerlink" title="项目包 - 开发依赖包"></a>项目包 - 开发依赖包</h2><blockquote>
<p>被记录到devDependencies节点中的包，只在开发期间会用到<br>    简写：<code>npm i 包名-D</code>  (<code>npm install包名 --save-dev</code>)</p>
</blockquote>
<ul>
<li><code>npm i xxx</code></li>
</ul>
<h2 id="项目包-核心依赖包"><a href="#项目包-核心依赖包" class="headerlink" title="项目包 - 核心依赖包"></a>项目包 - 核心依赖包</h2><blockquote>
<p>被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到<br>    简写：<code>npm i 包名</code>  (<code>npm install包名 -S(--save)</code>)<br>    从npm 5.0.0版本开始，–save已经变成默认行为，所以即使不加-S或–save，安装的包也会自动被加入到dependencies。</p>
</blockquote>
<ul>
<li><p><code>npm i axios</code></p>
</li>
<li><p><code>npm i vue-router@3.5.2 -S</code> (Vue2使用路由需制定为Router3版本)</p>
<blockquote>
<p>最新版的 Vue Router4 是为vue3设计的，不兼容Vue2。<br>  所以想在 Vue 2 中使用 Vue Router，安装包的时候需要指定 Vue Router 3 的版本</p>
</blockquote>
</li>
<li><p><code>npm i vue-router</code> (Vue3路由使用最新版即可)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端八股</title>
    <url>/tsukimiya.github.io/custom/%E5%85%AB%E8%82%A1.html</url>
    <content><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>先搞定这些，就去投简历！</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
浏览器渲染</p>
</li>
<li><p><input disabled="" type="checkbox"> 
性能优化</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
Less、Sass学一下</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
React了解一下</p>
</li>
<li><p><input disabled="" type="checkbox"> 
Tailwind CSS了解一下</p>
</li>
<li><p><input disabled="" type="checkbox"> 
git再学一下</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
ts学一下</p>
</li>
<li><p><input disabled="" type="checkbox"> 
复习一下Vue，同时看一下H5 C3 JS的八股 </p>
</li>
<li><p><input disabled="" type="checkbox"> 
复习一下webpack、nodejs、npm – 次要</p>
</li>
<li><p><input disabled="" type="checkbox"> 
复习一下mysql？了解一下Linux? – 次次要</p>
</li>
<li><p><input disabled="" type="checkbox"> 
vue的diff算法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
vue如何定义全局组件？</p>
</li>
<li><p><input disabled="" type="checkbox"> 
手写promise</p>
</li>
<li><p><input disabled="" type="checkbox"> 
常问算法 – 冒泡排序、二分查找、快速排序、二叉树、链表、堆栈、队列、递归、回溯、贪心算法、动态规划、位运算、排序算法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
刷一下 那些经典面试题</p>
</li>
</ul>
<h2 id="tostudylist"><a href="#tostudylist" class="headerlink" title="tostudylist"></a>tostudylist</h2><ul>
<li><p>算法 力扣hot100、150 , 剑指offer （大厂是比较看重算法的）</p>
<blockquote>
<p>大厂是比较看重算法的</p>
</blockquote>
</li>
<li><p>HTML&#x2F;CSS 常见的面试题 flex布局 盒子模型 BFC 重绘、重排 常见布局 HTML5 CSS3新特性等等</p>
</li>
<li><p>JS中的数据类型 闭包 作用域 原型 原型链 数组常见操作 字符串常见操作 事件循环 深浅拷贝 事件代理 DOM、BOM操作 防抖节流 ES6相关的等等</p>
</li>
<li><p>Vue相关的 响应式 通信方式 生命周期 MVVM原理 虚拟dom diff算法 key 插件 混入 指令 权限设计 Vue3新特性 等等</p>
</li>
<li><p>HTTP、Webpack、Node相关的问题</p>
</li>
<li><p>性能优化，前端安全，算法（如果目标企业不是大厂，可以练习一些常用的算法，如排序，数组字符串的常用操作）</p>
</li>
<li><p>数组常用方法</p>
</li>
<li><p>vue父子传值方式</p>
</li>
<li><p>跨域原因及处理方案</p>
</li>
<li><p>promise相关</p>
</li>
<li><p>页面的重绘重排</p>
</li>
<li><p>MVVM概念</p>
</li>
<li><p>简单算法题</p>
</li>
<li><p>element-ui覆盖方式</p>
</li>
<li><p>调试方法</p>
</li>
<li><p>axios封装 </p>
</li>
<li><p>前后端分离</p>
</li>
<li><p>打包自动化</p>
</li>
<li><p>代码版本管理、发布管理</p>
</li>
<li><p>微前端</p>
</li>
<li><p>日志管理</p>
</li>
<li><p>标准工程化、标准杨世华、自动化、组件化、插件化、nodeJS、性能优化</p>
</li>
<li><p>运维管理</p>
</li>
<li><p>nginx反向代理</p>
</li>
<li><p>服务器中台？</p>
</li>
<li><p>数据库表结构</p>
</li>
<li><p>网关、安全、加密？</p>
</li>
<li><p>uniapp？、微信小程序？、微信公众号？、安卓？、ios？</p>
</li>
<li><p>vue的异步组件、动态组件？</p>
</li>
<li><p>虚拟dom diff算法<br>  在vue框架团队开始着手开发框架的时候，他们有3种方法操作dom：1. document.createElement 2. innerHTML 3. virtual dom<br>  这个innerHTML性能是最差的，document是最好的，但是virtual dom开发体验是最好的，最后就是选用了这个进行框架的渲染。<br>  它需要配合渲染器和编译器来使用，像是vue就是先把模板语法通过编译器编译成一些对象，然后把对象扔给渲染器，渲染器最后把它渲染出来<br>  如果操作真实dom，它上面的元素，属性都特别多，程序运行起来会比较浪费时间</p>
</li>
<li><p>vue的diff算法和react的diff算法有区别，是什么？<br>  vue是能够明确的知道我要更新哪个组件，react是不知道的，只能从上往下找</p>
</li>
<li><p>有一百万条数据，返回给前端，前端怎么处理？怎么优化？（分页、虚拟列表、多线程webwork？）</p>
</li>
<li><p>时间切片？<br>  是在react Scheduler里面提出的，它通过将长时间运行的任务（如大组件树的渲染）分解为小任务（时间切片），并在多个浏览器任务之间交错执行这些小任务，确保了即使在执行大量工作时，浏览器也有机会处理其他高优先级任务，比如用户输入事件的响应，从而避免了界面卡顿。<br>  就是说，它是有一个人机交互时间，它不希望用户感觉卡顿，但是又不希望程序停下来运行，它就相当于把浏览器的运行和用户的交互交替运行，既让用户感觉不到卡顿，又让程序不停止运行</p>
</li>
<li><p>iframe和img都可以使用loading属性来实现懒加载</p>
</li>
<li><p>自动部署？</p>
</li>
<li><p>如何进行页面的主题切换？（换肤）</p>
</li>
<li><p>小程序如何进行分包？（项目有分包吗？）<br>  小程序本身有一个限制，当程序超过200m的时候，就没有办法进行打包了，所以需要分包</p>
</li>
<li><p>小程序的？onLoad、onShow、onReady、onHide、onUnload？onload和onshow的区别？</p>
</li>
<li><p>把小程序切出去，切到后台再切回来，会执行哪个？onshow？</p>
</li>
<li><p>微信小程序如何进行页面跳转？</p>
</li>
<li><p>小程序webview?嵌入一个H5页面？和H5的通信？和小程序通信？</p>
</li>
<li><p>小程序的bandtype和catchtype的区别？事件？还有个不是小程序的缓存？ – 一个冒泡，一个不冒泡？</p>
</li>
<li><p>抗锯齿？有些时候手机端显示文字可能会有锯齿，毛边，正常手机端是有个css属性可以抗锯齿的，但是那个效果并不好，而且支持性很差<br>transform里面的scale缩放，它用到了GPU，它这个是支持抗锯齿的，所以有的页面会写scale(1),啥都不做，也不缩放，目的就是为了抗锯齿，只要写到html根上</p>
</li>
<li><p>如何使动态路由持久化？</p>
</li>
<li><p>权限问题？如何处理？前端</p>
</li>
<li><p>按钮级别的权限？如控制菜单？</p>
</li>
<li><p>回溯？</p>
</li>
<li><p>递归是广度优先还是深度优先？<br>  递归是深度优先，它有一个回溯的操作<br>  广度优先是按队列来的<br>  递归是按栈来的，它有一个调用栈，最后一个递归调用的方法，最后调用，但是最先释放，然后依次回溯</p>
</li>
<li><p>vue的diff算法？（算是比较核心的东西？）</p>
</li>
<li><p>如何判断一个数据是数组？<br>  contructor.name？，就是那个构造函数的东西？<br>  还有isArray？原型链，instance of</p>
</li>
<li><p>vue-for的key是和diff算法有关的？</p>
</li>
<li><p>vue的响应式原理？</p>
</li>
<li><p>vue的路由变化是如何监听的？hash change？</p>
</li>
<li><p>如何使数组扁平化？<br>  es6的flat方法？还有es5的reduce方法？还有es5的递归？还有一个投机取巧的方法–转字符串转数组？</p>
</li>
<li><p>简历最好把自己会的技术都写上，不嫌多，最好列出来自己的技术，搜在线简历，有那种把所有的技术栈列在左边的，标有掌握还是熟悉的？推荐关注玩偶君的简历？玩偶君的简历，有技术栈，有项目经验，有项目展示，有自我评价，有联系方式，有github链接，有博客链接？？玩偶哥哥？</p>
</li>
<li><p>vue3的异步组件？动态组件？</p>
</li>
<li><p>负载均衡？</p>
</li>
<li><p>linux常用命令？</p>
</li>
<li><p>nignx常用命令？</p>
</li>
<li><p>rpc服务？</p>
</li>
<li><p>微服务mq？</p>
</li>
<li><p>数组去重？</p>
</li>
<li><p>js操作dom的方法？<br>  原生的document.queySelector、document.querySelectorAll、<br>  document.getElementsByClassName、<br>  document.getElementById、<br>  document.createElement、<br>  document.appendChild、…</p>
</li>
<li><p>浏览器缓存？</p>
</li>
<li><p>浏览器缓存机制？</p>
</li>
<li><p>session、cookie、token？jwt？</p>
</li>
<li><p>http和https的区别？</p>
</li>
<li><p>http2和http1.1？http1.1是有队列的，这个队列的长度是多少？</p>
</li>
<li><p>ssh的渲染方式？</p>
</li>
<li><p>分包加载？</p>
</li>
<li><p>js的线程和进程？</p>
</li>
<li><p>webjis?用来做地图的？</p>
</li>
<li><p>webrtc?</p>
</li>
<li><p>webgl?</p>
</li>
<li><p>websqllite?websqlL?</p>
</li>
<li><p>use strict严格模式？严格模式的限制？</p>
</li>
<li><p>变量提升？let和const有提升吗？</p>
</li>
<li><p>闭包？es6的let和const有闭包吗？</p>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h3><pre><code>* 两者都是用来控制元素是否显示
1. 在vue渲染模板的时候，v-if 是惰性加载的，只有条件为真时才会渲染，v-show 不管
2. v-show 通过改变元素的 display 属性来控制是否显示，v-if 是通过在 dom 中移除或者添加元素
3. v-if 每次都会重新渲染，v-show 只有第一次渲染
5. v-if 适合于条件不经常改变的场景，v-show 适合于频繁切换的场景
4. v-show 性能高，v-if 性能低 (其实实际开发中，这样的性能差是可以忽略不计的，基本都是使用 v-if)
</code></pre>
<h3 id="v-for-和-v-if-的优先级"><a href="#v-for-和-v-if-的优先级" class="headerlink" title="v-for 和 v-if 的优先级"></a>v-for 和 v-if 的优先级</h3><pre><code>1. vue2中，v-for优先级更高（v-if和v-for不推荐用在一个标签上，浪费性能）
2. vue3中，v-if的优先级提的更高了（但还是不推荐在同一个元素使用）
</code></pre>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="ES5和ES6继承的区别"><a href="#ES5和ES6继承的区别" class="headerlink" title="ES5和ES6继承的区别"></a>ES5和ES6继承的区别</h3><pre><code>* ES6 的继承机制，与 ES5 完全不同。
* ES5 通过 原型链或构造函数 实现继承，ES6 可以通过 class类 来实现继承。
- ES5 的继承机制：
是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。
- ES6 的继承机制：
则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。
* 这就是为什么 ES6 的继承必须先调用super()方法
  因为这一步会生成一个继承父类的this对象，没有这一步就无法继承父类。
</code></pre>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="页面适配的问题"><a href="#页面适配的问题" class="headerlink" title="页面适配的问题"></a>页面适配的问题</h3><pre><code>- 写页面是如何适配的？移动端、小程序是如何适配的？
  1. 响应式布局（rem动态计算）
  2. 媒体查询（px）
  3. 弹性布局（flex）
  4. 栅格布局（grid）
  5. vw、vh
- 如果说写H5页面，要适配移动端，包括大屏：
  正常来说，一旦包括了大屏，就不单单是手机端了，就绝对不可能用rem，用不了。
  因为rem会保证你当前这个字在哪个端都显示那么大，或者说你只要把PC端满足了，在手机端就满足不了。
  因为那个字的比例大小是不会变的，它永远是占屏幕的百分之多少，这是你动态算出来的结果。
  **那么正常来说，很多公司推荐的用法**：
  就算是手机端，也用px去显示，字体文字能用px就用px，因为px是最保真的。
  屏幕大了，这个文字一行可以多显示一点，屏幕小了可以少显示一点，
  但是**核心**还是这个：**CSS响应式@midia**，写多套的媒体查询，必须得写这个。
  这个东西 @media (max-width: 480px) &#123;
            body &#123;
              font-size: 14px;
            &#125;
          &#125;
  这套方案其实是最不好的，因为写东西太多了，非常繁琐，但是你这一个页面想要去适配这么多端，这个东西就逃不了

  很多公司也不愿意写这个媒体查询，因为这种方式非常不优雅
  就拿手机端最上面那个条来说，手机端那个条，它长的就和PC端不一样。
  PC端比如b站，有主页直播等横着放的，手机端就要放到一个菜单侧边栏里面，你就要重新再写一套
  当他的屏幕变小之后，要把PC这套给隐掉，这样的话：1.增加了工作量，2.不好维护
  所以说很多公司宁愿你去**写PC栈和m栈**，分多个项目去写。
  好处：手机可以完全跟PC分离，可以一点关系都没有，业务都可以分离，所以很多公司也都愿意这么去写

  但是目前来说，官网，门户（现在前端做门户做的少了，都变成外包项目了），但是这个门户，基本都是响应式的。
  因为它没啥用，就是做展示，给那个爬虫去爬，不管是手机端PC端，就是爬，页面就是死的。
  所以这种响应式的都是用在门户类业务，展示性数据大屏那种的，这两种用的比较多。
  因为页面基本内容不变，它没有更多的特殊的案例，比如手机端多个啥，PC端有个什么头，它没有这个东西
  这是目前来说**比较主流的两套**做适配的一个方案：**rem动态计算和px媒体查询**
  分到一套来说，能用px的就不用rem，能多展示内容的就多展示内容，尽量保证页面的宽度比
</code></pre>
<h3 id="定位的特殊应用"><a href="#定位的特殊应用" class="headerlink" title="定位的特殊应用"></a>定位的特殊应用</h3><ol>
<li>填满定位父元素<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81.png"></li>
<li>定位元素居中<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A82.png"></li>
<li>通过填满定位父元素，实现居中 – 上下左右都留出50px<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81-2.png"></li>
</ol>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><pre><code>* BFC（Block Formatting Context）块级格式化上下文，它规定了内部的块级元素的布局规则。
* 块级元素可以看作是一个独立的渲染区域，它规定了内部的元素如何布局，以及与外部的元素相互影响。
* BFC的布局规则/特性：
  1. 内部的块级元素会在垂直方向，一个接一个地放置。
  2. 内部的块级元素垂直方向的距离由margin决定。
  3. 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。
    即使存在浮动也是如此。
    - 也就是说，BFC的区域不会产生外边距合并(也叫margin塌陷)的问题。
  4. BFC的区域不会与float box重叠。（不会被其他浮动元素覆盖）
  5. 计算BFC的高度时，浮动子元素也参与计算。（BFC不会有浮动坍塌的问题）
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会在布局上影响到外面的元素，反之亦然。
* 创建/开启BFC的方法：
  1. float的值不为none
  2. position的值为absolute或fixed
  3. overflow的值不为visible
  4. display的值为flex、grid、inline-block、flow-root、table、table-cell和table-caption中的任何一个
    display: table-cell 和 table-caption 是用来模拟HTML表格的行为
  5. column-span为all的元素（即使该元素没有包裹在多列容器中）
  6. 位于flex布局的容器内(自身是伸缩项目)
  7. 多列容器（column-count或column-width）-- 如 column-count: 1;
* 自带BFC的元素：
  - 根元素
  - 表格元素（table、thead、tbody、tfoot、th、td、tr、caption）

** 在这些开启BFC的方法中，都或多或少会有一些副作用，其中display：flow-root的影响是最低的。
  - flow-root 生成一个块级元素盒 ，其会建立一个新的BFC。
  - 弊端：IE不太支持
</code></pre>
<h3 id="文字环绕图片显示"><a href="#文字环绕图片显示" class="headerlink" title="文字环绕图片显示"></a>文字环绕图片显示</h3><pre><code>给图片设置浮动，文字就自动环绕图片显示，不会被压住
CSS的浮动（float）属性**最初设计的主要目的**是为了实现**文字环绕图片**的效果。
</code></pre>
<h3 id="图片底部空白缝隙"><a href="#图片底部空白缝隙" class="headerlink" title="图片底部空白缝隙"></a>图片底部空白缝隙</h3><pre><code>* 图片底部有缝隙，是因为行内块元素会和文字的基线对齐
* 解决办法：
  1. 给图片添加vertical-align: top | middle | bottom 等（提倡使用的）
  2. 把图片转换为块级元素display：block
    // 只有行内元素、行内块元素才有vertical-align属性
    // 块级元素没有这个属性，也不会有空白空隙问题
  3. 设置font-size: 0; 也可以解决
</code></pre>
<h3 id="文本溢出显示省略号"><a href="#文本溢出显示省略号" class="headerlink" title="文本溢出显示省略号"></a>文本溢出显示省略号</h3><pre><code>* 单行文本溢出显示省略号：
  1. 强制一行内显示文本：white-space: nowrap;
  2. 超出的部分因此：over-flow: hidden;
  3. 文字用省略号代替超出的部分：text-overflow: ellipsis;

* 多行文本溢出显示省略号： -- 有兼容性问题 - 适用于webKit内核浏览器
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box; /* 弹性伸缩盒子模型显示 */
  -webkit-line-clamp: 2; /*  限制在一个块元素显示的文本的行数 */
  -webkit-box-orient: vertical; /* 设置伸缩盒对象的子元素的排列方式 */
这里的line是2，省略号是显示在第二行，如果第二行文字不够不显示省略号
一般是把盒子高度设置正好最后一行是line设置的位置

** 这个多行文本溢出显示省略号，更推荐让后台来做这个效果
   因为后台可以设置显示多少个字，操作更简单，且没有兼容性问题，效果会更佳
</code></pre>
<h3 id="边框重合变粗问题"><a href="#边框重合变粗问题" class="headerlink" title="边框重合变粗问题"></a>边框重合变粗问题</h3><pre><code>* 边框重合问题：
  如果一行的多个元素都是带有边框的，排列在一起，他们之间的边框会正好排列在一起
  (比如用浮动来实现)
  一般可能会想到给每个元素只设置一个左边框，最后一个元素设置左右边框之类，但是这样比较麻烦
* 解决办法：
  margin负值 -- 值设置为边框的宽度的负值
  这样右边的盒子边框正好压住左边的边框，就看起来是一条边框的效果

** 这种做法导致了一个问题：
如果想要做这样一个效果：鼠标滑到盒子上，边框变色显示
就会导致元素右边的边框被压住，没有显示出来
* 解决办法：
  鼠标经过某个盒子，提高当前盒子的层级：
  如果没有设置定位，则加相对定位（保留位置）因为**相对定位会压住其他标准流，还有浮动的盒子**
  如果有定位，则加z-index提高当前定位元素的层级
</code></pre>
<h3 id="CSS三角样式简写"><a href="#CSS三角样式简写" class="headerlink" title="CSS三角样式简写"></a>CSS三角样式简写</h3><pre><code>* 三角样式一般写法：
  width: 0;
  hight: 0;
  border-top: 100px solid transparent;
  border-right: 50px solid red;
  border-bottom: 0px solid transparent;
  border-left: 0px solid transparent;
* 简写写法：
  border-color: transparent red transparent transparent;
  border-style: solid;
  border-width: 100px 50px 0 0;
</code></pre>
<h3 id="flxe布局常用属性"><a href="#flxe布局常用属性" class="headerlink" title="flxe布局常用属性"></a>flxe布局常用属性</h3><pre><code>* 父项常见属性
flex-direction :设置主轴的方向
justify-content:设置主轴上的子元素排列方式
flex-wrap∶设置子元素是否换行
align-items :设置侧轴上的子元素排列方式(单行)
align-content:设置侧轴上的子元素的排列方式(多行)
flex-flow :复合属性，相当于同时设置了flex-direction和flex-wrap // 默认值：row nowrap

* 子项常见属性
flex子项目占的份数，定义子项目分配剩余空间【最重要】
  - flex是复合属性，包括flex-grow, flex-shrink, 和 flex-basis这三个子属性
  1. flex-grow，表示子项是否可放大，默认0
  2. flex-shrink，表示子项是否可缩小，默认1
  3. flex-basis，表示分配剩余空间之前，子项的初始大小，默认auto（某些解释为0）
  - flex单值语法：flex：1 ，会被作为flex-grow:1;的值
  - 双值语法：第二个值根据具体值来决定flex-shrink、flex-basis
    flex：1 200px; -- flex-grow:1; flex-shrink:1; flex-basis:200px;
    flex：1 1; -- flex-grow:1; flex-shrink:0; flex-basis:auto;

align-self控制子项自己在侧轴的排列方式（单独移动某个子项盒子）
order属性定义子项的排列顺序(前后顺序) -- 默认值为0，值越小排列越靠前
</code></pre>
<h3 id="属性选择器前缀写法"><a href="#属性选择器前缀写法" class="headerlink" title="属性选择器前缀写法"></a>属性选择器前缀写法</h3><pre><code>现在有这样一个结构：
&lt;ul&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
我们想要给这个span加上相同的样式，但是每个span有不同的图片显示，可以这么做：
&lt;ul&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon1&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon2&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon3&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon4&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
然后使用属性选择器：
ul li [class^=&quot;nav-icon&quot;]&#123; /* 设置相同的样式 */
  ...
&#125;
ul li .nav-icon-icon1&#123;...&#125; /* 每个span设置不同样式/图片 */
ul li .nav-icon-icon2&#123;...&#125;
ul li .nav-icon-icon3&#123;...&#125;
ul li .nav-icon-icon4&#123;...&#125;
</code></pre>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><pre><code>媒体查询（Media Query）是CSS3新语法。
@media 可以针对不同的屏幕尺寸设置不同的样式
当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

语法：
@media mediatype and|not|only (media feature) &#123;
  CSS-Code;
&#125;
- 用@media开头
- mediatype 媒体类型：all、screen、print(打印机 打印预览)等
- 关键字：and、not、only
- media feature 媒体特性 - 必须写在()里面

* 媒体特性：
  width： 定义输出设备中的页面可见区域宽度
  min-width：定义输出设备中的页面最小可见区域宽度
  max-width：定义输出设备中的页面最大可见区域宽度

* 示例：
在屏幕上 并且 最大宽度为 &lt;=800像素时候，设置想要的样式
@media screen and (max-width: 800px) &#123;
  ...
&#125;

** 为了防止混乱，媒体查询我们**从小到大**，或从大到小的顺序写
** CSS样式顺序：
  1. 重置样式 2. 正常写的样式 3. 媒体查询
  推荐这样来写，把媒体查询样式写在最后面，这样不会因为样式覆盖导致媒体查询不生效
</code></pre>
<h3 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h3><pre><code>媒体查询 + rem 实现不同设备宽度，页面元素大小动态变化
* 注意：一般会给页面较外层的元素设置rem值 + min-width值，避免页面元素过小，内容过度紧凑

** rem单位 -- css3新增的单位
rem是相对于根元素html的font-size来计算的
em是相对于父元素的font-size来计算的

@media screen and (min-width: 360px) &#123;
  html&#123;
    font-size: 50px;
  &#125;
&#125;
@media screen and (min-width: 640px) &#123;
  html&#123;
    font-size: 100px;
  &#125;
&#125;
-----------------------------------------------------
**** 实际开发适配 方案1：媒体查询+rem****
1. 媒体查询 - 按照设计稿与设备宽度的比例，动态计算并设置html跟标签的font-size大小
2. css中，设计稿中元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值

**** 方案2 ：flexible.js + rem （推荐）****
flexible.js 是手机淘宝团队出的简洁高效，兼容性更好的移动端适配库
我们不再需要写不同屏幕的媒体查询，因为里面js做了处理
--
它的原理是：把当前设备划分成10等份，并把html的font-size设置为1份的大小
这个时候，如果我们要把页面最大订死到版心的750像素，就需要给body设置max-width:750px;
同时写一个媒体查询，给html的font-size设置为75px：
@media screen and (max-width: 750px) &#123;
  font-size: 75px!important; // 设置最高权重，否则会被flexible.js覆盖
&#125;

***** 理解flexible.js *****
我们要做的，根据设计稿的大小，来计算我们写页面时候，划分为10等份的font-size大小
比如当前设计稿是750px，那么html的font-size 就是 75px
我们并不需要去设置html的font-size，而是按照这个75px值来写(设计稿的1/10为1rem)
里面页面元素的rem值：页面元素的rem值就是 px值 / 75px 
这样我们写出来的比例是正确的，font-size的值变化，页面元素也会等比例缩放跟着变化
flexible.js做的，就是根据实际设备屏幕宽度，动态的计算的划分给html的font-size大小
然后再去根据这个font-size大小，计算页面元素的rem值，显示出来
***************************

也就是说，我们不需要再去关心媒体查询，
只需要把页面设计稿的元素大小，按照 元素大小 / 1rem(设计稿的宽度 / 10) 换算为rem值即可

我们还可以借助cssrem插件，它能自动把px值换算为rem值 -- 我们写下的px，敲下回车提示，就会换算成对应的rem
注意：cssrem插件默认的html文字大小是16px，我们需要手动设置成我们想要的：
settings.json -- &quot;cssrem.rootFontSize&quot;: 75
这个时候，我们就不用去管媒体查询了，也不需要再管怎么换算的问题了o(^▽^)o

* github地址：https://github.com/amfe/lib-flexible
-----------------------------------------------------

*** 设计稿常见尺寸宽度
1. iPhone4、5 -- 640px
2. iPhone6、7、8 -- 750px
3. Android -- 常见320px、360px、375px、384px、400px、414px、500px、720px
// 大部分4.7-5寸的安卓设备为720px

一般情况下，我们以1、2套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果。
**现在基本以750px为标准**。
-----------------------------------------------------
** 动态设置html标签font-size大小
1. 假设设计稿是750px
2. 假设把整个屏幕划分为15等份（标准不一，也可以是20、10）
3. 每一份作为html字体大小，这里就是50px
4. 那么在320px设备的时候，字体大小为 320/15 = 21.33px
5. 用页面元素的大小，除以不同的html字体大小，能够实现页面元素盒子等比例缩放的效果

// rem的适配部分建议去看看腾讯Alloy团队对此的讲解
</code></pre>
<h3 id="媒体查询引入资源"><a href="#媒体查询引入资源" class="headerlink" title="媒体查询引入资源"></a>媒体查询引入资源</h3><pre><code>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的css样式
直接在link中判断设备的尺寸，引入不同的css文件
&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;xxx.css&quot;&gt;
**如：
&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 360px) and (max-width: 800px)&quot;
type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;
</code></pre>
<h3 id="样式文件import导入"><a href="#样式文件import导入" class="headerlink" title="样式文件import导入"></a>样式文件import导入</h3><pre><code>css3中，@import规则被引入，用来导入外部样式表。
css的@import规则是less、sass等css预处理器中常用到的.

css中，导入样式表有两种方式：
1. 直接导入
@import &quot;style.css&quot;; // 必须带上后缀名
2. 条件导入
@import &quot;style.css&quot; screen and (min-width: 360px) and (max-width: 800px)

less和sass中，同样使用@import导入文件，且默认会自动合并导入的文件内容。
less中导入文件：
@import &quot;style.less&quot;   // 可以不加后缀名 @import &quot;style&quot;  ---- 废弃了
新本的less 导入格式是@import url(common.less); // 可以不加后缀名
</code></pre>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="和语义区别"><a href="#和语义区别" class="headerlink" title="&lt;b&gt;和&lt;strong&gt;语义区别"></a><code>&lt;b&gt;</code>和<code>&lt;strong&gt;</code>语义区别</h3><pre><code>* &lt;b&gt;（Bold）标签：它是一个实体标签，仅表示文本应该以粗体显示，而不传达任何特定的语义信息。
  在HTML早期，&lt;b&gt;标签常被用于加粗文本纯粹出于视觉样式考虑，而不涉及内容的重要性或强调。
* &lt;strong&gt;（Strong Importance）标签：与&lt;b&gt;标签不同，&lt;strong&gt;标签具有语义上的含义，
  它表明被包含的文本具有特别的重要性或强度。
  搜索引擎会给予&lt;strong&gt;标签内的内容更高的权重，因为它暗示这些内容对于理解文档的主旨可能是关键的。
</code></pre>
<h3 id="TDK三大标签SEO优化"><a href="#TDK三大标签SEO优化" class="headerlink" title="TDK三大标签SEO优化"></a>TDK三大标签SEO优化</h3><pre><code>1. title
&lt;title&gt;xxx - xxxxx&lt;/title&gt;
建议：网站名(产品名) - 网站的介绍（尽量不超过30个汉字）
如：京东(JD.COM) - 综合网购首选 - 正品低价、品质保障、配送及时、轻松购物！
2. description
&lt;meta name=&quot;description&quot; content=&quot;...&quot; /&gt;
简要说明我们网站主要是做什么的。
多采用“我们是...”、“我们提供...”、“xxx网作为...”、“电话：010...”之类语句
3. keywords
&lt;meta name=&quot;keywords&quot; content=&quot;xxx,xxx,xxx,xxx&quot; /&gt;
页面关键字，是搜索引擎的关注点之一
keywords最好限制为6~8个关键字，关键词之间用英文逗号隔开，采用“关键词1,关键词2,关键词3”的格式
把权重产品靠前写，越靠前权重越高，被搜索的概率会越大
</code></pre>
<h3 id="LOGO-SEO优化"><a href="#LOGO-SEO优化" class="headerlink" title="LOGO SEO优化"></a>LOGO SEO优化</h3><pre><code>1. logo里面首先放一个 `h1`标签，目的是为了提权，告诉搜索引擎，这个地方很重要
2. h1里面再放一个 `链接` ，可以返回首页的，把logo的背景图片给链接即可
3. 为了让搜索引擎更好的收录我们，链接里面要放`文字（网站名称）`，但是文字不要显示出来
  - 方法1：text-index移到盒子外面(text-indent:-9999px;),over-flow:hidden; 淘宝的做法
  - 方法2：font-size:0; 京东的做法
4. 最后给链接一个`title属性`
</code></pre>
<h3 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h3><pre><code>* 标准的viewport设置
 `&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;`
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>宽度设置的是viewport宽度，可以设置</td>
</tr>
<tr>
<td>initial-scale</td>
<td>初始缩放比，大于0的数字</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>最大缩放比，大于0的数字</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>最小缩放比，大于0的数字</td>
</tr>
<tr>
<td>user-scalable</td>
<td>用户是否可以缩放,yes或no (1或0)</td>
</tr>
</tbody></table>
<h3 id="移动端物理像素比"><a href="#移动端物理像素比" class="headerlink" title="移动端物理像素比"></a>移动端物理像素比</h3><pre><code>* 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。
* 这是厂商在出厂时就设置好了,比如苹果6\7\8是750*1334
* 我们开发时候的1px不是一定等于1个物理像素的
* PC端页面，1个px等于1个物理像素的，但是移动端就不尽相同
* 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比

在移动端，手机都采用视网膜屏幕的技术，1个px等于多少物理像素点，由设备决定
在iphone8上，1个px等于2个物理像素点，750的物理像素宽，实际开发像素宽只有375px

视网膜屏幕(Retina)显示技术，把更多的物理像素点压缩至一块屏幕里，达到更高的分辨率，提高屏幕显示的细腻程度。
原来1css像素和物理像素是一一对应的，现在采取了更多的物理像素点来显示1个css像素。

**这就导致了一个问题：
  文字和纯色的盒子大小影响不会很大，但是图片就会出问题
  50*50的图片，会被放大两倍，变成100*100的显示，就会有一个**模糊**的问题
* 解决办法：
  在标准的viewport设置中，使用**倍图**来提高图片质量，解决在高清设备中的模糊问题
  **准备比实际需要大两倍的图片**
  如果需要一个50*50的图片，那么就准备一个100*100的图片，把它设置为50*50的显示，到手机里面就不会模糊了
  通常使用2倍图，具体几倍图看实际开发公司需求
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h3><pre><code>* 浏览器有一个同源策略，目的是为了保证用户信息的安全，防止恶意的网站窃取数据。
* 如果非同源，共有三种行为受到限制：
  （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
  （2） 无法接触非同源网页的 DOM。
  （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

* 常用的解决跨域的几种方式：
  1. cors -- 设置响应头
  2. jsonp -- 动态创建script标签 -- 只能发送get请求
  3. nginx反向代理 
  4. iframe多窗口通信 -- postMessage()跨文档通信 API / 片段识别符 -- hash
    还适用于window.open方法打开的窗口
    iframe跨域，需要设置name属性。
    iframe会阻塞页面加载，用的不多，因为不太好使
  5. document.domain属性 -- 同域名下的子域名之间规避同源政策
</code></pre>
<p>  <a href="https://wangdoc.com/javascript/bom/same-origin">浏览器同源限制</a></p>
<h4 id="iframe-和多窗口通信"><a href="#iframe-和多窗口通信" class="headerlink" title="iframe 和多窗口通信"></a>iframe 和多窗口通信</h4><pre><code>iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。
iframe窗口之中的脚本，可以获得父窗口和子窗口。
但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。

如果两个窗口一级域名相同，只是二级域名不同，那么*设置document.domain属性*，就可以*规避同源政策*，拿到 DOM。

对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。
- 片段识别符（fragment identifier）-- 属于破解
    指的是，URL 的#号后面的部分。比如 http://example.com/x.html#fragment 的 #fragment。
    如果只是改变片段标识符，页面不会重新刷新。
    父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。子窗口通  过监听 hashchange事件 得到通知。
    同样的，子窗口也可以改变父窗口的片段标识符。
- 跨文档通信API（Cross-document messaging） -- H5新增API
    这个 API 为window对象新增了一个 window.postMessage方法 ，允许跨窗口通信，不论这两个窗口是否同源。
    举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。
        // 父窗口打开一个子窗口
        var popup = window.open(&#39;http://bbb.com&#39;, &#39;title&#39;);
        // 父窗口向子窗口发消息
        popup.postMessage(&#39;Hello World!&#39;, &#39;http://bbb.com&#39;);
    postMessage方法的第一个参数是具体的信息内容，
    第二个参数是接收消息的窗口的源（origin），
    即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。

    父窗口和子窗口都可以通过message事件，监听对方的消息。
    通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。
</code></pre>
<h4 id="JSONP处理跨域"><a href="#JSONP处理跨域" class="headerlink" title="JSONP处理跨域"></a>JSONP处理跨域</h4><pre><code>JSONP 是服务器与客户端跨源通信的常用方法。
最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。
JSONP 的**优势**在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

1. 它通过在网页添加一个&lt;script&gt;元素，向服务器请求一个脚本，来实现跨域请求。
  如&lt;script src=&quot;http://api.foo.com?callback=bar&quot;&gt;&lt;/script&gt;
  注意，请求的脚本网址有一个callback参数（?callback=bar），用来告诉服务器，客户端的回调函数名称（bar）。
2. 服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（bar(&#123;...&#125;)）。
3. 客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是&lt;script&gt;标签请求的脚本内容。
  这时，客户端只要定义了bar()函数，就能在该函数体内，拿到服务器返回的 JSON 数据。
  function bar(data) &#123;
    console.log(&#39;Your public IP address is: &#39; + data.ip);
  &#125;;
  服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。
  bar(&#123;
    &#39;ip&#39;: &#39;8.8.8.8&#39;
  &#125;);
  由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了bar函数，该函数就会立即调用。
  作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。
</code></pre>
<h4 id="WebSocket处理跨域"><a href="#WebSocket处理跨域" class="headerlink" title="WebSocket处理跨域"></a><font id="websocket处理跨域">WebSocket处理跨域</font></h4><pre><code>WebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。
该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

例子：浏览器发出的 WebSocket 请求的头信息
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com

Origin字段，表示该请求的请求源（origin），即发自哪个域名。

正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源政策。
因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>
<h4 id="CORS处理跨域"><a href="#CORS处理跨域" class="headerlink" title="CORS处理跨域"></a>CORS处理跨域</h4><pre><code>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。
它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。
相比 JSONP 只能发GET请求，**CORS 允许任何类型的请求**。

对于CORS处理跨域，浏览器是帮我们自动进行了处理的。
浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息。比如添加一个origin字段，表示请求的来源。
整个 CORS 通信过程，都是浏览器自动完成，对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。
因此，**实现 CORS 通信的关键是服务器**。只要服务器实现了 CORS 接口，就可以跨源通信。  
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><pre><code>webSocket是一种通信协议，是建立在TCP之上的，使用ws://（非加密）和wss://（加密）作为协议前缀。
和HTTP协议不同，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
</code></pre>
<p>  详见 ↑ <a href="#websocket%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F">WebSocket处理跨域</a></p>
<h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><pre><code>JS是是一门单线程语言。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。
在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。
这样有利于随时响应主线程的通信。
但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

好处：一些计算密集型或高延迟的任务可以交由 Worker 线程执行，
主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。

**可以应用到千万级别数据的处理上**
</code></pre>
<h3 id="千万级别的数据如何处理？"><a href="#千万级别的数据如何处理？" class="headerlink" title="千万级别的数据如何处理？"></a>千万级别的数据如何处理？</h3><pre><code>- 后端返回给前端千万级别的数据应该如何处理？
  1. 分页 -- 每次只加载固定数量的数据项
    强调的是数据的结构性和导航控制
  2. 懒加载/无限滚动 -- 当用户滚动页面时，按需加载更多数据
    侧重于提供不间断的内容浏览体验。
  3. WebSocket 或 Server-Sent Events (SSE) 实时推送 -- 服务器将数据推送到浏览器，无需客户端请求
    对于实时性要求较高的应用，可以使用WebSocket或SSE建立持久连接，按需推送数据更新，而不是频繁地轮询后端。
  4. Web Worker -- 浏览器多线程处理，将计算密集型任务交给Worker线程
    在不影响用户界面响应的情况下处理大量数据。
    虽然Web Worker可以提高处理大数据的效率，
    但是千万级别的数据仍然可能超出Web Worker处理能力的上限，特别是在**内存使用方面**。
    因此，有效的数据分页、分块策略以及结合其他前端性能优化技术仍然是必要的。
  5. 虚拟列表 -- 一种UI渲染技术
    只实际渲染可视区域内的列表项，其余未可视部分则不渲染或只渲染占位符。
    随着滚动，列表项被动态地创建和销毁。
    目的是减少DOM元素的数量，从而优化内存使用和提高滚动性能。
</code></pre>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和&#x3D;&#x3D;的区别"></a>equals和&#x3D;&#x3D;的区别</h3><pre><code>1. “==”操作符用于比较两个对象的地址是否相等。
2. .equals() 方法用于比较两个对象的内容是否相等。
3. .equals()方法 可以通过去重写这个方法，来实现一些个性化比较。
</code></pre>
<p>  <a href="https://javabetter.cn/string/equals.html">字符串相等判断：Java中的equals()与&#x3D;&#x3D;的区别与用法</a></p>
<h3 id="list、set、map的区别"><a href="#list、set、map的区别" class="headerlink" title="list、set、map的区别"></a>list、set、map的区别</h3><pre><code>1. list是有序的，可重复的
2. set是无序的，元素不可重复
3. map是键值对，key不能重复
</code></pre>
<h3 id="hashmap、treemap的区别，分别什么时候使用？"><a href="#hashmap、treemap的区别，分别什么时候使用？" class="headerlink" title="hashmap、treemap的区别，分别什么时候使用？"></a>hashmap、treemap的区别，分别什么时候使用？</h3><pre><code>1、实现
HashMap：基于哈希散列表实现
TreeMap：SortMap接口，基于红黑树
2、存储
HashMap：随机存储
TreeMap：默认按键的升序排序
3、遍历
HashMap：Iterator遍历是随机的
TreeMap：Iterator遍历是有序的
4、键值对
HashMap：只允许键、值均为null
TreeMap：键、值都不能为null
5、安全
HashMap：非并发安全Map
TreeMap：非并发安全Map
6、效率
HashMap：高
TreeMap：低

7、性能损耗
 - HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。
- 而TreeMap的底层是一个Tree结构，所以速度会比较慢。

- HashMap因为要保存一个Array，所以会造成空间的浪费，
- TreeMap只保存要保持的节点，所以占用的空间比较小。

- HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。
- TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。

使用场景：
* HashMap：关心的是快速的插入、删除和查找操作，并且不需要元素有序时，HashMap是一个很好的选择。
  适用于大多数常规的键值对存储需求，如缓存、数据映射等。
* TreeMap：需要根据键进行排序（自然排序或自定义排序），
  或者需要频繁执行基于范围的查询（如查找某个键范围内的所有元素），则应使用TreeMap。
  它适用于实现索引、有序字典、有序统计等场景。
</code></pre>
<h3 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h3><pre><code>1. IO是面向流的，NIO是面向缓冲区的。
2. IO是阻塞的，NIO是非阻塞的。
3. IO是单向的（流），NIO是双向的（通道）。
4. IO是字节流，NIO是字符流。
5. IO是面向文件的，NIO是面向内存的。
6. IO是同步的，NIO是异步的。
- 对于较小文件的读取，两者差异较小，因为文件本身较小
- 对于较大文件的读取，NIO的效率明显优于IO。
  因为 NIO 使用了更高效的缓冲区和通道机制，可以在内存中进行更快的数据传输。

* 以下是 NIO 在网络传输中优于传统 I/O 的原因：
①、NIO 支持非阻塞 I/O，这意味着在执行 I/O 操作时，线程不会被阻塞。
②、NIO 支持 I/O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），
  并在 I/O 事件（如可读、可写）准备好时处理它们。
③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。
</code></pre>
<p>  <a href="https://javabetter.cn/nio/nio-better-io.html">Java NIO 比传统 IO 强在哪里？</a></p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3>]]></content>
  </entry>
  <entry>
    <title>日程表</title>
    <url>/tsukimiya.github.io/schedule/index.html</url>
    <content><![CDATA[<center style="width:100%;height:1px;position:relative">
    <p title="知无行则空，梦里看花。行非知犹盲，水中捞月。" 
       style="position:absolute;top:-50px;left:50%;transform: translateX(-48%);font-size:16px;cursor:help;
       background-image: linear-gradient(to right, purple, red, green);
       background-clip: text;
       color: transparent;"
    >知行合一</p>
</center>

<center style="color:#888;">NOW</center>
<hr style="height:1px;margin:2px 0 30px">

<table>
<thead>
<tr>
<th align="center">Stack</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Uniapp</td>
<td align="center"><a href="https://www.bilibili.com/video/BV1Bp4y1379L?p=1">Vue3+Ts+Pinia+uni-app黑马项目</a></td>
</tr>
</tbody></table>
<center style="color:#888;margin:80px 0 0">NEXT</center>
<hr style="height:1px;margin:2px 0 30px">


<table>
<thead>
<tr>
<th align="center">Stack</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Git</td>
<td align="center"><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程-廖雪峰</a></td>
</tr>
<tr>
<td align="center">TS</td>
<td align="center"><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">TS入门教程-xcatliu</a>、<a href="https://wangdoc.com/typescript/">TypeScript 教程 - 阮一峰-网道</a></td>
</tr>
<tr>
<td align="center">React</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Task</title>
    <url>/tsukimiya.github.io/schedule/task.html</url>
    <content><![CDATA[<center style="width:100%;height:1px;position:relative">
    <!-- 一直想不出令我满意的词，无灯夜航虽然意味上很好，但是音韵上总觉差点 -->
    <!-- 一版：知无行则空，梦里看花。行非知犹盲，无灯夜航。 -->
    <!-- 二版：知无行则空，梦里看花。行非知犹盲，海底捞月。 -->
    <!-- 二版：知无行则空，梦里看花。行非知犹盲，水中捞月。 -->
    <p title="知无行则空，梦里看花。行非知犹盲，水中捞月。" 
       style="position:absolute;top:-50px;left:50%;transform: translateX(-48%);font-size:16px;cursor:help;
       background-image: linear-gradient(to right, purple, red, green);
       background-clip: text;
       color: transparent;"
    >知行合一</p>
</center>

<blockquote>
<p>快给我滚去学习！给你一拳 👊👊👊</p>
</blockquote>
<h2 id="Study-Tech"><a href="#Study-Tech" class="headerlink" title="Study Tech"></a>Study Tech</h2><h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h3><ul>
<li><p>pink html + css + 移动端后面这部分看一下</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV14J4114768/?p=389">https://www.bilibili.com/video/BV14J4114768/?p=389</a><br>  p357-388为 CSS2D、3D(这里有空也看一下吧，正好做一下笔记)<br>  后面<br>  p389-p502大致都是移动端，包括流式布局，Less，响应式相关<br>  p503-513为bootStrap<br>  bootStrap BS 以 Less (Sass), OOCSS 与 SMACSS 为基础<br>  最后是项目</p>
</blockquote>
</li>
<li><p>黑马程序员前端项目uniapp小兔鲜儿微信小程序项目视频教程，基于Vue3+Ts+Pinia+uni-app的最新组合技术栈开发的电商业务全流程（2023-8-8 | 20h40min）<br>  <a href="https://www.bilibili.com/video/BV1Bp4y1379L?p=1">https://www.bilibili.com/video/BV1Bp4y1379L?p=1</a><br>  &gt; Vue3移动端uni-app项目<br>  &gt; 老师也许是个大牛，但是讲课不行，不适合初学者，适合有经验的听一下</p>
</li>
<li><p>vue框架</p>
<ul>
<li><p>邓瑞编程 3小时学会Vue3 (24.1.23 | 2h16min)</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1nV411Q7RX">https://www.bilibili.com/video/BV1nV411Q7RX</a><br>  有个人博客教程<a href="https://www.dengruicode.com/">https://www.dengruicode.com/</a><br>  可以看看这个，反正很短</p>
</blockquote>
</li>
<li><p><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a> <font color='red'> 推荐 </font></p>
<blockquote>
<p>写的很细，无论是基础还是进阶都可以看</p>
</blockquote>
</li>
</ul>
</li>
<li><p>es6</p>
<ul>
<li>黑马视频<br>  <a href="https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&p=91">https://www.bilibili.com/video/BV1Kt411w7MP?t=9.0&amp;p=91</a></li>
</ul>
</li>
<li><p>ajax + git</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1zs411h74a/?p=75">黑马Git教程</a>(17.1.16 | 75-101p | 4h5min)</p>
</li>
<li><p>vue项目 双元 day9-p14 路由懒加载 、p15上线<br>  p12 通过CDN优化打包</p>
</li>
</ul>
<h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h3><ul>
<li><p>微信小程序 + uni-app （2021-12-17 | 30h）<br><a href="https://www.bilibili.com/video/BV1834y1676P?t=75.0">https://www.bilibili.com/video/BV1834y1676P?t=75.0</a></p>
<blockquote>
<p>有点老了，看下面这个尚硅谷的吧？或者直接下面的小兔鲜uniapp项目</p>
</blockquote>
</li>
<li><p>尚硅谷微信小程序开发教程，2024最新版微信小程序项目实战！（2024-02-20 | 35h42min）<br><a href="https://www.bilibili.com/video/BV1LF4m1E7kB?p=1">https://www.bilibili.com/video/BV1LF4m1E7kB?p=1</a></p>
<blockquote>
<p>微信小程序教程 + 项目</p>
</blockquote>
</li>
<li><p>react<br><a href="https://www.bilibili.com/video/BV1gh411U7JD?t=50.3">https://www.bilibili.com/video/BV1gh411U7JD?t=50.3</a></p>
</li>
<li><p>js面试<br>  黑马程序员前端面试必看视频教程（手写Promise+js设计模式+继承+函数柯里化等）（2023-9-5 | 12h）<br>  <a href="https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1">https://www.bilibili.com/video/BV1mH4y1Q7Z7?t=282.1</a></p>
<p>  尚硅谷经典前端面试题精讲第一季(web前端大咖总结) （2018-11-1 | 5h07min）<br>  <a href="https://www.bilibili.com/video/BV1nb411P7tQ/?vd_source=8a77e97d04f83a8e2b569f53a587210a">https://www.bilibili.com/video/BV1nb411P7tQ/?vd_source=8a77e97d04f83a8e2b569f53a587210a</a></p>
</li>
<li><p>项目</p>
<ul>
<li><p>黑马程序员前端Vue项目《iHRM人力资源后台管理》全套教程，从vue基础模板开发到整体开发、nginx部署上线（2023-11-07 | 26h）<br>  <a href="https://www.bilibili.com/video/BV1Te411X7Wz?p=1">https://www.bilibili.com/video/BV1Te411X7Wz?p=1</a></p>
<blockquote>
<p>Vue2项目 </p>
</blockquote>
</li>
<li><p>黑马程序员前端Vue3小兔鲜电商项目实战，vue3全家桶从入门到实战电商项目一套通关（2023-5-9 | 17h）<br>  <a href="https://www.bilibili.com/video/BV1Ac411K7EQ?p=1">https://www.bilibili.com/video/BV1Ac411K7EQ?p=1</a></p>
<blockquote>
<p>Vue3项目 </p>
</blockquote>
</li>
<li><p>尚硅谷Vue项目实战硅谷甄选，vue3项目+TypeScript前端项目一套通关（2023-5-16 | 46h32min）<br>  <a href="https://www.bilibili.com/video/BV1Xh411V7b5?p=1">https://www.bilibili.com/video/BV1Xh411V7b5?p=1</a></p>
<blockquote>
<p>有时间还是学一遍这个吧！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>TS</p>
<ul>
<li>小满TypeScript基础教程全集（完结）（2021-12-28 | 6h31min）<br>  <a href="https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.999.0.0&vd_source=8a77e97d04f83a8e2b569f53a587210a">https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.999.0.0&amp;vd_source=8a77e97d04f83a8e2b569f53a587210a</a></li>
</ul>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV19n4y1d7Gr/?vd_source=8a77e97d04f83a8e2b569f53a587210a">禹神：前端项目部署指南，前端项目打包上线</a></p>
<ul>
<li>阮一峰 TS教程 网道<br><a href="https://wangdoc.com/typescript/">https://wangdoc.com/typescript/</a></li>
<li>阮一峰 JS教程 网道<br><a href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><p>排序算法——冒泡排序原理动图详解及实现<br><a href="https://blog.csdn.net/qq_43792385/article/details/99466879">https://blog.csdn.net/qq_43792385/article/details/99466879</a></p>
<blockquote>
<p>小满模拟面试p1的图很好，老师讲的很好</p>
</blockquote>
</li>
<li><p>TS<br>  <a href="https://xiaoman.blog.csdn.net/article/details/122167155?spm=1001.2014.3001.5502">https://xiaoman.blog.csdn.net/article/details/122167155?spm=1001.2014.3001.5502</a><br>  作者 小满zs B站有视频，讲的很好？<br>  <a href="https://blog.csdn.net/qq1195566313?type=blog">https://blog.csdn.net/qq1195566313?type=blog</a></p>
</li>
<li><p>防盗链<br>cdn资源如果不设置防盗链，会被爬虫或者别的网站引用，但是流量还是消耗你的，到时候你的流量嘎嘎跑，月底缴费直接破产，设置了防盗链就只能自己的网站才能拿这个资源</p>
</li>
<li><p>html页面如何使用emoji表情？js如何使用emoji？ <a href="https://zhuanlan.zhihu.com/p/328516890">参考一篇文章</a></p>
</li>
<li><p>面试必问之 JS 事件循环(Event Loop)，看这一篇足够 <a href="https://zhuanlan.zhihu.com/p/580956436">https://zhuanlan.zhihu.com/p/580956436</a></p>
</li>
<li><p>axios<br>结合async和await调用axios<br>如果想要处理报错 – try catch<br>更优雅的处理 – 拦截器 – 可以处理全部的错误</p>
</li>
<li><p>如果想要本地搜索排除某些页面，其余全部页面都会被搜索到<br>目前只有一个办法：将想要排除搜索的页面，排除渲染，不被渲染的页面上的内容是搜索不到的，<br>所以还是得手搓页面XD</p>
</li>
<li><p>移动端使用js的控制台<br>【探秘JavaScript移动调试神器：JS-Mobile-Console】<a href="https://mbd.baidu.com/ma/s/WNjqoqqA">https://mbd.baidu.com/ma/s/WNjqoqqA</a><br>【移动端调试神器vConsole】<a href="https://mbd.baidu.com/ma/s/ZTdBK5C1">https://mbd.baidu.com/ma/s/ZTdBK5C1</a><br>可以直接使用js在线工具就行了，因为我只是需要在移动端使用控制台来进行验证一些代码，所以js在线工具完全可以满足</p>
</li>
<li><p>写一个sleep函数？研究过promise的应该写个sleep函数很简单？</p>
</li>
<li><p>为什么v-if是把元素移除和添加进页面的，然而v-if添加进页面的元素上带有的id属性，页面上的a链接指向它的锚点不起作用，为什么？如果换成v-show就没关系，因为控制的是display的值<br>也就是说，新添加进页面的元素的id属性不能作为锚点使用？</p>
</li>
<li><p>如何记录网站每天的访问量及访问IP？</p>
</li>
<li><p>在首页和标签页添加 字数统计+阅读时长 以及 打赏 &#x2F;&#x2F; 应该要修改源模版文件代码</p>
<blockquote>
<p>要将字数统计和阅读时长设置添加到首页和标签页，你需要在网站的主题或模板文件中进行修改。具体来说，你需要找到首页和标签页的模板文件，并在其中添加相应的代码以显示字数统计和阅读时长。<br>  通常，这些模板文件可以在你的网站主题文件夹中找到。你可以查看主题的文档或者在主题文件夹中搜索包含首页和标签页内容的模板文件。<br>  一旦找到了这些模板文件，你可以根据需要修改它们，添加类似以下的代码来显示字数统计和阅读时长：<br>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.symbols %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>字数统计: &#123;&#123; page.symbols &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if page.time %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阅读时长: &#123;&#123; page.time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><br>请注意，具体的代码可能会因为你使用的网站平台或主题而有所不同。最好查阅你使用的平台或主题的文档，以确保正确添加字数统计和阅读时长功能。</p>
</blockquote>
</li>
<li><p>CSS 布局经典问题大全<br><a href="https://www.html-js.com/article/5889">https://www.html-js.com/article/5889</a></p>
</li>
<li><p>网站会DDOS攻击会有哪些反应，如何应对此现象？<br><a href="https://www.html-js.com/article/6657">https://www.html-js.com/article/6657</a></p>
</li>
<li><p>响应式网页设计——怎样让一个网站在手机、平板上好看<br><a href="https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/">https://www.freecodecamp.org/chinese/news/responsive-web-design-how-to-make-a-website-look-good-on-phones-and-tablets/</a></p>
</li>
<li><p>什么是 XSS？如何保护网站免受 DOM 跨站脚本攻击<br><a href="https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/">https://www.freecodecamp.org/chinese/news/how-to-protect-against-dom-xss-attacks/</a></p>
</li>
<li><p>SEO优化？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=4.5&p=311">https://www.bilibili.com/video/BV14J4114768?t=4.5&amp;p=311</a></p>
</li>
<li><p>上传服务器？<br><a href="https://www.bilibili.com/video/BV14J4114768?t=2.5&p=355">https://www.bilibili.com/video/BV14J4114768?t=2.5&amp;p=355</a></p>
</li>
<li><p>多栏布局<br>多栏布局是最常见的css布局之一，实现的方式不下10种，它们分别应对各种各样的业务场景，而bs的流式布局堪称撑起一片天，它的响应式看似独霸天下能满足80%的要求，但开发者们仍会保留20%用于追逐更高效的技巧，而且随着前端的发展，原生bs流式布局已然有更优的实现方式了。</p>
</li>
<li><p>Layui – 快速实现页面布局效果，</p>
</li>
<li><p>防抖 节流<br><a href="https://www.bilibili.com/video/BV1zs411h74a?t=5.0&p=66">https://www.bilibili.com/video/BV1zs411h74a?t=5.0&amp;p=66</a></p>
</li>
<li><p>web APIs(页面适配，less，Sass等一些)</p>
<blockquote>
<p>Sass是css预处理器，提供了类似编程语言的功能，包括变量、嵌套规则、混合、继承、函数等。帮助开发者更高效的编写和组织样式表<br>  Sass并不能直接在浏览器执行，所以好需要配置IDE插件或者专门工具来将Sass文件编译成css文件才能使用</p>
</blockquote>
<blockquote>
<p>Less受Sass的启发，为开发人员提供更加高效便捷的样式表编写方式</p>
</blockquote>
</li>
<li><p>es6，模块化，组件化，css3，less，scss</p>
</li>
<li><p>QQ的卡片是怎么写的？随机给一张图片的那种卡片</p>
</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1p84y1P7Z5">尚硅谷前端入门html+css零基础教程，零基础前端开发html5+css3视频</a></p>
<ul>
<li><p><a href="https://gongchenghuigch.github.io/2018/10/24/reactecharts/">echarts-for-react使用详解(雷达图)</a></p>
</li>
<li><p><a href="https://gongchenghuigch.github.io/2018/10/15/linuxbase/">Linux基本命令</a></p>
</li>
<li><p><a href="https://gongchenghuigch.github.io/2019/09/14/awat/">setTimeout,promise,async await的区别</a></p>
<blockquote>
<p>EventLoop - 同步任务、异步任务（宏任务微任务）</p>
</blockquote>
</li>
</ul>
<h3 id="OWARI"><a href="#OWARI" class="headerlink" title="OWARI"></a>OWARI</h3><ol start="0">
<li><p>前端</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1eC411p73m/">前端技术的十八年风雨(2006-2024)-bilibili</a></li>
</ul>
</li>
<li><p>vue框架</p>
<ul>
<li>黑马vue课程（21.8 | vue2 - 12h）<br>  <a href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&p=32">https://www.bilibili.com/video/BV1zq4y1p7ga?t=3.5&amp;p=32</a><blockquote>
<p>vue3的部分和vue2的东西弄到一块了，不太好<br>  <a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=296">vue3-p296</a>开始是vue3，但是和vue2内容有绝大程度的重合，vue2部分挺不错，3就不推荐了</p>
</blockquote>
</li>
<li>vue项目 双元 – day10 - vuex<blockquote>
<p>传智 黑马课程 about 2 hours at 21years</p>
</blockquote>
</li>
<li>尚硅谷 禹神 Vue3+TS（23.12.19 | 14h）<blockquote>
<p>TypeScript+Vue3组合式API编码，讲的很好，就是有些东西没讲到，可以看官方文档补一下<br>      <a href="https://www.bilibili.com/video/BV1Za4y1r7KE">https://www.bilibili.com/video/BV1Za4y1r7KE</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li>阮一峰es6教程<br> <a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br> <a href="https://wangdoc.com/es6/intro">https://wangdoc.com/es6/intro</a></li>
</ul>
</li>
</ol>
<h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><ol>
<li><p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">鱼皮前端学习路线</a></p>
<blockquote>
<p><a href="https://www.codefather.cn/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-by-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE/">https://www.codefather.cn/前端学习路线-by-程序员鱼皮/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习路线</a></p>
<blockquote>
<p><a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
</ol>
<h2 id="Resourse"><a href="#Resourse" class="headerlink" title="Resourse"></a>Resourse</h2><ol>
<li><p><a href="https://www.freecodecamp.org/chinese/learn">freecodecamp编程免费教学慈善组织</a></p>
<blockquote>
<p>编程学习课程(可以获得认证，有官方中文) <a href="https://www.freecodecamp.org/chinese/learn">https://www.freecodecamp.org/chinese/learn</a></p>
</blockquote>
<blockquote>
<p>也有程序员英文学习课程——<a href="https://www.freecodecamp.org/chinese/learn/a2-english-for-developers/">学习面向开发者的英语课程</a></p>
</blockquote>
<blockquote>
<p>对应的<a href="https://www.freecodecamp.org/chinese/news/">专栏</a> 可以阅读学习一些技术文章</p>
</blockquote>
<blockquote>
<p>对应的<a href="https://forum.freecodecamp.org/c/chinese/533">学习论坛</a> 也是支持中文的</p>
</blockquote>
</li>
<li><p><a href="https://www.w3cschool.cn/codecamp/">w3c编程入门实战训练</a></p>
<blockquote>
<p><a href="https://www.w3cschool.cn/codecamp/">https://www.w3cschool.cn/codecamp/</a></p>
</blockquote>
</li>
<li><p><a href="https://developer.aliyun.com/learning/roadmap/frontend">阿里云前端开发学习</a></p>
<blockquote>
<p>同样是阿里云学习路线的网页，两者都在一个界面<br> <a href="https://developer.aliyun.com/learning/roadmap/frontend">https://developer.aliyun.com/learning/roadmap/frontend</a></p>
</blockquote>
</li>
<li><p><a href="https://time.geekbang.org/column/intro/154">极客时间前端基础 ￥59</a></p>
<blockquote>
<p>主讲人 程劭非（winter）  前手机淘宝前端负责人<br> 讲解JS、HTML、CSS、浏览器<br> <a href="https://time.geekbang.org/column/intro/154">https://time.geekbang.org/column/intro/154</a></p>
</blockquote>
</li>
</ol>
<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ol>
<li><p><a href="https://www.xuanfengge.com/it-job-seekers-resume-how-to-write.html">IT求职者的简历该如何编写</a>(轩枫阁)</p>
<blockquote>
<p>2014&#x2F;10&#x2F;14的帖子，不过还是有很多值得学习的地方</p>
</blockquote>
</li>
<li><p><a href="https://www.laoyujianli.com/">老鱼简历</a>(鱼皮)</p>
<blockquote>
<p>根据模板快速制作简历，可惜模版太少，不好看</p>
</blockquote>
</li>
<li><p><a href="https://www.canva.cn/"><font color="red">Canva可画</font></a>  </p>
<blockquote>
<p>非常好用的在线编辑工具，有很多简历模板，也可以自己制作<br>把老鱼简历薄纱了</p>
</blockquote>
</li>
<li><p><a href="https://juejin.cn/post/7080765301175877640"><font color="red">前端校招简历点评</font></a>（掘金 | 2022-03-30）</p>
<blockquote>
<p>说了很多简历的点，非常值得借鉴</p>
</blockquote>
</li>
</ol>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <font color="red">小满模拟面试</font> 强烈推荐！！(非常值得多刷的东西，小满和康老师太牛了！)<br><a href="https://www.bilibili.com/video/BV1gB4y1V7cN?t=10.8">https://www.bilibili.com/video/BV1gB4y1V7cN?t=10.8</a></li>
</ul>
<p>先在郑州实习一个月？因为还没放假，要是学校再有啥事情，还得飞回来，<br>然后后面再去广州看看？俺姨在广州的哪里？看看附近有没有实习的工作吧。</p>
<font color="red">
4号5号先去那些不要求uniapp和小程序的投一下
然后再去学校工作啦招聘投一下
</font>

<h3 id="前端经典面试题"><a href="#前端经典面试题" class="headerlink" title="前端经典面试题"></a>前端经典面试题</h3><ul>
<li><p><a href="https://juejin.cn/post/7056400571967733774">前端常见面试题（56道）（掘金）</a></p>
</li>
<li><p><a href="https://gitcode.csdn.net/6628b83a9ab37021bfb0b886.html">前端经典面试题 30道 (gitcode)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_39843414/article/details/120213065">前端经典面试题60道，附答案！(CSDN)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/2301_76379381/article/details/138986137">前端经典面试题 30道(1)</a></p>
</li>
<li><p><a href="https://gongchenghuigch.github.io/2019/09/15/mianshi/#toc-heading-1">前端经典面试题大全 - gongchenhui博客</a></p>
</li>
<li><p><a href="https://gongchenghuigch.github.io/2021/02/02/300%E9%81%93%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">300道基础面试题 - gongchenhui博客</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tsukimiya.github.io/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
