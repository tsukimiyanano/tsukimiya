<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="mask-icon" href="/tsukimiya.github.io/images/Study.ico" color="#222">

<link rel="stylesheet" href="/tsukimiya.github.io/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miniver:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tsukimiyanano.github.io","root":"/tsukimiya.github.io/","images":"/tsukimiya.github.io/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/tsukimiya.github.io/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/tsukimiya.github.io/js/config.js"></script>

    <meta name="description" content="TODO  浏览器渲染 – 回流、重绘  性能优化  Less、Sass学一下  React了解一下  Tailwind CSS了解一下  ts学一下  微前端   vue的异步组件suspense、动态组件 is属性 和keep-alive保持组件状态  如何使动态路由持久化？  回溯 – 一种搜索策略，经常用递归来实现(或者使用迭代 – 使用栈模拟递归)  vue的diff算法 – 双端比较、">
<meta property="og:type" content="website">
<meta property="og:title" content="前端八股">
<meta property="og:url" content="https://tsukimiyanano.github.io/tsukimiya.github.io/custom/%E5%85%AB%E8%82%A1.html">
<meta property="og:site_name" content="Ayu&#39;s Study Blog">
<meta property="og:description" content="TODO  浏览器渲染 – 回流、重绘  性能优化  Less、Sass学一下  React了解一下  Tailwind CSS了解一下  ts学一下  微前端   vue的异步组件suspense、动态组件 is属性 和keep-alive保持组件状态  如何使动态路由持久化？  回溯 – 一种搜索策略，经常用递归来实现(或者使用迭代 – 使用栈模拟递归)  vue的diff算法 – 双端比较、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tsukimiyanano.github.io/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81.png">
<meta property="og:image" content="https://tsukimiyanano.github.io/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A82.png">
<meta property="og:image" content="https://tsukimiyanano.github.io/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81-2.png">
<meta property="article:published_time" content="2024-05-30T02:10:10.000Z">
<meta property="article:modified_time" content="2024-06-04T09:48:57.788Z">
<meta property="article:author" content="Ayu">
<meta property="article:tag" content="hexo,next,ayu,tsukimiya,前端,node.js,nodejs,Node,nodeJS,vue,Vue,VUE,blog,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tsukimiyanano.github.io/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81.png">


<link rel="canonical" href="https://tsukimiyanano.github.io/tsukimiya.github.io/custom/%E5%85%AB%E8%82%A1">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":"","permalink":"https://tsukimiyanano.github.io/tsukimiya.github.io/custom/%E5%85%AB%E8%82%A1.html","path":"custom/八股.html","title":"前端八股"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端八股 | Ayu's Study Blog
</title>
  







<link rel="dns-prefetch" href="https://waline.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/tsukimiya.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/tsukimiya.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ayu's Study Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">求求你给我一份工作吧，我什么都会做的`orz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/tsukimiya.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tsukimiya.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/tsukimiya.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/tsukimiya.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/tsukimiya.github.io/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-guestbook"><a href="/tsukimiya.github.io/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>guestbook</a></li><li class="menu-item menu-item-pulledpost"><a href="/tsukimiya.github.io/PulledPost/" rel="section"><i class="fa fa-heart fa-fw"></i>PulledPost</a></li><li class="menu-item menu-item-cuntom-page"><a href="/tsukimiya.github.io/custom" rel="section"><i class="fa fa-folder fa-fw"></i>Cuntom Page</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO"><span class="nav-number">1.</span> <span class="nav-text">TODO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tostudylist"><span class="nav-number">2.</span> <span class="nav-text">tostudylist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue"><span class="nav-number">3.</span> <span class="nav-text">Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-if-%E5%92%8C-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">v-if 和 v-show 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-for-%E5%92%8C-v-if-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.2.</span> <span class="nav-text">v-for 和 v-if 的优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS"><span class="nav-number">4.</span> <span class="nav-text">JS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5%E5%92%8CES6%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">ES5和ES6继承的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parseInt"><span class="nav-number">4.2.</span> <span class="nav-text">parseInt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-map-parseInt"><span class="nav-number">4.3.</span> <span class="nav-text">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.4.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS"><span class="nav-number">5.</span> <span class="nav-text">CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E9%80%82%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.</span> <span class="nav-text">页面适配的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">定位的特殊应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC"><span class="nav-number">5.3.</span> <span class="nav-text">BFC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E5%AD%97%E7%8E%AF%E7%BB%95%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA"><span class="nav-number">5.4.</span> <span class="nav-text">文字环绕图片显示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E5%BA%95%E9%83%A8%E7%A9%BA%E7%99%BD%E7%BC%9D%E9%9A%99"><span class="nav-number">5.5.</span> <span class="nav-text">图片底部空白缝隙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7"><span class="nav-number">5.6.</span> <span class="nav-text">文本溢出显示省略号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E6%A1%86%E9%87%8D%E5%90%88%E5%8F%98%E7%B2%97%E9%97%AE%E9%A2%98"><span class="nav-number">5.7.</span> <span class="nav-text">边框重合变粗问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS%E4%B8%89%E8%A7%92%E6%A0%B7%E5%BC%8F%E7%AE%80%E5%86%99"><span class="nav-number">5.8.</span> <span class="nav-text">CSS三角样式简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flxe%E5%B8%83%E5%B1%80%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">5.9.</span> <span class="nav-text">flxe布局常用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%E5%89%8D%E7%BC%80%E5%86%99%E6%B3%95"><span class="nav-number">5.10.</span> <span class="nav-text">属性选择器前缀写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.11.</span> <span class="nav-text">媒体查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rem%E9%80%82%E9%85%8D%E5%B8%83%E5%B1%80"><span class="nav-number">5.12.</span> <span class="nav-text">rem适配布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%BC%95%E5%85%A5%E8%B5%84%E6%BA%90"><span class="nav-number">5.13.</span> <span class="nav-text">媒体查询引入资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E6%96%87%E4%BB%B6import%E5%AF%BC%E5%85%A5"><span class="nav-number">5.14.</span> <span class="nav-text">样式文件import导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.15.</span> <span class="nav-text">清除浮动的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">5.16.</span> <span class="nav-text">隐藏元素的三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">5.17.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML"><span class="nav-number">6.</span> <span class="nav-text">HTML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E8%AF%AD%E4%B9%89%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.</span> <span class="nav-text">&lt;b&gt;和&lt;strong&gt;语义区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TDK%E4%B8%89%E5%A4%A7%E6%A0%87%E7%AD%BESEO%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.</span> <span class="nav-text">TDK三大标签SEO优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LOGO-SEO%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">LOGO SEO优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta%E8%A7%86%E5%8F%A3%E6%A0%87%E7%AD%BE"><span class="nav-number">6.4.</span> <span class="nav-text">meta视口标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E6%AF%94"><span class="nav-number">6.5.</span> <span class="nav-text">移动端物理像素比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-2"><span class="nav-number">6.6.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">浏览器跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iframe-%E5%92%8C%E5%A4%9A%E7%AA%97%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">7.1.1.</span> <span class="nav-text">iframe 和多窗口通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSONP%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="nav-number">7.1.2.</span> <span class="nav-text">JSONP处理跨域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="nav-number">7.1.3.</span> <span class="nav-text">WebSocket处理跨域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="nav-number">7.1.4.</span> <span class="nav-text">CORS处理跨域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">7.2.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Worker"><span class="nav-number">7.3.</span> <span class="nav-text">Web Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">千万级别的数据如何处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">7.5.</span> <span class="nav-text">前端优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5%E8%BF%87%E7%A8%8B"><span class="nav-number">7.6.</span> <span class="nav-text">浏览器访问网页过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">7.7.</span> <span class="nav-text">HTTPS加密通信过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-3"><span class="nav-number">7.8.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">8.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.1.</span> <span class="nav-text">equals和&#x3D;&#x3D;的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E3%80%81set%E3%80%81map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.2.</span> <span class="nav-text">list、set、map的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap%E3%80%81treemap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">hashmap、treemap的区别，分别什么时候使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO%E5%92%8CIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.4.</span> <span class="nav-text">NIO和IO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-4"><span class="nav-number">8.5.</span> <span class="nav-text"></span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ayu"
      src="/tsukimiya.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ayu</p>
  <div class="site-description" itemprop="description">你们怎么能这么卷！！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/tsukimiya.github.io/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/tsukimiya.github.io/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tsukimiya.github.io/tags/">
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1832715838@qq.com" title="E-Mail → mailto:1832715838@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/tsukimiyanano" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tsukimiyanano" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">前端八股
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      <div class="post-body">
          <h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li><input checked="" disabled="" type="checkbox"> 浏览器渲染 – 回流、重绘</li>
<li><input checked="" disabled="" type="checkbox"> 性能优化</li>
<li><input checked="" disabled="" type="checkbox"> Less、Sass学一下</li>
<li><input checked="" disabled="" type="checkbox"> React了解一下</li>
<li><input checked="" disabled="" type="checkbox"> Tailwind CSS了解一下</li>
<li><input checked="" disabled="" type="checkbox"> ts学一下</li>
<li><input checked="" disabled="" type="checkbox"> 微前端 </li>
<li><input checked="" disabled="" type="checkbox"> vue的异步组件suspense、动态组件 is属性 和keep-alive保持组件状态</li>
<li><input checked="" disabled="" type="checkbox"> 如何使动态路由持久化？</li>
<li><input checked="" disabled="" type="checkbox"> 回溯 – 一种搜索策略，经常用递归来实现(或者使用迭代 – 使用栈模拟递归)</li>
<li><input checked="" disabled="" type="checkbox"> vue的diff算法 – 双端比较、同级比较、深度优先</li>
<li><input checked="" disabled="" type="checkbox"> vue如何定义全局组件<br> vue2-Vue.component(‘xx’,xx)<br> vue3-app.component(‘xx’,xx)</li>
<li><input checked="" disabled="" type="checkbox"> 复习一下mysql、了解一下Linux</li>
<li><input disabled="" type="checkbox"> git再学一下</li>
<li><input disabled="" type="checkbox"> 复习一下Vue，同时看一下H5 C3 JS的八股 </li>
<li><input disabled="" type="checkbox"> 复习一下webpack、nodejs、npm – 次要</li>
<li><input disabled="" type="checkbox"> 手写promise</li>
<li><input disabled="" type="checkbox"> 常问算法 – 冒泡排序、二分查找、快速排序、二叉树、堆栈、队列、贪心算法、动态规划、位运算、</li>
<li><input disabled="" type="checkbox"> 刷一下 那些经典面试题</li>
<li><input disabled="" type="checkbox"> 常见的安全协议如 HTTPS、SSH 等的原理和使用方法。</li>
<li><input disabled="" type="checkbox"> SSL通信过程</li>
</ol>
<p>** 可以前两个八股总结的挑一些看看</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fe.ecool.fun/topic-list?mode=light"><font color="red">前端面试题宝典</font></a><blockquote>
<p>提供分类和搜索功能，以及有难易度标注<br>适合长时间学习使用，保持更新</p>
</blockquote>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/wxlvip/Interviewer/blob/master/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#http-%E5%92%8C-https">八股总结 - github</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016593221815910408?share_token=d3db69f2-0924-4a84-9e44-72779c0c9dd5">八股总结 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7349136892334047247?share_token=55fcf98d-de35-4c8a-99c0-76381b929a8c">八股总结2 - 掘金</a></li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/hyqwan/fe-plan/irgtabu9ou5ve1f0">前端反卷计划</a></li>
<li><a target="_blank" rel="noopener" href="https://wuzhouwei.github.io/docs/tutorial-zwzj/zwzj_js/">御心狐博客</a></li>
</ul>
<h2 id="tostudylist"><a href="#tostudylist" class="headerlink" title="tostudylist"></a>tostudylist</h2><ul>
<li><p>算法 力扣hot100、150 , 剑指offer （大厂是比较看重算法的）</p>
<blockquote>
<p>大厂是比较看重算法的</p>
</blockquote>
</li>
<li><p>HTML&#x2F;CSS 常见的面试题 flex布局 盒子模型 常见布局 HTML5 CSS3新特性等等</p>
</li>
<li><p>JS中的数据类型 闭包 作用域 原型 原型链 数组常见操作 字符串常见操作 事件循环 深浅拷贝 事件代理 DOM、BOM操作 防抖节流 ES6相关的等等</p>
</li>
<li><p>Vue相关的 响应式 通信方式 生命周期 MVVM原理 虚拟dom diff算法 key 插件 混入 指令 权限设计 Vue3新特性 等等</p>
</li>
<li><p>HTTP、Webpack、Node相关的问题</p>
</li>
<li><p>前端安全，算法（如果目标企业不是大厂，可以练习一些常用的算法，如排序，数组字符串的常用操作）</p>
</li>
<li><p>数组常用方法</p>
</li>
<li><p>vue父子传值方式</p>
</li>
<li><p>HTTPS 中间人攻击<br>中间人攻击过程如下：</p>
<ol>
<li>服务器向客户端发送公钥。</li>
<li>攻击者截获公钥，保留在自己手上。</li>
<li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li>
<li>客户端收到伪造的公钥后，生成加密hash值发给服务器。</li>
<li>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。</li>
<li>同时生成假的加密hash值，发给服务器。</li>
<li>服务器用私钥解密获得假秘钥。</li>
<li>服务器用加秘钥加密传输信息</li>
</ol>
<p><strong>防范方法:</strong> 服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性。</p>
</li>
<li><p>promise相关</p>
</li>
<li><p>MVVM概念</p>
</li>
<li><p>简单算法题</p>
</li>
<li><p>element-ui覆盖方式</p>
</li>
<li><p>调试方法</p>
</li>
<li><p>axios封装 </p>
</li>
<li><p>前后端分离</p>
</li>
<li><p>打包自动化</p>
</li>
<li><p>代码版本管理、发布管理</p>
</li>
<li><p>日志管理</p>
</li>
<li><p>标准工程化、标准杨世华、自动化、组件化、插件化、nodeJS、性能优化</p>
</li>
<li><p>运维管理</p>
</li>
<li><p>nginx反向代理</p>
</li>
<li><p>服务器中台？</p>
</li>
<li><p>数据库表结构</p>
</li>
<li><p>网关、安全、加密？</p>
</li>
<li><p>uniapp？、微信小程序？、微信公众号？、安卓？、ios？</p>
</li>
<li><p>虚拟dom diff算法<br>  在vue框架团队开始着手开发框架的时候，他们有3种方法操作dom：1. document.createElement 2. innerHTML 3. virtual dom<br>  这个innerHTML性能是最差的，document是最好的，但是virtual dom开发体验是最好的，最后就是选用了这个进行框架的渲染。<br>  它需要配合渲染器和编译器来使用，像是vue就是先把模板语法通过编译器编译成一些对象，然后把对象扔给渲染器，渲染器最后把它渲染出来<br>  如果操作真实dom，它上面的元素，属性都特别多，程序运行起来会比较浪费时间</p>
</li>
<li><p>vue的diff算法和react的diff算法有区别，是什么？<br>  vue是能够明确的知道我要更新哪个组件，react是不知道的，只能从上往下找</p>
</li>
<li><p>有一百万条数据，返回给前端，前端怎么处理？怎么优化？（分页、虚拟列表、多线程webwork？）</p>
</li>
<li><p>时间切片？<br>  是在react Scheduler里面提出的，它通过将长时间运行的任务（如大组件树的渲染）分解为小任务（时间切片），并在多个浏览器任务之间交错执行这些小任务，确保了即使在执行大量工作时，浏览器也有机会处理其他高优先级任务，比如用户输入事件的响应，从而避免了界面卡顿。<br>  就是说，它是有一个人机交互时间，它不希望用户感觉卡顿，但是又不希望程序停下来运行，它就相当于把浏览器的运行和用户的交互交替运行，既让用户感觉不到卡顿，又让程序不停止运行</p>
</li>
<li><p>iframe和img都可以使用loading属性来实现懒加载</p>
</li>
<li><p>自动部署？</p>
</li>
<li><p>如何进行页面的主题切换？（换肤）</p>
</li>
<li><p>小程序如何进行分包？（项目有分包吗？）<br>  小程序本身有一个限制，当程序超过200m的时候，就没有办法进行打包了，所以需要分包</p>
</li>
<li><p>小程序的？onLoad、onShow、onReady、onHide、onUnload？onload和onshow的区别？</p>
</li>
<li><p>把小程序切出去，切到后台再切回来，会执行哪个？onshow？</p>
</li>
<li><p>微信小程序如何进行页面跳转？</p>
</li>
<li><p>小程序webview?嵌入一个H5页面？和H5的通信？和小程序通信？</p>
</li>
<li><p>小程序的bandtype和catchtype的区别？事件？还有个不是小程序的缓存？ – 一个冒泡，一个不冒泡？</p>
</li>
<li><p>抗锯齿？有些时候手机端显示文字可能会有锯齿，毛边，正常手机端是有个css属性可以抗锯齿的，但是那个效果并不好，而且支持性很差<br>transform里面的scale缩放，它用到了GPU，它这个是支持抗锯齿的，所以有的页面会写scale(1),啥都不做，也不缩放，目的就是为了抗锯齿，只要写到html根上</p>
</li>
<li><p>权限问题？如何处理？前端</p>
</li>
<li><p>按钮级别的权限？如控制菜单？</p>
</li>
<li><p>回溯？</p>
</li>
<li><p>递归是广度优先还是深度优先？<br>  递归是深度优先，它有一个回溯的操作<br>  广度优先是按队列来的<br>  递归是按栈来的，它有一个调用栈，最后一个递归调用的方法，最后调用，但是最先释放，然后依次回溯</p>
</li>
<li><p>vue的diff算法？（算是比较核心的东西？）</p>
</li>
<li><p>如何判断一个数据是数组？<br>  contructor.name？，就是那个构造函数的东西？<br>  还有isArray？原型链，instance of</p>
</li>
<li><p>vue-for的key是和diff算法有关的？</p>
</li>
<li><p>vue的响应式原理？</p>
</li>
<li><p>vue的路由变化是如何监听的？hash change？</p>
</li>
<li><p>如何使数组扁平化？<br>  es6的flat方法？还有es5的reduce方法？还有es5的递归？还有一个投机取巧的方法–转字符串转数组？</p>
</li>
<li><p>简历最好把自己会的技术都写上，不嫌多，最好列出来自己的技术，搜在线简历，有那种把所有的技术栈列在左边的，标有掌握还是熟悉的？推荐关注玩偶君的简历？玩偶君的简历，有技术栈，有项目经验，有项目展示，有自我评价，有联系方式，有github链接，有博客链接？？玩偶哥哥？</p>
</li>
<li><p>vue3的异步组件？动态组件？</p>
</li>
<li><p>负载均衡？</p>
</li>
<li><p>linux常用命令？</p>
</li>
<li><p>nignx常用命令？</p>
</li>
<li><p>rpc服务？</p>
</li>
<li><p>微服务mq？</p>
</li>
<li><p>数组去重？</p>
</li>
<li><p>js操作dom的方法？<br>  原生的document.queySelector、document.querySelectorAll、<br>  document.getElementsByClassName、<br>  document.getElementById、<br>  document.createElement、<br>  document.appendChild、…</p>
</li>
<li><p>浏览器缓存？</p>
</li>
<li><p>浏览器缓存机制？</p>
</li>
<li><p>session、cookie、token？jwt？</p>
</li>
<li><p>http和https的区别？</p>
</li>
<li><p>http2和http1.1？http1.1是有队列的，这个队列的长度是多少？</p>
</li>
<li><p>ssh的渲染方式？</p>
</li>
<li><p>分包加载？</p>
</li>
<li><p>js的线程和进程？</p>
</li>
<li><p>webjis?用来做地图的？</p>
</li>
<li><p>webrtc?</p>
</li>
<li><p>webgl?</p>
</li>
<li><p>websqllite?websqlL?</p>
</li>
<li><p>use strict严格模式？严格模式的限制？</p>
</li>
<li><p>变量提升？let和const有提升吗？</p>
</li>
<li><p>闭包。es6的let和const有闭包吗？</p>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h3><pre><code>* 两者都是用来控制元素是否显示
1. 在vue渲染模板的时候，v-if 是惰性加载的，只有条件为真时才会渲染，v-show 不管
2. v-show 通过改变元素的 display 属性来控制是否显示，v-if 是通过在 dom 中移除或者添加元素
3. v-if 每次都会重新渲染，v-show 只有第一次渲染
5. v-if 适合于条件不经常改变的场景，v-show 适合于频繁切换的场景
4. v-show 性能高，v-if 性能低 (其实实际开发中，这样的性能差是可以忽略不计的，基本都是使用 v-if)
</code></pre>
<h3 id="v-for-和-v-if-的优先级"><a href="#v-for-和-v-if-的优先级" class="headerlink" title="v-for 和 v-if 的优先级"></a>v-for 和 v-if 的优先级</h3><pre><code>1. vue2中，v-for优先级更高（v-if和v-for不推荐用在一个标签上，浪费性能）
2. vue3中，v-if的优先级提的更高了（但还是不推荐在同一个元素使用）
</code></pre>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="ES5和ES6继承的区别"><a href="#ES5和ES6继承的区别" class="headerlink" title="ES5和ES6继承的区别"></a>ES5和ES6继承的区别</h3><pre><code>* ES6 的继承机制，与 ES5 完全不同。
* ES5 通过 原型链或构造函数 实现继承，ES6 可以通过 class类 来实现继承。
- ES5 的继承机制：
是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。
- ES6 的继承机制：
则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。
* 这就是为什么 ES6 的继承必须先调用super()方法
  因为这一步会生成一个继承父类的this对象，没有这一步就无法继承父类。
</code></pre>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><pre><code>parseInt() 函数**解析字符串**并返回整数。
语法：
parseInt(string, radix)
参数：
* radix
基数radix，接收[2,36]的值作为基数，指定进制。
如果radix为1，则为无效基数，返回NaN。（没有意义，在数值解析中被认为是无效的）
如果省略radix，或 为0：
  - 如果字符串以 &quot;0x&quot;或&quot;0X&quot; 开头，则基数为 16（十六进制）
  - 如果字符串以 &quot;0&quot; 开头，则基数为 8（八进制）。此特性**已弃用**
  - 如果字符串以任何其他值开头，则基数为 10（十进制） -- 默认值

  ** 旧浏览器将导致 parseInt(&quot;010&quot;) 为 8，
    因为旧版本的 ECMAScript（比 ECMAScript 5 旧）当字符串以 &quot;0&quot; 开头时使用八进制基数 (8) 作为默认值。
    从 ECMAScript 5 开始，默认值为十进制基数 (10)。

返回值：
** 只返回字符串中的第一个数字！
** 如果第一个字符不能转换为数字，parseInt() 返回 NaN。
-----------------------------------------
示例：
parseInt([1,2,3]) // 1
因为parseInt() 函数只解析字符串，所以如果传入的参数不是字符串，它会先将其转换为字符串。
parseInt([1,2,3].toString()) -&gt; parseInt(&quot;1,2,3&quot;) // 1
----
parseInt(&quot;0x11&quot;) // 17
parseInt(&quot;0X11&quot;) // 17
</code></pre>
<h3 id="1-2-3-map-parseInt"><a href="#1-2-3-map-parseInt" class="headerlink" title="[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)"></a><code>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code></h3><pre><code>返回值：[1,NaN,NaN]

原因：
map函数会给函数参数传递三个参数：当前元素、索引、原数组。
所以这里是：
parseInt(&quot;1&quot;, 0, [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]) -&gt; parseInt(&quot;1&quot;, 0) -&gt; 1
parseInt(&quot;2&quot;, 1, [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]) -&gt; parseInt(&quot;2&quot;, 1) -&gt; NaN
parseInt(&quot;3&quot;, 2, [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]) -&gt; parseInt(&quot;3&quot;, 2) -&gt; NaN
第一次遍历，是10进制，返回的1，
第二次遍历，1是无效基数，返回NaN，
第三次遍历，是2进制，但3不是有效的数字，返回NaN
-----------------------------------------
测试map给函数传入的参数：
function go(value)&#123;
  console.log(arguments)
  return value
&#125;
[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(go) // [1,2,3]
* arguments：
[&quot;1&quot;,0,[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]]
[&quot;2&quot;,1,[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]]
[&quot;3&quot;,2,[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]]
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="页面适配的问题"><a href="#页面适配的问题" class="headerlink" title="页面适配的问题"></a>页面适配的问题</h3><pre><code>- 写页面是如何适配的？移动端、小程序是如何适配的？
  1. 响应式布局（rem动态计算）
  2. 媒体查询（px）
  3. 弹性布局（flex）
  4. 栅格布局（grid）
  5. vw、vh
- 如果说写H5页面，要适配移动端，包括大屏：
  正常来说，一旦包括了大屏，就不单单是手机端了，就绝对不可能用rem，用不了。
  因为rem会保证你当前这个字在哪个端都显示那么大，或者说你只要把PC端满足了，在手机端就满足不了。
  因为那个字的比例大小是不会变的，它永远是占屏幕的百分之多少，这是你动态算出来的结果。
  **那么正常来说，很多公司推荐的用法**：
  就算是手机端，也用px去显示，字体文字能用px就用px，因为px是最保真的。
  屏幕大了，这个文字一行可以多显示一点，屏幕小了可以少显示一点，
  但是**核心**还是这个：**CSS响应式@midia**，写多套的媒体查询，必须得写这个。
  这个东西 @media (max-width: 480px) &#123;
            body &#123;
              font-size: 14px;
            &#125;
          &#125;
  这套方案其实是最不好的，因为写东西太多了，非常繁琐，但是你这一个页面想要去适配这么多端，这个东西就逃不了

  很多公司也不愿意写这个媒体查询，因为这种方式非常不优雅
  就拿手机端最上面那个条来说，手机端那个条，它长的就和PC端不一样。
  PC端比如b站，有主页直播等横着放的，手机端就要放到一个菜单侧边栏里面，你就要重新再写一套
  当他的屏幕变小之后，要把PC这套给隐掉，这样的话：1.增加了工作量，2.不好维护
  所以说很多公司宁愿你去**写PC栈和m栈**，分多个项目去写。
  好处：手机可以完全跟PC分离，可以一点关系都没有，业务都可以分离，所以很多公司也都愿意这么去写

  但是目前来说，官网，门户（现在前端做门户做的少了，都变成外包项目了），但是这个门户，基本都是响应式的。
  因为它没啥用，就是做展示，给那个爬虫去爬，不管是手机端PC端，就是爬，页面就是死的。
  所以这种响应式的都是用在门户类业务，展示性数据大屏那种的，这两种用的比较多。
  因为页面基本内容不变，它没有更多的特殊的案例，比如手机端多个啥，PC端有个什么头，它没有这个东西
  这是目前来说**比较主流的两套**做适配的一个方案：**rem动态计算和px媒体查询**
  分到一套来说，能用px的就不用rem，能多展示内容的就多展示内容，尽量保证页面的宽度比
</code></pre>
<h3 id="定位的特殊应用"><a href="#定位的特殊应用" class="headerlink" title="定位的特殊应用"></a>定位的特殊应用</h3><ol>
<li>填满定位父元素<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81.png"></li>
<li>定位元素居中<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A82.png"></li>
<li>通过填满定位父元素，实现居中 – 上下左右都留出50px<br><img src="/tsukimiya.github.io/images/%E5%85%AB%E8%82%A1/%E5%AE%9A%E4%BD%8D%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A81-2.png"></li>
</ol>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><pre><code>* BFC（Block Formatting Context）块级格式化上下文，它规定了内部的块级元素的布局规则。
* 块级元素可以看作是一个独立的渲染区域，它规定了内部的元素如何布局，以及与外部的元素相互影响。
* BFC的布局规则/特性：
  1. 内部的块级元素会在垂直方向，一个接一个地放置。
  2. 内部的块级元素垂直方向的距离由margin决定。
  3. 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。
    即使存在浮动也是如此。
    - 也就是说，BFC的区域不会产生外边距合并(也叫margin塌陷)的问题。
  4. BFC的区域不会与float box重叠。（不会被其他浮动元素覆盖）
  5. 计算BFC的高度时，浮动子元素也参与计算。（BFC不会有浮动坍塌的问题）
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会在布局上影响到外面的元素，反之亦然。
* 创建/开启BFC的方法：
  1. float的值不为none
  2. position的值为absolute或fixed
  3. overflow的值不为visible
  4. display的值为flex、grid、inline-block、flow-root、table、table-cell和table-caption中的任何一个
    display: table-cell 和 table-caption 是用来模拟HTML表格的行为
  5. column-span为all的元素（即使该元素没有包裹在多列容器中）
  6. 位于flex布局的容器内(自身是伸缩项目)
  7. 多列容器（column-count或column-width）-- 如 column-count: 1;
* 自带BFC的元素：
  - 根元素
  - 表格元素（table、thead、tbody、tfoot、th、td、tr、caption）

** 在这些开启BFC的方法中，都或多或少会有一些副作用，其中display：flow-root的影响是最低的。
  - flow-root 生成一个块级元素盒 ，其会建立一个新的BFC。
  - 弊端：IE不太支持
</code></pre>
<h3 id="文字环绕图片显示"><a href="#文字环绕图片显示" class="headerlink" title="文字环绕图片显示"></a>文字环绕图片显示</h3><pre><code>给图片设置浮动，文字就自动环绕图片显示，不会被压住
CSS的浮动（float）属性**最初设计的主要目的**是为了实现**文字环绕图片**的效果。
</code></pre>
<h3 id="图片底部空白缝隙"><a href="#图片底部空白缝隙" class="headerlink" title="图片底部空白缝隙"></a>图片底部空白缝隙</h3><pre><code>* 图片底部有缝隙，是因为行内块元素会和文字的基线对齐
* 解决办法：
  1. 给图片添加vertical-align: top | middle | bottom 等（提倡使用的）
  2. 把图片转换为块级元素display：block
    // 只有行内元素、行内块元素才有vertical-align属性
    // 块级元素没有这个属性，也不会有空白空隙问题
  3. 设置font-size: 0; 也可以解决
</code></pre>
<h3 id="文本溢出显示省略号"><a href="#文本溢出显示省略号" class="headerlink" title="文本溢出显示省略号"></a>文本溢出显示省略号</h3><pre><code>* 单行文本溢出显示省略号：
  1. 强制一行内显示文本：white-space: nowrap;
  2. 超出的部分因此：over-flow: hidden;
  3. 文字用省略号代替超出的部分：text-overflow: ellipsis;

* 多行文本溢出显示省略号： -- 有兼容性问题 - 适用于webKit内核浏览器
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box; /* 弹性伸缩盒子模型显示 */
  -webkit-line-clamp: 2; /*  限制在一个块元素显示的文本的行数 */
  -webkit-box-orient: vertical; /* 设置伸缩盒对象的子元素的排列方式 */
这里的line是2，省略号是显示在第二行，如果第二行文字不够不显示省略号
一般是把盒子高度设置正好最后一行是line设置的位置

** 这个多行文本溢出显示省略号，更推荐让后台来做这个效果
   因为后台可以设置显示多少个字，操作更简单，且没有兼容性问题，效果会更佳
</code></pre>
<h3 id="边框重合变粗问题"><a href="#边框重合变粗问题" class="headerlink" title="边框重合变粗问题"></a>边框重合变粗问题</h3><pre><code>* 边框重合问题：
  如果一行的多个元素都是带有边框的，排列在一起，他们之间的边框会正好排列在一起
  (比如用浮动来实现)
  一般可能会想到给每个元素只设置一个左边框，最后一个元素设置左右边框之类，但是这样比较麻烦
* 解决办法：
  margin负值 -- 值设置为边框的宽度的负值
  这样右边的盒子边框正好压住左边的边框，就看起来是一条边框的效果

** 这种做法导致了一个问题：
如果想要做这样一个效果：鼠标滑到盒子上，边框变色显示
就会导致元素右边的边框被压住，没有显示出来
* 解决办法：
  鼠标经过某个盒子，提高当前盒子的层级：
  如果没有设置定位，则加相对定位（保留位置）因为**相对定位会压住其他标准流，还有浮动的盒子**
  如果有定位，则加z-index提高当前定位元素的层级
</code></pre>
<h3 id="CSS三角样式简写"><a href="#CSS三角样式简写" class="headerlink" title="CSS三角样式简写"></a>CSS三角样式简写</h3><pre><code>* 三角样式一般写法：
  width: 0;
  hight: 0;
  border-top: 100px solid transparent;
  border-right: 50px solid red;
  border-bottom: 0px solid transparent;
  border-left: 0px solid transparent;
* 简写写法：
  border-color: transparent red transparent transparent;
  border-style: solid;
  border-width: 100px 50px 0 0;
</code></pre>
<h3 id="flxe布局常用属性"><a href="#flxe布局常用属性" class="headerlink" title="flxe布局常用属性"></a>flxe布局常用属性</h3><pre><code>* 父项常见属性
flex-direction :设置主轴的方向
justify-content:设置主轴上的子元素排列方式
flex-wrap∶设置子元素是否换行
align-items :设置侧轴上的子元素排列方式(单行)
align-content:设置侧轴上的子元素的排列方式(多行)
flex-flow :复合属性，相当于同时设置了flex-direction和flex-wrap // 默认值：row nowrap

* 子项常见属性
flex子项目占的份数，定义子项目分配剩余空间【最重要】
  - flex是复合属性，包括flex-grow, flex-shrink, 和 flex-basis这三个子属性
  1. flex-grow，表示子项是否可放大，默认0
  2. flex-shrink，表示子项是否可缩小，默认1
  3. flex-basis，表示分配剩余空间之前，子项的初始大小，默认auto（某些解释为0）
  - flex单值语法：flex：1 ，会被作为flex-grow:1;的值
  - 双值语法：第二个值根据具体值来决定flex-shrink、flex-basis
    flex：1 200px; -- flex-grow:1; flex-shrink:1; flex-basis:200px;
    flex：1 1; -- flex-grow:1; flex-shrink:0; flex-basis:auto;

align-self控制子项自己在侧轴的排列方式（单独移动某个子项盒子）
order属性定义子项的排列顺序(前后顺序) -- 默认值为0，值越小排列越靠前
</code></pre>
<h3 id="属性选择器前缀写法"><a href="#属性选择器前缀写法" class="headerlink" title="属性选择器前缀写法"></a>属性选择器前缀写法</h3><pre><code>现在有这样一个结构：
&lt;ul&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
我们想要给这个span加上相同的样式，但是每个span有不同的图片显示，可以这么做：
&lt;ul&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon1&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon2&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon3&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;nav-icon-icon4&quot;&gt;xxx&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
然后使用属性选择器：
ul li [class^=&quot;nav-icon&quot;]&#123; /* 设置相同的样式 */
  ...
&#125;
ul li .nav-icon-icon1&#123;...&#125; /* 每个span设置不同样式/图片 */
ul li .nav-icon-icon2&#123;...&#125;
ul li .nav-icon-icon3&#123;...&#125;
ul li .nav-icon-icon4&#123;...&#125;
</code></pre>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><pre><code>媒体查询（Media Query）是CSS3新语法。
@media 可以针对不同的屏幕尺寸设置不同的样式
当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

语法：
@media mediatype and|not|only (media feature) &#123;
  CSS-Code;
&#125;
- 用@media开头
- mediatype 媒体类型：all、screen、print(打印机 打印预览)等
- 关键字：and、not、only
- media feature 媒体特性 - 必须写在()里面

* 媒体特性：
  width： 定义输出设备中的页面可见区域宽度
  min-width：定义输出设备中的页面最小可见区域宽度
  max-width：定义输出设备中的页面最大可见区域宽度

* 示例：
在屏幕上 并且 最大宽度为 &lt;=800像素时候，设置想要的样式
@media screen and (max-width: 800px) &#123;
  ...
&#125;

** 为了防止混乱，媒体查询我们**从小到大**，或从大到小的顺序写
** CSS样式顺序：
  1. 重置样式 2. 正常写的样式 3. 媒体查询
  推荐这样来写，把媒体查询样式写在最后面，这样不会因为样式覆盖导致媒体查询不生效
</code></pre>
<h3 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h3><pre><code>媒体查询 + rem 实现不同设备宽度，页面元素大小动态变化
* 注意：一般会给页面较外层的元素设置rem值 + min-width值，避免页面元素过小，内容过度紧凑

** rem单位 -- css3新增的单位
rem是相对于根元素html的font-size来计算的
em是相对于父元素的font-size来计算的

@media screen and (min-width: 360px) &#123;
  html&#123;
    font-size: 50px;
  &#125;
&#125;
@media screen and (min-width: 640px) &#123;
  html&#123;
    font-size: 100px;
  &#125;
&#125;
-----------------------------------------------------
**** 实际开发适配 方案1：媒体查询+rem****
1. 媒体查询 - 按照设计稿与设备宽度的比例，动态计算并设置html跟标签的font-size大小
2. css中，设计稿中元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值

**** 方案2 ：flexible.js + rem （推荐）****
flexible.js 是手机淘宝团队出的简洁高效，兼容性更好的移动端适配库
我们不再需要写不同屏幕的媒体查询，因为里面js做了处理
--
它的原理是：把当前设备划分成10等份，并把html的font-size设置为1份的大小
这个时候，如果我们要把页面最大订死到版心的750像素，就需要给body设置max-width:750px;
同时写一个媒体查询，给html的font-size设置为75px：
@media screen and (max-width: 750px) &#123;
  font-size: 75px!important; // 设置最高权重，否则会被flexible.js覆盖
&#125;

***** 理解flexible.js *****
我们要做的，根据设计稿的大小，来计算我们写页面时候，划分为10等份的font-size大小
比如当前设计稿是750px，那么html的font-size 就是 75px
我们并不需要去设置html的font-size，而是按照这个75px值来写(设计稿的1/10为1rem)
里面页面元素的rem值：页面元素的rem值就是 px值 / 75px 
这样我们写出来的比例是正确的，font-size的值变化，页面元素也会等比例缩放跟着变化
flexible.js做的，就是根据实际设备屏幕宽度，动态的计算的划分给html的font-size大小
然后再去根据这个font-size大小，计算页面元素的rem值，显示出来
***************************

也就是说，我们不需要再去关心媒体查询，
只需要把页面设计稿的元素大小，按照 元素大小 / 1rem(设计稿的宽度 / 10) 换算为rem值即可

我们还可以借助cssrem插件，它能自动把px值换算为rem值 -- 我们写下的px，敲下回车提示，就会换算成对应的rem
注意：cssrem插件默认的html文字大小是16px，我们需要手动设置成我们想要的：
settings.json -- &quot;cssrem.rootFontSize&quot;: 75
这个时候，我们就不用去管媒体查询了，也不需要再管怎么换算的问题了o(^▽^)o

* github地址：https://github.com/amfe/lib-flexible
-----------------------------------------------------

*** 设计稿常见尺寸宽度
1. iPhone4、5 -- 640px
2. iPhone6、7、8 -- 750px
3. Android -- 常见320px、360px、375px、384px、400px、414px、500px、720px
// 大部分4.7-5寸的安卓设备为720px

一般情况下，我们以1、2套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果。
**现在基本以750px为标准**。
-----------------------------------------------------
** 动态设置html标签font-size大小
1. 假设设计稿是750px
2. 假设把整个屏幕划分为15等份（标准不一，也可以是20、10）
3. 每一份作为html字体大小，这里就是50px
4. 那么在320px设备的时候，字体大小为 320/15 = 21.33px
5. 用页面元素的大小，除以不同的html字体大小，能够实现页面元素盒子等比例缩放的效果

// rem的适配部分建议去看看腾讯Alloy团队对此的讲解
</code></pre>
<h3 id="媒体查询引入资源"><a href="#媒体查询引入资源" class="headerlink" title="媒体查询引入资源"></a>媒体查询引入资源</h3><pre><code>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的css样式
直接在link中判断设备的尺寸，引入不同的css文件
&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;xxx.css&quot;&gt;
**如：
&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 360px) and (max-width: 800px)&quot;
type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;
</code></pre>
<h3 id="样式文件import导入"><a href="#样式文件import导入" class="headerlink" title="样式文件import导入"></a>样式文件import导入</h3><pre><code>css3中，@import规则被引入，用来导入外部样式表。
css的@import规则是less、sass等css预处理器中常用到的.

css中，导入样式表有两种方式：
1. 直接导入
@import &quot;style.css&quot;; // 必须带上后缀名
2. 条件导入
@import &quot;style.css&quot; screen and (min-width: 360px) and (max-width: 800px)

less和sass中，同样使用@import导入文件，且默认会自动合并导入的文件内容。
less中导入文件：
@import &quot;style.less&quot;   // 可以不加后缀名 @import &quot;style&quot;  ---- 废弃了
新本的less 导入格式是@import url(common.less); // 可以不加后缀名
</code></pre>
<h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><pre><code>1. 添加伪元素：
  .clearfix:after &#123;
    content: &quot;&quot;;
    display: block;
    clear: both;
  &#125;
2. 使元素创建BFC，常用方式：overflow:hidden;
</code></pre>
<h3 id="隐藏元素的三种方式"><a href="#隐藏元素的三种方式" class="headerlink" title="隐藏元素的三种方式"></a>隐藏元素的三种方式</h3><pre><code>opacity: 0、visibility: hidden、display: none
1. opacity: 0
渲染效果：元素仍然占据空间，只是完全透明，不可见。这意味着元素仍然存在于页面布局中，其位置和大小保持不变。
布局影响：元素仍然参与页面布局，会影响周围元素的布局。
事件监听：元素仍然接收鼠标和其他用户交互事件。
访问性：屏幕阅读器仍可以读取内容，除非额外添加了 aria-hidden=&quot;true&quot;。
2. visibility: hidden
渲染效果：元素不可见，但保留其原本的空间，就像元素仍然可见一样。
布局影响：元素仍然占据空间，不影响页面布局。
事件监听：元素不会接收任何用户交互事件，即使光标悬停或点击在元素的位置上。
访问性：屏幕阅读器仍可以读取内容，除非额外添加了 aria-hidden=&quot;true&quot;。
3. display: none
渲染效果：元素完全从页面中消失，不仅不可见，而且不占据任何空间。
布局影响：元素不会参与页面布局，不会对周围元素的布局造成任何影响。
事件监听：元素不会接收任何用户交互事件，因为元素实际上已经从文档流中移除。
访问性：屏幕阅读器不会读取内容，元素对于辅助技术来说是不可见的。
* 总结：
- 使用 opacity: 0 可以让元素透明但保留空间，适合动画和过渡效果。
- 使用 visibility: hidden 可以隐藏元素，但仍保留其在布局中的位置，适用于临时隐藏元素而不改变布局的情况。
- 使用 display: none 完全移除元素，适用于不需要元素在页面布局中占位的情况。
</code></pre>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="和语义区别"><a href="#和语义区别" class="headerlink" title="&lt;b&gt;和&lt;strong&gt;语义区别"></a><code>&lt;b&gt;</code>和<code>&lt;strong&gt;</code>语义区别</h3><pre><code>* &lt;b&gt;（Bold）标签：它是一个实体标签，仅表示文本应该以粗体显示，而不传达任何特定的语义信息。
  在HTML早期，&lt;b&gt;标签常被用于加粗文本纯粹出于视觉样式考虑，而不涉及内容的重要性或强调。
* &lt;strong&gt;（Strong Importance）标签：与&lt;b&gt;标签不同，&lt;strong&gt;标签具有语义上的含义，
  它表明被包含的文本具有特别的重要性或强度。
  搜索引擎会给予&lt;strong&gt;标签内的内容更高的权重，因为它暗示这些内容对于理解文档的主旨可能是关键的。
</code></pre>
<h3 id="TDK三大标签SEO优化"><a href="#TDK三大标签SEO优化" class="headerlink" title="TDK三大标签SEO优化"></a>TDK三大标签SEO优化</h3><pre><code>1. title
&lt;title&gt;xxx - xxxxx&lt;/title&gt;
建议：网站名(产品名) - 网站的介绍（尽量不超过30个汉字）
如：京东(JD.COM) - 综合网购首选 - 正品低价、品质保障、配送及时、轻松购物！
2. description
&lt;meta name=&quot;description&quot; content=&quot;...&quot; /&gt;
简要说明我们网站主要是做什么的。
多采用“我们是...”、“我们提供...”、“xxx网作为...”、“电话：010...”之类语句
3. keywords
&lt;meta name=&quot;keywords&quot; content=&quot;xxx,xxx,xxx,xxx&quot; /&gt;
页面关键字，是搜索引擎的关注点之一
keywords最好限制为6~8个关键字，关键词之间用英文逗号隔开，采用“关键词1,关键词2,关键词3”的格式
把权重产品靠前写，越靠前权重越高，被搜索的概率会越大
</code></pre>
<h3 id="LOGO-SEO优化"><a href="#LOGO-SEO优化" class="headerlink" title="LOGO SEO优化"></a>LOGO SEO优化</h3><pre><code>1. logo里面首先放一个 `h1`标签，目的是为了提权，告诉搜索引擎，这个地方很重要
2. h1里面再放一个 `链接` ，可以返回首页的，把logo的背景图片给链接即可
3. 为了让搜索引擎更好的收录我们，链接里面要放`文字（网站名称）`，但是文字不要显示出来
  - 方法1：text-index移到盒子外面(text-indent:-9999px;),over-flow:hidden; 淘宝的做法
  - 方法2：font-size:0; 京东的做法
4. 最后给链接一个`title属性`
</code></pre>
<h3 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h3><pre><code>* 标准的viewport设置
 `&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;`
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>宽度设置的是viewport宽度，可以设置</td>
</tr>
<tr>
<td>initial-scale</td>
<td>初始缩放比，大于0的数字</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>最大缩放比，大于0的数字</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>最小缩放比，大于0的数字</td>
</tr>
<tr>
<td>user-scalable</td>
<td>用户是否可以缩放,yes或no (1或0)</td>
</tr>
</tbody></table>
<h3 id="移动端物理像素比"><a href="#移动端物理像素比" class="headerlink" title="移动端物理像素比"></a>移动端物理像素比</h3><pre><code>* 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。
* 这是厂商在出厂时就设置好了,比如苹果6\7\8是750*1334
* 我们开发时候的1px不是一定等于1个物理像素的
* PC端页面，1个px等于1个物理像素的，但是移动端就不尽相同
* 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比

在移动端，手机都采用视网膜屏幕的技术，1个px等于多少物理像素点，由设备决定
在iphone8上，1个px等于2个物理像素点，750的物理像素宽，实际开发像素宽只有375px

视网膜屏幕(Retina)显示技术，把更多的物理像素点压缩至一块屏幕里，达到更高的分辨率，提高屏幕显示的细腻程度。
原来1css像素和物理像素是一一对应的，现在采取了更多的物理像素点来显示1个css像素。

**这就导致了一个问题：
  文字和纯色的盒子大小影响不会很大，但是图片就会出问题
  50*50的图片，会被放大两倍，变成100*100的显示，就会有一个**模糊**的问题
* 解决办法：
  在标准的viewport设置中，使用**倍图**来提高图片质量，解决在高清设备中的模糊问题
  **准备比实际需要大两倍的图片**
  如果需要一个50*50的图片，那么就准备一个100*100的图片，把它设置为50*50的显示，到手机里面就不会模糊了
  通常使用2倍图，具体几倍图看实际开发公司需求
</code></pre>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h3><pre><code>* 浏览器有一个同源策略，目的是为了保证用户信息的安全，防止恶意的网站窃取数据。
* 如果非同源，共有三种行为受到限制：
  （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
  （2） 无法接触非同源网页的 DOM。
  （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

* 常用的解决跨域的几种方式：
  1. cors -- 设置响应头
  2. jsonp -- 动态创建script标签 -- 只能发送get请求
  3. nginx反向代理 
  4. iframe多窗口通信 -- postMessage()跨文档通信 API / 片段识别符 -- hash
    还适用于window.open方法打开的窗口
    iframe跨域，需要设置name属性。
    iframe会阻塞页面加载，用的不多，因为不太好使
  5. document.domain属性 -- 同域名下的子域名之间规避同源政策
</code></pre>
<p>  <a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/same-origin">浏览器同源限制</a></p>
<h4 id="iframe-和多窗口通信"><a href="#iframe-和多窗口通信" class="headerlink" title="iframe 和多窗口通信"></a>iframe 和多窗口通信</h4><pre><code>iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。
iframe窗口之中的脚本，可以获得父窗口和子窗口。
但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。

如果两个窗口一级域名相同，只是二级域名不同，那么*设置document.domain属性*，就可以*规避同源政策*，拿到 DOM。

对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。
- 片段识别符（fragment identifier）-- 属于破解
    指的是，URL 的#号后面的部分。比如 http://example.com/x.html#fragment 的 #fragment。
    如果只是改变片段标识符，页面不会重新刷新。
    父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。子窗口通  过监听 hashchange事件 得到通知。
    同样的，子窗口也可以改变父窗口的片段标识符。
- 跨文档通信API（Cross-document messaging） -- H5新增API
    这个 API 为window对象新增了一个 window.postMessage方法 ，允许跨窗口通信，不论这两个窗口是否同源。
    举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。
        // 父窗口打开一个子窗口
        var popup = window.open(&#39;http://bbb.com&#39;, &#39;title&#39;);
        // 父窗口向子窗口发消息
        popup.postMessage(&#39;Hello World!&#39;, &#39;http://bbb.com&#39;);
    postMessage方法的第一个参数是具体的信息内容，
    第二个参数是接收消息的窗口的源（origin），
    即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。

    父窗口和子窗口都可以通过message事件，监听对方的消息。
    通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。
</code></pre>
<h4 id="JSONP处理跨域"><a href="#JSONP处理跨域" class="headerlink" title="JSONP处理跨域"></a>JSONP处理跨域</h4><pre><code>JSONP 是服务器与客户端跨源通信的常用方法。
最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。
JSONP 的**优势**在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

1. 它通过在网页添加一个&lt;script&gt;元素，向服务器请求一个脚本，来实现跨域请求。
  如&lt;script src=&quot;http://api.foo.com?callback=bar&quot;&gt;&lt;/script&gt;
  注意，请求的脚本网址有一个callback参数（?callback=bar），用来告诉服务器，客户端的回调函数名称（bar）。
2. 服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（bar(&#123;...&#125;)）。
3. 客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是&lt;script&gt;标签请求的脚本内容。
  这时，客户端只要定义了bar()函数，就能在该函数体内，拿到服务器返回的 JSON 数据。
  function bar(data) &#123;
    console.log(&#39;Your public IP address is: &#39; + data.ip);
  &#125;;
  服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。
  bar(&#123;
    &#39;ip&#39;: &#39;8.8.8.8&#39;
  &#125;);
  由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了bar函数，该函数就会立即调用。
  作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。
</code></pre>
<h4 id="WebSocket处理跨域"><a href="#WebSocket处理跨域" class="headerlink" title="WebSocket处理跨域"></a><font id="websocket处理跨域">WebSocket处理跨域</font></h4><pre><code>WebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。
该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

例子：浏览器发出的 WebSocket 请求的头信息
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com

Origin字段，表示该请求的请求源（origin），即发自哪个域名。

正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源政策。
因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>
<h4 id="CORS处理跨域"><a href="#CORS处理跨域" class="headerlink" title="CORS处理跨域"></a>CORS处理跨域</h4><pre><code>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。
它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。
相比 JSONP 只能发GET请求，**CORS 允许任何类型的请求**。

对于CORS处理跨域，浏览器是帮我们自动进行了处理的。
浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息。比如添加一个origin字段，表示请求的来源。
整个 CORS 通信过程，都是浏览器自动完成，对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。
因此，**实现 CORS 通信的关键是服务器**。只要服务器实现了 CORS 接口，就可以跨源通信。  
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><pre><code>webSocket是一种通信协议，是建立在TCP之上的，使用ws://（非加密）和wss://（加密）作为协议前缀。
和HTTP协议不同，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
</code></pre>
<p>  详见 ↑ <a href="#websocket%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F">WebSocket处理跨域</a></p>
<h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><pre><code>JS是是一门单线程语言。
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。
在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。
这样有利于随时响应主线程的通信。
但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

好处：一些计算密集型或高延迟的任务可以交由 Worker 线程执行，
主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。

**可以应用到千万级别数据的处理上**
</code></pre>
<h3 id="千万级别的数据如何处理？"><a href="#千万级别的数据如何处理？" class="headerlink" title="千万级别的数据如何处理？"></a>千万级别的数据如何处理？</h3><pre><code>- 后端返回给前端千万级别的数据应该如何处理？
  1. 分页 -- 每次只加载固定数量的数据项
    强调的是数据的结构性和导航控制
  2. 懒加载/无限滚动 -- 当用户滚动页面时，按需加载更多数据
    侧重于提供不间断的内容浏览体验。
  3. WebSocket 或 Server-Sent Events (SSE) 实时推送 -- 服务器将数据推送到浏览器，无需客户端请求
    对于实时性要求较高的应用，可以使用WebSocket或SSE建立持久连接，按需推送数据更新，而不是频繁地轮询后端。
  4. Web Worker -- 浏览器多线程处理，将计算密集型任务交给Worker线程
    在不影响用户界面响应的情况下处理大量数据。
    虽然Web Worker可以提高处理大数据的效率，
    但是千万级别的数据仍然可能超出Web Worker处理能力的上限，特别是在**内存使用方面**。
    因此，有效的数据分页、分块策略以及结合其他前端性能优化技术仍然是必要的。
  5. 虚拟列表 -- 一种UI渲染技术
    只实际渲染可视区域内的列表项，其余未可视部分则不渲染或只渲染占位符。
    随着滚动，列表项被动态地创建和销毁。
    目的是减少DOM元素的数量，从而优化内存使用和提高滚动性能。
</code></pre>
<h3 id="前端优化策略"><a href="#前端优化策略" class="headerlink" title="前端优化策略"></a>前端优化策略</h3><pre><code>1. 减少HTTP请求数 -- 项目资源合并
2. 项目资源压缩 -- 代码、图片等资源压缩
3. 精灵图/雪碧图 -- 减少http请求
  * 随着CSS3、SVG、字体图标等技术的兴起，CSS Sprite的使用场景逐渐减少
  因为精灵图在响应式设计和高密度屏幕上的兼容性和灵活性较差。
4. 字体图标
5. 减少DOM操作 -- 减少重绘和回流
6. 异步加载 -- 避免阻塞页面渲染
7. 静态资源CDN -- 缩短用户请求静态资源的距离，提高资源加载速度
8. 按需加载
9. 懒加载 -- 延迟加载策略，推迟非关键资源的加载，减少页面初始加载时间，节省带宽，减轻服务器负担
10. 预加载 -- 提前加载关键资源，减少用户等待时间，改善首次加载速度和用户体验。
  * 可以通过&lt;link rel=&quot;preload&quot;&gt;在文档解析期间，会告知浏览器优先加载特定资源 
  * 预加载通常指两种情况：
    1. 主动预加载(称优先加载更合适些) -- 在页面加载时候，优先加载关键资源
    2. 预测性预加载 -- 网站有多个页面，开发者可能会预测用户接下来最有可能访问的页面，并预先加载该页面的关键资源
  ** 过度预加载可能会浪费带宽和服务器资源

11. 减少DNS查询 -- 加载外部资源时，浏览器会根据域名查询DNS，DNS查询是耗时的。
  * 可以通过减少不同域名的使用、使用DNS预加载技术（如&lt;link rel=&quot;dns-prefetch&quot;&gt;）、利用CDN和子域来优化DNS查询

12. 代码分割 -- 代码分割可以将代码拆分成多个包，然后按需加载
13. 缓存 -- 浏览器缓存
14. 减少JS执行时间 -- 避免复杂的计算和循环，减少时间监听器的数量，避免在页面加载时执行大量脚本
15. Web Workers -- 将复杂或耗时的计算任务放到Web Workers中执行，避免阻塞主线程，保持UI响应性。
</code></pre>
<h3 id="浏览器访问网页过程"><a href="#浏览器访问网页过程" class="headerlink" title="浏览器访问网页过程"></a>浏览器访问网页过程</h3><pre><code>1. 输入域名，开始访问
2. 检查DNS缓存：浏览器首先会检查本地DNS缓存中是否存在该域名对应的IP地址记录。
   如果找到且记录有效（未过期），则跳过DNS解析，使用该IP地址
3. DNS查询：若DNS缓存中没有找到有效记录，浏览器会向DNS服务器发起请求，进行域名解析，最终获得目标网站的IP地址。
4. 检查HTTP缓存：在得到IP地址后，浏览器先检查其HTTP缓存中是否有与请求URL相匹配的缓存资源。
   如果存在有效（未过期且遵循缓存控制策略）的缓存，浏览器可以直接使用这些资源，无需向服务器发送请求。
5. 发送HTTP请求：如果缓存检查失败，或者缓存策略要求重新验证资源状态，浏览器会向服务器发送HTTP请求。
6. 接收响应并处理：服务器接收到请求后，会根据请求内容和当前资源状态返回响应。

* 通过以上流程，浏览器能够高效地管理缓存，减少不必要的网络传输，提高网页加载速度和用户体验。
</code></pre>
<h3 id="HTTPS加密通信过程"><a href="#HTTPS加密通信过程" class="headerlink" title="HTTPS加密通信过程"></a>HTTPS加密通信过程</h3><pre><code>HTTPS加密方式：SSL/TLS安全协议 
采用非对称加密和对称加密相结合的方式
1. 客户端首先向服务器请求HTTPS连接
  ** HTTPS连接是建立在TCP连接之上的，TCP三次握手建立连接之后，才会进行HTTPS连接
2. 服务器响应客户端请求，将CA证书发送给客户端。证书包含公钥和大量的信息，如颁发机构信息，有效期等。
  ** 证书用来验证服务器的身份，防止被中间人攻击
  ** 证书本身携带电子签名，可以用来验证证书的完整性和真实性，防止证书被篡改。
3. 客户端解析证书并对其进行验证。
   如果证书不是可信机构颁布，或者证书上的域名与实际域名不一致，或者证书已经过期，就会显示警告
   如果证书没有问题，客户端会从证书中取出公钥，然后生成一个随机密钥，用公钥加密后发送给服务器。
      ** 这个随机密钥，就是后面HTTPS通信的对称加密密钥。
      ** 有些文章会说“随机码key”或是“随机数A”
      ** 每次建立HTTPS连接时，都会生成一个随机密钥，每次密钥都是不同的。
      ** 这就保证了如果服务器的公钥泄漏，之前通信的数据还是无法被破解。
4. 服务器使用私钥解密，得到密钥。
   ** 经过以上步骤，客户端和服务端就建立了安全连接，完美解决了对称加密的密钥泄漏问题。
   ** 也就是中间人攻击的问题。
5. 服务器使用密钥对数据进行对称加密，发送给客户端，客户端使用相同的密钥解密数据。

* 这篇文章解释的非常好！
https://segmentfault.com/a/1190000021494676
</code></pre>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和&#x3D;&#x3D;的区别"></a>equals和&#x3D;&#x3D;的区别</h3><pre><code>1. “==”操作符用于比较两个对象的地址是否相等。
2. .equals() 方法用于比较两个对象的内容是否相等。
3. .equals()方法 可以通过去重写这个方法，来实现一些个性化比较。
</code></pre>
<p>  <a target="_blank" rel="noopener" href="https://javabetter.cn/string/equals.html">字符串相等判断：Java中的equals()与&#x3D;&#x3D;的区别与用法</a></p>
<h3 id="list、set、map的区别"><a href="#list、set、map的区别" class="headerlink" title="list、set、map的区别"></a>list、set、map的区别</h3><pre><code>1. list是有序的，可重复的
2. set是无序的，元素不可重复
3. map是键值对，key不能重复
</code></pre>
<h3 id="hashmap、treemap的区别，分别什么时候使用？"><a href="#hashmap、treemap的区别，分别什么时候使用？" class="headerlink" title="hashmap、treemap的区别，分别什么时候使用？"></a>hashmap、treemap的区别，分别什么时候使用？</h3><pre><code>1、实现
HashMap：基于哈希散列表实现
TreeMap：SortMap接口，基于红黑树
2、存储
HashMap：随机存储
TreeMap：默认按键的升序排序
3、遍历
HashMap：Iterator遍历是随机的
TreeMap：Iterator遍历是有序的
4、键值对
HashMap：只允许键、值均为null
TreeMap：键、值都不能为null
5、安全
HashMap：非并发安全Map
TreeMap：非并发安全Map
6、效率
HashMap：高
TreeMap：低

7、性能损耗
 - HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。
- 而TreeMap的底层是一个Tree结构，所以速度会比较慢。

- HashMap因为要保存一个Array，所以会造成空间的浪费，
- TreeMap只保存要保持的节点，所以占用的空间比较小。

- HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。
- TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。

使用场景：
* HashMap：关心的是快速的插入、删除和查找操作，并且不需要元素有序时，HashMap是一个很好的选择。
  适用于大多数常规的键值对存储需求，如缓存、数据映射等。
* TreeMap：需要根据键进行排序（自然排序或自定义排序），
  或者需要频繁执行基于范围的查询（如查找某个键范围内的所有元素），则应使用TreeMap。
  它适用于实现索引、有序字典、有序统计等场景。
</code></pre>
<h3 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h3><pre><code>1. IO是面向流的，NIO是面向缓冲区的。
2. IO是阻塞的，NIO是非阻塞的。
3. IO是单向的（流），NIO是双向的（通道）。
4. IO是字节流，NIO是字符流。
5. IO是面向文件的，NIO是面向内存的。
6. IO是同步的，NIO是异步的。
- 对于较小文件的读取，两者差异较小，因为文件本身较小
- 对于较大文件的读取，NIO的效率明显优于IO。
  因为 NIO 使用了更高效的缓冲区和通道机制，可以在内存中进行更快的数据传输。

* 以下是 NIO 在网络传输中优于传统 I/O 的原因：
①、NIO 支持非阻塞 I/O，这意味着在执行 I/O 操作时，线程不会被阻塞。
②、NIO 支持 I/O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），
  并在 I/O 事件（如可读、可写）准备好时处理它们。
③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。
</code></pre>
<p>  <a target="_blank" rel="noopener" href="https://javabetter.cn/nio/nio-better-io.html">Java NIO 比传统 IO 强在哪里？</a></p>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3>
      </div>
      
      
      
    </div>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ayu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">170k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:35</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/comments.js"></script><script src="/tsukimiya.github.io/js/utils.js"></script><script src="/tsukimiya.github.io/js/motion.js"></script><script src="/tsukimiya.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"Leave Something, messi or meshi"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/tieba"],"meta":["nick","mail","link"],"requiredMeta":["nick"],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/tsukimiya.github.io/custom/%E5%85%AB%E8%82%A1.html"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
