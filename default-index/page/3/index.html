<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="mask-icon" href="/tsukimiya.github.io/images/Study.ico" color="#222">

<link rel="stylesheet" href="/tsukimiya.github.io/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miniver:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tsukimiyanano.github.io","root":"/tsukimiya.github.io/","images":"/tsukimiya.github.io/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/tsukimiya.github.io/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/tsukimiya.github.io/js/config.js"></script>

    <meta name="description" content="你们怎么能这么卷！！">
<meta property="og:type" content="website">
<meta property="og:title" content="Ayu&#39;s Study Blog">
<meta property="og:url" content="https://tsukimiyanano.github.io/tsukimiya.github.io/default-index/page/3/index.html">
<meta property="og:site_name" content="Ayu&#39;s Study Blog">
<meta property="og:description" content="你们怎么能这么卷！！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ayu">
<meta property="article:tag" content="hexo,next,ayu,tsukimiya,前端,node.js,nodejs,Node,nodeJS,vue,Vue,VUE,blog,博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tsukimiyanano.github.io/tsukimiya.github.io/default-index/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ayu's Study Blog</title>
  







<link rel="dns-prefetch" href="https://waline.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/tsukimiya.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/tsukimiya.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ayu's Study Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">求求你给我一份工作吧，我什么都会做的`orz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/tsukimiya.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tsukimiya.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/tsukimiya.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/tsukimiya.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/tsukimiya.github.io/schedule/task.html" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-guestbook"><a href="/tsukimiya.github.io/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>guestbook</a></li><li class="menu-item menu-item-pulledpost"><a href="/tsukimiya.github.io/PulledPost/" rel="section"><i class="fa fa-heart fa-fw"></i>PulledPost</a></li><li class="menu-item menu-item-cuntom-page"><a href="/tsukimiya.github.io/custom" rel="section"><i class="fa fa-folder fa-fw"></i>Cuntom Page</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ayu"
      src="/tsukimiya.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ayu</p>
  <div class="site-description" itemprop="description">你们怎么能这么卷！！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/tsukimiya.github.io/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/tsukimiya.github.io/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tsukimiya.github.io/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1832715838@qq.com" title="E-Mail → mailto:1832715838@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/tsukimiyanano" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tsukimiyanano" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/" class="post-title-link" itemprop="url">ref引用DOM元素和组件实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-30 22:23:21" itemprop="dateCreated datePublished" datetime="2024-04-30T22:23:21+08:00">2024-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-04 14:00:38" itemprop="dateModified" datetime="2024-05-04T14:00:38+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/30/Vue2/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标:<br>能够使用<code>ref</code>获取页面上DOM或组件的引用：<br>给元素或组件添加<code>ref=&quot;xxx&quot;</code>的引用名称，通过<code>this.$refs.xxx</code>获取元素或组件的实例</p>
</blockquote>
<blockquote>
<p>能够知道<code>$nextTick</code>的应用场景并合理地使用：把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</p>
</blockquote>
<blockquote>
<p>通过<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=127">“购物车案例”</a>巩固前4天所有学知识</p>
</blockquote>
<h2 id="ref引用-引用DOM元素-组件实例"><a href="#ref引用-引用DOM元素-组件实例" class="headerlink" title="ref引用 - 引用DOM元素 &#x2F; 组件实例"></a>ref引用 - 引用DOM元素 &#x2F; 组件实例</h2><blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<ol>
<li><p>什么是ref 引用<br> ref用来辅助开发者在<strong>不依赖于jQuery的情况下</strong>且<strong>在不调用DOM API的前提下</strong>，<strong>获取页面上DOM元素或组件的引用</strong>。</p>
<p> 每个vue的组件实例上，都包含一个<code>$refs</code>对象，里面存储着对应的DOM元素或组件的引用。<strong>默认情况下，组件的<code>$refs</code> 指向一个空对象</strong>。</p>
<blockquote>
<p>打印出vue实例对象this，可以看到，凡是$开头的，都是vue内置的一些成员。</p>
</blockquote>
</li>
<li><p>使用ref引用 DOM元素<br> 在标签上通过ref属性来指定一个名字，这个名字就指向这个标签，并添加到<code>$ref</code>对象中。如：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;myh1&quot;</span>&gt;</span>APP根组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">$refs</span>:&#123;<span class="comment">//vue实例上的$refs属性值</span></span><br><span class="line">    <span class="attr">myh1</span>: h1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myh1</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//操作DOM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ref引用 组件实例<br> 只要<strong>在引用的子组件的标签上，加一个ref</strong>，这个名字就指向了这个子组件的vue实例，就可以通过它来调用这个子组件的属性和方法。</p>
</li>
</ol>
<p><font color='red'>建议：只要是ref的引用，尽量都以Ref后缀结尾，这样一看名字就知道是个引用</font></p>
<h2 id="this-nextTick的应用场景"><a href="#this-nextTick的应用场景" class="headerlink" title="this.$nextTick的应用场景"></a><code>this.$nextTick</code>的应用场景</h2><ul>
<li><strong>问题</strong></li>
</ul>
<p>在app组件中，控制组件内按钮和输入框元素的切换</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;inputVisible&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;showButton&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iptRef&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> @<span class="attr">click</span>=<span class="string">&quot;showinput&quot;</span>&gt;</span>显示输入框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们想要在切换到输入框的时候，直接进入输入框焦点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">showButton</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是<code>this.$refs.iptRef.focus()</code>这样却报错了<br><code>TypeError: Cannot read properties of undefined (reading &#39;focus&#39;)</code><br>这个错误代表说，我要调用一个focus方法，或我要访问一个focus属性，但是它前面那个东西是undefined<br>当我们打印<code>console.log(this.$refs.iptRef);</code>会发现它是<code>undefined</code>！</p>
<ul>
<li><strong>分析原因</strong></li>
</ul>
<p>在这个函数中，我们是更改inputVisible的值让文本框显示出来，但是现在页面上文本框还未显示出来，所以拿不到这个元素，因此是undefined<br>在Vue的生命周期中，当data里面的数据变化，会触发DOM元素的更新，根据最新的数据，重新渲染页面的UI结构。<strong>在updated之前，页面还没来得及重新渲染，所以数据是新的，但是页面的结构是旧的。</strong><br>所以<code>this.inputVisible = true;</code>这句执行之后，页面上还是按钮，文本框还未被展示，还需要一个更新的过程，需要一定的时间。如果立马去执行<code>this.$refs.iptRef.focus()</code>是拿不到文本框的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><font color='red'>总结：<code>this.inputVisible = true</code>这行代码执行完，只是数据是最新的，页面还没来得及重新渲染，没有文本框，拿不到它的引用，所以是undefined</font><br>要想不报错，<code>this.$refs.iptRef.focus()</code>这一行调用应该放在页面重新渲染完毕之后</p>
<ul>
<li><strong>解决</strong> – <code>this.$nextTick(cb)</code>方法<br>里面接收一个回调，cb是callback<br>代表：<strong>把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</strong><br>保证cb回调函数可以操作到最新的DOM元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">Vue组件与生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 20:35:44" itemprop="dateCreated datePublished" datetime="2024-04-24T20:35:44+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-07 13:18:11" itemprop="dateModified" datetime="2024-05-07T13:18:11+08:00">2024-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/24/Vue2/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>掌握.vue单文件组件的基本用法<br>组件的props(自定义属性)：数组写法、对象写法<br>解决多个组件间的样式冲突 – scoped<br><a href="#deep"><strong>&#x2F;deep&#x2F;样式穿透</strong></a>应用场景：<strong>修改第三方组件库组件的默认样式</strong></p>
</blockquote>
<blockquote>
<p>掌握组件生命周期的执行顺序和应用场景：创建阶段、运行阶段、销毁阶段<br>vue 中常用的生命周期函数&#x2F;生命周期钩子：<strong>created、mounted</strong></p>
</blockquote>
<blockquote>
<p>能够掌握组件通讯的三种方式：父-&gt; 子（自定义属性）、子-&gt; 父（自定义事件）、兄弟组件（EventBus）</p>
</blockquote>
<p>[toc]</p>
<h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><ol>
<li><p>什么是组件化开发<br><strong>组件化开发</strong>指的是∶根据<strong>封装</strong>的思想，<strong>把页面上可重用的UI结构封装为组件</strong>，从而方便项目的开发和维护。</p>
</li>
<li><p>vue中的组件化开发<br>vue是一个<strong>支持组件化开发</strong>的前端框架。<br>vue中规定：<strong>组件的后缀名是.vue</strong><br>vue中，root就是根，而这个根就是el所控制的那个区域。在main.js文件里，vue实例中通过 render 函数指定组件渲染到HTML页面中，替换了el区域。即：<strong>render函数中，渲染的是哪个.vue组件，那么这个组件就叫做“根组件”</strong></p>
</li>
<li><p><font color='green'>vue组件的三个组成部分</font></p>
<ul>
<li><font color='green'>template -&gt; 组件的模板结构</font></li>
<li><font color='green'>script -&gt; 组件的JavaScript行为</font></li>
<li><font color='green'>style -&gt; 组件的样式</font></li>
</ul>
<p> 注意：<font color='red'>每个组件中必须包含template模板结构，而script行为和style样式是可选的组成部分</font></p>
</li>
</ol>
<p>简单示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 组件的模版结构中，应该包含一个根元素，这个最外层的div不能有兄弟元素 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span> &gt;</span>这是用户自定义的Test.vue -- &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">// 默认导出，固定写法！</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 注意：.vue组件中的data不能像之前一样，不能指向对象,必须是一个函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">// data数据源</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span>&#123;<span class="comment">// 这个return出去的对象中，可以定义数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">// 在组件中，this就表示当前组件的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">username</span> = <span class="string">&#x27;aaa&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.text-box</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">background-color</span>: pink;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">h3</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>组件之间的<font color='red'>父子关系</font><br>组件之间的父子关系、兄弟关系，<strong>是在使用时候才会产生的</strong><br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB.png" alt="image"></li>
</ol>
<h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的<strong>三个步骤</strong></h3><p><img src="/tsukimiya.github.io/images/vue/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt="image"><br><font color="green">注意：在components节点中，注册组件是一个对象的写法，前面是定义的名称，后面是要注册的组件。在对象里面，键名和值如果一样，可以省略值只写键名。如’Left’:Left可以简写成Left</font></p>
<ul>
<li><p>通过components注册的是<font color='red'>私有子组件</font><br>例如：<br>在组件A的components节点下，注册了组件F。<br>则组件F只能用在组件A中;不能被用在组件C中。</p>
</li>
<li><p>注册<font color='red'>全局组件</font><br>如果某个组件，使用非常频繁，好多组件中都要用到它，那么每次都要导入注册并使用，就很麻烦。所以可以注册全局组件</p>
<p>  <font color='green'>在vue项目的 main.js入口文件中，通过Vue.component()方法，可以注册全局组件。</font>示例代码如下:</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Count</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Count.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：字符串格式，表示组件的“注册名称”</span></span><br><span class="line"><span class="comment">// 参数2：需要被全局注册的那个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyCount&#x27;</span>,<span class="title class_">Count</span>)</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：在自己的组件中，不能使用自己！</strong></p>
</li>
</ul>
<h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的<strong>自定义属性</strong>，<strong>在封装通用组件的时候</strong>，合理地使用 props 可以极大的<font color='red' size='5'>提高组件的复用性！</font><br>它的语法格式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性,允许使用者指定初始值</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其它自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font fcolor='green'>props中的数据，可以直接在模板结构中被使用</font>。使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;init&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left.vue组件中，使用注册了的Count组件</span></span><br><span class="line"><span class="comment">// 指定初始值，但是这里传入的是一个字符串，并不是一个真正的数值</span></span><br><span class="line">&lt;<span class="title class_">Count</span> init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color='red'>结合v-bind使用自定义属性</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样就传入的是数值6了</span><br><span class="line"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color='green'>官网文档-&gt;即便 <code>9</code> 是静态的，我们仍然需要 <code>v-bind</code> 来告诉 Vue，这是一个 JavaScript 表达式而不是一个字符串</font></p>
</li>
<li><p><font color='red'>props对子组件是只读的 (父组件-&gt;子组件 单向数据传递)</font><br>Vue规定:组件中封装的自定义属性是只读的，程序员不能直接修改props的值。否则会直接报错。<br>注意：props是对定义该属性的子组件只读，<font color='red'>在父组件中，你可以通过v-bind绑定props的值，并且这个值是可以更改的。</font><strong>当父组件中的值改变时，Vue会自动将新值传递给子组件，并且子组件会根据新的值重新渲染</strong>。这种方式实际上是通过props属性进行了<strong>单向数据流</strong>，确保数据流动的可预测性和可维护性。<br><font color='red'>如果子组件需要修改传递过来的值，通常应该通过触发事件并将修改传递给父组件来实现。</font><br><font color='green'>props可以被作为初始值使用的，把它传给data的属性进行初始赋值使用：</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count+=1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>, &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Count</span> :init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="props的default默认值"><a href="#props的default默认值" class="headerlink" title="props的default默认值"></a>props的default默认值</h3><p>在声明自定义属性时，可以通过default来定义属性的默认值。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="comment">// 自定义属性：&#123; /* 配置选项 */ &#125;</span></span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="comment">// 如果外界使用Count组件，没有传递默认值，则默认值生效</span></span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props的-type-值类型"><a href="#props的-type-值类型" class="headerlink" title="props的 type 值类型"></a>props的 type 值类型</h3><p>在声明自定义属性时，<font color='red'>可以通过type来定义属性的值类型。</font>示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="comment">// 用type属性定义属性的值类型</span></span><br><span class="line">            <span class="comment">// init的值类型必须是Number数字</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color='red'>还可以通过数组形式，为当前属性定义多个可能的类型：<code>type: [Number, String]</code></font><br><font color='green'>如果是带有默认值的对象类型，对象或数组默认值必须从一个工厂函数获取：</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封面的信息对象</span></span><br><span class="line"><span class="attr">cover</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="comment">// 默认值是一个空对象</span></span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="props的-required-必填项"><a href="#props的-required-必填项" class="headerlink" title="props的 required 必填项"></a>props的 required 必填项</h3><p>加上required必填项之后，哪怕有默认值，不传也会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">require</span>: <span class="literal">true</span>,<span class="comment">//必填项校验</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props属性的命名规定"><a href="#props属性的命名规定" class="headerlink" title="props属性的命名规定"></a>props属性的命名规定</h3><p>Vue里面有一个规定，如果<strong>某一个属性</strong>在定义的时候，里面<strong>包含了一个大写的字符</strong>（是一个<strong>小驼峰</strong>），在进行<strong>绑定的时候</strong>，可以直接写成原名字，不过<strong>建议改成连字符格式</strong>，因为这样看起来会<strong>更舒服</strong>一些<br>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="attr">props</span>:[cmtCount]</span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;xxx :cmtCount=<span class="string">&quot;...&quot;</span>&gt;&lt;/xxx&gt;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">xxx</span> <span class="attr">:cmt-count</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span> <span class="comment">// 建议</span></span><br></pre></td></tr></table></figure>


<h3 id="组件间的样式冲突-scoped"><a href="#组件间的样式冲突-scoped" class="headerlink" title="组件间的样式冲突 - scoped"></a>组件间的样式冲突 - scoped</h3><p>默认情况下，<strong>写在.vue组件中的样式会全局生效</strong>，因此很容易造成<strong>多个组件之间的样式冲突问题</strong>。<br>导致组件之间样式冲突的<strong>根本原因</strong>是:<br>    <font color='purple'>1. 单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</font><br>    <font color='purple'>2. 每个组件中的样式，都会影响整个index.html页面中的DOM元素</font></p>
<p>注意：单页面应用程序中，HTML页面是只有一个的，我们的所有组件都是在这个HTML中生效的</p>
<ul>
<li><p>解决方案 – <font color='red'>核心原理：css属性选择器</font><br>给当前页面标签都加一个固定的自定义属性，不同的组件之间的自定义属性不一样</p>
</li>
<li><p>vue简化：<strong>scoped属性</strong><br>只要给当前组件的style加上scoped的属性，vue底层在生成组件的时候，会自动给每个标签自动生成一个data-v-xxx</p>
</li>
</ul>
<h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="&#x2F;deep&#x2F;样式穿透"></a><font id='deep' color='red'>&#x2F;deep&#x2F;样式穿透</font></h4><p><font color='#00a86b'>作用：在父组件中改造子组件里的样式</font><br><font color='red'>应用场景：当使用第三方组件库的时候，如果有修改组件默认样式的需求，需要用到&#x2F;deep&#x2F;</font></p>
<ul>
<li><p>scoped有一个缺陷，场景：<br>Left 和 Right 都注册使用了 Count组件<br>Left加了scoped属性，而Right没加<br>如果想在Left中的style里修改Count里面的样式，会发现不起作用，而如果在Right中修改，会发现Left和Right里面的Count组件样式都变了。</p>
</li>
<li><p>原因：<br>在Left中修改，比如h5{..},因为加了scoped，所以会变成h5[data-v-xx]{..}，而count中的标签并没有data-v-xx属性，所以不会生效。<br>而在没有scoped属性的Right中修改，则产生的就是样式冲突</p>
</li>
<li><p>解决方案：&#x2F;deep&#x2F;样式穿透<br>&#x2F;deep&#x2F; h5{ … }<br>在选择器前面加个前缀+空格，在浏览器可以查看到，这个h5标签被加上了一个[data-v-xx] 的前缀<br><font color='red'>加上<code>/deep/</code>之后就不再是 <code>类名[data-v-xxx]</code> 的 选择特定属性的选择器 了，而是变成了 <code>[data-v-xxx] 类名</code> 的 后代选择器 。</font></p>
</li>
</ul>
<h2 id="Vue运行原理"><a href="#Vue运行原理" class="headerlink" title="Vue运行原理"></a><strong>Vue运行原理</strong></h2><p>在把app渲染到页面的过程中，不是把页面的模板结构直接丢到页面上，而是有个编译的过程。<br>浏览器能够直接解析HTML页面，但是不识别vue页面。<br>在<code>package.json</code>里面，<code>devDependencies</code>里面有个<code>vue-template-complier</code>包，就是vue模板编译器，作用就是把.vue文件编译成js交给浏览器解析运行。<br>在.vue中写的任何代码，要渲染到浏览器中，都依赖于这个包的解析与转换。</p>
<p>我们上面在页面上渲染了2次Count.vue组件，我们在页面上看到的两个Count组件，就是两个组件的实例。<br>实例，就是相当于new一个构造函数得到一个实例。我们编写的Count.vue，可以理解为它就是一个构造函数，new这个构造函数就会得到一个Count实例。<br>我们没有直接new，而是通过标签形式去用这个组件，这个用的过程可以理解为一个new的过程<br>所以说，<strong>这个组件，在定义的时候，它只是一个模板结构，当用标签的形式去使用的时候，才是在创建一个它的实例。</strong><br>如果在components下声明一个组件，不去用它不会创建组件实例。</p>
<blockquote>
<p><font color='red'>整个项目如何跑起来的：</font><br><font color='#00a86b'>webpack从main.js(入口文件)开始打包，发现main里面用到了app，于是把app创建一个实例出来。然后app里面又用到了Left和Right，然后这两个里面又用到了Count，就这样一直通过一个树的形式，把整个树都解析转换，最后编译成纯js代码。然后把js文件放到首页里面去，浏览器就会解析和执行这里面的代码，把组件都给渲染到页面上</font></p>
</blockquote>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol>
<li><p>生命周期 &amp; 生命周期函数<br><font color='red'>生命周期</font>(Life Cycle)是指一个组件从<font color='red'>创建-&gt;运行-&gt;销毁</font>的整个阶段，<font color='red'>强调的是一个时间段</font>。</p>
<p> <font color='red'>生命周期函数</font>:是由vue框架提供的<font color='red'>内置函数</font>，会伴随着组件的生命周期，<font color='red'>自动按次序执行</font>。<br> 注意:<font color='#00a86b'>生命周期</font>强调的是<font color='#00a86b'>时间段</font>，<font color='#00a86b'>生命周期函数</font>强调的是<font color='#00a86b'>时间点</font>。</p>
</li>
<li><p>组件生命周期函数(<strong>生命周期钩子</strong>)的分类<br>在生命周期里面，它会按顺序依次执行这些函数。<br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="img"></p>
</li>
<li><p>生命周期图示<br>可以官方给出的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">“生命周期图示”</a>，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=106">进一步理解组件生命周期执行过程</a>。<br><a href="/tsukimiya.github.io/custom/pages/lifecycle.html" target="_blank"><font color='red'>中文详解图示</font></a></p>
</li>
</ol>
<ul>
<li><p><font color='green'>执行次数</font><br>创建阶段：1次<br>运行阶段：0-N次<br>销毁阶段：1次</p>
</li>
<li><p><font color='red'>最重要的生命周期钩子</font></p>
<ol>
<li><font color='red'>created</font><br> data、props、methods都是可用状态<br> 常用它发起ajax请求来拿数据，转存到data中，供template模板渲染时候使用。</li>
<li><font color='red'>mounted</font><br> 第一次把DOM元素结构渲染好，最早去操作DOM</li>
<li><font color='red'>updated</font><br> 可以操作最新的更新过后的DOM</li>
</ol>
<p>  其他的很少会用到，记不住也没关系</p>
</li>
</ul>
<h2 id="组件之间的通讯-数据共享"><a href="#组件之间的通讯-数据共享" class="headerlink" title="组件之间的通讯(数据共享)"></a>组件之间的通讯(数据共享)</h2><ol>
<li><p>组件之间的关系<br>最常见的：兄弟关系、父子关系<br>离的比较远的，也可以认为是一种变态的兄弟关系</p>
</li>
<li><p><strong>父向子传值</strong> – <strong>自定义属性</strong><br><font color='red'>再次注意: props是只读的！</font><br><img src="/tsukimiya.github.io/images/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.png" alt="image"></p>
</li>
<li><p><strong>子向父传值</strong> – <strong>自定义事件</strong><br>第一步是绑定了一个事件，这是个处理函数。<font color='red'><code>$emit</code>就代表触发这个事件</font>，谁触发这个事件，谁传一个值过来。<br><font color='#00a86b'>子向父传值：在子组件调用$emit，父组件<font color='red'>在子组件标签上</font>用@绑定(监听)这个自定义事件</font><br><font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。<br><img src="/tsukimiya.github.io/images/vue/%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<blockquote>
<p>vue在内部要想触发click事件，它也是用this或vm<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">method</span>:&#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">e</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">vm.$emit(<span class="string">&#x27;click&#x27;</span>,&#123;<span class="comment">//事件对象e</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">clientX</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">clientY</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">target</span>:dom元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p><strong>兄弟组件之间的数据共享</strong> – <strong>EventBus</strong><br>在<font color='red'>vue2.x</font>中，兄弟组件之间数据共享的方案是<font color='red'>EventBus</font>。</p>
<ul>
<li>EventBus使用步骤</li>
</ul>
<ol>
<li>创建<code>eventBus.js</code>模块，并向外共享一个<strong>Vue的实例对象</strong></li>
<li>在数据<strong>发送方</strong>，调用<code>bus.$emit(&#39;事件名称&#39;,要发送的数据)</code>方法<strong>触发自定义事件</strong></li>
<li>在数据<strong>接收方</strong>，调用<code>bus.$on(&#39;事件名称&#39;,事件处理函数)</code>方法<strong>注册一个自定义事件</strong><br> 数据在事件处理函数的形参中拿到。</li>
</ol>
<p> <font color='#00a86b'>依旧是发送方触发事件，发送数据，接收方绑定事件监听，接受数据。</font><br> 这里的<code>$on</code>就相当于jQuery的on绑定事件<br> <strong>为什么这里要用到一个共享的实例EventBus</strong> ？因为<font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。</p>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/vue/%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt="image"></p>
<p>注意：虽然可以使用EventBus来在父子组件之间传值，但是这不是Vue官方推荐的做法。<strong>props和自定义事件更适合处理父子组件之间的通信，因为它们更直观和易于理解</strong>。 Event Bus 通常更适用于非父子关系的组件之间的通信，例如兄弟组件之间。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="vscode插件-Path-Autocomplete-路径提示"><a href="#vscode插件-Path-Autocomplete-路径提示" class="headerlink" title="vscode插件 Path Autocomplete - @路径提示"></a>vscode插件 Path Autocomplete - @路径提示</h3><p>下载插件之后，要在自己配置项里面添加如下配置,添加在头部就行<br>设置 – setting.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入文件时是否携带文件的扩展名</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 配置 @ 的路径提示</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.pathMappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><font color="red">注意：只有vscode打开的文件夹根目录是项目根目录时才起作用！！</font></p>
<blockquote>
<p>总觉得这个功能vscode也集成进去了？一开始没装的时候，好像就触发了，也懒得验证了hh</p>
</blockquote>
<h3 id="Auto-Close-Tag插件"><a href="#Auto-Close-Tag插件" class="headerlink" title="Auto Close Tag插件"></a>Auto Close Tag插件</h3><p>输入<code>&lt;xx&gt;</code>标签前半部分，会自动补全后半部分<br>不过新版vscode好像已经集成了这个功能，没有安装也是这样，装了没啥变化</p>
<h3 id="方法简写形式"><a href="#方法简写形式" class="headerlink" title="方法简写形式"></a>方法简写形式</h3><p><strong>如果方法只有一行，可以简写到行内</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count += 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>先指令，后绑定，最后绑事件<br>这是一个子组件的绑定示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Goods</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    :state=<span class="string">&quot;item.goods_state&quot;</span></span><br><span class="line">    @state_change=<span class="string">&quot;getNewState&quot;</span></span><br><span class="line">&gt;&lt;/<span class="title class_">Goods</span>&gt;</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/" class="post-title-link" itemprop="url">Vue2 过滤器、侦听器、计算属性、axios & vue-cli</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-21 14:09:30" itemprop="dateCreated datePublished" datetime="2024-04-21T14:09:30+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-01 10:14:20" itemprop="dateModified" datetime="2024-05-01T10:14:20+08:00">2024-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/21/Vue2/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>在实际开发中合理运用过滤器、侦听器、计算属性解决问题<br>使用axios发起Ajax请求<br>使用vue-cli工具生成工程化的Vue项目</p>
</blockquote>
<p>[toc]</p>
<h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><blockquote>
<p>2020年9月 vue3发布。增加了很多新功能，但是也删掉了一些功能。 比如删掉了vue2中的过滤器filter功能。<br>与此同时，官方建议： <strong>用方法调用或计算属性替换过滤器</strong>。<br>filter过滤器能加工数据，computed计算属性和methods方法也都可以加工数据，这样的话，就功能重复了…(于是filter被开除了XDD)</p>
</blockquote>
<p>vue3已经把过滤器删掉了，只能在vue2中使用，会基础语法就行了。</p>
<ul>
<li><font color="green">过滤器要点</font><ol>
<li>必须被定义到 <code>filters节点</code> 之下，本质是一个函数</li>
<li>强调：过滤器中一定要有一个返回值</li>
<li>过滤器函数中的 形参<code>val</code>(随意命名)，永远都是管道符前面的那个值。(多个形参，则第一个外都是undefined)</li>
<li>过滤器函数 由 管道符 <code>|</code> 调用</li>
<li>过滤器只能在 <code>差值表达式</code> 或 <code>属性绑定指令v-bind</code> 中调用</li>
<li>最终得到的结果是过滤器的返回值</li>
</ol>
</li>
</ul>
<p><strong>过滤器常用于文本的格式化</strong>,应该被添加在JavaScript表达式的尾部，由“<strong>管道符</strong>”进行调用。示例:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在花括号中通过管道符调用capitalize过滤器，对message的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中通过管道符调用formatId过滤器，对rawId的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="私有过滤器-和-全局过滤器"><a href="#私有过滤器-和-全局过滤器" class="headerlink" title="私有过滤器 和 全局过滤器"></a>私有过滤器 和 全局过滤器</h3><p><strong>在 <code>filters节点</code> 下定义的过滤器</strong>，称为“<strong>私有过滤器</strong>”，因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器，则可以按照如下的格式<strong>定义全局过滤器</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器–独立于每个vm实例之外 </span></span><br><span class="line"><span class="comment">// Vue.filter()方法接收两个参数:</span></span><br><span class="line"><span class="comment">// 第1个参数，是全局过滤器的&quot;名字”</span></span><br><span class="line"><span class="comment">// 第2个参数，是全局过滤器的&quot;处理函数&quot;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>( <span class="string">&#x27;capitalize&#x27;</span>, <span class="function">(<span class="params">str</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;~~&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果想要定义多个全局过滤器就再写一个</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capi2&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&#x27;--全局2&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">注意：如果私有过滤器和全局过滤器名字一致，此时按就近原则</font></p>
<h3 id="其他用法-–-连续调用、传参"><a href="#其他用法-–-连续调用、传参" class="headerlink" title="其他用法 – 连续调用、传参"></a>其他用法 – 连续调用、传参</h3><ol>
<li><p>连续调用多个过滤器 – 串联地调用<br>如：<code>&#123;&#123;message | filterA | filterB&#125;&#125;</code></p>
</li>
<li><p>过滤器传参</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | filterA(arg1,arg2)&#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;filterA&#x27;</span>,<span class="function">(<span class="params">msg,arg1,arg2</span>)=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器的兼容性<br>仅在vue 2.x 和 1.x中受支持<br>3.x建议使用 <strong>计算属性</strong> 或 <strong>方法</strong> 代替<br>具体的迁移指南参考官方文档给出的<a target="_blank" rel="noopener" href="https://v3.vuejs.org/guide/migration/filters.html#migration-strategy">说明</a></p>
</li>
</ol>
<h2 id="Watch侦听器"><a href="#Watch侦听器" class="headerlink" title="Watch侦听器"></a>Watch侦听器</h2><p>Watch侦听器 <strong>监视数据的变化，做出特定操作</strong>，变量名与监听的值对应。语法格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">// 监视username变化</span></span><br><span class="line">        <span class="comment">// newVal - 变化后的新值，oldVal - 旧值</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">应用场景如：侦听用户输入的用户名，每次变化就去查找是否被占用</font></p>
<h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><ol>
<li>方法格式的侦听器<ul>
<li>缺点1: 无法在刚进入页面的时候，自动触发！！</li>
<li>缺点2: 如果侦听的是一个对象，对象中的属性发生了变化，不会触发侦听器！！</li>
</ul>
</li>
<li><strong>对象格式的侦听器</strong><ul>
<li>好处1: 可以通过<strong>immediate选项</strong>，让侦听器自动触发！！</li>
<li>好处2：可以通过<strong>deep选项</strong>，让侦听器深度监听对象中每个属性的变化！！</li>
</ul>
</li>
</ol>
<ul>
<li><font color="green">推荐：为了写起来方便，建议定义成方法格式，如果确实需要，再改成对象格式。</font></li>
</ul>
<h3 id="immediate选项"><a href="#immediate选项" class="headerlink" title="immediate选项"></a>immediate选项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// true表示一进入页面就触发，false是默认值，不写这个参数也是false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦听-–-deep选项"><a href="#深度侦听-–-deep选项" class="headerlink" title="深度侦听 – deep选项"></a>深度侦听 – deep选项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125; &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">info</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 对象里任意属性变化了，都会触发侦听器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要侦听的是对象的子属性的变化，则必须包裹一层单引号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>(newVal)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ol>
<li>什么是计算属性<br>计算属性指的是通过一系列运算之后，最终得到一个属性值。<br>这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</li>
<li>应用场景：<font color='red'>实现代码复用</font></li>
</ol>
<ul>
<li>计算属性的使用<ol>
<li>计算属性要定义到computed节点下，定义成方法格式</li>
<li>虽然声明的方法格式，但是要当做普通的属性来用<blockquote>
<p>打印出vue实例，可以发现定义的计算属性是被挂到属性上面的，和data节点上的属性一样</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>示例代码如下︰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">r</span>:<span class="number">0</span>,<span class="attr">g</span>:<span class="number">0</span>,<span class="attr">b</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 计算属性要定义到computed节点下，定义成方法格式</span></span><br><span class="line">        <span class="title function_">rgb</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rgb</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h2><blockquote>
<p>axios是一个<strong>专注于网络请求</strong>的库！它只负责发请求和拿数据<br>    中文官网地址：<a target="_blank" rel="noopener" href="http://www.axios-js.com/">http://www.axios-js.com/</a></p>
</blockquote>
<ul>
<li><p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// url中的查询参数，get请求体传参，可选</span></span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用axios得到的返回值是一个 Promise 对象<br>axios在请求到数据之后，在真正的数据之外，套了一层壳,result得到的就是套完壳之后的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123; 真实的数据 &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">status</span>: xxx,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><font color='red'>结合async和await调用axios</font></strong><br>这个<code>.then</code>用起来有点麻烦，我们可以使用await来进行简化<br><font color='green'>如果调用某个方法的返回值是 Promise 实例，则前面可以添加await！（这样得到的就直接是result）</font><br><font color='red'>await 只能用在被 async 修饰 的方法中</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用解构赋值来获取data</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于axios-get和axios-post发起请求"><a href="#基于axios-get和axios-post发起请求" class="headerlink" title="基于axios.get和axios.post发起请求"></a>基于axios.get和axios.post发起请求</h3><ol>
<li>axois.get<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//GET参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure></li>
<li>axios.post<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意await要在async修饰的函数中使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">unit</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">    <span class="attr">contact</span>: <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">    <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">    <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-cli的安装和使用"><a href="#vue-cli的安装和使用" class="headerlink" title="vue-cli的安装和使用"></a>vue-cli的安装和使用</h2><p>中文官网：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<ol>
<li><p>什么是单页面应用程序？<br><strong>单页面应用程序</strong>（英文名: Single Page Application）简称SPA，顾名思义，<strong>指的是一个Web 网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p>
</li>
<li><p>什么是vue-cli<br><strong>vue-cli是Vue.js开发的标准工具</strong>。它简化了程序员基于webpack创建工程化的Vue项目的过程。</p>
</li>
<li><p>安装<br>vue-cli是npm上的一个全局包，使用<code>npm i</code>命令，即可方便的把它安装到自己电脑上：<code>npm i -g @vue/cli</code></p>
<ul>
<li><code>vue -V</code>查看安装的版本号</li>
</ul>
</li>
<li><p>使用<br>基于vue-cli快速生成工程化的Vue项目：<code>vue create 项目名称</code>(建议名称用不带空格的英文)<br> 在想要创建项目的文件夹执行此命令，即会生成项目文件夹，命名即为 项目名称</p>
<ul>
<li>选择预设(用方向键)<br>  <strong>初学者建议选择最后一项 – 手动选择要安装哪些功能</strong><br>  按空格选中要安装的预设<br>  一开始建议选择：<br>  Choose Vue version(新版没有这个)、Babel、CSS Pre-processors,其他的不要选<br>  下面接着选择vue版本为2.x，css预处理器为less</li>
</ul>
</li>
<li><p>vue项目中src目录的构成：</p>
<ol>
<li>assets 文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源</li>
<li>components 文件夹：程序员封装的、可复用的组件，都要放到components目录下。<br> 里面有一个默认组件HelloWorld.vue，给它删除</li>
<li>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</li>
<li>app.Vue 是项目的根组件。我们创建项目之后，看到的页面就是app.Vue，如果想重新换一个页面出来，只需要把它给清空掉。里面的template是一个模版结构。</li>
</ol>
</li>
<li><p>vue项目的运行流程<br> 在工程化的项目中，vue要做的事情很单纯: <strong>通过main.js把 App.vue渲染到index.html的指定区域中</strong>。<br> 其中：</p>
<ul>
<li><strong>App.vue</strong>用来编写待渲染的<strong>模板结构</strong></li>
<li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li>
<li><strong>main.js</strong> 把 App.vue渲染到了index.html所预留的区域中  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 vue 这个包，得到Vue构造函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入App.vue根组件，将来要把App.vue中的模板结构，渲染到HTML页面中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// 把 render 函数指定的组件渲染到HTML页面中，这里指定了App</span></span><br><span class="line">    <span class="comment">// 我们最终的结果是，把这个指定的组件，放到id为app的所在的这个位置，把它给替换掉了</span></span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// vue实例的$mount()方法，作用和el属性完全一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="字符串函数charAt"><a href="#字符串函数charAt" class="headerlink" title="字符串函数charAt()"></a>字符串函数charAt()</h3><p>接收索引值，从字符串中获取对应字符，如：<br><code>&#39;hello&#39;.charAt(4) //&#39;o&#39;</code></p>
<h3 id="将字符串第一个字符变为大写"><a href="#将字符串第一个字符变为大写" class="headerlink" title="将字符串第一个字符变为大写"></a>将字符串第一个字符变为大写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> first = str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="keyword">const</span> other = str.<span class="title function_">slice</span>(<span class="number">1</span>)<span class="comment">//从指定索引往后截取字符串，返回得到的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first+other)</span><br></pre></td></tr></table></figure>

<h3 id="ajax原生写法"><a href="#ajax原生写法" class="headerlink" title="ajax原生写法"></a>ajax原生写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">Vue2 基本使用 & 常用指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-20 12:51:08" itemprop="dateCreated datePublished" datetime="2024-04-20T12:51:08+08:00">2024-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-15 13:14:43" itemprop="dateModified" datetime="2024-05-15T13:14:43+08:00">2024-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/20/Vue2/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>使用Vue指令完成页面结构的渲染<br>使用Vue调试工具辅助Vue的开发</p>
</blockquote>
<blockquote>
<p><strong>掌握Vue的两个特性：数据驱动视图、双向数据绑定<br>    掌握Vue的底层原理 MVVM – model数据源、view视图&#x2F;页面结构、viewmodel vue实例<br>    掌握Vue六大类指令的使用</strong><br>    vue2指令新学到的东西：<br>    属性绑定指令中的：<a href="#obj">对象写法</a><br>    事件绑定指令中的：<a href="#param">参数问题</a>、<a href="#event">$event</a>、<a href="#modifier">事件修饰符</a>、<a href="#keyModifier">按键修饰符</a><br>    双向绑定指令中的：<a href="#v-model">v-model修饰符</a><br>    条件渲染指令中的：<a href="#if">v-if配套的v-else指令</a><br>    列表渲染指令中的：<a href="#key">key属性绑定</a></p>
</blockquote>
<blockquote>
<p>vscode插件推荐：Volar、Vue VSCode Snippets。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40808668/article/details/134277604">简单说明</a>(CSDN)</p>
</blockquote>
<blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/guide/">Vue 2.x 官方文档</a>(已不再维护)<br>Vue是一套<strong>用于构建用户界面的前端框架</strong><br>构建用户界面：用vue往html页面填充数据<br>框架：一套现成的解决方案，程序员只能遵守框架的规范去编写业务功能</p>
<p>学习vue就是学习vue框架中规定的用法<br><strong>vue的指令、组件(是对UI结构的复用)、路由、Vuex、vue组件库</strong></p>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
<h3 id="vue的两个特性："><a href="#vue的两个特性：" class="headerlink" title="vue的两个特性："></a>vue的两个特性：</h3><ol>
<li><strong>数据驱动视图</strong><br> vue会监听数据的变化，自动重新渲染页面的结构<br> 注意：<span style="color:red;" >数据驱动视图是单向的数据绑定<span></li>
<li><strong>双向数据绑定</strong><br> 填写表单时，自动把内容同步到数据源中<blockquote>
<p>在网页中，form表单负责<font color='green'>采集数据</font>，Ajax负责<font color='green'>提交数据</font></p>
</blockquote>
</li>
</ol>
<h3 id="MVVM-–-vue的底层原理"><a href="#MVVM-–-vue的底层原理" class="headerlink" title="MVVM – vue的底层原理"></a>MVVM – vue的底层原理</h3><p><font color='red'>MVVM是 vue 实现数据驱动视图和双向数据绑定的核心原理。</font><br>MVVM 指的是 <strong>M</strong>odel(数据源)、<strong>V</strong>iew(视图) 和 <strong>V</strong>iew<strong>M</strong>odel(vue实例)，它把每个 HTML 页面都拆分成了这三个部分。</p>
<p>在MVVM概念中:<br><strong>Model</strong> 表示当前页面渲染时所依赖的<strong>数据源</strong>。<br><strong>View</strong> 表示当前页面所渲染的 DOM 结构。(<strong>页面结构，也即是视图</strong>)<br><strong>ViewModel</strong> 表示 <strong>vue 的实例</strong>，它是<strong>MVVM的核心</strong>。(也就是vue)<br><img src="/tsukimiya.github.io/images/vue/MVVM%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p>
<ul>
<li>MVVM的工作原理：<br>  ViewModel作为MVVM的核心，是它把当前页面的<font color="green">数据源</font>(Model)和<font color="green">页面的结构</font>(View)连接在了一起。<br>  <img src="/tsukimiya.github.io/images/vue/MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image"><br>  <strong>当数据源发生变化时</strong>，会被ViewModel监听到，VM会根据最新的数据源<strong>自动更新</strong>页面的结构<br>  <strong>当表单元素的值发生变化时</strong>，也会被VM监听到，VM会把变化过后最新的值<strong>自动同步</strong>到Model数据源中</li>
</ul>
<h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><p>当前，vue共有3个大版本，其中:<br>3.x版本的vue 于2020-09-19发布<br>2.x版本的vue 已于 2023 年 12 月 31 日停止维护<br>1.x版本的vue几乎被淘汰，不再建议学习与使用</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p>基本使用步骤</p>
<ol>
<li>导入VUE.js脚本文件<br> 可以借助 script 标签直接通过 CDN(提供 npm 包服务) 来使用 Vue：<br> <code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在页面声明一个将要被vue所控制的区域</li>
<li>创建vm实例对象(vue实例对象)</li>
</ol>
</li>
<li><p>基本代码与MVVM的对应关系<br> model：data指向的对象<br> view：el指向的选择器<br> ViewModel：new Vue()构造函数得到的实例对象</p>
</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。<br>指令是vue开发中最基础、最常用、最简单的知识点</p>
<p>vue的指令 <strong>按照不同用途</strong> 可以分为如下6大类：</p>
<ol>
<li><p>内容渲染指令：<code>v-text</code> 、<code>&#123;&#123;&#125;&#125;</code>  、 <code>v-html</code></p>
<blockquote>
<p>v-test 会覆盖默认文本内容，一般使用<code>&#123;&#123;&#125;&#125;</code>插值表达式<br> v-text和差值表达式只能渲染纯文本内容<br> v-html可以把带标签的字符串渲染成HTML内容</p>
</blockquote>
</li>
<li><p>属性绑定指令: <code>v-bind</code> &#x2F; <code>:xxx=</code> </p>
<blockquote>
<p>差值表达式只能用在元素的内容节点中，不能用在属性节点中<br> v-bind用法：<code>&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;</code><br> <strong>vue规定 <code>v-bind:</code> 指令可以简写为<code>:</code></strong></p>
</blockquote>
<blockquote>
<p>在vue提供的<strong>模版渲染语法中</strong>，除了支持绑定简单的数据值之外，还<font color="green">支持JS表达式的运算</font><br> 但是<font color="green">只能写简单的JS表达式，不能写if等复杂的JS语句</font>，如字符串拼接等：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;number + <span class="number">1</span>&#125;&#125;、&#123;&#123;ok?<span class="string">&#x27;YES&#x27;</span>:<span class="string">&#x27;NO&#x27;</span>&#125;&#125;、&#123;&#123;msg.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reserve</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)&#125;&#125;<span class="comment">//反转字符串</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><font id="obj" color="red">v-bind的<strong>对象写法</strong></font><br> <code>&lt;xxx v-bind=&quot;&#123;x:100,y:200&#125;&quot;/&gt;</code> 等同于：<code>&lt;xxx :x=&quot;100&quot; :y=&quot;200&quot;/&gt;</code></li>
</ul>
</li>
<li><p>事件绑定指令：<code>v-on</code> &#x2F; <code>@</code></p>
<blockquote>
<p>语法如 <code>v-on:clock=&quot;add&quot;</code> 简写<code>@click=&quot;add&quot;</code><br> methods下的函数变量也支持简写：<code>add:function()&#123;&#125; --&gt; add()&#123;&#125;</code><br> 在处理函数中<strong>修改数据的值</strong>可以通过vm(接受vue实例的变量名)来修改：vm.count,但是不推荐，<strong>推荐用this</strong></p>
</blockquote>
<ul>
<li><p>绑定事件并传参</p>
<blockquote>
<p>在调用的地方传参 <code>@click=&quot;add(1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="param" color="red">参数问题</font></p>
<blockquote>
<ul>
<li>如果定义的函数变量是有参数的<br>1. <code>add(n)&#123;&#125; -- @click=&quot;add(1)&quot;</code> 正常传参 n&#x2F;&#x2F;1<br>2. <code>add(n)&#123;&#125; -- @click=&quot;add()&quot;</code> n&#x2F;&#x2F;undefined<br>3. <code>add(n)&#123;&#125; -- @click=&quot;add&quot;</code> n被认定为事件对象PointerEvent，通常我们会定义为e&#x2F;event</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果是多个参数，如<br>1. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1,2)&quot;</code> 正常传参 a&#x2F;&#x2F;1 b&#x2F;&#x2F;2<br>2. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1)&quot;</code> a&#x2F;&#x2F;1 b&#x2F;&#x2F;undefined<br>3. <code>add(a,b)&#123;&#125; -- @click=&quot;add()&quot;</code> a&#x2F;un b&#x2F;&#x2F;un<br>4. <code>add(a,b)&#123;&#125; -- @click=&quot;add&quot;</code> a&#x2F;&#x2F;事件对象PointerEvent ，b&#x2F;&#x2F;undefined</li>
</ul>
</blockquote>
</li>
<li><p><font id="event" color="red">事件对象$event</font>(不常用)</p>
<blockquote>
<p>vue提供了内置变量<code>$event</code>,它就是原生DOM的事件对象e<br>  在绑定事件的时候，如果不传参 <code>add(e)&#123;&#125; -- @click=&quot;add&quot;</code> , 我们会接受到一个事件对象e<br>  如果传参，<code>@click=&quot;add(1)&quot;</code>,我们就接收不到这个事件对象了<br>  <strong>我们既要传参，又要用到事件对象e</strong>，如想要从事件对象上拿到e.target(触发事件的事件源) ，这个时候就可以用<code>$event</code><br>  <strong><code>$event</code>使用：传<code>$event</code>作参数进去，拿形参接收</strong><br>  <code>add(n,e)&#123;&#125; --  @click=&quot;add(1,$event)&quot;</code><br>  或<code>add(e,n)&#123;&#125; --  @click=&quot;add($event,1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="modifier" color="red">事件修饰符</font></p>
<blockquote>
<p>在事件处理函数中，调用<code>event.preventDefault()</code>(阻止默认行为)或<code>event.stopPropagation()</code>(阻止冒泡)是非常常见的需求。<br>  因此，vue提供了<strong>事件修饰符</strong>的概念，辅助程序员更方便的<strong>对事件的触发进行控制</strong>。<br>  如 <code>@click.prevent=&quot;show&quot;</code>绑定了show事件，同时阻止了默认行为<br>  常见的5个事件修饰符如下：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>.prevent</strong></td>
<td><strong>阻止默认行为</strong>(例如：阻止a链接的跳转、表单的提交等)</td>
</tr>
<tr>
<td align="center"><strong>.stop</strong></td>
<td><strong>阻止事件冒泡</strong></td>
</tr>
<tr>
<td align="center">.capture</td>
<td>以 捕获模式 触发当前的 事件处理函数</td>
</tr>
<tr>
<td align="center">.once</td>
<td>绑定的事件只触发1次</td>
</tr>
<tr>
<td align="center">.self</td>
<td>只有在 event.target 是当前元素自身时 触发事件处理函数</td>
</tr>
</tbody></table>
<ul>
<li><font id="keyModifier" color="red">按键修饰符</font>(用的不是很多)<blockquote>
<p>在<strong>监听键盘事件</strong>时，经常需要<strong>判断详细的按键</strong>。<br>  此时，可以为键盘的相关事件添加<strong>按键修饰符</strong>，如：<br>  <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> – 只有在<code>key</code>是<code>Enter</code>时，调用<code>vm.submit()</code><br>  <code>&lt;input @keyup.esc=&quot;clearInput&quot;&gt;</code> – 只有在<code>key</code>是<code>Esc</code>时，调用<code>vm.clearInput()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>双向绑定指令 <code>v-model</code></p>
<blockquote>
<p>用来辅助程序员在<strong>不操作DOM</strong>的前提下，<strong>快速获取表单的数据</strong>。<br>     能够产生数据交互的只有表单元素，所以只有表单元素才能使用<code>v-model</code>,才有意义<br>     表单元素 input、textarea、select<br>     v-model内部会判断绑定元素的类型，根据元素类型来决定将绑定的值给哪个属性。如复选框checkbox就是给checked属性，如果是text框就是value属性</p>
</blockquote>
<ul>
<li><font id="v-model" color="red">v-model修饰符</font><blockquote>
<p>为了方便对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.number</td>
<td>自动将用户的输入值转为数值类型</td>
<td><code>&lt;input v-model.number=&quot;age&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.trim</td>
<td>自动过滤用户输入的首尾空白字符</td>
<td><code>&lt;input v-model.trim=&quot;msg&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.lazy</td>
<td>在”change”时而非”input”时更新</td>
<td><code>&lt;input v-model.lazy=&quot;msg&quot;/&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>lazy的作用是input事件(表单处于焦点时候)不更新，失去焦点触发change事件才更新</p>
</blockquote>
</li>
<li><p>条件渲染指令 <code>v-if</code>、<code>v-show</code></p>
<blockquote>
<p>辅助开发者<strong>按需控制DOM的显示与隐藏</strong><br> v-if动态的把元素DOM从页面添加和移除<br> v-show是通过css动态添加display：none样式来显示和隐藏<br> <strong>如果要频繁切换元素的显示状态，show的性能更好</strong><br> <strong>如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好</strong><br> 这个只是说给面试官听的，<font color="green">在实际开发中，绝大多数情况不用考虑性能问题，直接使用v-if就好了！</font><br> 因为在大多数情况下，这种性能差异是微不足道的，除非在处理大量组件或频繁切换时才会产生明显影响。</p>
</blockquote>
<ul>
<li><p><font color="green">页面的执行(一个v-if的好问题)</font></p>
<blockquote>
<p>Q：如果我们页面有一个<code>&lt;p v-if=&quot;flag&quot;&gt;&lt;/p&gt; -- flag=false</code>，因为页面是从上往下执行的，那么页面是先创建p标签再移除呢，还是一开始就不创建呢？<br>  A：<strong>当我们用了vue-cli以后，用到单文件组件(.vue文件)的时候，它是先编译，然后再去运行。</strong><br>  先把整个网页编译成js，然后完整的去执行。标签也是被当做js去运行的，去加载的，这个问题就不存在了<br>  在 Vue 中，会根据 <code>v-if</code> 指令来决定是否渲染 DOM 元素。当 <code>flag</code> 初始值为 <code>false</code> 时，<code>&lt;p&gt;</code> 标签不会被创建到 DOM 中，<strong>Vue 在编译阶段会将 <code>v-if</code> 条件为 <code>false</code> 的元素直接移除</strong>。<br>  具体的流程如下：<br>      1. Vue 开始解析模板，并执行编译步骤。<br>      2. 当解析到带有 <code>v-if</code> 指令的元素时，Vue 会根据条件的真假决定是否将该元素包含在虚拟 DOM 中。<br>      3. 如果 <code>flag</code> 的初始值为 <code>false</code>，则 Vue 不会将 <code>&lt;p&gt;</code> 标签添加到虚拟 DOM 中。<br>      4. 最终，Vue 将虚拟 DOM 渲染为真实的 DOM，此时 <code>&lt;p&gt;</code> 标签不会出现在页面上。<br>  因此，页面上不会先创建 <code>&lt;p&gt;</code> 标签再移除，而是在一开始就不会创建 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
</li>
<li><p><font id="if" color="green">v-if配套的指令 – <code>v-else</code></font></p>
<blockquote>
<p>多个元素按需展示<br>  注意：v-else指令<strong>必须配合v-if指令一起使用</strong>，否则不会被识别：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表渲染指令 <code>v-for</code> 和 <code>:key</code> <font color="red">重要</font></p>
<blockquote>
<p>辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。<br>     v-for指令需要使用<code>item in items</code>形式的特殊语法<br>     v-for支持一个可选的第二个参数，即当前项的索引<code>(item,index) in items</code><br>     注意：v-for指令中的 item项 和 index索引 都是形参，可以根据需要命名</p>
</blockquote>
<ul>
<li><font id="key" color="red">强调v-for循环中key值的绑定</font><blockquote>
<p>官方推荐在用v-for的时候一定要绑定一个key属性，既提升性能、又防止列表状态紊乱。而且尽量把id作为key的值(id唯一)<br>  <font color="#000">官方对key的值类型有要求，只能是字符串或数字类型，并且key的值必须唯一，不能重复(相当于id)</font><br>  也不能以index为值，如果key以索引为值，会数据紊乱，<strong>key必须唯一且稳定，不唯一就会终端报错，唯一又不稳定就会数据紊乱。</strong><br>  <code>&lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</code><br>  如果使用v-for<strong>只是为了循环渲染出内容</strong>，<code>:key</code><strong>可以绑定为index索引</strong>，因为这个时候并没有实际的作用，只是<strong>为了不让报错</strong>而已<br>  <font color="green">不懂key到底有什么用的可以去了解下diff算法和虚拟dom？</font><br>  <font color="purple">key是元素的标识，具有唯一性，diff算法同层比较会根据key判断，dom是在原基础上更新，还是删除再重新创建，若key不唯一，会造成dom额外的删除再创建，消耗性能</font></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="lable复选框的for属性"><a href="#lable复选框的for属性" class="headerlink" title="lable复选框的for属性"></a>lable复选框的for属性</h3><p>下面这个示例中,如果要选中男，应该点击对应的复选框，点击男不行，这样用户的体验很不好，可操作区域非常窄。<br>应该把它的可操作区域给放大，点击复选框还是男都可以选中，此时就用到了for属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>for指向id，希望点这个lable让谁被选中，就for那个元素的id</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="a元素的JavaScript-伪协议"><a href="#a元素的JavaScript-伪协议" class="headerlink" title="a元素的JavaScript 伪协议"></a>a元素的JavaScript 伪协议</h3><p><code>&lt;a href=&quot;javascript:;&quot; @click=&quot;remove&quot;&gt;删除&lt;/a&gt;</code><br>这段代码是一个 HTML 锚点元素 <code>&lt;a&gt;</code> 的写法，其中<code>javascript:;</code> 是一个 JavaScript 伪协议，用于在点击链接时执行 JavaScript 代码或阻止默认行为。</p>
<p>通常情况下，当用户点击这个链接时，浏览器会执行 <code>JavaScript:;</code> 这里的 JavaScript 代码是空的，所以实际上不会发生任何操作。<br>这种写法通常用于创建一个占位符链接，或者作为一个“空链接”，<strong>用于在不跳转页面的情况下执行一些 JavaScript 操作，比如触发事件或者执行某些函数</strong>。</p>
<h3 id="JS-filter-方法-–-Array-prototype-filter"><a href="#JS-filter-方法-–-Array-prototype-filter" class="headerlink" title="JS - filter() 方法 – Array.prototype.filter()"></a>JS - filter() 方法 – Array.prototype.filter()</h3><p><code>filter()</code> 方法是 JavaScript 中数组的一个内置方法，用于过滤数组中的元素，并返回一个符合条件的新数组。<br>如：<br><code>let arr = [1,2,3].filter(item=&gt;item&gt;1) //[1,2]</code><br><code>let arr = [&#123;id:1,name:&quot;zs&quot;&#125;,&#123;id:2..&#125;].filter(item =&gt; item.id !=2) // [&#123;id:1,name:&quot;zs&quot;&#125;]</code></p>
<p>但是，除了数组外，<code>filter()</code> 方法还可以应用于类数组对象和可迭代对象。例如，字符串也可以通过 <code>filter()</code> 方法进行过滤操作。</p>
<p>下面是一个例子，演示如何在字符串中使用 <code>filter()</code> 方法来过滤出特定的字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filteredStr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(str, <span class="function"><span class="params">char</span> =&gt;</span> char !== <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredStr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// 输出：Heo Word!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先使用 <code>Array.prototype.filter.call()</code> 来调用 <code>filter()</code> 方法，并将字符串 <code>str</code> 当作第一个参数传入。然后，我们定义了一个过滤条件，即过滤掉所有的 ‘l’ 字符。最后，我们将过滤后的字符数组通过 <code>join()</code> 方法连接成一个新的字符串，并输出结果。</p>
<p>总之，虽然 <code>filter()</code> 方法通常用于数组，但通过一些技巧，我们也可以在其他类型的对象上使用它。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/" class="post-title-link" itemprop="url">前端工程化与Webpack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-18 23:41:46" itemprop="dateCreated datePublished" datetime="2024-04-18T23:41:46+08:00">2024-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-08 13:48:02" itemprop="dateModified" datetime="2024-05-08T13:48:02+08:00">2024-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Webpack/" itemprop="url" rel="index"><span itemprop="name">Webpack</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Webpack/" itemprop="url" rel="index"><span itemprop="name">Webpack</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/18/Vue2/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>了解工程化的前端开发方式<br>知道Webpack在实际开发中所起到的作用</p>
<blockquote>
<p>我们只需要了解webpack的工作原理，并不要求我们掌握如何配置，因为工作中我们会使用一些工具如Vue-CLI脚手架，它们已经帮我们配置好了</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>webpack 的基本使用</strong>：安装、webpack.config.js、修改打包入口<br><strong>webpack的两个插件</strong>(常用的plugin的基本使用)：<br>webpack-dev-server – (每次修改后自动进行项目的打包和构建)<br>html-webpack-plugin – (把src里面的首页在内存中复制一份，放到根目录中)<br><strong>常用的loader 的基本使用</strong>：协助webpack打包处理特定的文件模块。<br><strong>Source Map 的作用</strong>：精准定位到错误行并显示对应的源码，方便开发者调试源码中的错误</p>
</blockquote>
<h2 id="前端工程化相关概念"><a href="#前端工程化相关概念" class="headerlink" title="前端工程化相关概念"></a>前端工程化相关概念</h2><p>前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。<br>好处:前端开发自成体系，有一套标准的开发方案和流程。</p>
<p>实际的前端开发，是四个现代化：</p>
<ul>
<li><strong>模块化</strong> (js的模块化、css的模块化、资源的模块化) ———— js的复用</li>
<li><strong>组件化</strong> (复用现有的UI结构、样式、行为) ———— UI结构的复用</li>
<li><strong>规范化</strong> (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</li>
<li><strong>自动化</strong> (自动化构建、自动部署、自动化测试)</li>
</ul>
<h3 id="前端工程化解决方案"><a href="#前端工程化解决方案" class="headerlink" title="前端工程化解决方案"></a>前端工程化解决方案</h3><ul>
<li>早期的前端工程化解决方案:<ul>
<li>grunt (<a target="_blank" rel="noopener" href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</li>
<li>gulp (<a target="_blank" rel="noopener" href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</li>
</ul>
</li>
<li>目前主流的前端工程化解决方案:<ul>
<li>webpack (<a target="_blank" rel="noopener" href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</li>
<li>parcel (<a target="_blank" rel="noopener" href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>) ———— 开发第三方包会用到</li>
</ul>
</li>
</ul>
<h2 id="webpack-常见用法"><a href="#webpack-常见用法" class="headerlink" title="webpack 常见用法"></a>webpack 常见用法</h2><ol>
<li><p>什么是webpack？<br> 概念：webPack是<strong>前端项目工程化的具体解决方案</strong>。<br> 主要功能: 它提供了友好的<strong>前端模块化开发支持</strong>，以及<strong>代码压缩混淆</strong>(干掉注释和空格)、<strong>处理浏览器端JavaScript的兼容性</strong>、<strong>性能优化</strong>等强大的功能。<br> 好处:让程序员把<strong>工作的重心</strong>放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意:目前Vue，React等前端项目，基本上都是基于webpack进行工程化开发的。</p>
</li>
<li><p>创建列表隔行变色项目</p>
<ol>
<li>新建项目空白目录，并运行npm init -y命令，初始化包管理配置文件 package.json</li>
<li>新建src源代码目录</li>
<li>新建src -&gt; index.html首页和src -&gt; index.js 脚本文件</li>
<li>初始化首页基本的结构</li>
<li>运行npm install jquery -S命令，安装jQuery(-S明确告诉npm，包要记录到dependencies下，开发上线都会用到)</li>
<li>通过ES6模块化的方式导入jQuery，实现列表隔行变色效果</li>
</ol>
</li>
<li><p>在项目中安装webpack<br> 运行如下命令，安装webpack相关的两个包（-D告诉npm记录到devDependencies下，只在开发阶段会用到）<br> <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code></p>
</li>
<li><p>在项目中配置webpack</p>
<ol>
<li><p>在项目根目录中，创建名为<strong>webpack.config.js</strong>的webpack配置文件，并初始化如下的基本配置:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// mode 用来指定构建模式。可选值有 development和 production</span></span><br><span class="line">    <span class="comment">// 开发阶段选develement，上线改成production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在package.json的 scripts节点下，新增<strong>dev脚本</strong>如下:<br> 这个dev是可以随意命名的，后面的webpack是必须写webpack<br> scripts节点下有个默认的test脚本，删掉就行</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script 节点下的脚本，可以通过 npm run 执行。例如 npm run dev</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中运行npm run dev命令，启动 webpack进行项目的打包构建<br> 运行成功后，项目会多一个dist文件夹，里面的main.js就是webpack根据index.js帮我们自动生成的，做一下兼容性处理<br> 处理完以后，index.js还有兼容性问题，而main.js没有兼容性问题<br> 所以网页应该引入的是main.js文件<br> .<br> 由nodejs升级引起的构建错误：0308010C:digital envelope routines::unsupported<br> <a target="_blank" rel="noopener" href="https://juejin.cn/post/7202639428132044858">https://juejin.cn/post/7202639428132044858</a><br> 报错原因可以看这篇文章<br> 解决设置（似乎还没有一个100%完全的解决方法，都会存在一些问题）:<br> <code>&quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack&quot;</code><br> .<br> 这个main.js是webpack帮我们把jquery.js和index.js文件进行了合并，但是并没有压缩，main.js中还有注释和代码缩进，如果要压缩，需要把webpack.config.js的mode设置为production，然后重新运行，整个文件的体积就被压缩的更小了，但是打包的时间更长了<br> .<br> 所以开发的时候，mode都设置成develement，只有上线的时候才会设置为production</p>
</li>
<li><p>webpack的默认约定 ———— 如何打包<br> 在webpack 4.x和5.的版本中，有如下的默认约定:</p>
<ol>
<li>默认的打包入口文件为src -&gt; index.js</li>
<li>默认的输出文件路径为dist -&gt; main.js</li>
</ol>
<p> 注意:可以在webpack.config.js中修改打包的默认约定<br> 如果找不到要处理的文件，就会报错</p>
</li>
<li><p>自定义打包的入口和出口<br> 在webpack.config.js 配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">&#x27;path&#x27;</span>) <span class="comment">//导入 node.js中专门操作路径的模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//打包入口文件的路径</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//输出文件的存放路径 </span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="comment">//输出文件的名称</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>这个时候，我们会发现，每次我们更改index.js的代码之后，都需要再次执行npm run dev更新生成的文件才行，这样非常麻烦，所以我们需要用到webpack的插件</p>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><p>最常用的webpack插件有两个：</p>
<ol>
<li>webpack-dev-server<ul>
<li>类似于node.js的nodemon工具</li>
<li>每当修改了源代码，webpack都会自动进行项目的打包和构建</li>
</ul>
</li>
<li>html-webpack-plugin<ul>
<li>webpack 中的HTML插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定制index.html页面的内容<hr></li>
</ul>
</li>
</ol>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol>
<li><p>安装webpack-dev-server<br> <code>npm i webpack-dev-server@3.11.2 -D</code><br> .<br> 在配置好之后，npm run dev 运行报错<br> Unable to load ‘@webpack-cli&#x2F;serve’ command<br> TypeError: options.forEach is not a function<br> .<br> 下载<code>npm install webpack@5.42.1 webpack-cli@4.10.0 -D</code></p>
</li>
<li><p>配置webpack-dev-server</p>
<ol>
<li>修改package.json -&gt; scripts中的dev命令如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script节点下的脚本，可以通过npm run 执行</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>再次运行npm run dev命令，重新进行项目的打包<br> 在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</li>
</ol>
<p> 注意:webpack-dev-server 会启动一个实时打包的http服务器</p>
</li>
</ol>
<p>注意，webpack-dev-server启动后，构建后的文件是在内存中的，不会实际生成具体的文件，所以我们打开的页面效果不会发生变化</p>
<p>我们执行npm run dev 命令，它执行的其实是webpack serve命令<br>这个命令执行成功后，第一行返回的是，<br><code>i ｢wds｣: Project is running at http://localhost:8080/</code><br>是整个项目运行在8080端口<br>所以，要看更新后的效果，要打开这个网址来查看，不能和以前一样的方法查看，因为之前查看的是file协议，不是当前的http协议</p>
<p>我们打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 网址，进入src，浏览器就会自动打开这个目录下的index文件，但是还是页面没有更改，我们再看第二行<br><code>i ｢wds｣: webpack output is served from /</code><br>告诉我们，输出在根目录，但是根目录并看不到bundle.js，但是其实它是有的，我们打开<a target="_blank" rel="noopener" href="http://localhost:8080/bundle.js">http://localhost:8080/bundle.js</a> 可以访问到该文件</p>
<p><strong>webpack-dev-server这个插件，它把生成的bundle没有放到实际的物理磁盘上，而是放到了内存里面</strong><br>这是因为，如果频繁的修改文件，ctrl s，如果是把文件放到物理磁盘上，就会频繁的读写磁盘，对磁盘寿命性能都会有很大影响，所以要访问最新的bundle要访问内存里的bundle，所以应该<strong>在页面加载和引用内存里的bundle.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://localhost:8080/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// 也可以直接这样引用，看不见，但是可以引用的</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>但是由于我的vscode默认的使用5500端口，所以第二种引用会引用到5500端口，但是5500端口并不存在bundle.js，所以会报错,只能使用第一种引用</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>有一点不方便的是，打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 之后，我们还要点击一次src进入目录中，才能打开首页<br>我们希望一进入8080就能看到首页<br>html-webpack-plugin，这个插件可以把src里面的首页复制一份，放到根目录中<br>安装插件：<code>npm i html-webpack-plugin@5.3.2 -D</code></p>
<ul>
<li><p>配置 – 在webpack.config.js中配置<br>  把new出来的插件htmlPlugin 挂载&#x2F;添加到plugins插件的数组里面，这样webpack在运行的时候就会调用这个插件的实例，把src(template)里的页面复制一份放到根目录(filename)中<br>  不过也是复制出来的一个内存里的页面</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入HTML插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 2．创建HTML插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,<span class="comment">//指定原文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,<span class="comment">//指定生成的文件的存放路径</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> ,</span><br><span class="line">    <span class="comment">// 3．通过 plugins节点，使 htmlPlugin插件生效</span></span><br><span class="line">    <span class="attr">plugins</span>: [htmlPlugin], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个作用<br>  html-webpack-plugin插件除了帮我们复制页面，还会在复制出来的页面，自动注入一个脚本(js引用)，去引用内存里的bundle.js<br>  .<br>  我们npm run dev运行之后，如果把html页面的js引入注释掉，内存中页面样式是还在的，并没有消失。<br>  我们查看源码，可以发现它是有js引用的，而且是没有加.&#x2F;的同级目录引用，因为内存中的html和hundle.js在同一级目录</p>
</li>
</ul>
<p>配置完webpack之后，我们的开发体验会变的很好，但是配置过程又非常繁琐。<br>我不想自己配置，又想体验配置后的好处 ———— Vue-cli<br>这个工具已经帮我们配置好了webpack</p>
<h2 id="devServer-节点"><a href="#devServer-节点" class="headerlink" title="devServer 节点"></a>devServer 节点</h2><p>还有一个不爽的点(程序员的很多不爽XDD)，每次重新运行项目，都要手动打开8080页面，我们懒就要懒到底<br><strong>在npm run dev运行成功之后，自动打开浏览器展示网页</strong></p>
<ul>
<li>配置<br>  在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 初次打包完成后，自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 实时打包所使用的主机地址</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="comment">//实时打包所使用的端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="webpack中的loader（加载器）"><a href="#webpack中的loader（加载器）" class="headerlink" title="webpack中的loader（加载器）"></a>webpack中的loader（加载器）</h2><ol>
<li><p>loader概述<br> 在实际开发过程中，webpack默认只能打包处理以.js 后缀名结尾的模块。其他<strong>非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包</strong>，否则会报错!</p>
<p> loader加载器的作用:<strong>协助webpack打包处理特定的文件模块</strong>。比如:</p>
<ul>
<li>css-loader可以打包处理.css相关的文件</li>
<li>less-loader可以打包处理.less相关的文件</li>
<li>babel-loader可以打包处理webpack无法处理的高级JS语法</li>
</ul>
<p> 在webpack里面，一切都可以进行导入，一切皆模块，不建议程序员手动去引入样式和脚本(link，script)</p>
<p> 在js中也可以导入样式(ES6语法)<code>import &#39;./css/index.css&#39;</code></p>
</li>
<li><p>打包处理 css 文件</p>
<ol>
<li>运行<code>npm i style-loader@3.0.0 css-loader@5.2.6 -D</code>命令，安装处理css文件的loader</li>
<li>在webpack.config.js 的 module -&gt; rules 数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
 其中，<strong>test</strong>表示匹配的<strong>文件类型</strong>, <strong>use</strong>表示对应<strong>要调用的loader</strong><br> 注意:</li>
</ol>
<ul>
<li>use数组中指定的loader <strong>顺序是固定的</strong></li>
<li>多个loader的调用顺序是: <strong>从后往前调用</strong><br>  loader在调用的时候，是从后往前调的 <a href='#loader-调用过程'>loader调用过程</a></li>
</ul>
</li>
<li><p>打包处理 less文件</p>
<ol>
<li>运行<code>npm i less-loader@10.0.1 less@4.1.1 -D</code>命令</li>
<li>在webpack.config.js 的module -&gt; rules数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个less是内部依赖项，就是less-loader内部依赖于less，但是不需要手动的去声明less</li>
</ol>
</li>
<li><p>打包处理样式表中与url路径相关的文件</p>
<ol>
<li>运行<code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code>命令</li>
<li>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        <span class="comment">//如果需要调用的loader只有一个(use)，则只传递一个字符串也行，如果有多个loader，则必须指定数组</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,<span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&#x27;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中?之后的是 loader的参数项:</li>
</ol>
<ul>
<li>limit用来指定图片的大小，单位是字节(byte)</li>
<li>只有≤limit 大小的图片，才会被转为base64格式的图片</li>
</ul>
</li>
<li><p>打包处理js文件中的高级语法<br> webpack只能打包处理一部分高级的JavaScript语法。对于那些webpack无法处理的高级js语法，需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1．定义了名为info的装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">//2．为目标添加静态属性info</span></span><br><span class="line">    target.<span class="property">info</span> = <span class="string">&#x27;Person info&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3．为Person类应用info装饰器</span></span><br><span class="line">@info</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4．打印 Person 的静态属性info</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.1 运行如下的命令安装对应的依赖包:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js的 module -&gt; rules数组中，添加loader规则如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span> , <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>exclude排除了node_modules文件夹，因为只需要处理我们自己写的代码就可以了，第三方的包没有兼容性问题，本身已经解决了，不需要处理(如果不排除也会对其进行处理影响性能)</p>
<p>5.2 配置babel-loader<br>打包处理js文件中的高级语法，比处理其他文件要多这么一步<br>在项目根目录下，创建名为 babel.config.js 的配置文件，定义Babel的配置项如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些配置从官方文档找到对应项直接粘过来就行了</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//声明babel 可用的插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考Babel的官网<a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></p>
<h3 id="loader-调用过程"><a href="#loader-调用过程" class="headerlink" title="loader 调用过程"></a>loader 调用过程</h3><ol>
<li>webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</li>
<li>由于代码中包含了 index.css 这个文件，因此 webpack默认处理不了</li>
<li><strong>当webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器。</strong></li>
<li>webpack 把 index.css 这个文件，先转交给最后一个 loader 进行处理(先转交给css-loader) .</li>
<li>当 css-loader 处理完毕之后，会把处理的结果，转交给下一个 loader (转交给style-loader)</li>
<li>当 style-loader 处理完毕之后，发现没有下一个 loader 了，于是就把处理的结果，转交给了 webpack</li>
<li>webpack 把 style-loader 处理的结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。<br><img src="/tsukimiya.github.io/images/vue/loader%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="loader调用过程"></li>
</ol>
<h3 id="base64图片的优缺点"><a href="#base64图片的优缺点" class="headerlink" title="base64图片的优缺点"></a>base64图片的优缺点</h3><p>浏览器在拿到HTMl标签以后，需要再发送请求，拿到图片以后才能把图片渲染出来</p>
<p>但是使用用base64图片，在拿到img标签以后，就顺手的把图片对应的字符串也给请求下来了，可以防止发起一些不必要的网络请求</p>
<p>如果页面有许多小图标，就要发送很多次请求，对性能来讲非常不好，就可以把图片都转成base64格式的字符串</p>
<p>缺点：<br>图片转成base64，体积会增大一点点，所以大图片就不适合</p>
<p><strong>ES6 import导入图片得到的是一个base64字符串</strong>(可以打印看一下)<br>如 <code>import logo from &#39;./images/logo.png&#39;</code></p>
<h3 id="webpack处理样式的过程"><a href="#webpack处理样式的过程" class="headerlink" title="webpack处理样式的过程"></a>webpack处理样式的过程</h3><p>ES6在js文件导入样式<code>import &#39;./css/index.css&#39;</code><br>这种语法代表，只需要加载这个文件，把css样式给加载过来，不需要接收(接收的话，打印出来是undefined)</p>
<p>webpack加载和处理js文件，处理的结果会生成一个新的js文件(如bundle.js)，而且会在页面引用过去，在这个bundle.js里面，会包含我们import引入的样式，在这个bundle.js里面，css样式会被转成js的方式去运行</p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>我们如果要上线，应该拿到这些文件发给后端，让后端去部署上线<br>发布上线就是：<br>前端把项目生成一份最终的结果，有页面，配套的css js 图片等等<br>所有资源都在生成的文件夹里面，把所有内容打包发给后端<br>后端拿到结果去部署上线</p>
<p>现在我们要解决的问题是：页面和bundle.js放到内存里面了，需要把它生成到实际的物理磁盘上。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>在package.json文件的scripts节点下，新增build命令如下:<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    “dev&quot; : &quot;webpack serve&quot;，//开发环境中，运行dev命令</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时，运行 build命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <code>--mode</code>是一个参数项，用来指定webpack的<strong>运行模式</strong>。production 代表生产环境，会对打包生成的文件进行<strong>代码压缩</strong>和<strong>性能优化</strong>。<br>    注意:通过<code>--mode</code>指定的参数项，会<strong>覆盖</strong>webpack.config.js 中的<code>--mode</code>选项。</p>
<p>这里的dev命令是webpack serve，就是我们装的插件，是把文件生成到内存中，可以监听文件的更改自动执行npm run dev<br>而这里build就是要执行webpack命令把文件生成到磁盘上，这里注意要改成<br>    <code>set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack --mode production</code></p>
<h3 id="优化图片和js文件存放路径"><a href="#优化图片和js文件存放路径" class="headerlink" title="优化图片和js文件存放路径"></a>优化图片和js文件存放路径</h3><ol>
<li>js文件<br>在webpack.js的output对象属性中，把filename前面加上个文件夹<br> <code>filename:&#39;js/bundle.js&#39;</code></li>
<li>图片<br>修改webpack.config.js 中的url-loader配置项，新增outputPath选项即可指定图片文件的输出路径: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jpg|png|gif$/</span> ,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">22228</span>,</span><br><span class="line">            <span class="comment">//明确指定把打包生成的图片文件，存储到dist目录下的 image 文件夹中</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者直接用?xx&#x3D;xx&amp;xx&#x3D;xx的方式在loader后面携带参数 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>, <span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&amp;outputPath=images&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置和使用clean-webpack-plugin插件自动删除dist目录"><a href="#配置和使用clean-webpack-plugin插件自动删除dist目录" class="headerlink" title="配置和使用clean-webpack-plugin插件自动删除dist目录"></a>配置和使用clean-webpack-plugin插件自动删除dist目录</h3><p><strong>webpack5已经默认封装(内置)了该插件，直接在配置文件里output设置属性clean:true即可</strong></p>
<hr>
<p>为了防止旧文件干扰我们的事件，在每次重新发布的时候会把生成的打包好的dist文件夹删掉。<br>为了在每次打包发布时自动清理掉dist目录中的旧文件，可以安装并配置dlean-webpack-plugin插件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1．安装清理dist目录的 webpack 插件</span></span><br><span class="line">npm install clean-webpack-plugin@<span class="number">3.0</span><span class="number">.0</span> -D</span><br><span class="line"><span class="comment">// 2．按需导入插件、得到插件的构造函数之后，创建插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanwebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanwebpackPlugin</span>()</span><br><span class="line"><span class="comment">// 3．把创建的 cleanPlugin 插件实例对象，挂载到plugins节点中</span></span><br><span class="line"><span class="attr">plugins</span>: [htmlPlugin,cleanPlugin],<span class="comment">//挂载插件 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检验是否是删除之后重新生产的方法</strong>：<br>可以在dist文件夹下新建如1.txt文件，重新打包，如果文件还在，说明是没有删除直接打包的，如果不再了，那就是删除之后重新打包。</li>
</ul>
<h3 id="企业级项目的打包发布"><a href="#企业级项目的打包发布" class="headerlink" title="企业级项目的打包发布"></a><font color="red">企业级项目的打包发布</font></h3><p>企业级的项目在进行打包发布时，远比刚才的方式要复杂的多，主要的发布流程如下:</p>
<ul>
<li>生成打包报告，根据报告分析具体的优化方案</li>
<li>Tree-Shaking</li>
<li>为第三方库启用CDN加载</li>
<li>配置组件的按需加载</li>
<li>开启路由懒加载</li>
<li>自定制首页内容</li>
</ul>
<h2 id="source-Map-–-开发阶段检错"><a href="#source-Map-–-开发阶段检错" class="headerlink" title="source Map – 开发阶段检错"></a>source Map – 开发阶段检错</h2><p>告诉你文件的报错位置，用于调试bug<br>开发阶段 npm run dev 检错的<br><strong>在发布项目的时候，处于安全性考虑，建议关闭SourceMap</strong>。防止一些人通过报错位置来拿到我们的源代码(通过修改页面代码来主动让页面某功能报错来拿到该功能位置的源码这样吗？)<br>新版本开发环境建议使用cheap-module-source-map？</p>
<ol>
<li>什么是 source Map<br> <strong>Source Map就是一个信息文件，里面储存着位置信息</strong>。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的<strong>转换前的位置</strong>。<br> 有了它，出错的时候，<strong>除错工具将直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</li>
</ol>
<p>即是：页面报错，控制台会显示错误以及错误文件及其报错位置，如果没有配置这个，它显示的就是打包压缩后的代码的位置</p>
<ol start="2">
<li><p>webpack <strong>开发环境下的</strong> Source Map<br> <strong>在开发环境下</strong>，webpack<strong>默认启用了</strong>Source Map功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。<br> 但是，开发环境下默认生成的Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</p>
</li>
<li><p>解决默认的Source Map的问题<br> 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="comment">// eval-source-map 仅限在&quot;开发模式&quot;下使用，不建议在&quot;生产模式&quot;下使用。</span></span><br><span class="line">    <span class="comment">//此选项生成的 Source Map 能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span></span><br><span class="line">    <span class="comment">// 在开发调试阶段，建议大家都把devtool的值设置为eval-source-map</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">//省略其它配置项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack <strong>生产环境下的</strong> Source Map<br>在生产环境下，如果省略了devtool选项，则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人</p>
</li>
<li><p><strong>只定位行数不暴露源码</strong> – 对调试和安全都比较友好<br>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以<strong>将devtool的值设置为nosources-source-map</strong>。<br>知道了行号，我们就可以定位到源码的行位置来解决bug</p>
</li>
<li><p>定位行数且暴露源码<br>在生产环境下，如果<strong>想在定位报错行数的同时，展示具体报错的源码</strong>。此时可以将devtool的值设置为source-map。<br>坚决不推荐。(但是这不是和eval-source-map一样吗？？)<br>这种方式会生成一个SourceMap(但是nosources-source-map也有，eval-soure-map应该也有吧)<br>可以看到在dist的js目录下，除了有bundle.js还有个bundle.js.map，这就是我们的SourceMap</p>
</li>
</ol>
<h3 id="Source-Map的最佳实践"><a href="#Source-Map的最佳实践" class="headerlink" title="Source Map的最佳实践"></a>Source Map的最佳实践</h3><ol>
<li>开发环境下:<ul>
<li>建议把devtool的值设置为<strong>eval-source-map</strong></li>
<li>好处: 可以精准定位到具体的错误行</li>
</ul>
</li>
<li>生产环境下:<ul>
<li>建议<strong>关闭Source Map</strong> 或 将devtool的值设置为<strong>nosources-source-map</strong></li>
<li>好处: 防止源码泄露，提高网站的安全性</li>
</ul>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="快速终止服务器"><a href="#快速终止服务器" class="headerlink" title="快速终止服务器"></a>快速终止服务器</h3><p><font color="red">两次 ctrl + c 可以直接结束 webpack serve，不需要再去输入y结束</font><br>Vue CLI也一样，因为它是内置了webpack</p>
<h3 id="webpack中-的原理和好处"><a href="#webpack中-的原理和好处" class="headerlink" title="webpack中 @ 的原理和好处"></a>webpack中 @ 的原理和好处</h3><p>这样一个场景：<br>src目录下 有一个info文件 js&#x2F;text&#x2F;info<br>而这个info文件要导入src目录下的msg.js文件<br>就需要这样导入: import msg from ‘..&#x2F;..&#x2F;msg’<br>如果info的文件层级再深一点，这个..&#x2F;会让人不知道翻了几层<br>所以<br><strong>建议大家都使用 @ 符号表示src源代码目录，从外往里查找，不要使用..&#x2F;从里往外查找</strong><br>import msg from ‘@&#x2F;msg.js’</p>
<p>在webpack里面，@不能直接用，需要先配置一下<br>在webpack.config.js中，module.exports中增加一个resolve属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 告诉webpack，程序员写的代码中，@符号表示src这一层目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在浏览器安装vue-devtools调试工具"><a href="#在浏览器安装vue-devtools调试工具" class="headerlink" title="在浏览器安装vue-devtools调试工具"></a>在浏览器安装vue-devtools调试工具</h3><p>edge扩展中直接搜，有一个vue.js-devtools<br><strong>在详情设置中，有个允许访问文件URL(文件网址)的设置，默认是关闭的状态，需要我们手动打开</strong></p>
<h2 id="实际开发中不需要自己配置webpack"><a href="#实际开发中不需要自己配置webpack" class="headerlink" title="实际开发中不需要自己配置webpack"></a><strong>实际开发中不需要自己配置webpack</strong></h2><ul>
<li>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</li>
<li>开箱即用，所有webpack配置项都是现成的!</li>
<li>我们只需要知道webpack 中的基本概念即可!</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Node.js简单实现后端服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-15 20:23:00" itemprop="dateCreated datePublished" datetime="2024-04-15T20:23:00+08:00">2024-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-29 17:32:20" itemprop="dateModified" datetime="2024-04-29T17:32:20+08:00">2024-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>该示例没有用到数据库，是通过创建POST表单路由进行处理数据，将数据保存到文件中，以及数据校验<br>用到的npm包&#x2F;第三方模块：<br>Express：<code>npm i express@4.17.1</code> – Web 开发框架，快速创建 Web 服务器<br>Joi：<code>npm install joi --save</code> – hapijs 自带的数据校验模块<br>@escook&#x2F;express-joi中间件: <code>npm i @escook/express-joi</code> – 实现自动对表单数据进行验证的功能<br>cors： <code>npm i cors</code> – 配置cors跨域<br>dayjs： <code>npm install dayjs --save</code> – 格式化时间</p>
</blockquote>
<blockquote>
<p>全局安装了nodemon工具，可以监听文件的更改，自动重新执行</p>
</blockquote>
<blockquote>
<p>这个是航空文化馆项目的后端，还没写完<br>没有用到mysql模块：<code>npm i mysql</code><br>也没有用到express-session中间件：<code>npm i express-session</code>（这个干吗用的？）</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0">
<li>如果是拿被别人写好的项目，第一步是导入这个项目所用的包，<code>npm i</code>命令</li>
<li>创建后端项目文件夹如serve</li>
<li>初始化文件夹<code>npm init -y</code><br> 在空项目的根目录中初始化一个package.json的包管理配置文件</li>
<li>安装必要的包&#x2F;依赖<br> 安装Express —— <code>npm i express@4.17.1</code></li>
<li>创建服务器文件，命名如app.js</li>
</ol>
<h2 id="创建简单的web服务器-及其-模块化"><a href="#创建简单的web服务器-及其-模块化" class="headerlink" title="创建简单的web服务器 及其 模块化"></a>创建简单的web服务器 及其 模块化</h2><ol>
<li><p>创建基本的express框架 – eser(vscode快捷生成代码&#x2F;&#x2F;自己配置 – 文件–首选项–配置用户代码片段)</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Express server running at http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)      </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由<br> 可以先在当前文件尝试是否成功，之后再分离到对应模块</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建express路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// 提交预约表单</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/form&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用postman测试请求是否成功<br> 向 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/form">http://127.0.0.1:8080/form</a> 发送post请求<br> 响应函数中打印出来的req.body结果是undefined，这是因为我们没有配置解析表单的中间件</p>
</li>
<li><p>配置解析表单的中间件<br> &#x2F;&#x2F; 配置解析表单数据的中间件,注意：这个中间件，只能解析applicaton&#x2F;x-www-form-urlencoded格式的表单数据<br> <code>app.use(express.urlencoded(&#123;extended:false&#125;))</code><br> 再次发送请求，我们就得到了表单提交的数据</p>
</li>
<li><p>分离到路由模块<br> 创建router文件夹，创建如user.js文件&#x2F;&#x2F;处理用户路由<br> 将路由部分写到这个地方，然后把router暴露出去<br> <code>module.exports = router</code><br> 然后在app.js中导入并使用路由模块</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
<li><p>分离处理函数到路由处理模块，同5操作<br> 创建router_handler文件夹，在该目录下创建对应的用户路由处理文件user.js<br> 把处理函数暴露出去</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">formSubmit</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在路由模块导入导入用户路由处理函数对应的模块<br> <code>const user_handler = require(&#39;../router_handler/user&#39;)</code><br> 路由的响应函数换成对应的user_handler.formSubmit</p>
</li>
</ol>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>这里使用joi模块来进行数据验证<br>Joi 是 hapijs 自带的数据校验模块，他已经高度封装常用的校验功能。</p>
<ol>
<li><p>安装joi包，为表单中携带的每个数据项，定义验证规则</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install joi --save</span><br><span class="line"><span class="comment">// ES6写法 import Joi from &#x27;joi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>安装 @escook&#x2F;express-joi 中间件，来实现自动对表单数据进行验证的功能：<br> <code>npm i @escook/express-joi</code></p>
</li>
<li><p>joi验证规则</p>
<ul>
<li>string() 值必须是字符串</li>
<li>number() 值必须是数字</li>
<li>alphanum() 值只能是包含 a-zA-Z0-9 的字符串</li>
<li>min(length) 最小长度</li>
<li>max(length) 最大长度</li>
<li>required() 值是必填项，不能为 undefined</li>
<li>pattern(正则表达式) 值必须符合正则表达式的规则</li>
<li>any() 任意</li>
<li>date() 日期</li>
<li>time() 时间</li>
<li>iso() 要求字符串值采用有效的 ISO 8601 日期格式。</li>
</ul>
</li>
<li><p>新建 &#x2F;schema&#x2F;user.js 用户信息验证规则模块，并初始化代码如下：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单校验规则</span></span><br><span class="line"><span class="keyword">const</span> unit = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> contact = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> phone = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[1][\d]&#123;10&#125;$/</span>).required()</span><br><span class="line"><span class="keyword">const</span> numVisitors = joi.<span class="title function_">number</span>().<span class="title function_">min</span>(<span class="number">16</span>).required()</span><br><span class="line"><span class="keyword">const</span> guide = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/yes|no|是|否/</span>).required()</span><br><span class="line"><span class="keyword">const</span> date = joi.<span class="title function_">date</span>().<span class="title function_">min</span>(<span class="string">&#x27;now&#x27;</span>).<span class="title function_">iso</span>().required()</span><br><span class="line"><span class="keyword">const</span> time = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[\d]&#123;2&#125;[\s]*:[\s]*[\d]&#123;2&#125;$/</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单的验证规则对象</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">form_schema</span> =&#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        unit,</span><br><span class="line">        contact,</span><br><span class="line">        phone,</span><br><span class="line">        numVisitors,</span><br><span class="line">        guide,</span><br><span class="line">        date,</span><br><span class="line">        time,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由模块添加数据校验</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入需要验证的规则</span></span><br><span class="line"><span class="keyword">const</span> &#123;form_schema&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 在表单提交的路由中，声明局部中间件，对当前请求中携带的数据进行验证<br> 数据验证通过后，会把这次请求流转给后面的路由处理函数<br> 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理<br> <code>router.post(&#39;/form&#39;,expressJoi(form_schema), user_handler.formSubmit)</code></p>
</li>
<li><p>在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端<br> 在路由注册之后声明错误级别中间件，注意这里需要在app.js导入joi</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    <span class="comment">//数据验证失败</span></span><br><span class="line">    <span class="keyword">if</span>(err <span class="keyword">instanceof</span> joi.<span class="property">ValidationError</span>) <span class="keyword">return</span> res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 未知错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> postman测试成功</p>
</li>
</ol>
<h2 id="配置cors-跨域"><a href="#配置cors-跨域" class="headerlink" title="配置cors 跨域"></a>配置cors 跨域</h2><p>之前我们都是在postman发送请求测试，如果我们在自己写的页面发送请求会发现报错<br>这是因为我们的页面打开的是file协议，而服务器则是http协议，</p>
<p>使用<strong>cors中间件</strong>解决跨域问题<br>cors 是Express的一个第三方中间件。通过安装和配置cors 中间件，可以很方便地解决跨域问题。<br>使用步骤分为如下3步:<br>    1. 运行<code>npm install cors</code>安装中间件<br>    2. 使用<code>const cors = require(&#39;cors&#39;)</code>导入中间件<br>    3. 在路由之前调用<code>app.use(cors())</code>配置中间件</p>
<p>注意：<strong>一定要在路由之前配置cors中间件，从而解决接口跨域的问题</strong></p>
<ul>
<li>前端发送axios请求：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        unit : <span class="string">&quot;00&quot;</span>,</span><br><span class="line">        contact : <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">        <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">        <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">        <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
注意：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的，然而我们没有配置解析JSON表单数据的中间件，所以后端能够接收到请求，但是拿不到参数</li>
</ul>
<p>配置解析JSON格式表单数据的中间件：<code>app.use(express.json())</code><br>再次在页面发送axois请求，测试成功</p>
<h2 id="处理数据-–-date时间格式化"><a href="#处理数据-–-date时间格式化" class="headerlink" title="处理数据 – date时间格式化"></a>处理数据 – date时间格式化</h2><blockquote>
<p>在路由处理模块，我们通过<code>const userInfo = req.body</code>接收了获取的数据<br>    但是打印userInfo出来发现，<code>date: 2025-05-15T00:00:00.000Z,</code>，和我们传入的<code>2025-05-15</code>并不一致<br>    遍历对象打印date又变成了：<code>date: Thu May 15 2025 08:00:00 GMT+0800 (中国标准时间)</code><br>    这也许是因为数据校验调用了date()导致<code>const date = joi.date().min(&#39;now&#39;).iso().required()</code><br>    所以我们需要手动处理一下接收到的date的格式</p>
</blockquote>
<ol>
<li><p>下载dayjs组件库，并引入到路由处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载 dayjs 组件库</span></span><br><span class="line">npm install dayjs --save</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进行引用</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&#x27;dayjs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理data<br>我们可以通过forEach遍历，并打印出每一项的数据（需要把对象的键值对包装成数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entries()方法 把对象中的 每个键值对 包装成一对数组 最后返回一个数组</span></span><br><span class="line"><span class="comment">// 返回如[ [key1,value,],[key2,value2] ,.. ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(userInfo).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] == <span class="string">&#x27;date&#x27;</span>)&#123;</span><br><span class="line">        item[<span class="number">1</span>] = <span class="title function_">dayjs</span>(item[<span class="number">1</span>]).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>date数据处理完毕</p>
</li>
</ol>
<h2 id="将数据保存到文件中"><a href="#将数据保存到文件中" class="headerlink" title="将数据保存到文件中"></a>将数据保存到文件中</h2><ol>
<li><p>导入fs文件处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>向form.txt文件中追加每一项数据,不需要我们手动去创建txt文件，如果没有会自动创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的路径，是以执行的文件为基准的,这里是暴露出去的函数，是在路由里面执行的</span></span><br><span class="line"><span class="comment">// 而路由是注册在app.js文件的，所以以app.js为基准</span></span><br><span class="line"><span class="comment">//这里是追加内容的函数，和写入函数writeFile使用一样，如果该文件不存在则会创建该文件</span></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./form.txt&#x27;</span>,data, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就成功向form.txt文件写入数据了，但是数据是没有换行的</p>
</li>
<li><p>写入数据换行 – 换行符常量 <code>os.EOL</code><br>先引入os模块：<code>const os = require(&#39;os&#39;)</code><br>然后修改追加的data数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里插入数据依旧插入的英文名称，没有进行更改对应中文处理</span></span><br><span class="line"><span class="keyword">let</span> data = item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>] + os.<span class="property">EOL</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;<span class="comment">// 每一次插入前，都多空上一行 和加上一行分隔符</span></span><br><span class="line">    data = os.<span class="property">EOL</span> + <span class="string">&quot;####预约申请表####&quot;</span> + os.<span class="property">EOL</span> + data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="增加msg路由模块"><a href="#增加msg路由模块" class="headerlink" title="增加msg路由模块"></a>增加msg路由模块</h2><blockquote>
<p>比form路由简单些，不需要进行太多数据验证，只需要保证数据不为空就行</p>
</blockquote>
<p>这里直接贴出代码</p>
<ul>
<li><p>路由模块 msg.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入express模块，并创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> msgRouter = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由处理模块</span></span><br><span class="line"><span class="keyword">const</span> msg_hander = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入数据校验模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; msg_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msgRouter.<span class="title function_">post</span>(<span class="string">&#x27;/msg&#x27;</span>,<span class="title function_">expressJoi</span>(msg_schema),msg_hander.<span class="property">msgSubmit</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = msgRouter</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msgSubmit</span> = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = req.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">&#x27;####留言####&#x27;</span> + os.<span class="property">EOL</span> + msg.<span class="property">msg</span> + os.<span class="property">EOL</span> + os.<span class="property">EOL</span>;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./msg.txt&#x27;</span>,data,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送留言数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据校验模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>);</span><br><span class="line"><span class="comment">// 校验规则 msg不少于10个字符，且是必填项</span></span><br><span class="line"><span class="keyword">const</span> msg = joi.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">10</span>).required();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msg_schema</span> = &#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        msg,<span class="comment">//注意必须写在body属性中，因为数据在req.body中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：记得要在app.js主程序页面配置路由<code>app.use(msgRouter)</code></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/tsukimiya.github.io/default-index/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/tsukimiya.github.io/default-index/">1</a><a class="page-number" href="/tsukimiya.github.io/default-index/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ayu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">167k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:32</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/comments.js"></script><script src="/tsukimiya.github.io/js/utils.js"></script><script src="/tsukimiya.github.io/js/motion.js"></script><script src="/tsukimiya.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"Leave Something, message or money"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/tieba"],"meta":["nick","mail","link"],"requiredMeta":["nick"],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/tsukimiya.github.io/default-index/page/3/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
