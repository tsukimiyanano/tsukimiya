<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/tsukimiya.github.io/images/Study.ico">
  <link rel="mask-icon" href="/tsukimiya.github.io/images/Study.ico" color="#222">

<link rel="stylesheet" href="/tsukimiya.github.io/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miniver:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tsukimiyanano.github.io","root":"/tsukimiya.github.io/","images":"/tsukimiya.github.io/images","scheme":"Pisces","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/tsukimiya.github.io/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/tsukimiya.github.io/js/config.js"></script>

    <meta name="description" content="你们怎么能这么卷！！">
<meta property="og:type" content="website">
<meta property="og:title" content="Ayu&#39;s Study Blog">
<meta property="og:url" content="https://tsukimiyanano.github.io/tsukimiya.github.io/default-index/index.html">
<meta property="og:site_name" content="Ayu&#39;s Study Blog">
<meta property="og:description" content="你们怎么能这么卷！！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ayu">
<meta property="article:tag" content="hexo,ayu,tsukimiya,前端,node.js,nodejs,blog,博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tsukimiyanano.github.io/tsukimiya.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ayu's Study Blog</title>
  







<link rel="dns-prefetch" href="https://waline.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/tsukimiya.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/tsukimiya.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ayu's Study Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">求求你给我一份工作吧，我什么都会做的`orz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/tsukimiya.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tsukimiya.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/tsukimiya.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/tsukimiya.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/tsukimiya.github.io/schedule/task.html" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-guestbook"><a href="/tsukimiya.github.io/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>guestbook</a></li><li class="menu-item menu-item-pulledpost"><a href="/tsukimiya.github.io/PulledPost/" rel="section"><i class="fa fa-heart fa-fw"></i>PulledPost</a></li><li class="menu-item menu-item-cuntom-page"><a href="/tsukimiya.github.io/custom" rel="section"><i class="fa fa-folder fa-fw"></i>Cuntom Page</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ayu"
      src="/tsukimiya.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ayu</p>
  <div class="site-description" itemprop="description">你们怎么能这么卷！！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/tsukimiya.github.io/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/tsukimiya.github.io/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tsukimiya.github.io/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:1832715838@qq.com" title="E-Mail → mailto:1832715838@qq.com" rel="noopener me" target="_blank">E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/05/02/Vue/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/05/02/Vue/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/" class="post-title-link" itemprop="url">路由(vue-router)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-02 15:42:11" itemprop="dateCreated datePublished" datetime="2024-05-02T15:42:11+08:00">2024-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-03 22:25:23" itemprop="dateModified" datetime="2024-05-03T22:25:23+08:00">2024-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/05/02/Vue/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/05/02/Vue/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/05/02/Vue/7.%E8%B7%AF%E7%94%B1%EF%BC%88vue-router%EF%BC%89/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标:<br>能够在项目中安装和配置路由<br>能够使用路由实现单页面应用程序的开发<br>能够使用导航守卫控制路由的访问权限</p>
</blockquote>
<h2 id="axios的使用"><a href="#axios的使用" class="headerlink" title="axios的使用"></a>axios的使用</h2><ol>
<li><p>首先安装axios包<br><code>npm i axios</code> ，结果报错<code>ERR! ERESOLVE could not resolve ERESOLVE could not resolve</code><br>解决办法是在后面加 <code>--legacy-peer-deps</code> 即可<br><code>npm install axios -save --legacy-peer-deps</code><br>报错的原因是由于npm不同版本库之间命令不兼容。</p>
</li>
<li><p>在left组件发送get请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;getInfo&quot;</span>&gt;发起<span class="title class_">Get</span>请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在right组件发送post请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;postInfo&quot;</span>&gt;发起 <span class="title class_">Post</span> 请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">postInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="考虑问题-–-优化"><a href="#考虑问题-–-优化" class="headerlink" title="考虑问题 – 优化"></a>考虑问题 – 优化</h3><ul>
<li><p>问题</p>
<ol>
<li>每个组件中，都可能会有发请求的需求，都需要先导入axios，然后调用这些方法，每次用都很麻烦</li>
<li>每次请求地址都需要写完整地址，但是我们的请求根路径都完全一样。如果将来后端把根路径改了，我们就需要修改每一个组件，不利于后期维护。</li>
</ol>
</li>
<li><p>思考<br>每一个.vue组件都相当于一个vue实例，我们可以理解为：每一个.vue组件都是new Vue()这个构造函数得到的</p>
</li>
<li><p>优化1 – <strong>在Vue的原型链上挂载一个axios</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 一般我们不叫axios，而是$http</span></span><br><span class="line"><span class="comment">// 因为vue内置的一些成员都是以$开头的(模仿内置成员)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span> = axios</span><br></pre></td></tr></table></figure>
<p>这样我们<strong>在每一个组件中</strong>，就不需要再导入axios，<strong>直接通过this&#x2F;原型访问</strong></p>
</li>
<li><p>优化2 – <strong>全局配置 axios 的请求根路径</strong><br>在往原型上挂之前，通过axios做一下局域的配置：<br><code>axios.defaults.baseURL = &#39;请求根路径&#39; // axios自带的属性</code><br>组件使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点<br><strong>无法实现api接口的复用</strong>：如果这个api在多个页面都需要被用到，每一次都需要重新调这个api接口</p>
</li>
</ul>
<h2 id="路由的基本配置与使用"><a href="#路由的基本配置与使用" class="headerlink" title="路由的基本配置与使用"></a>路由的基本配置与使用</h2><ol>
<li><p>什么是路由<br>路由(router) 就是 <strong>对应关系</strong></p>
</li>
<li><p>SPA(单页面应用程序) 与 前端路由<br>SPA指的是一个web网站只有唯一的一个HTML页面，<strong>所有组件的展示与切换</strong>都在这唯一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</li>
<li><p>什么是前端路由<br>通俗易懂的概念：<strong>Hash地址</strong>(就是#锚链接) 与 <strong>组件</strong> 之间的 <strong>对应关系</strong><br>不同的哈希，会展示出不同的组件页面</p>
</li>
<li><p><strong>前端路由的工作方式</strong></p>
<ol>
<li>用户点击了页面上的路由链接</li>
<li>导致了URL地址栏中的Hash值发生了变化</li>
<li>前端路由监听了到Hash地址的变化</li>
<li>前端路由把当前Hash地址对应的组件渲染都浏览器中</li>
</ol>
<p> <font color="green">结论：前端路由，指的是 Hash地址 与 组件之间 的 对应关系</font><br> <img src="/tsukimiya.github.io/images/vue/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.png" alt="img"></p>
</li>
</ol>
<h3 id="vue-router的基本使用"><a href="#vue-router的基本使用" class="headerlink" title="vue-router的基本使用"></a>vue-router的基本使用</h3><blockquote>
<p>前端路由的底层原理是监听了浏览器的onhashchange事件，自己去封装前端路由是非常麻烦的一件事，我们可以用现成的包去实现前端路由的处理 – vue-router(vue项目中的一个路由的包，只能在vue项目中用)</p>
</blockquote>
<ol>
<li><p>什么是vue-router<br><strong>vue-router</strong>是vue.js官方给出的<strong>路由解决方案</strong>。它只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换。<br>vue-router 的官方文档地址: <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p>
</li>
<li><p><strong>vue-router 安装和配置的步骤</strong></p>
<ol>
<li><p>安装vue-router包：<code>npm i vue-router@3.5.2 -S</code><br>   如果因为ESLint安装报错，可以加上后缀：<code>npm i vue-router@3.5.2 -S --legacy-peer-deps</code><br>   vue-router最新版本Vue Router 4 是为 Vue 3 设计的，不兼容Vue2。<br>   所以想在 Vue 2 中使用 Vue Router，安装包的时候需要指定 Vue Router 3 的版本</p>
</li>
<li><p>创建路由模块<br>   在src源代码目录下，新建router&#x2F;index.js路由模块，并初始化如下代码：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js 就是当前项目的路由模块</span></span><br><span class="line"><span class="comment">// 1. 导入 Vue 和 VueRouter 的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外共享路由的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入并挂载路由模块</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入路由模块，目的：拿到路由的实例对象</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="comment">// 在 Vue 项目中，要想把路由用起来，必须把路由实例对象，通过下面的方式进行挂载</span></span><br><span class="line">  <span class="comment">// router：路由的实例对象</span></span><br><span class="line">  router <span class="comment">// 这里是简写</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 导入路由的时候，index.js可以省略 – <code>import router from &#39;@/router&#39;</code><br> <font color="green">在模块化导入的时候，如果只给了一层路径，默认会导入和加载路径下面名字叫index.js的文件</font></p>
</li>
<li><p>声明路由链接和占位符&#x2F;<strong>声明路由的对应关系(路由规则)</strong><br> 声明占位符：<br> <font color="red">App.vue甚至不需要导入组件，只需要声明一个占位符即可，通过a链接切换对应的组件</font></p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/left&quot;</span>&gt;</span>left <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/right&quot;</span>&gt;</span> right<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只要在项目中安装和配置了 vue-router，则就可以使用 router-view 这个组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 作用：占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在路由模块声明路由的对应关系 – <strong>路由规则</strong>：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Left</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Left-item.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Right</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Right-item.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用router-link代替a链接<br>   router-link本质上也会被渲染成a链接</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当安装和配置了 vue-router 后，就可以使用 router-link来替代普通的a链接 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 优势：不用写前面的#，它会在点这个router-link的时候自动在前面加上# --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="路由重定向-–-redirect"><a href="#路由重定向-–-redirect" class="headerlink" title="路由重定向 – redirect"></a>路由重定向 – redirect</h2><p><strong>路由重定向</strong>指的是:用户在访问<strong>地址A</strong>的时候，<strong>强制用户跳转</strong>到地址C，从而展示特定的组件页面。通过路由规则的<strong>redirect</strong>属性，指定一个新的路由地址，可以很方便地设置路由的重定向:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 在routers数组中，声明路由的匹配规则</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span>&#125;, </span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Right</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>通过路由实现<strong>组件的嵌套展示</strong>，叫做嵌套路由。</p>
<p>如果某个组件本身就是通过路由的方式呈现出来的，在这个组件里又放一些路由规则，这样就形成了路由嵌套。<br><img src="/tsukimiya.github.io/images/vue/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1.png" alt="img"></p>
<ul>
<li><p>声明子级路由标签和占位符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Right.vue</span><br><span class="line"><span class="comment">&lt;!-- 子级路由链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/right/tab2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 子级路由占位符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明嵌套路由的规则 – 路由对应关系</strong><br>通过<strong>Children</strong>属性声明<strong>子路由规则</strong><br>在src&#x2F;router&#x2F;index.js路由模块中，导入需要的组件，并通过children属性声明子路由规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tab1</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab2</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tab2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// routes 是一个数组，作用：定义 “hash 地址” 与 “组件”之间的对应关系</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">      <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">        &#123; <span class="attr">path</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：子路由规则，不要以斜线开头！</font></p>
</li>
<li><p>嵌套路由的路由重定向<br>在right的路由规则中加上redirect即可，这样路径&#x2F;right就直接跳转到了&#x2F;right&#x2F;tab2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 当用户访问 / 的时候，通过 redirect 属性跳转到 /left 对应的路由规则</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/left&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/left&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Left</span> &#125;,</span><br><span class="line">  &#123; <span class="comment">// right页面的路由规则(父级路由规则)</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/right&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Right</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/right/tab2&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [ <span class="comment">// 通过children属性，嵌套声明子级路由规则</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab1</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;tab2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Tab2</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认子路由</strong><br>除了使用redirect路由重定向，还可以使用默认子路由<br>默认子路由：如果children数组中，某个路由规则的path值为空字符串，则这条路由规则，叫做“默认子路由”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // right页面的路由规则(父级路由规则)</span><br><span class="line">  path: &#x27;/right&#x27;,</span><br><span class="line">  component: Right,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; path: &#x27;&#x27;, component: Tab1 &#125;,</span><br><span class="line">    &#123; path: &#x27;tab1&#x27;, component: Tab1 &#125;,//也可以不写这条规则，而是把tab1的路由标签改为/right</span><br><span class="line">    &#123; path: &#x27;tab2&#x27;, component: Tab2 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认子路由和重定向都可以展示出children里面的某一个子组件。</strong></p>
</li>
</ul>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>思考：有如下3个路由链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义如下3个路由规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br><span class="line">&#123;<span class="attr">path</span>: <span class="string">&#x27;/movie/3&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：路由规则的复用性差</strong></p>
<ol>
<li><p>动态路由的概念<br>动态路由指的是:把 Hash地址 中<strong>可变的部分</strong>定义为<strong>参数项</strong>，从而<strong>提高路由规则的复用性</strong>。<br>在vue-router中使用<strong>英文的冒号</strong>( <strong>:</strong> )来定义路由的参数项。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由中的动态参数以︰进行声明，冒号后面的是动态参数的名称</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>将多个路由规则，合并成了一个，提高了路由规则的复用性</strong><br><font color="red">注意：路由链接的跳转地址是不能出现冒号<code>:</code>的！<code>&lt;router-link to=&quot;/movie/1&quot;&gt;电影1&lt;/router-link&gt;</code></font></p>
</li>
<li><p>在组件中拿到动态参数项的值<br>  <code>this.$route</code>是路由的<strong>“参数对象”</strong><br>  <code>this.$router</code>是路由的<strong>“导航对象”</strong><br>  要想拿到上面movie的id值应该通过：<code>this.$route.params.id</code></p>
</li>
</ol>
<h3 id="为路由规则开启prop传参"><a href="#为路由规则开启prop传参" class="headerlink" title="为路由规则开启prop传参"></a>为路由规则开启prop传参</h3><p>简化拿参数的方式。这种方式和<code>this.$route.params.id</code>是彼此独立的，想用哪个就用哪个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="comment">// 为当前这条路由规则开启props传参</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// movie.vue</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>] <span class="comment">// 这样就拿到了</span></span><br></pre></td></tr></table></figure>

<h3 id="拓展-query-和-fullPath"><a href="#拓展-query-和-fullPath" class="headerlink" title="拓展 query 和 fullPath"></a>拓展 query 和 fullPath</h3><ol>
<li><p>在 hash 地址中，&#x2F; 后面的参数项，叫做 “路径参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.params</code> 来访问路径参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 hash 地址中，？后面的参数项，叫做 “查询参数”<br>在路由“参数对象”中，需要使用 <code>this.$route.query</code> 来访问查询参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/1&quot;</span>&gt;</span>电影1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie/2?name=zs age=20&quot;</span>&gt;</span>电影2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>this.$route</code>中，path只是路径部分; fullPath是完整的地址<br>  <code>/movie/2</code> 是 path 的值<br>  <code>/movie/2?name=zs age=20</code> 是 fullPath 的值</p>
</li>
</ol>
<h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><p>导航就是跳转的意思，组件之间的切换，它专业的术语叫导航。</p>
<h3 id="声明式导航-编程式导航"><a href="#声明式导航-编程式导航" class="headerlink" title="声明式导航 &amp; 编程式导航"></a>声明式导航 &amp; 编程式导航</h3><ul>
<li><p>在浏览器中，<strong>点击链接</strong>实现导航的方式，叫做<strong>声明式导航</strong>。<br>例如：<br>普通网页中点击a链接、vue 项目中点击router-link都属于声明式导航</p>
</li>
<li><p>在浏览器中，<strong>调用API方法</strong>实现导航的方式，叫做<strong>编程式导航</strong>。<br>例如<br>普通网页中调用<code>location.href</code>跳转到新页面的方式，属于编程式导航</p>
</li>
</ul>
<h4 id="vue-router-中的编程式导航API"><a href="#vue-router-中的编程式导航API" class="headerlink" title="vue-router 中的编程式导航API"></a>vue-router 中的编程式导航API</h4><p>vue-router(导航对象)提供了许多编程式导航的API，其中最常用的导航API分别是:</p>
<ol>
<li><p><code>this.$router.push(&#39;hash地址&#39;)</code><br>  跳转到指定 hash 地址，并<strong>增加</strong>一条历史记录</p>
</li>
<li><p><code>this.$router.replace(&#39;hash地址&#39;)</code><br>  跳转到指定的hash地址，并<strong>替换掉当前的</strong>历史记录</p>
</li>
<li><p><code>this.$router.go(数值n)</code><br>  n可以是正数也可以是负数，在浏览历史里面进行<strong>前进和后退</strong></p>
</li>
<li><p><code>$router.go</code>的简化用法<br>在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法:<br>  (1) <code>$router.back()</code>：在历史记录中，<strong>后退</strong>到上一个页面<br>  (2) <code>$router.forward()</code>：在历史记录中，<strong>前进</strong>到下一个页面</p>
</li>
</ol>
<p><font color="red">注意：在行内使用编程式导航跳转的时候，this必须要省略，否则会报错！</font></p>
<h3 id="路由导航守卫-–-控制路由的访问权限"><a href="#路由导航守卫-–-控制路由的访问权限" class="headerlink" title="路由导航守卫 – 控制路由的访问权限"></a>路由导航守卫 – 控制路由的访问权限</h3><p><strong>导航守卫</strong>可以<strong>控制路由的访问权限</strong>。</p>
<p>假设规定，当前项目中，main这个后台主页只有登陆以后才允许被访问(前提)<br>怎么证明你有没有登陆————token<br>可以读你的localStorage，看里面有没有token值，如果有就认为你已经是登录了，没有就认为你没有登陆。</p>
<p><img src="/tsukimiya.github.io/images/vue/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB.png" alt="img"></p>
<ol>
<li><p>全局前置守卫<br>  前置：比如从a跳到b，还没跳过去，就会触发守卫。<br>  每次发生路由的<strong>导航跳转</strong>时，都会触发<strong>全局前置守卫</strong>。因此，在全局前置守卫中，程序员可以<strong>对每个路由进行访问权限的控制</strong>:</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"><span class="comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫”</span></span><br><span class="line"><span class="comment">//每次发生路由导航跳转的时候，都会自动触发 fn 这个“回调函数”</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(fn)</span><br></pre></td></tr></table></figure>
</li>
<li><p>守卫方法的3个形参<br>  全局前置守卫的回调函数中接收3个形参，格式为:</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局前置守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ro 是将要访问的路由的信息对象</span></span><br><span class="line">  <span class="comment">// from 是将要离开的路由的信息对象</span></span><br><span class="line">  <span class="comment">// next 是一个函数，调用next() 表示放行，允许这次路由导航</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>next函数的3种调用方式<br>具体使用哪一种，看自己的需求<br><img src="/tsukimiya.github.io/images/vue/next%E5%87%BD%E6%95%B0%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="img"></p>
</li>
</ol>
<ul>
<li>全局前置守卫控制访问权限简单示例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为router实例对象，声明全局前置导航守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 分析：</span></span><br><span class="line">  <span class="comment">// 1. 要拿到用户将要访问的hash地址 </span></span><br><span class="line">  <span class="comment">// 2. 判断hash地址是否等于/main</span></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; <span class="comment">// 等于 /main ，证明需要登陆之后才能访问成功，</span></span><br><span class="line">    <span class="comment">// 需要读取 localStorage 中的 token值</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() <span class="comment">// 有token值，则已登录 放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 无 token值 则强制跳转到login登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不等于则访问的不是后台主页,不需要登陆 直接放行 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
vue的导航守卫中除了全局前置守卫之外，还有全局解析守卫、全局后置钩子、路由独享的守卫、组件内的守卫，共5种<br>其中，<strong>全局前置守卫的用法是最常见的</strong>，后面的几种后续会进行补充</li>
</ul>
<h2 id="案例练习"><a href="#案例练习" class="headerlink" title="案例练习"></a>案例练习</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?t=87.0&p=193">路由应用案例</a><blockquote>
<p>后台管理案例</p>
</blockquote>
</li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=204">黑马头条</a><blockquote>
<p>SPA单页面应用程序 移动端 简单案例<br>  实现下拉刷新、上拉加载更多功能、Vant组件库的使用</p>
</blockquote>
</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="hash地址注意点"><a href="#hash地址注意点" class="headerlink" title="hash地址注意点"></a>hash地址注意点</h3><p>hash地址里面字母都要是小写，<font color="red">url地址里面不要出现大写字符或字母</font>。<br>除非是一些 搜索关键字 可以出现大写</p>
<h3 id="有权限的hash地址"><a href="#有权限的hash地址" class="headerlink" title="有权限的hash地址"></a>有权限的hash地址</h3><p>在导航守卫 – 全局前置守卫中<br>这个if是判断我们访问的是否是一个有权限的hash地址：<code>if (to.path === &#39;/main&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="title function_">next</span>() </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">next</span>() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们项目中有多个页面，都需要访问权限，这一个判断肯定满足不了我们的需求<br>我们可以在后面加 或 <code>|</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home&#x27;</span> || to.<span class="property">path</span> === <span class="string">&#x27;/home/users&#x27;</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是条件会变的越来越长</p>
<p>我们还可以通过数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathArr = [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> (pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>后面有任何的地址，都可以放到数组里面去<br>如果觉得多了以后，数组也会变的特别长，可以把这个数组单独处理为js文件，需要的时候再导入过来。如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/router/pathArr.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [<span class="string">&#x27;home&#x27;</span>,<span class="string">&#x27;/home/users&#x27;</span>,<span class="string">&#x27;/home/rights&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/router/index.js</span></span><br><span class="line"><span class="keyword">import</span> pathArr <span class="keyword">from</span> <span class="string">&#x27;@/router/pathArr.js&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//不需再声明</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">function</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(pathArr.<span class="title function_">indexOf</span>(to.<span class="property">path</span>)!=-<span class="number">1</span>)&#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用meta属性进行权限处理"><a href="#使用meta属性进行权限处理" class="headerlink" title="使用meta属性进行权限处理"></a><font color="green">使用meta属性进行权限处理</font></h3><p><font color="red">可以配置meta属性，使用前置守卫进行判断是否需要进行权限处理，会方便很多</font></p>
<ol>
<li><p>配置 <code>meta</code> 属性<br>  在路由配置中，可以在每个路由的 <code>meta</code> 属性中指定需要进行权限处理的信息。例如:</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Admin</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">requiresAuth</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] <span class="comment">// 用于指定可以访问特定路由的用户的角色</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他路由...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>/admin</code> 路由需要进行权限处理，只有具有 <code>admin</code> 角色的用户才能访问。</p>
</li>
<li><p>使用前置守卫<br>  在 Vue Router 中，使用 <code>beforeEach</code> 前置守卫来拦截导航并执行权限检查：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span>) &#123;<span class="comment">// 检查是否需要进行权限处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isAuthenticated</span>()) &#123;<span class="comment">// 检查用户是否已登录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasRequiredRoles</span>(to.<span class="property">meta</span>.<span class="property">roles</span>))&#123; <span class="comment">// 检查用户是否具有所需的权限</span></span><br><span class="line">          <span class="title function_">next</span>()<span class="comment">// 允许导航</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">&#x27;/no-access&#x27;</span>) <span class="comment">// 无权限，重定向到无权限页面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)<span class="comment">// 未登录，重定向到登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">// 不需要权限处理，允许导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  其中，isAuthenticated() 和 hasRequiredRoles() 是自定义函数，用于检查用户是否已登录以及是否具有所需的权限。</p>
</li>
</ol>
<ul>
<li><p><strong>isAuthenticated()函数 ：用于检查用户是否已登录</strong><br><strong>通常用于判断用户是否携带有效的 token</strong>。<br>实际应用中，可以根据自己的后端 API 设计来实现 isAuthenticated() 函数：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的 token。</li>
<li>向后端 API 发送一个请求，携带用户的 token。</li>
<li>后端 API 验证 token 的有效性。</li>
<li>如果 token 有效，后端 API 返回成功响应。</li>
<li>isAuthenticated() 函数返回 true，表示用户已登录。</li>
<li>否则，isAuthenticated() 函数返回 false，表示用户未登录或 token 无效。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isAuthenticated</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取 token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;<span class="comment">// 如果 token 存在，向后端 API 发送请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/verify-token&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;  <span class="comment">// &#x27;data&#x27; 是一个 JavaScript 对象，包含从服务器接收到的 JSON 数据</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果 token 有效，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 无效，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 token 不存在，返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>.then(res =&gt; res.json())</code> 是 JavaScript Promise 链中的一个回调函数。<br>作用: 将服务器返回的 HTTP 响应对象 (res)————服务器响应的主体部分（JSON 字符串） 转换为一个纯 JavaScript 对象，并将其传递给下一个 .then() 回调函数。<br>注意：<br>只有当服务器响应的 Content-Type 头部设置为 <code>application/json</code> 时，<code>res.json()</code> 方法才能正常工作。<br>如果服务器响应的主体部分不是有效的 JSON 字符串，<code>res.json()</code> 方法会抛出一个错误。</li>
</ol>
</li>
<li><p><strong>hasRequiredRoles() 函数用于检查用户是否具有访问特定路由所需的权限。</strong><br>它的实现方式取决于你的具体应用程序和后端 API 设计。<br>一种常见的方法：</p>
<ol>
<li>从本地存储（如 localStorage 或 sessionStorage）中获取用户的角色。</li>
<li>将用户的角色与路由配置中指定的所需角色进行比较。</li>
<li>如果用户具有所有必需的角色，则返回 true，表示用户具有访问权限。</li>
<li>否则，返回 false，表示用户没有访问权限。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userRoles = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;roles&#x27;</span>)<span class="comment">// 从本地存储中获取用户的角色</span></span><br><span class="line">  <span class="comment">// 将用户的角色与所需的权限进行比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; requiredRoles.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!userRoles.<span class="title function_">includes</span>(requiredRoles[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果用户具有所有必需的角色，返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>另一种方法：<br>向后端 API 发送一个请求，携带用户的 token 和路由的所需角色。后端 API 检查用户的权限并返回一个响应，指示用户是否具有访问权限。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasRequiredRoles</span>(<span class="params">requiredRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)<span class="comment">// 从本地存储中获取用户的 token</span></span><br><span class="line">  <span class="comment">// 向后端 API 发送请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/auth/check-permissions&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">requiredRoles</span>: requiredRoles</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">success</span>) &#123;<span class="comment">// 如果用户具有访问权限，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果用户没有访问权限，返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果请求失败，返回 false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/05/01/Vue/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&%E6%8F%92%E6%A7%BD&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/05/01/Vue/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&%E6%8F%92%E6%A7%BD&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">vue组件高级用法 - 动态组件&插槽&自定义指令&ESlint</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-01 10:01:07" itemprop="dateCreated datePublished" datetime="2024-05-01T10:01:07+08:00">2024-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-02 15:15:37" itemprop="dateModified" datetime="2024-05-02T15:15:37+08:00">2024-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/05/01/Vue/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&%E6%8F%92%E6%A7%BD&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/05/01/Vue/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&%E6%8F%92%E6%A7%BD&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/05/01/Vue/6.vue%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&%E6%8F%92%E6%A7%BD&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标:<br>能够使用keep-alive实现组件的缓存<br>能够使用插槽提高组件的复用性<br>能够了解常见的ESLint语法规则</p>
</blockquote>
<h2 id="动态组件的使用"><a href="#动态组件的使用" class="headerlink" title="动态组件的使用"></a>动态组件的使用</h2><p>动态组件指的是<strong>动态切换组件的显示与隐藏</strong>。实现不同组件的按需展示。</p>
<ol>
<li><p>如何实现动态组件的渲染<br> vue提供了一个内置的<code>component</code>组件，作用：组件的占位符。专门用来实现动态组件的渲染。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1．当前要渲染的组件名称</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">comName</span>: <span class="string">&#x27;Left&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;! -- <span class="number">2</span>．通过is属性，动态指定要渲染的组件--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>．点击按钮，动态切换组件的名称 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Left&#x27;&quot;</span>&gt;</span>展示 Left 组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;comName = &#x27;Right&#x27;&quot;</span>&gt;</span>展示 Right组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内置标签keep-alive – 保持组件的状态</strong><br>每次切换组件都是上一个组件被销毁和下一个组件被创建-&gt;运行<br>如果再次创建同一个组件，它会重新初始化一遍数据，和上一个组件是没有关系的<br> 如果我们希望切换回来之后原来的数据状态还在，就可以使用<font color="red">keep-alive：防止组件被隐藏的时候被销毁</font></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 这样隐藏Left的时候不会移除这个组件，而是打上一个inactive标记(被缓存了)（未使用的、不活动的）<br> <font color="green">总结：keep-alive可以把内部的组件进行缓存，而不是销毁组件</font></p>
</li>
<li><p><strong>keep-alive 对应的生命周期函数</strong><br> 当组件<strong>被缓存</strong>时，会自动触发组件的<strong>deactivated</strong>生命周期函数。<br> 当组件<strong>被激活</strong>时，会自动触发组件的<strong>activated</strong>生命周期函数。</p>
</li>
<li><p><strong>keep-alive的include属性 – 指定哪些组件可以被缓存</strong><br> 只有名称匹配的组件会被缓存</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;Left,Right&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p> 除了include，还有个exclude属性，表示排除项<br> 注意：这两个属性不能同时使用</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="了解组件-注册名称-和-组件声明时name-的区别"><a href="#了解组件-注册名称-和-组件声明时name-的区别" class="headerlink" title="了解组件 注册名称 和 组件声明时name 的区别"></a>了解组件 注册名称 和 组件声明时name 的区别</h2><p>如果在声明组件(定义组件模板结构)的时候，没有为组件指定 name 名称，则组件的名称默认就是“注册时候的名称”。当提供了name属性之后，组件的名称就是name属性的值。</p>
<ul>
<li><strong>对比</strong>(3、4 is my think):</li>
</ul>
<ol>
<li>组件的“<strong>注册名称</strong>”的主要应用场景是: 以<strong>标签</strong>的形式，把注册好的组件，渲染和使用到页面结构之中</li>
<li>组件声明时候的“<strong>name</strong>”名称的主要应用场景: <strong>结合keep-alive标签实现组件缓存功能</strong>;以及在<strong>调试工具</strong>中看到组件的 name <strong>名称</strong></li>
<li>一般情况下，注册名称可以将name属性完全替代，不去注册name属性</li>
<li><strong>name属性的独特应用场景：递归组件</strong>。指在组件的模板中，使用该组件自身的情况。(这样场景下，注册名称是替代不了name属性的)</li>
</ol>
<p>开发中，为了标准、方便，<strong>建议给每个组件起一个name名称</strong>。(虽然我还是不理解除了4的情况有什么必要)</p>
<h2 id="插槽的使用-默认插槽、具名插槽、作用域插槽"><a href="#插槽的使用-默认插槽、具名插槽、作用域插槽" class="headerlink" title="插槽的使用(默认插槽、具名插槽、作用域插槽)"></a>插槽的使用(默认插槽、具名插槽、作用域插槽)</h2><p><strong>插槽</strong>（Slot）是vue为<strong>组件的封装者</strong>提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。</p>
<p><font color="red">在组件的内容节点填写内容，然后把它给渲染出来</font><br><img src="/tsukimiya.github.io/images/vue/%E6%8F%92%E6%A7%BD.png" alt="img"></p>
<h3 id="v-slot指令-–-简写："><a href="#v-slot指令-–-简写：" class="headerlink" title="v-slot指令  – 简写：#"></a>v-slot指令  – 简写：#</h3><p><strong>vue官方规定：每一个 slot 插槽，都要有一个 name 名称</strong><br>如果省略了 slot 的 name 属性，则有一个<strong>默认名称</strong>叫做 <strong>default</strong></p>
<p>默认情况下，在使用组件的时候，提供的内容都会被填充到名字为default的插槽中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有一个插槽的话，name不写也可以</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color="green">如果要把内容填充到指定名称的插槽中，需要使用<code>v-slot：</code>这个指令</font><font color="red"> – 简写：#</font><br><font color="red">注意：v-slot指令，只能被用在 组件components 或 template标签</font><br>template是个虚拟的标签，只起到一个包裹性的作用，不会被渲染成任何真实的元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    //或</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="插槽的默认内容-后备内容"><a href="#插槽的默认内容-后备内容" class="headerlink" title="插槽的默认内容&#x2F;后备内容"></a>插槽的默认内容&#x2F;后备内容</h3><p>官方的专业术语：后备内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// left组件</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>带有名字的插槽就叫做具名插槽。</p>
<p>它也是一个具名插槽，或者叫默认插槽</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>在预留插槽的时候，声明数据项。在使用的时候可以接收数据并使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Left</span><br><span class="line"><span class="comment">&lt;!-- 在封装组件的时候，为预留的slot提供属性对应的值，这种用法叫做“作用域插槽” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;hello vue.js&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是default插槽的默认内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果插槽没有声明数据项，则形参scope是个空对象<br><font color="green">接收数据的形参建议用 scope(作用域) 来命名</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// app.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; scope.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽的解构赋值"><a href="#作用域插槽的解构赋值" class="headerlink" title="作用域插槽的解构赋值"></a>作用域插槽的解构赋值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二个p标签 -- &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote>
<p>vue允许开发者自定义指令</p>
</blockquote>
<p>vue中的自定义指令分为两类，分别是:</p>
<ul>
<li>私有自定义指令</li>
<li>全局自定义指令</li>
</ul>
<h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>在每个vue 组件中，可以在 <strong>directives节点</strong>下声明<strong>私有自定义指令</strong>。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="comment">//为绑定到的 HTML 元素设置红色的文字</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el</span>)&#123; </span><br><span class="line">            <span class="comment">// 形参中的 el是绑定了此指令的、原生的DOM对象(固定的写法)</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当指令第一次被绑定到元素上的时候，会立即触发bind方法</span></span><br><span class="line">&lt;<span class="title class_">Left</span> v-color&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>binding.value</code>获取指令绑定的值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//官方推荐用binding</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Left</span> v-color=<span class="string">&quot;&#x27;green&#x27;&quot;</span>&gt;&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>update函数</strong><br><strong>bind</strong>函数<strong>只调用1次</strong>：当指令<strong>第一次绑定到元素时</strong>调用；当DOM更新时bind函数不会被触发。<br><strong>update</strong>函数会在<strong>每次DOM更新时被调用</strong>，绑定的时候不会触发：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//每次DOM更新时被调用，绑定的时候不会触发</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">          el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-color=<span class="string">&quot;color&quot;</span>&gt;<span class="variable constant_">APP</span>根组件&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;color=&#x27;red&#x27;&quot;</span>&gt;</span>变成红色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数简写形式</strong><br>如果 bind 和 update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 bind 和 update 时，会触发相同的业务逻辑</span></span><br><span class="line">    <span class="title function_">color</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>和定义过滤器filter一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1: 字符串，表示全局自定义指令的名字</span></span><br><span class="line"><span class="comment">// 参数2: 对象，用来接收指令的参数值</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,<span class="keyword">function</span>(<span class="params">el,binding</span>)&#123; <span class="comment">//简写形式</span></span><br><span class="line">    el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象形式：</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>,&#123; <span class="comment">//简写形式</span></span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123; </span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ESLint工具"><a href="#ESLint工具" class="headerlink" title="ESLint工具"></a>ESLint工具</h2><p>可组装的JS和JSX检查工具 – 约束代码风格<br>在你的js代码里面 帮你发现问题，并且解决问题</p>
<p>两个中文官网 <a target="_blank" rel="noopener" href="https://nodejs.cn/eslint/">官网1</a> <a target="_blank" rel="noopener" href="https://eslint.nodejs.cn/docs/latest/">官网2</a></p>
<p>当在项目里面配置了ESLint以后，它就会去检查代码风格，有问题就会报错</p>
<ul>
<li><p>vscode 设置<br>缩进：设置 -  搜索 Editor:Tab Size 设置为2<br>保存：设置 - 文本编辑器 - 格式化 - Format on Save(保存时格式化文件) </p>
</li>
<li><p>使用ESLint – 创建新的vue项目<br>在选择预设的时候，加上一个Linter &#x2F; Formatter(默认被选上的)<br>然后后面的选项中就多了一项：选择要安装的ESLint的语法规范<br>选择倒数第二项 – Standard config 标准配置<br>然后选择：<br>Lint on save（ctrl s保存的时候进行检查）<br>Lint and fix on commit（提交代码的时候进行代码规范的检查，并且把检查到的问题自动修复）<br>只勾选第一项默认的就行，第二项不建议勾选。</p>
</li>
<li><p>ESLint配置文件 eslintrc.js<br>这里是定义的一些规则：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">//固定格式 只在发布阶段会报一个黄色警告，开发阶段不会</span></span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们可以去 <a target="_blank" rel="noopener" href="https://eslint.nodejs.cn/">官网</a> 的开发文档的规则参考部分来查看这些规则的作用：<br>  no-console 禁止使用console，no-debugger 禁止使用debugger</p>
</li>
</ul>
<h3 id="ESLint-规则"><a href="#ESLint-规则" class="headerlink" title="ESLint 规则"></a>ESLint 规则</h3><p>不符合规则会报对应的错误，以及错误所在的行列数<br>具体报错规则可以去 <a target="_blank" rel="noopener" href="https://nodejs.cn/eslint/">ESLint 中文文档</a> 直接搜索</p>
<ol>
<li>不能出现连续的空行</li>
<li>在文件的末尾必须要有空行</li>
<li>不能有多余的空格</li>
<li>字符串要用单引号</li>
<li>对象和属性之间，需要有一个空格分隔</li>
<li>要求或禁止末尾逗号</li>
<li>在注释中的 <code>//</code> 或 <code>/*</code> 后强制使用一致的间距<blockquote>
<p>&#x2F;&#x2F; 这里是正确注释，<code>//</code>后最少要有一个空格</p>
</blockquote>
</li>
<li>强制一致的缩进（该缩进的要缩进，不该缩进的不能缩进）</li>
<li><code>import</code>导入模块的语句必须声明在文件的顶部</li>
<li>定义变量而没有使用会报错</li>
<li>方法的形参之前需要保留一个空格<blockquote>
<p>show () {} 括号前后都要有一个空格</p>
</blockquote>
</li>
</ol>
<h3 id="禁用某规则"><a href="#禁用某规则" class="headerlink" title="禁用某规则"></a>禁用某规则</h3><p>如果不想遵守某个规则，和ESLint反着来，可以禁止这个规则<br>在官方文档中，找到这个规则，会说明如何更改，直接复制想要更改的规则呢么的代码即可<br>配置如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="comment">// 在方法的形参 () 之前，是否必须有空格</span></span><br><span class="line">    <span class="comment">// always代表需要这个空格，不满足这个规则会报一个warn警告</span></span><br><span class="line">    <span class="string">&quot;space-before-function-paren&quot;</span>: [<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;always&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：只要修改了配置文件，都需要重启服务器</p>
<h3 id="配置VSCode"><a href="#配置VSCode" class="headerlink" title="配置VSCode"></a>配置VSCode</h3><p>我们不能保证写的代码完全符合ESLint的要求，所以可以装一些插件，在保存文件的时候自动对文件进行格式化。</p>
<ul>
<li><p>ESLint插件<br>装过之后需要再配置文件中加一下配置项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 -- settingsjson</span></span><br><span class="line"><span class="comment">// ESLint 插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 老师是这样的</span></span><br><span class="line">    <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 搜的一个是这样</span></span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prettier - Code formatter 插件<br>在<code>C:\Users\lenovo</code>目录下新建<code>.prettierrc</code>配置文件<br>填入 <code>&#123;&quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;printWidth&quot;: 300&#125;</code><br>然后在vscode设置 – settings.json里面添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\lenovo\\.prettierrc&quot;</span>,</span><br><span class="line"><span class="string">&quot;eslint.alwaysShowStatus&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"><span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 每行文字个数超过此限制将会被迫换行</span></span><br><span class="line"><span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line"><span class="comment">// 设置vue文件中，HTML代码的格式化插件    </span></span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line"><span class="string">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;trailingComma&quot;</span>:<span class="string">&quot;none&quot;</span>,</span><br><span class="line">        <span class="string">&quot;semi&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;singleQuote&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;arrowParens&quot;</span>:<span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">        <span class="string">&quot;printWidth&quot;</span>:<span class="number">300</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：</p>
<ol>
<li>开发哪个项目，就用vscode直接打开该项目目录(保证两个插件能够正常生效)</li>
<li>在vue文件 – ctrl + s 能够格式化文件<blockquote>
<p>前提：在.vue文件右键 – 选择“使用..格式化文档&#x2F;格式化文档的方式” – 点击 配置默认格式化程序，点击 Prettier 将其设置为默认值<br>问题：设置默认格式后保存出现逗号的，在setting.json文件中 通过ctrl+f 搜索找到editor.formatOnSave，将其注释就可以解决这个问题</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="自定义事件使用-event"><a href="#自定义事件使用-event" class="headerlink" title="自定义事件使用$event"></a>自定义事件使用$event</h3><p>内置变量<code>$event</code>，是在我们需要向绑定事件传递参数时候，用来接收事件对象e使用的<br><code>@click=&quot;add(1,$event)&quot; --- add(n,e)&#123;&#125;</code></p>
<p><font color="green">只要自定义事件里面接收到的值被覆盖了，就可以考虑使用<code>$event</code></font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Count</span> @num-change=<span class="string">&quot;getNewNum(item,$event)&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自定义事件</span></span><br><span class="line"><span class="title function_">getNewNum</span>(<span class="params">item,val</span>)&#123; </span><br><span class="line">    item.<span class="property">goods_count</span> = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于main-js中的小提示"><a href="#关于main-js中的小提示" class="headerlink" title="关于main.js中的小提示"></a>关于main.js中的小提示</h3><p>main.js的第四行：<br><code>Vue.config.productionTip = false</code><br>默认是false，改为true会在终端给出一个温馨提示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br><span class="line">See more tips at https://vuejs.org/guide/deployment.html</span><br></pre></td></tr></table></figure>
<p>把这句代码删了就相当于是true</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/30/Vue/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/30/Vue/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/" class="post-title-link" itemprop="url">ref引用DOM元素和组件实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-30 22:23:21 / 修改时间：22:30:21" itemprop="dateCreated datePublished" datetime="2024-04-30T22:23:21+08:00">2024-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/30/Vue/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/30/Vue/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/30/Vue/5.ref%E5%BC%95%E7%94%A8DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标:<br>能够使用<code>ref</code>获取页面上DOM或组件的引用<br>能够知道<code>$nextTick</code>的应用场景并合理地使用<br>通过<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=127">“购物车案例”</a>巩固前4天所有学知识</p>
</blockquote>
<h2 id="ref引用-引用DOM元素-组件实例"><a href="#ref引用-引用DOM元素-组件实例" class="headerlink" title="ref引用 - 引用DOM元素 &#x2F; 组件实例"></a>ref引用 - 引用DOM元素 &#x2F; 组件实例</h2><blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<ol>
<li><p>什么是ref 引用<br> ref用来辅助开发者在<strong>不依赖于jQuery的情况下</strong>且<strong>在不调用DOM API的前提下</strong>，<strong>获取页面上DOM元素或组件的引用</strong>。</p>
<p> 每个vue的组件实例上，都包含一个<code>$refs</code>对象，里面存储着对应的DOM元素或组件的引用。<strong>默认情况下，组件的<code>$refs</code> 指向一个空对象</strong>。</p>
<blockquote>
<p>打印出vue实例对象this，可以看到，凡是$开头的，都是vue内置的一些成员。</p>
</blockquote>
</li>
<li><p>使用ref引用 DOM元素<br> 在标签上通过ref属性来指定一个名字，这个名字就指向这个标签，并添加到<code>$ref</code>对象中。如：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&quot;myh1&quot;</span>&gt;</span>APP根组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">$refs</span>:&#123;<span class="comment">//vue实例上的$refs属性值</span></span><br><span class="line">    <span class="attr">myh1</span>: h1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myh1</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span><span class="comment">//操作DOM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ref引用 组件实例<br> 只要<strong>在引用的子组件的标签上，加一个ref</strong>，这个名字就指向了这个子组件的vue实例，就可以通过它来调用这个子组件的属性和方法。</p>
</li>
</ol>
<p><font color='red'>建议：只要是ref的引用，尽量都以Ref后缀结尾，这样一看名字就知道是个引用</font></p>
<h2 id="this-nextTick的应用场景"><a href="#this-nextTick的应用场景" class="headerlink" title="this.$nextTick的应用场景"></a><code>this.$nextTick</code>的应用场景</h2><ul>
<li><strong>问题</strong></li>
</ul>
<p>在app组件中，控制组件内按钮和输入框元素的切换</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;inputVisible&quot;</span> @<span class="attr">blur</span>=<span class="string">&quot;showButton&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iptRef&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> @<span class="attr">click</span>=<span class="string">&quot;showinput&quot;</span>&gt;</span>显示输入框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们想要在切换到输入框的时候，直接进入输入框焦点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">showButton</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是<code>this.$refs.iptRef.focus()</code>这样却报错了<br><code>TypeError: Cannot read properties of undefined (reading &#39;focus&#39;)</code><br>这个错误代表说，我要调用一个focus方法，或我要访问一个focus属性，但是它前面那个东西是undefined<br>当我们打印<code>console.log(this.$refs.iptRef);</code>会发现它是<code>undefined</code>！</p>
<ul>
<li><strong>分析原因</strong></li>
</ul>
<p>在这个函数中，我们是更改inputVisible的值让文本框显示出来，但是现在页面上文本框还未显示出来，所以拿不到这个元素，因此是undefined<br>在Vue的生命周期中，当data里面的数据变化，会触发DOM元素的更新，根据最新的数据，重新渲染页面的UI结构。<strong>在updated之前，页面还没来得及重新渲染，所以数据是新的，但是页面的结构是旧的。</strong><br>所以<code>this.inputVisible = true;</code>这句执行之后，页面上还是按钮，文本框还未被展示，还需要一个更新的过程，需要一定的时间。如果立马去执行<code>this.$refs.iptRef.focus()</code>是拿不到文本框的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><font color='red'>总结：<code>this.inputVisible = true</code>这行代码执行完，只是数据是最新的，页面还没来得及重新渲染，没有文本框，拿不到它的引用，所以是undefined</font><br>要想不报错，<code>this.$refs.iptRef.focus()</code>这一行调用应该放在页面重新渲染完毕之后</p>
<ul>
<li><strong>解决</strong> – <code>this.$nextTick(cb)</code>方法<br>里面接收一个回调，cb是callback<br>代表：<strong>把回调函数里面的代码推迟到当DOM重新渲染完毕之后执行</strong><br>保证cb回调函数可以操作到最新的DOM元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showinput</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">iptRef</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">Vue组件与生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 20:35:44" itemprop="dateCreated datePublished" datetime="2024-04-24T20:35:44+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-30 22:48:39" itemprop="dateModified" datetime="2024-04-30T22:48:39+08:00">2024-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/24/Vue/4.Vue%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>能够掌握.vue单文件组件的基本用法<br>能够掌握组件通讯的三种方式<br>掌握组件生命周期的执行顺序和应用场景</p>
</blockquote>
<p>[toc]</p>
<h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><ol>
<li><p>什么是组件化开发<br><strong>组件化开发</strong>指的是∶根据<strong>封装</strong>的思想，<strong>把页面上可重用的UI结构封装为组件</strong>，从而方便项目的开发和维护。</p>
</li>
<li><p>vue中的组件化开发<br>vue是一个<strong>支持组件化开发</strong>的前端框架。<br>vue中规定：<strong>组件的后缀名是.vue</strong><br>vue中，root就是根，而这个根就是el所控制的那个区域。在main.js文件里，vue实例中通过 render 函数指定组件渲染到HTML页面中，替换了el区域。即：<strong>render函数中，渲染的是哪个.vue组件，那么这个组件就叫做“根组件”</strong></p>
</li>
<li><p><font color='green'>vue组件的三个组成部分</font></p>
<ul>
<li><font color='green'>template -&gt; 组件的模板结构</font></li>
<li><font color='green'>script -&gt; 组件的JavaScript行为</font></li>
<li><font color='green'>style -&gt; 组件的样式</font></li>
</ul>
<p> 注意：<font color='red'>每个组件中必须包含template模板结构，而script行为和style样式是可选的组成部分</font></p>
</li>
</ol>
<p>简单示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 组件的模版结构中，应该包含一个根元素，这个最外层的div不能有兄弟元素 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span> &gt;</span>这是用户自定义的Test.vue -- &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="comment">// 默认导出，固定写法！</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 注意：.vue组件中的data不能像之前一样，不能指向对象,必须是一个函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">// data数据源</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span>&#123;<span class="comment">// 这个return出去的对象中，可以定义数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">changeName</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">// 在组件中，this就表示当前组件的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">username</span> = <span class="string">&#x27;aaa&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.text-box</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">background-color</span>: pink;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">h3</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>组件之间的<font color='red'>父子关系</font><br>组件之间的父子关系、兄弟关系，<strong>是在使用时候才会产生的</strong><br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB.png" alt="img"></li>
</ol>
<h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的<strong>三个步骤</strong></h3><p><img src="/tsukimiya.github.io/images/vue/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt="img"><br><font color="green">注意：在components节点中，注册组件是一个对象的写法，前面是定义的名称，后面是要注册的组件。在对象里面，键名和值如果一样，可以省略值只写键名。如’Left’:Left可以简写成Left</font></p>
<ul>
<li><p>通过components注册的是<font color='red'>私有子组件</font><br>例如：<br>在组件A的components节点下，注册了组件F。<br>则组件F只能用在组件A中;不能被用在组件C中。</p>
</li>
<li><p>注册<font color='red'>全局组件</font><br>如果某个组件，使用非常频繁，好多组件中都要用到它，那么每次都要导入注册并使用，就很麻烦。所以可以注册全局组件</p>
<p>  <font color='green'>在vue项目的 main.js入口文件中，通过Vue.component()方法，可以注册全局组件。</font>示例代码如下:</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Count</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Count.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：字符串格式，表示组件的“注册名称”</span></span><br><span class="line"><span class="comment">// 参数2：需要被全局注册的那个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyCount&#x27;</span>,<span class="title class_">Count</span>)</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：在自己的组件中，不能使用自己！</strong></p>
</li>
</ul>
<h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的<strong>自定义属性</strong>，<strong>在封装通用组件的时候</strong>，合理地使用 props 可以极大的<font color='red' size='5'>提高组件的复用性！</font><br>它的语法格式如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性,允许使用者指定初始值</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其它自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font fcolor='green'>props中的数据，可以直接在模板结构中被使用</font>。使用示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;init&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;<span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left.vue组件中，使用注册了的Count组件</span></span><br><span class="line"><span class="comment">// 指定初始值，但是这里传入的是一个字符串，并不是一个真正的数值</span></span><br><span class="line">&lt;<span class="title class_">Count</span> init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color='red'>结合v-bind使用自定义属性</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样就传入的是数值6了</span><br><span class="line"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color='green'>官网文档-&gt;即便 <code>9</code> 是静态的，我们仍然需要 <code>v-bind</code> 来告诉 Vue，这是一个 JavaScript 表达式而不是一个字符串</font></p>
</li>
<li><p><font color='red'>props对子组件是只读的 (父组件-&gt;子组件 单向数据传递)</font><br>Vue规定:组件中封装的自定义属性是只读的，程序员不能直接修改props的值。否则会直接报错。<br>注意：props是对定义该属性的子组件只读，<font color='red'>在父组件中，你可以通过v-bind绑定props的值，并且这个值是可以更改的。</font><strong>当父组件中的值改变时，Vue会自动将新值传递给子组件，并且子组件会根据新的值重新渲染</strong>。这种方式实际上是通过props属性进行了<strong>单向数据流</strong>，确保数据流动的可预测性和可维护性。<br><font color='red'>如果子组件需要修改传递过来的值，通常应该通过触发事件并将修改传递给父组件来实现。</font><br><font color='green'>props可以被作为初始值使用的，把它传给data的属性进行初始赋值使用：</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count.vue组件中</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count+=1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>, &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Count</span> :init=<span class="string">&quot;6&quot;</span>&gt;&lt;/<span class="title class_">Count</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="props的default默认值"><a href="#props的default默认值" class="headerlink" title="props的default默认值"></a>props的default默认值</h3><p>在声明自定义属性时，可以通过default来定义属性的默认值。示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="comment">// 自定义属性：&#123; /* 配置选项 */ &#125;</span></span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="comment">// 如果外界使用Count组件，没有传递默认值，则默认值生效</span></span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props的-type-值类型"><a href="#props的-type-值类型" class="headerlink" title="props的 type 值类型"></a>props的 type 值类型</h3><p>在声明自定义属性时，<font color='red'>可以通过type来定义属性的值类型。</font>示例代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="comment">// 用type属性定义属性的值类型</span></span><br><span class="line">            <span class="comment">// init的值类型必须是Number数字</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props的-required-必填项"><a href="#props的-required-必填项" class="headerlink" title="props的 required 必填项"></a>props的 required 必填项</h3><p>加上required必填项之后，哪怕有默认值，不传也会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">init</span>: &#123;</span><br><span class="line">            <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">require</span>: <span class="literal">true</span>,<span class="comment">//必填项校验</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件间的样式冲突-scoped"><a href="#组件间的样式冲突-scoped" class="headerlink" title="组件间的样式冲突 - scoped"></a>组件间的样式冲突 - scoped</h3><p>默认情况下，<strong>写在.vue组件中的样式会全局生效</strong>，因此很容易造成<strong>多个组件之间的样式冲突问题</strong>。<br>导致组件之间样式冲突的<strong>根本原因</strong>是:<br>    <font color='purple'>1. 单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</font><br>    <font color='purple'>2. 每个组件中的样式，都会影响整个index.html页面中的DOM元素</font></p>
<p>注意：单页面应用程序中，HTML页面是只有一个的，我们的所有组件都是在这个HTML中生效的</p>
<ul>
<li><p>解决方案 – <font color='red'>核心原理：css属性选择器</font><br>给当前页面标签都加一个固定的自定义属性，不同的组件之间的自定义属性不一样</p>
</li>
<li><p>vue简化：<strong>scoped属性</strong><br>只要给当前组件的style加上scoped的属性，vue底层在生成组件的时候，会自动给每个标签自动生成一个data-v-xxx</p>
</li>
</ul>
<h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="&#x2F;deep&#x2F;样式穿透"></a>&#x2F;deep&#x2F;样式穿透</h4><p><font color='#00a86b'>作用：在父组件中改造子组件里的样式</font><br><font color='violet'>应用场景：当使用第三方组件库的时候，如果有修改组件默认样式的需求，需要用到&#x2F;deep&#x2F;</font></p>
<ul>
<li><p>scoped有一个缺陷，场景：<br>Left 和 Right 都注册使用了 Count组件<br>Left加了scoped属性，而Right没加<br>如果想在Left中的style里修改Count里面的样式，会发现不起作用，而如果在Right中修改，会发现Left和Right里面的Count组件样式都变了。</p>
</li>
<li><p>原因：<br>在Left中修改，比如h5{..},因为加了scoped，所以会变成h5[data-v-xx]{..}，而count中的标签并没有data-v-xx属性，所以不会生效。<br>而在没有scoped属性的Right中修改，则产生的就是样式冲突</p>
</li>
<li><p>解决方案：&#x2F;deep&#x2F;样式穿透<br>&#x2F;deep&#x2F; h5{ … }<br>在选择器前面加个前缀+空格，在浏览器可以查看到，这个h5标签被加上了一个[data-v-xx] 的前缀</p>
</li>
</ul>
<h2 id="Vue运行原理"><a href="#Vue运行原理" class="headerlink" title="Vue运行原理"></a><strong>Vue运行原理</strong></h2><p>在把app渲染到页面的过程中，不是把页面的模板结构直接丢到页面上，而是有个编译的过程。<br>浏览器能够直接解析HTML页面，但是不识别vue页面。<br>在<code>package.json</code>里面，<code>devDependencies</code>里面有个<code>vue-template-complier</code>包，就是vue模板编译器，作用就是把.vue文件编译成js交给浏览器解析运行。<br>在.vue中写的任何代码，要渲染到浏览器中，都依赖于这个包的解析与转换。</p>
<p>我们上面在页面上渲染了2次Count.vue组件，我们在页面上看到的两个Count组件，就是两个组件的实例。<br>实例，就是相当于new一个构造函数得到一个实例。我们编写的Count.vue，可以理解为它就是一个构造函数，new这个构造函数就会得到一个Count实例。<br>我们没有直接new，而是通过标签形式去用这个组件，这个用的过程可以理解为一个new的过程<br>所以说，<strong>这个组件，在定义的时候，它只是一个模板结构，当用标签的形式去使用的时候，才是在创建一个它的实例。</strong><br>如果在components下声明一个组件，不去用它不会创建组件实例。</p>
<blockquote>
<p><font color='red'>整个项目如何跑起来的：</font><br><font color='#00a86b'>webpack从main.js(入口文件)开始打包，发现main里面用到了app，于是把app创建一个实例出来。然后app里面又用到了Left和Right，然后这两个里面又用到了Count，就这样一直通过一个树的形式，把整个树都解析转换，最后编译成纯js代码。然后把js文件放到首页里面去，浏览器就会解析和执行这里面的代码，把组件都给渲染到页面上</font></p>
</blockquote>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol>
<li><p>生命周期 &amp; 生命周期函数<br><font color='red'>生命周期</font>(Life Cycle)是指一个组件从<font color='red'>创建-&gt;运行-&gt;销毁</font>的整个阶段，<font color='red'>强调的是一个时间段</font>。</p>
<p> <font color='red'>生命周期函数</font>:是由vue框架提供的<font color='red'>内置函数</font>，会伴随着组件的生命周期，<font color='red'>自动按次序执行</font>。<br> 注意:<font color='#00a86b'>生命周期</font>强调的是<font color='#00a86b'>时间段</font>，<font color='#00a86b'>生命周期函数</font>强调的是<font color='#00a86b'>时间点</font>。</p>
</li>
<li><p>组件生命周期函数(<strong>生命周期钩子</strong>)的分类<br>在生命周期里面，它会按顺序依次执行这些函数。<br><img src="/tsukimiya.github.io/images/vue/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="img"></p>
</li>
<li><p>生命周期图示<br>可以官方给出的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">“生命周期图示”</a>，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=106">进一步理解组件生命周期执行过程</a>。</p>
</li>
</ol>
<ul>
<li><p><font color='green'>执行次数</font><br>创建阶段：1次<br>运行阶段：0-N次<br>销毁阶段：1次</p>
</li>
<li><p><font color='red'>最重要的生命周期钩子</font></p>
<ol>
<li><font color='red'>created</font><br> data、props、methods都是可用状态<br> 常用它发起ajax请求来拿数据，转存到data中，供template模板渲染时候使用。</li>
<li><font color='red'>mounted</font><br> 第一次把DOM元素结构渲染好，最早去操作DOM</li>
<li><font color='red'>updated</font><br> 可以操作最新的更新过后的DOM</li>
</ol>
<p>  其他的很少会用到，记不住也没关系</p>
</li>
</ul>
<h2 id="组件之间的通讯-数据共享"><a href="#组件之间的通讯-数据共享" class="headerlink" title="组件之间的通讯(数据共享)"></a>组件之间的通讯(数据共享)</h2><ol>
<li><p>组件之间的关系<br>最常见的：兄弟关系、父子关系<br>离的比较远的，也可以认为是一种变态的兄弟关系</p>
</li>
<li><p><strong>父向子传值</strong> – <strong>自定义属性</strong><br><font color='red'>再次注意: props是只读的！</font><br><img src="/tsukimiya.github.io/images/vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.png" alt="img"></p>
</li>
<li><p><strong>子向父传值</strong> – <strong>自定义事件</strong><br>第一步是绑定了一个事件，这是个处理函数。<font color='red'><code>$emit</code>就代表触发这个事件</font>，谁触发这个事件，谁传一个值过来。<br><font color='#00a86b'>子向父传值：在子组件调用$emit，父组件<font color='red'>在子组件标签上</font>用@绑定(监听)这个自定义事件</font><br><font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。<br><img src="/tsukimiya.github.io/images/vue/%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC.png" alt="img"></p>
<blockquote>
<p>vue在内部要想触发click事件，它也是用this或vm<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;show&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">method</span>:&#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">e</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">vm.$emit(<span class="string">&#x27;click&#x27;</span>,&#123;<span class="comment">//事件对象e</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">clientX</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">clientY</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">target</span>:dom元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p><strong>兄弟组件之间的数据共享</strong> – <strong>EventBus</strong><br>在<font color='red'>vue2.x</font>中，兄弟组件之间数据共享的方案是<font color='red'>EventBus</font>。</p>
<ul>
<li>EventBus使用步骤</li>
</ul>
<ol>
<li>创建<code>eventBus.js</code>模块，并向外共享一个<strong>Vue的实例对象</strong></li>
<li>在数据<strong>发送方</strong>，调用<code>bus.$emit(&#39;事件名称&#39;,要发送的数据)</code>方法<strong>触发自定义事件</strong></li>
<li>在数据<strong>接收方</strong>，调用<code>bus.$on(&#39;事件名称&#39;,事件处理函数)</code>方法<strong>注册一个自定义事件</strong><br> 数据在事件处理函数的形参中拿到。</li>
</ol>
<p> <font color='#00a86b'>依旧是发送方触发事件，发送数据，接收方绑定事件监听，接受数据。</font><br> 这里的<code>$on</code>就相当于jQuery的on绑定事件<br> <strong>为什么这里要用到一个共享的实例EventBus</strong> ？因为<font color='red'>绑定事件和触发事件要在同一个实例上！！</font><strong>有绑定有触发</strong>。</p>
</li>
</ol>
<p><img src="/tsukimiya.github.io/images/vue/%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC.png" alt="img"></p>
<p>注意：虽然可以使用EventBus来在父子组件之间传值，但是这不是Vue官方推荐的做法。<strong>props和自定义事件更适合处理父子组件之间的通信，因为它们更直观和易于理解</strong>。 Event Bus 通常更适用于非父子关系的组件之间的通信，例如兄弟组件之间。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="vscode插件-Path-Autocomplete-路径提示"><a href="#vscode插件-Path-Autocomplete-路径提示" class="headerlink" title="vscode插件 Path Autocomplete - @路径提示"></a>vscode插件 Path Autocomplete - @路径提示</h3><p>下载插件之后，要在自己配置项里面添加如下配置,添加在头部就行<br>设置 – setting.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入文件时是否携带文件的扩展名</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 配置 @ 的路径提示</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.pathMappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p><font color="red">注意：只有vscode打开的文件夹根目录是项目根目录时才起作用！！</font></p>
<blockquote>
<p>总觉得这个功能vscode也集成进去了？一开始没装的时候，好像就触发了，也懒得验证了hh</p>
</blockquote>
<h3 id="Auto-Close-Tag插件"><a href="#Auto-Close-Tag插件" class="headerlink" title="Auto Close Tag插件"></a>Auto Close Tag插件</h3><p>输入<code>&lt;xx&gt;</code>标签前半部分，会自动补全后半部分<br>不过新版vscode好像已经集成了这个功能，没有安装也是这样，装了没啥变化</p>
<h3 id="方法简写形式"><a href="#方法简写形式" class="headerlink" title="方法简写形式"></a>方法简写形式</h3><p><strong>如果方法只有一行，可以简写到行内</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count += 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>先指令，后绑定，最后绑事件<br>这是一个子组件的绑定示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Goods</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    :id=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    :state=<span class="string">&quot;item.goods_state&quot;</span></span><br><span class="line">    @state_change=<span class="string">&quot;getNewState&quot;</span></span><br><span class="line">&gt;&lt;/<span class="title class_">Goods</span>&gt;</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/21/Vue/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/21/Vue/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/" class="post-title-link" itemprop="url">Vue2 过滤器、侦听器、计算属性、axios & vue-cli</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-21 14:09:30" itemprop="dateCreated datePublished" datetime="2024-04-21T14:09:30+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-01 10:14:20" itemprop="dateModified" datetime="2024-05-01T10:14:20+08:00">2024-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/21/Vue/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/21/Vue/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/21/Vue/3.%E8%BF%87%E6%BB%A4%E5%99%A8%20%E4%BE%A6%E5%90%AC%E5%99%A8%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%20axios&vue-cli/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>在实际开发中合理运用过滤器、侦听器、计算属性解决问题<br>使用axios发起Ajax请求<br>使用vue-cli工具生成工程化的Vue项目</p>
</blockquote>
<p>[toc]</p>
<h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><blockquote>
<p>2020年9月 vue3发布。增加了很多新功能，但是也删掉了一些功能。 比如删掉了vue2中的过滤器filter功能。<br>与此同时，官方建议： <strong>用方法调用或计算属性替换过滤器</strong>。<br>filter过滤器能加工数据，computed计算属性和methods方法也都可以加工数据，这样的话，就功能重复了…(于是filter被开除了XDD)</p>
</blockquote>
<p>vue3已经把过滤器删掉了，只能在vue2中使用，会基础语法就行了。</p>
<ul>
<li><font color="green">过滤器要点</font><ol>
<li>必须被定义到 <code>filters节点</code> 之下，本质是一个函数</li>
<li>强调：过滤器中一定要有一个返回值</li>
<li>过滤器函数中的 形参<code>val</code>(随意命名)，永远都是管道符前面的那个值。(多个形参，则第一个外都是undefined)</li>
<li>过滤器函数 由 管道符 <code>|</code> 调用</li>
<li>过滤器只能在 <code>差值表达式</code> 或 <code>属性绑定指令v-bind</code> 中调用</li>
<li>最终得到的结果是过滤器的返回值</li>
</ol>
</li>
</ul>
<p><strong>过滤器常用于文本的格式化</strong>,应该被添加在JavaScript表达式的尾部，由“<strong>管道符</strong>”进行调用。示例:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在花括号中通过管道符调用capitalize过滤器，对message的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中通过管道符调用formatId过滤器，对rawId的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="私有过滤器-和-全局过滤器"><a href="#私有过滤器-和-全局过滤器" class="headerlink" title="私有过滤器 和 全局过滤器"></a>私有过滤器 和 全局过滤器</h3><p><strong>在 <code>filters节点</code> 下定义的过滤器</strong>，称为“<strong>私有过滤器</strong>”，因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器，则可以按照如下的格式<strong>定义全局过滤器</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器–独立于每个vm实例之外 </span></span><br><span class="line"><span class="comment">// Vue.filter()方法接收两个参数:</span></span><br><span class="line"><span class="comment">// 第1个参数，是全局过滤器的&quot;名字”</span></span><br><span class="line"><span class="comment">// 第2个参数，是全局过滤器的&quot;处理函数&quot;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>( <span class="string">&#x27;capitalize&#x27;</span>, <span class="function">(<span class="params">str</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;~~&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果想要定义多个全局过滤器就再写一个</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capi2&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&#x27;--全局2&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">注意：如果私有过滤器和全局过滤器名字一致，此时按就近原则</font></p>
<h3 id="其他用法-–-连续调用、传参"><a href="#其他用法-–-连续调用、传参" class="headerlink" title="其他用法 – 连续调用、传参"></a>其他用法 – 连续调用、传参</h3><ol>
<li><p>连续调用多个过滤器 – 串联地调用<br>如：<code>&#123;&#123;message | filterA | filterB&#125;&#125;</code></p>
</li>
<li><p>过滤器传参</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | filterA(arg1,arg2)&#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;filterA&#x27;</span>,<span class="function">(<span class="params">msg,arg1,arg2</span>)=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器的兼容性<br>仅在vue 2.x 和 1.x中受支持<br>3.x建议使用 <strong>计算属性</strong> 或 <strong>方法</strong> 代替<br>具体的迁移指南参考官方文档给出的<a target="_blank" rel="noopener" href="https://v3.vuejs.org/guide/migration/filters.html#migration-strategy">说明</a></p>
</li>
</ol>
<h2 id="Watch侦听器"><a href="#Watch侦听器" class="headerlink" title="Watch侦听器"></a>Watch侦听器</h2><p>Watch侦听器 <strong>监视数据的变化，做出特定操作</strong>，变量名与监听的值对应。语法格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">// 监视username变化</span></span><br><span class="line">        <span class="comment">// newVal - 变化后的新值，oldVal - 旧值</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><font color="green">应用场景如：侦听用户输入的用户名，每次变化就去查找是否被占用</font></p>
<h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><ol>
<li>方法格式的侦听器<ul>
<li>缺点1: 无法在刚进入页面的时候，自动触发！！</li>
<li>缺点2: 如果侦听的是一个对象，对象中的属性发生了变化，不会触发侦听器！！</li>
</ul>
</li>
<li><strong>对象格式的侦听器</strong><ul>
<li>好处1: 可以通过<strong>immediate选项</strong>，让侦听器自动触发！！</li>
<li>好处2：可以通过<strong>deep选项</strong>，让侦听器深度监听对象中每个属性的变化！！</li>
</ul>
</li>
</ol>
<ul>
<li><font color="green">推荐：为了写起来方便，建议定义成方法格式，如果确实需要，再改成对象格式。</font></li>
</ul>
<h3 id="immediate选项"><a href="#immediate选项" class="headerlink" title="immediate选项"></a>immediate选项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span> <span class="comment">// true表示一进入页面就触发，false是默认值，不写这个参数也是false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深度侦听-–-deep选项"><a href="#深度侦听-–-deep选项" class="headerlink" title="深度侦听 – deep选项"></a>深度侦听 – deep选项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125; &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">info</span>:&#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;<span class="comment">// 侦听器的处理函数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// 对象里任意属性变化了，都会触发侦听器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果要侦听的是对象的子属性的变化，则必须包裹一层单引号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>(newVal)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ol>
<li>什么是计算属性<br>计算属性指的是通过一系列运算之后，最终得到一个属性值。<br>这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</li>
<li>应用场景：<font color='red'>实现代码复用</font></li>
</ol>
<ul>
<li>计算属性的使用<ol>
<li>计算属性要定义到computed节点下，定义成方法格式</li>
<li>虽然声明的方法格式，但是要当做普通的属性来用<blockquote>
<p>打印出vue实例，可以发现定义的计算属性是被挂到属性上面的，和data节点上的属性一样</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>示例代码如下︰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">r</span>:<span class="number">0</span>,<span class="attr">g</span>:<span class="number">0</span>,<span class="attr">b</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 计算属性要定义到computed节点下，定义成方法格式</span></span><br><span class="line">        <span class="title function_">rgb</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rgb</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h2><blockquote>
<p>axios是一个<strong>专注于网络请求</strong>的库！它只负责发请求和拿数据<br>    中文官网地址：<a target="_blank" rel="noopener" href="http://www.axios-js.com/">http://www.axios-js.com/</a></p>
</blockquote>
<ul>
<li><p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// url中的查询参数，get请求体传参，可选</span></span><br><span class="line">    <span class="attr">params</span>:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用axios得到的返回值是一个 Promise 对象<br>axios在请求到数据之后，在真正的数据之外，套了一层壳,result得到的就是套完壳之后的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123; 真实的数据 &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">status</span>: xxx,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><font color='red'>结合async和await调用axios</font></strong><br>这个<code>.then</code>用起来有点麻烦，我们可以使用await来进行简化<br><font color='green'>如果调用某个方法的返回值是 Promise 实例，则前面可以添加await！（这样得到的就直接是result）</font><br><font color='red'>await 只能用在被 async 修饰 的方法中</font></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用解构赋值来获取data</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele.<span class="title function_">addEventLister</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; =  <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;请求的 URL 地址&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于axios-get和axios-post发起请求"><a href="#基于axios-get和axios-post发起请求" class="headerlink" title="基于axios.get和axios.post发起请求"></a>基于axios.get和axios.post发起请求</h3><ol>
<li>axois.get<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//GET参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br></pre></td></tr></table></figure></li>
<li>axios.post<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意await要在async修饰的函数中使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">unit</span>: <span class="string">&quot;00&quot;</span>,</span><br><span class="line">    <span class="attr">contact</span>: <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">    <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">    <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">    <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-cli的安装和使用"><a href="#vue-cli的安装和使用" class="headerlink" title="vue-cli的安装和使用"></a>vue-cli的安装和使用</h2><p>中文官网：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<ol>
<li><p>什么是单页面应用程序？<br><strong>单页面应用程序</strong>（英文名: Single Page Application）简称SPA，顾名思义，<strong>指的是一个Web 网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p>
</li>
<li><p>什么是vue-cli<br><strong>vue-cli是Vue.js开发的标准工具</strong>。它简化了程序员基于webpack创建工程化的Vue项目的过程。</p>
</li>
<li><p>安装<br>vue-cli是npm上的一个全局包，使用<code>npm i</code>命令，即可方便的把它安装到自己电脑上：<code>npm i -g @vue/cli</code></p>
<ul>
<li><code>vue -V</code>查看安装的版本号</li>
</ul>
</li>
<li><p>使用<br>基于vue-cli快速生成工程化的Vue项目：<code>vue create 项目名称</code>(建议名称用不带空格的英文)<br> 在想要创建项目的文件夹执行此命令，即会生成项目文件夹，命名即为 项目名称</p>
<ul>
<li>选择预设(用方向键)<br>  <strong>初学者建议选择最后一项 – 手动选择要安装哪些功能</strong><br>  按空格选中要安装的预设<br>  一开始建议选择：<br>  Choose Vue version(新版没有这个)、Babel、CSS Pre-processors,其他的不要选<br>  下面接着选择vue版本为2.x，css预处理器为less</li>
</ul>
</li>
<li><p>vue项目中src目录的构成：</p>
<ol>
<li>assets 文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源</li>
<li>components 文件夹：程序员封装的、可复用的组件，都要放到components目录下。<br> 里面有一个默认组件HelloWorld.vue，给它删除</li>
<li>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</li>
<li>app.Vue 是项目的根组件。我们创建项目之后，看到的页面就是app.Vue，如果想重新换一个页面出来，只需要把它给清空掉。里面的template是一个模版结构。</li>
</ol>
</li>
<li><p>vue项目的运行流程<br> 在工程化的项目中，vue要做的事情很单纯: <strong>通过main.js把 App.vue渲染到index.html的指定区域中</strong>。<br> 其中：</p>
<ul>
<li><strong>App.vue</strong>用来编写待渲染的<strong>模板结构</strong></li>
<li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li>
<li><strong>main.js</strong> 把 App.vue渲染到了index.html所预留的区域中  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 vue 这个包，得到Vue构造函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入App.vue根组件，将来要把App.vue中的模板结构，渲染到HTML页面中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Vue的实例对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// 把 render 函数指定的组件渲染到HTML页面中，这里指定了App</span></span><br><span class="line">    <span class="comment">// 我们最终的结果是，把这个指定的组件，放到id为app的所在的这个位置，把它给替换掉了</span></span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// vue实例的$mount()方法，作用和el属性完全一样</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="字符串函数charAt"><a href="#字符串函数charAt" class="headerlink" title="字符串函数charAt()"></a>字符串函数charAt()</h3><p>接收索引值，从字符串中获取对应字符，如：<br><code>&#39;hello&#39;.charAt(4) //&#39;o&#39;</code></p>
<h3 id="将字符串第一个字符变为大写"><a href="#将字符串第一个字符变为大写" class="headerlink" title="将字符串第一个字符变为大写"></a>将字符串第一个字符变为大写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> first = str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="keyword">const</span> other = str.<span class="title function_">slice</span>(<span class="number">1</span>)<span class="comment">//从指定索引往后截取字符串，返回得到的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first+other)</span><br></pre></td></tr></table></figure>

<h3 id="ajax原生写法"><a href="#ajax原生写法" class="headerlink" title="ajax原生写法"></a>ajax原生写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xxx</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/20/Vue/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/20/Vue/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">Vue2 基本使用 & 常用指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-20 12:51:08" itemprop="dateCreated datePublished" datetime="2024-04-20T12:51:08+08:00">2024-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 13:34:41" itemprop="dateModified" datetime="2024-04-26T13:34:41+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Vue2/" itemprop="url" rel="index"><span itemprop="name">Vue2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/20/Vue/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/20/Vue/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/20/Vue/2.vue2%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>使用Vue指令完成页面结构的渲染<br>使用Vue调试工具辅助Vue的开发</p>
</blockquote>
<blockquote>
<p><strong>掌握Vue的两个特性：数据驱动视图、双向数据绑定<br>    掌握Vue的底层原理 MVVM – model数据源、view视图&#x2F;页面结构、viewmodel vue实例<br>    掌握Vue六大类指令的使用</strong><br>    vue2指令新学到的东西：<br>    事件绑定指令中的：<a href="#param">参数问题</a>、<a href="#event">$event</a>、<a href="#modifier">事件修饰符</a>、<a href="#keyModifier">按键修饰符</a><br>    双向绑定指令中的：<a href="#v-model">v-model修饰符</a><br>    条件渲染指令中的：<a href="#if">v-if配套的v-else指令</a><br>    列表渲染指令中的：<a href="#key">key属性绑定</a></p>
</blockquote>
<blockquote>
<p>vscode插件推荐：Volar、Vue VSCode Snippets。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40808668/article/details/134277604">简单说明</a>(CSDN)</p>
</blockquote>
<blockquote>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
</blockquote>
<p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/guide/">Vue 2.x 官方文档</a>(已不再维护)<br>Vue是一套<strong>用于构建用户界面的前端框架</strong><br>构建用户界面：用vue往html页面填充数据<br>框架：一套现成的解决方案，程序员只能遵守框架的规范去编写业务功能</p>
<p>学习vue就是学习vue框架中规定的用法<br><strong>vue的指令、组件(是对UI结构的复用)、路由、Vuex、vue组件库</strong></p>
<p><font color='red'>Vue的优势：MVVM的数据驱动视图 – 在vue中，程序员不需要操作DOM，只需要把数据维护好即可。</font><br>因此，在vue项目中，墙裂不建议安装和使用jQuery，因为没有操作DOM的需求，如果有也是极少的。</p>
<h3 id="vue的两个特性："><a href="#vue的两个特性：" class="headerlink" title="vue的两个特性："></a>vue的两个特性：</h3><ol>
<li><strong>数据驱动视图</strong><br> vue会监听数据的变化，自动重新渲染页面的结构<br> 注意：<span style="color:red;" >数据驱动视图是单向的数据绑定<span></li>
<li><strong>双向数据绑定</strong><br> 填写表单时，自动把内容同步到数据源中<blockquote>
<p>在网页中，form表单负责<font color='green'>采集数据</font>，Ajax负责<font color='green'>提交数据</font></p>
</blockquote>
</li>
</ol>
<h3 id="MVVM-–-vue的底层原理"><a href="#MVVM-–-vue的底层原理" class="headerlink" title="MVVM – vue的底层原理"></a>MVVM – vue的底层原理</h3><p><font color='red'>MVVM是 vue 实现数据驱动视图和双向数据绑定的核心原理。</font><br>MVVM 指的是 <strong>M</strong>odel(数据源)、<strong>V</strong>iew(视图) 和 <strong>V</strong>iew<strong>M</strong>odel(vue实例)，它把每个 HTML 页面都拆分成了这三个部分。</p>
<p>在MVVM概念中:<br><strong>Model</strong> 表示当前页面渲染时所依赖的<strong>数据源</strong>。<br><strong>View</strong> 表示当前页面所渲染的 DOM 结构。(<strong>页面结构，也即是视图</strong>)<br><strong>ViewModel</strong> 表示 <strong>vue 的实例</strong>，它是<strong>MVVM的核心</strong>。(也就是vue)<br><img src="/tsukimiya.github.io/images/vue/MVVM%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p>
<ul>
<li>MVVM的工作原理：<br>  ViewModel作为MVVM的核心，是它把当前页面的<font color="green">数据源</font>(Model)和<font color="green">页面的结构</font>(View)连接在了一起。<br>  <img src="/tsukimiya.github.io/images/vue/MVVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="img"><br>  <strong>当数据源发生变化时</strong>，会被ViewModel监听到，VM会根据最新的数据源<strong>自动更新</strong>页面的结构<br>  <strong>当表单元素的值发生变化时</strong>，也会被VM监听到，VM会把变化过后最新的值<strong>自动同步</strong>到Model数据源中</li>
</ul>
<h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><p>当前，vue共有3个大版本，其中:<br>3.x版本的vue 于2020-09-19发布<br>2.x版本的vue 已于 2023 年 12 月 31 日停止维护<br>1.x版本的vue几乎被淘汰，不再建议学习与使用</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p>基本使用步骤</p>
<ol>
<li>导入VUE.js脚本文件<br> 可以借助 script 标签直接通过 CDN(提供 npm 包服务) 来使用 Vue：<br> <code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在页面声明一个将要被vue所控制的区域</li>
<li>创建vm实例对象(vue实例对象)</li>
</ol>
</li>
<li><p>基本代码与MVVM的对应关系<br> model：data指向的对象<br> view：el指向的选择器<br> ViewModel：new Vue()构造函数得到的实例对象</p>
</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。<br>指令是vue开发中最基础、最常用、最简单的知识点</p>
<p>vue的指令 <strong>按照不同用途</strong> 可以分为如下6大类：</p>
<ol>
<li><p>内容渲染指令：<code>v-text</code> 、<code>&#123;&#123;&#125;&#125;</code>  、 <code>v-html</code></p>
<blockquote>
<p>v-test 会覆盖默认文本内容，一般使用<code>&#123;&#123;&#125;&#125;</code>插值表达式<br> v-text和差值表达式只能渲染纯文本内容<br> v-html可以把带标签的字符串渲染成HTML内容</p>
</blockquote>
</li>
<li><p>属性绑定指令: <code>v-bind</code> &#x2F; <code>:xxx=</code> </p>
<blockquote>
<p>差值表达式只能用在元素的内容节点中，不能用在属性节点中<br> v-bind用法：<code>&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;tips&quot;&gt;</code><br> <strong>vue规定 <code>v-bind:</code> 指令可以简写为<code>:</code></strong></p>
</blockquote>
<blockquote>
<p>在vue提供的<strong>模版渲染语法中</strong>，除了支持绑定简单的数据值之外，还<font color="green">支持JS表达式的运算</font><br> 但是<font color="green">只能写简单的JS表达式，不能写if等复杂的JS语句</font>，如字符串拼接等：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;number + <span class="number">1</span>&#125;&#125;、&#123;&#123;ok?<span class="string">&#x27;YES&#x27;</span>:<span class="string">&#x27;NO&#x27;</span>&#125;&#125;、&#123;&#123;msg.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reserve</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)&#125;&#125;<span class="comment">//反转字符串</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p>事件绑定指令：<code>v-on</code> &#x2F; <code>@</code></p>
<blockquote>
<p>语法如 <code>v-on:clock=&quot;add&quot;</code> 简写<code>@click=&quot;add&quot;</code><br> methods下的函数变量也支持简写：<code>add:function()&#123;&#125; --&gt; add()&#123;&#125;</code><br> 在处理函数中<strong>修改数据的值</strong>可以通过vm(接受vue实例的变量名)来修改：vm.count,但是不推荐，<strong>推荐用this</strong></p>
</blockquote>
<ul>
<li><p>绑定事件并传参</p>
<blockquote>
<p>在调用的地方传参 <code>@click=&quot;add(1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="param" color="red">参数问题</font></p>
<blockquote>
<ul>
<li>如果定义的函数变量是有参数的<br>1. <code>add(n)&#123;&#125; -- @click=&quot;add(1)&quot;</code> 正常传参 n&#x2F;&#x2F;1<br>2. <code>add(n)&#123;&#125; -- @click=&quot;add()&quot;</code> n&#x2F;&#x2F;undefined<br>3. <code>add(n)&#123;&#125; -- @click=&quot;add&quot;</code> n被认定为事件对象PointerEvent，通常我们会定义为e&#x2F;event</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果是多个参数，如<br>1. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1,2)&quot;</code> 正常传参 a&#x2F;&#x2F;1 b&#x2F;&#x2F;2<br>2. <code>add(a,b)&#123;&#125; -- @click=&quot;add(1)&quot;</code> a&#x2F;&#x2F;1 b&#x2F;&#x2F;undefined<br>3. <code>add(a,b)&#123;&#125; -- @click=&quot;add()&quot;</code> a&#x2F;un b&#x2F;&#x2F;un<br>4. <code>add(a,b)&#123;&#125; -- @click=&quot;add&quot;</code> a&#x2F;&#x2F;事件对象PointerEvent ，b&#x2F;&#x2F;undefined</li>
</ul>
</blockquote>
</li>
<li><p><font id="event" color="red">事件对象$event</font>(不常用)</p>
<blockquote>
<p>vue提供了内置变量<code>$event</code>,它就是原生DOM的事件对象e<br>  在绑定事件的时候，如果不传参 <code>add(e)&#123;&#125; -- @click=&quot;add&quot;</code> , 我们会接受到一个事件对象e<br>  如果传参，<code>@click=&quot;add(1)&quot;</code>,我们就接收不到这个事件对象了<br>  <strong>我们既要传参，又要用到事件对象e</strong>，如想要从事件对象上拿到e.target(触发事件的事件源) ，这个时候就可以用<code>$event</code><br>  <strong><code>$event</code>使用：传<code>$event</code>作参数进去，拿形参接收</strong><br>  <code>add(n,e)&#123;&#125; --  @click=&quot;add(1,$event)&quot;</code><br>  或<code>add(e,n)&#123;&#125; --  @click=&quot;add($event,1)&quot;</code></p>
</blockquote>
</li>
<li><p><font id="modifier" color="red">事件修饰符</font></p>
<blockquote>
<p>在事件处理函数中，调用<code>event.preventDefault()</code>(阻止默认行为)或<code>event.stopPropagation()</code>(阻止冒泡)是非常常见的需求。<br>  因此，vue提供了<strong>事件修饰符</strong>的概念，辅助程序员更方便的<strong>对事件的触发进行控制</strong>。<br>  如 <code>@click.prevent=&quot;show&quot;</code>绑定了show事件，同时阻止了默认行为<br>  常见的5个事件修饰符如下：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>.prevent</strong></td>
<td><strong>阻止默认行为</strong>(例如：阻止a链接的跳转、表单的提交等)</td>
</tr>
<tr>
<td align="center"><strong>.stop</strong></td>
<td><strong>阻止事件冒泡</strong></td>
</tr>
<tr>
<td align="center">.capture</td>
<td>以 捕获模式 触发当前的 事件处理函数</td>
</tr>
<tr>
<td align="center">.once</td>
<td>绑定的事件只触发1次</td>
</tr>
<tr>
<td align="center">.self</td>
<td>只有在 event.target 是当前元素自身时 触发事件处理函数</td>
</tr>
</tbody></table>
<ul>
<li><font id="keyModifier" color="red">按键修饰符</font>(用的不是很多)<blockquote>
<p>在<strong>监听键盘事件</strong>时，经常需要<strong>判断详细的按键</strong>。<br>  此时，可以为键盘的相关事件添加<strong>按键修饰符</strong>，如：<br>  <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> – 只有在<code>key</code>是<code>Enter</code>时，调用<code>vm.submit()</code><br>  <code>&lt;input @keyup.esc=&quot;clearInput&quot;&gt;</code> – 只有在<code>key</code>是<code>Esc</code>时，调用<code>vm.clearInput()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>双向绑定指令 <code>v-model</code></p>
<blockquote>
<p>用来辅助程序员在<strong>不操作DOM</strong>的前提下，<strong>快速获取表单的数据</strong>。<br>     能够产生数据交互的只有表单元素，所以只有表单元素才能使用<code>v-model</code>,才有意义<br>     表单元素 input、textarea、select<br>     v-model内部会判断绑定元素的类型，根据元素类型来决定将绑定的值给哪个属性。如复选框checkbox就是给checked属性，如果是text框就是value属性</p>
</blockquote>
<ul>
<li><font id="v-model" color="red">v-model修饰符</font><blockquote>
<p>为了方便对用户输入的内容进行处理，vue为v-model指令提供了3个修饰符：</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.number</td>
<td>自动将用户的输入值转为数值类型</td>
<td><code>&lt;input v-model.number=&quot;age&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.trim</td>
<td>自动过滤用户输入的首尾空白字符</td>
<td><code>&lt;input v-model.trim=&quot;msg&quot;/&gt;</code></td>
</tr>
<tr>
<td align="center">.lazy</td>
<td>在”change”时而非”input”时更新</td>
<td><code>&lt;input v-model.lazy=&quot;msg&quot;/&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>lazy的作用是input事件(表单处于焦点时候)不更新，失去焦点触发change事件才更新</p>
</blockquote>
</li>
<li><p>条件渲染指令 <code>v-if</code>、<code>v-show</code></p>
<blockquote>
<p>辅助开发者<strong>按需控制DOM的显示与隐藏</strong><br> v-if动态的把元素DOM从页面添加和移除<br> v-show是通过css动态添加display：none样式来显示和隐藏<br> <strong>如果要频繁切换元素的显示状态，show的性能更好</strong><br> <strong>如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好</strong><br> 这个只是说给面试官听的，<font color="green">在实际开发中，绝大多数情况不用考虑性能问题，直接使用v-if就好了！</font><br> 因为在大多数情况下，这种性能差异是微不足道的，除非在处理大量组件或频繁切换时才会产生明显影响。</p>
</blockquote>
<ul>
<li><p><font color="green">页面的执行(一个v-if的好问题)</font></p>
<blockquote>
<p>Q：如果我们页面有一个<code>&lt;p v-if=&quot;flag&quot;&gt;&lt;/p&gt; -- flag=false</code>，因为页面是从上往下执行的，那么页面是先创建p标签再移除呢，还是一开始就不创建呢？<br>  A：<strong>当我们用了vue-cli以后，用到单文件组件(.vue文件)的时候，它是先编译，然后再去运行。</strong><br>  先把整个网页编译成js，然后完整的去执行。标签也是被当做js去运行的，去加载的，这个问题就不存在了</p>
</blockquote>
</li>
<li><p><font id="if" color="green">v-if配套的指令 – <code>v-else</code></font></p>
<blockquote>
<p>多个元素按需展示<br>  注意：v-else指令<strong>必须配合v-if指令一起使用</strong>，否则不会被识别：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表渲染指令 <code>v-for</code> 和 <code>:key</code> <font color="red">重要</font></p>
<blockquote>
<p>辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。<br>     v-for指令需要使用<code>item in items</code>形式的特殊语法<br>     v-for支持一个可选的第二个参数，即当前项的索引<code>(item,index) in items</code><br>     注意：v-for指令中的 item项 和 index索引 都是形参，可以根据需要命名</p>
</blockquote>
<ul>
<li><font id="key" color="red">强调v-for循环中key值的绑定</font><blockquote>
<p>官方推荐在用v-for的时候一定要绑定一个key属性，既提升性能、又防止列表状态紊乱。而且尽量把id作为key的值(id唯一)<br>  <font color="#000">官方对key的值类型有要求，只能是字符串或数字类型，并且key的值必须唯一，不能重复(相当于id)</font><br>  也不能以index为值，如果key以索引为值，会数据紊乱，<strong>key必须唯一且稳定，不唯一就会终端报错，唯一又不稳定就会数据紊乱。</strong><br>  <code>&lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;</code><br>  在vue单组件中，如果用到for循环，但是没有绑key的话，会直接在终端里报错<br>  <font color="green">不懂key到底有什么用的可以去了解下diff算法和虚拟dom？</font></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="lable复选框的for属性"><a href="#lable复选框的for属性" class="headerlink" title="lable复选框的for属性"></a>lable复选框的for属性</h3><p>下面这个示例中,如果要选中男，应该点击对应的复选框，点击男不行，这样用户的体验很不好，可操作区域非常窄。<br>应该把它的可操作区域给放大，点击复选框还是男都可以选中，此时就用到了for属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>for指向id，希望点这个lable让谁被选中，就for那个元素的id</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;cb2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="a元素的JavaScript-伪协议"><a href="#a元素的JavaScript-伪协议" class="headerlink" title="a元素的JavaScript 伪协议"></a>a元素的JavaScript 伪协议</h3><p><code>&lt;a href=&quot;javascript:;&quot; @click=&quot;remove&quot;&gt;删除&lt;/a&gt;</code><br>这段代码是一个 HTML 锚点元素 <code>&lt;a&gt;</code> 的写法，其中<code>javascript:;</code> 是一个 JavaScript 伪协议，用于在点击链接时执行 JavaScript 代码或阻止默认行为。</p>
<p>通常情况下，当用户点击这个链接时，浏览器会执行 <code>JavaScript:;</code> 这里的 JavaScript 代码是空的，所以实际上不会发生任何操作。<br>这种写法通常用于创建一个占位符链接，或者作为一个“空链接”，<strong>用于在不跳转页面的情况下执行一些 JavaScript 操作，比如触发事件或者执行某些函数</strong>。</p>
<h3 id="JS-filter-方法-–-Array-prototype-filter"><a href="#JS-filter-方法-–-Array-prototype-filter" class="headerlink" title="JS - filter() 方法 – Array.prototype.filter()"></a>JS - filter() 方法 – Array.prototype.filter()</h3><p><code>filter()</code> 方法是 JavaScript 中数组的一个内置方法，用于过滤数组中的元素，并返回一个符合条件的新数组。<br>如：<br><code>let arr = [1,2,3].filter(item=&gt;item&gt;1) //[1,2]</code><br><code>let arr = [&#123;id:1,name:&quot;zs&quot;&#125;,&#123;id:2..&#125;].filter(item =&gt; item.id !=2) // [&#123;id:1,name:&quot;zs&quot;&#125;]</code></p>
<p>但是，除了数组外，<code>filter()</code> 方法还可以应用于类数组对象和可迭代对象。例如，字符串也可以通过 <code>filter()</code> 方法进行过滤操作。</p>
<p>下面是一个例子，演示如何在字符串中使用 <code>filter()</code> 方法来过滤出特定的字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> filteredStr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(str, <span class="function"><span class="params">char</span> =&gt;</span> char !== <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredStr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// 输出：Heo Word!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先使用 <code>Array.prototype.filter.call()</code> 来调用 <code>filter()</code> 方法，并将字符串 <code>str</code> 当作第一个参数传入。然后，我们定义了一个过滤条件，即过滤掉所有的 ‘l’ 字符。最后，我们将过滤后的字符数组通过 <code>join()</code> 方法连接成一个新的字符串，并输出结果。</p>
<p>总之，虽然 <code>filter()</code> 方法通常用于数组，但通过一些技巧，我们也可以在其他类型的对象上使用它。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/" class="post-title-link" itemprop="url">前端工程化与Webpack</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-18 23:41:46" itemprop="dateCreated datePublished" datetime="2024-04-18T23:41:46+08:00">2024-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-21 15:33:42" itemprop="dateModified" datetime="2024-04-21T15:33:42+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Vue/Webpack/" itemprop="url" rel="index"><span itemprop="name">Webpack</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Webpack/" itemprop="url" rel="index"><span itemprop="name">Webpack</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/18/Vue/1.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8EWebpack/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>目标：<br>了解工程化的前端开发方式<br>知道Webpack在实际开发中所起到的作用</p>
<blockquote>
<p>我们只需要了解webpack的工作原理，并不要求我们掌握如何配置，因为工作中我们会使用一些工具如Vue-CLI脚手架，它们已经帮我们配置好了</p>
</blockquote>
</blockquote>
<p>[toc]</p>
<h2 id="前端工程化相关概念"><a href="#前端工程化相关概念" class="headerlink" title="前端工程化相关概念"></a>前端工程化相关概念</h2><p>前端工程化指的是:在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。<br>好处:前端开发自成体系，有一套标准的开发方案和流程。</p>
<p>实际的前端开发，是四个现代化：</p>
<ul>
<li><strong>模块化</strong> (js的模块化、css的模块化、资源的模块化) ———— js的复用</li>
<li><strong>组件化</strong> (复用现有的UI结构、样式、行为) ———— UI结构的复用</li>
<li><strong>规范化</strong> (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</li>
<li><strong>自动化</strong> (自动化构建、自动部署、自动化测试)</li>
</ul>
<h3 id="前端工程化解决方案"><a href="#前端工程化解决方案" class="headerlink" title="前端工程化解决方案"></a>前端工程化解决方案</h3><ul>
<li>早期的前端工程化解决方案:<ul>
<li>grunt (<a target="_blank" rel="noopener" href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</li>
<li>gulp (<a target="_blank" rel="noopener" href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</li>
</ul>
</li>
<li>目前主流的前端工程化解决方案:<ul>
<li>webpack (<a target="_blank" rel="noopener" href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</li>
<li>parcel (<a target="_blank" rel="noopener" href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>) ———— 开发第三方包会用到</li>
</ul>
</li>
</ul>
<h2 id="webpack-常见用法"><a href="#webpack-常见用法" class="headerlink" title="webpack 常见用法"></a>webpack 常见用法</h2><ol>
<li><p>什么是webpack？<br> 概念：webPack是<strong>前端项目工程化的具体解决方案</strong>。<br> 主要功能: 它提供了友好的<strong>前端模块化开发支持</strong>，以及<strong>代码压缩混淆</strong>(干掉注释和空格)、<strong>处理浏览器端JavaScript的兼容性</strong>、<strong>性能优化</strong>等强大的功能。<br> 好处:让程序员把<strong>工作的重心</strong>放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意:目前Vue，React等前端项目，基本上都是基于webpack进行工程化开发的。</p>
</li>
<li><p>创建列表隔行变色项目</p>
<ol>
<li>新建项目空白目录，并运行npm init -y命令，初始化包管理配置文件 package.json</li>
<li>新建src源代码目录</li>
<li>新建src -&gt; index.html首页和src -&gt; index.js 脚本文件</li>
<li>初始化首页基本的结构</li>
<li>运行npm install jquery -S命令，安装jQuery(-S明确告诉npm，包要记录到dependencies下，开发上线都会用到)</li>
<li>通过ES6模块化的方式导入jQuery，实现列表隔行变色效果</li>
</ol>
</li>
<li><p>在项目中安装webpack<br> 运行如下命令，安装webpack相关的两个包（-D告诉npm记录到devDependencies下，只在开发阶段会用到）<br> <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code></p>
</li>
<li><p>在项目中配置webpack</p>
<ol>
<li><p>在项目根目录中，创建名为<strong>webpack.config.js</strong>的webpack配置文件，并初始化如下的基本配置:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// mode 用来指定构建模式。可选值有 development和 production</span></span><br><span class="line">    <span class="comment">// 开发阶段选develement，上线改成production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在package.json的 scripts节点下，新增<strong>dev脚本</strong>如下:<br> 这个dev是可以随意命名的，后面的webpack是必须写webpack<br> scripts节点下有个默认的test脚本，删掉就行</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script 节点下的脚本，可以通过 npm run 执行。例如 npm run dev</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在终端中运行npm run dev命令，启动 webpack进行项目的打包构建<br> 运行成功后，项目会多一个dist文件夹，里面的main.js就是webpack根据index.js帮我们自动生成的，做一下兼容性处理<br> 处理完以后，index.js还有兼容性问题，而main.js没有兼容性问题<br> 所以网页应该引入的是main.js文件<br> .<br> 由nodejs升级引起的构建错误：0308010C:digital envelope routines::unsupported<br> <a target="_blank" rel="noopener" href="https://juejin.cn/post/7202639428132044858">https://juejin.cn/post/7202639428132044858</a><br> 报错原因可以看这篇文章<br> 解决设置（似乎还没有一个100%完全的解决方法，都会存在一些问题）:<br> <code>&quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack&quot;</code><br> .<br> 这个main.js是webpack帮我们把jquery.js和index.js文件进行了合并，但是并没有压缩，main.js中还有注释和代码缩进，如果要压缩，需要把webpack.config.js的mode设置为production，然后重新运行，整个文件的体积就被压缩的更小了，但是打包的时间更长了<br> .<br> 所以开发的时候，mode都设置成develement，只有上线的时候才会设置为production</p>
</li>
<li><p>webpack的默认约定 ———— 如何打包<br> 在webpack 4.x和5.的版本中，有如下的默认约定:</p>
<ol>
<li>默认的打包入口文件为src -&gt; index.js</li>
<li>默认的输出文件路径为dist -&gt; main.js</li>
</ol>
<p> 注意:可以在webpack.config.js中修改打包的默认约定<br> 如果找不到要处理的文件，就会报错</p>
</li>
<li><p>自定义打包的入口和出口<br> 在webpack.config.js 配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>( <span class="string">&#x27;path&#x27;</span>) <span class="comment">//导入 node.js中专门操作路径的模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//打包入口文件的路径</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//输出文件的存放路径 </span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="comment">//输出文件的名称</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>这个时候，我们会发现，每次我们更改index.js的代码之后，都需要再次执行npm run dev更新生成的文件才行，这样非常麻烦，所以我们需要用到webpack的插件</p>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><p>最常用的webpack插件有两个：</p>
<ol>
<li>webpack-dev-server<ul>
<li>类似于node.js的nodemon工具</li>
<li>每当修改了源代码，webpack都会自动进行项目的打包和构建</li>
</ul>
</li>
<li>html-webpack-plugin<ul>
<li>webpack 中的HTML插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定制index.html页面的内容<hr></li>
</ul>
</li>
</ol>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ol>
<li><p>安装webpack-dev-server<br> <code>npm i webpack-dev-server@3.11.2 -D</code><br> .<br> 在配置好之后，npm run dev 运行报错<br> Unable to load ‘@webpack-cli&#x2F;serve’ command<br> TypeError: options.forEach is not a function<br> .<br> 下载<code>npm install webpack@5.42.1 webpack-cli@4.10.0 -D</code></p>
</li>
<li><p>配置webpack-dev-server</p>
<ol>
<li>修改package.json -&gt; scripts中的dev命令如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// script节点下的脚本，可以通过npm run 执行</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>再次运行npm run dev命令，重新进行项目的打包<br> 在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果</li>
</ol>
<p> 注意:webpack-dev-server 会启动一个实时打包的http服务器</p>
</li>
</ol>
<p>注意，webpack-dev-server启动后，构建后的文件是在内存中的，不会实际生成具体的文件，所以我们打开的页面效果不会发生变化</p>
<p>我们执行npm run dev 命令，它执行的其实是webpack serve命令<br>这个命令执行成功后，第一行返回的是，<br><code>i ｢wds｣: Project is running at http://localhost:8080/</code><br>是整个项目运行在8080端口<br>所以，要看更新后的效果，要打开这个网址来查看，不能和以前一样的方法查看，因为之前查看的是file协议，不是当前的http协议</p>
<p>我们打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 网址，进入src，浏览器就会自动打开这个目录下的index文件，但是还是页面没有更改，我们再看第二行<br><code>i ｢wds｣: webpack output is served from /</code><br>告诉我们，输出在根目录，但是根目录并看不到bundle.js，但是其实它是有的，我们打开<a target="_blank" rel="noopener" href="http://localhost:8080/bundle.js">http://localhost:8080/bundle.js</a> 可以访问到该文件</p>
<p><strong>webpack-dev-server这个插件，它把生成的bundle没有放到实际的物理磁盘上，而是放到了内存里面</strong><br>这是因为，如果频繁的修改文件，ctrl s，如果是把文件放到物理磁盘上，就会频繁的读写磁盘，对磁盘寿命性能都会有很大影响，所以要访问最新的bundle要访问内存里的bundle，所以应该<strong>在页面加载和引用内存里的bundle.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://localhost:8080/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// 也可以直接这样引用，看不见，但是可以引用的</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>但是由于我的vscode默认的使用5500端口，所以第二种引用会引用到5500端口，但是5500端口并不存在bundle.js，所以会报错,只能使用第一种引用</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>有一点不方便的是，打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> 之后，我们还要点击一次src进入目录中，才能打开首页<br>我们希望一进入8080就能看到首页<br>html-webpack-plugin，这个插件可以把src里面的首页复制一份，放到根目录中<br>安装插件：<code>npm i html-webpack-plugin@5.3.2 -D</code></p>
<ul>
<li><p>配置 – 在webpack.config.js中配置<br>  把new出来的插件htmlPlugin 挂载&#x2F;添加到plugins插件的数组里面，这样webpack在运行的时候就会调用这个插件的实例，把src(template)里的页面复制一份放到根目录(filename)中<br>  不过也是复制出来的一个内存里的页面</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入HTML插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 2．创建HTML插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,<span class="comment">//指定原文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,<span class="comment">//指定生成的文件的存放路径</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> ,</span><br><span class="line">    <span class="comment">// 3．通过 plugins节点，使 htmlPlugin插件生效</span></span><br><span class="line">    <span class="attr">plugins</span>: [htmlPlugin], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个作用<br>  html-webpack-plugin插件除了帮我们复制页面，还会在复制出来的页面，自动注入一个脚本(js引用)，去引用内存里的bundle.js<br>  .<br>  我们npm run dev运行之后，如果把html页面的js引入注释掉，内存中页面样式是还在的，并没有消失。<br>  我们查看源码，可以发现它是有js引用的，而且是没有加.&#x2F;的同级目录引用，因为内存中的html和hundle.js在同一级目录</p>
</li>
</ul>
<p>配置完webpack之后，我们的开发体验会变的很好，但是配置过程又非常繁琐。<br>我不想自己配置，又想体验配置后的好处 ———— Vue-cli<br>这个工具已经帮我们配置好了webpack</p>
<h2 id="devServer-节点"><a href="#devServer-节点" class="headerlink" title="devServer 节点"></a>devServer 节点</h2><p>还有一个不爽的点(程序员的很多不爽XDD)，每次重新运行项目，都要手动打开8080页面，我们懒就要懒到底<br><strong>在npm run dev运行成功之后，自动打开浏览器展示网页</strong></p>
<ul>
<li>配置<br>  在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 初次打包完成后，自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 实时打包所使用的主机地址</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="comment">//实时打包所使用的端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="webpack中的loader（加载器）"><a href="#webpack中的loader（加载器）" class="headerlink" title="webpack中的loader（加载器）"></a>webpack中的loader（加载器）</h2><ol>
<li><p>loader概述<br> 在实际开发过程中，webpack默认只能打包处理以.js 后缀名结尾的模块。其他<strong>非.js后缀名结尾的模块，webpack默认处理不了，需要调用loader加载器才可以正常打包</strong>，否则会报错!</p>
<p> loader加载器的作用:<strong>协助webpack打包处理特定的文件模块</strong>。比如:</p>
<ul>
<li>css-loader可以打包处理.css相关的文件</li>
<li>less-loader可以打包处理.less相关的文件</li>
<li>babel-loader可以打包处理webpack无法处理的高级JS语法</li>
</ul>
<p> 在webpack里面，一切都可以进行导入，一切皆模块，不建议程序员手动去引入样式和脚本(link，script)</p>
<p> 在js中也可以导入样式(ES6语法)<code>import &#39;./css/index.css&#39;</code></p>
</li>
<li><p>打包处理 css 文件</p>
<ol>
<li>运行<code>npm i style-loader@3.0.0 css-loader@5.2.6 -D</code>命令，安装处理css文件的loader</li>
<li>在webpack.config.js 的 module -&gt; rules 数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; </span><br><span class="line">    <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
 其中，<strong>test</strong>表示匹配的<strong>文件类型</strong>, <strong>use</strong>表示对应<strong>要调用的loader</strong><br> 注意:</li>
</ol>
<ul>
<li>use数组中指定的loader <strong>顺序是固定的</strong></li>
<li>多个loader的调用顺序是: <strong>从后往前调用</strong><br>  loader在调用的时候，是从后往前调的 <a href='#loader-调用过程'>loader调用过程</a></li>
</ul>
</li>
<li><p>打包处理 less文件</p>
<ol>
<li>运行<code>npm i less-loader@10.0.1 less@4.1.1 -D</code>命令</li>
<li>在webpack.config.js 的module -&gt; rules数组中，添加loader规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个less是内部依赖项，就是less-loader内部依赖于less，但是不需要手动的去声明less</li>
</ol>
</li>
<li><p>打包处理样式表中与url路径相关的文件</p>
<ol>
<li>运行<code>npm i url-loader@4.1.1 file-loader@6.2.0 -D</code>命令</li>
<li>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">        <span class="comment">//如果需要调用的loader只有一个(use)，则只传递一个字符串也行，如果有多个loader，则必须指定数组</span></span><br><span class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,<span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&#x27;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中?之后的是 loader的参数项:</li>
</ol>
<ul>
<li>limit用来指定图片的大小，单位是字节(byte)</li>
<li>只有≤limit 大小的图片，才会被转为base64格式的图片</li>
</ul>
</li>
<li><p>打包处理js文件中的高级语法<br> webpack只能打包处理一部分高级的JavaScript语法。对于那些webpack无法处理的高级js语法，需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1．定义了名为info的装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">//2．为目标添加静态属性info</span></span><br><span class="line">    target.<span class="property">info</span> = <span class="string">&#x27;Person info&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3．为Person类应用info装饰器</span></span><br><span class="line">@info</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4．打印 Person 的静态属性info</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">info</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.1 运行如下的命令安装对应的依赖包:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure>
<p>在webpack.config.js的 module -&gt; rules数组中，添加loader规则如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span> , <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>exclude排除了node_modules文件夹，因为只需要处理我们自己写的代码就可以了，第三方的包没有兼容性问题，本身已经解决了，不需要处理(如果不排除也会对其进行处理影响性能)</p>
<p>5.2 配置babel-loader<br>打包处理js文件中的高级语法，比处理其他文件要多这么一步<br>在项目根目录下，创建名为 babel.config.js 的配置文件，定义Babel的配置项如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些配置从官方文档找到对应项直接粘过来就行了</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//声明babel 可用的插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请参考Babel的官网<a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></p>
<h3 id="loader-调用过程"><a href="#loader-调用过程" class="headerlink" title="loader 调用过程"></a>loader 调用过程</h3><ol>
<li>webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</li>
<li>由于代码中包含了 index.css 这个文件，因此 webpack默认处理不了</li>
<li><strong>当webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器。</strong></li>
<li>webpack 把 index.css 这个文件，先转交给最后一个 loader 进行处理(先转交给css-loader) .</li>
<li>当 css-loader 处理完毕之后，会把处理的结果，转交给下一个 loader (转交给style-loader)</li>
<li>当 style-loader 处理完毕之后，发现没有下一个 loader 了，于是就把处理的结果，转交给了 webpack</li>
<li>webpack 把 style-loader 处理的结果，合并到&#x2F;dist&#x2F;bundle.js中，最终生成打包好的文件。</li>
</ol>
<h3 id="base64图片的优缺点"><a href="#base64图片的优缺点" class="headerlink" title="base64图片的优缺点"></a>base64图片的优缺点</h3><p>浏览器在拿到HTMl标签以后，需要再发送请求，拿到图片以后才能把图片渲染出来</p>
<p>但是使用用base64图片，在拿到img标签以后，就顺手的把图片对应的字符串也给请求下来了，可以防止发起一些不必要的网络请求</p>
<p>如果页面有许多小图标，就要发送很多次请求，对性能来讲非常不好，就可以把图片都转成base64格式的字符串</p>
<p>缺点：<br>图片转成base64，体积会增大一点点，所以大图片就不适合</p>
<p><strong>ES6 import导入图片得到的是一个base64字符串</strong>(可以打印看一下)<br>如 <code>import logo from &#39;./images/logo.png&#39;</code></p>
<h3 id="webpack处理样式的过程"><a href="#webpack处理样式的过程" class="headerlink" title="webpack处理样式的过程"></a>webpack处理样式的过程</h3><p>ES6在js文件导入样式<code>import &#39;./css/index.css&#39;</code><br>这种语法代表，只需要加载这个文件，把css样式给加载过来，不需要接收(接收的话，打印出来是undefined)</p>
<p>webpack加载和处理js文件，处理的结果会生成一个新的js文件(如bundle.js)，而且会在页面引用过去，在这个bundle.js里面，会包含我们import引入的样式，在这个bundle.js里面，css样式会被转成js的方式去运行</p>
<h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>我们如果要上线，应该拿到这些文件发给后端，让后端去部署上线<br>发布上线就是：<br>前端把项目生成一份最终的结果，有页面，配套的css js 图片等等<br>所有资源都在生成的文件夹里面，把所有内容打包发给后端<br>后端拿到结果去部署上线</p>
<p>现在我们要解决的问题是：页面和bundle.js放到内存里面了，需要把它生成到实际的物理磁盘上。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>在package.json文件的scripts节点下，新增build命令如下:<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    “dev&quot; : &quot;webpack serve&quot;，//开发环境中，运行dev命令</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时，运行 build命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <code>--mode</code>是一个参数项，用来指定webpack的<strong>运行模式</strong>。production 代表生产环境，会对打包生成的文件进行<strong>代码压缩</strong>和<strong>性能优化</strong>。<br>    注意:通过<code>--mode</code>指定的参数项，会<strong>覆盖</strong>webpack.config.js 中的<code>--mode</code>选项。</p>
<p>这里的dev命令是webpack serve，就是我们装的插件，是把文件生成到内存中，可以监听文件的更改自动执行npm run dev<br>而这里build就是要执行webpack命令把文件生成到磁盘上，这里注意要改成<br>    <code>set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; webpack --mode production</code></p>
<h3 id="优化图片和js文件存放路径"><a href="#优化图片和js文件存放路径" class="headerlink" title="优化图片和js文件存放路径"></a>优化图片和js文件存放路径</h3><ol>
<li>js文件<br>在webpack.js的output对象属性中，把filename前面加上个文件夹<br> <code>filename:&#39;js/bundle.js&#39;</code></li>
<li>图片<br>修改webpack.config.js 中的url-loader配置项，新增outputPath选项即可指定图片文件的输出路径: <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jpg|png|gif$/</span> ,</span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">22228</span>,</span><br><span class="line">            <span class="comment">//明确指定把打包生成的图片文件，存储到dist目录下的 image 文件夹中</span></span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者直接用?xx&#x3D;xx&amp;xx&#x3D;xx的方式在loader后面携带参数 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>, <span class="attr">use</span>: <span class="string">&#x27;url-loader?limit=22229&amp;outputPath=images&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置和使用clean-webpack-plugin插件自动删除dist目录"><a href="#配置和使用clean-webpack-plugin插件自动删除dist目录" class="headerlink" title="配置和使用clean-webpack-plugin插件自动删除dist目录"></a>配置和使用clean-webpack-plugin插件自动删除dist目录</h3><p><strong>webpack5已经默认封装(内置)了该插件，直接在配置文件里output设置属性clean:true即可</strong></p>
<hr>
<p>为了防止旧文件干扰我们的事件，在每次重新发布的时候会把生成的打包好的dist文件夹删掉。<br>为了在每次打包发布时自动清理掉dist目录中的旧文件，可以安装并配置dlean-webpack-plugin插件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1．安装清理dist目录的 webpack 插件</span></span><br><span class="line">npm install clean-webpack-plugin@<span class="number">3.0</span><span class="number">.0</span> -D</span><br><span class="line"><span class="comment">// 2．按需导入插件、得到插件的构造函数之后，创建插件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanwebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanwebpackPlugin</span>()</span><br><span class="line"><span class="comment">// 3．把创建的 cleanPlugin 插件实例对象，挂载到plugins节点中</span></span><br><span class="line"><span class="attr">plugins</span>: [htmlPlugin,cleanPlugin],<span class="comment">//挂载插件 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>检验是否是删除之后重新生产的方法</strong>：<br>可以在dist文件夹下新建如1.txt文件，重新打包，如果文件还在，说明是没有删除直接打包的，如果不再了，那就是删除之后重新打包。</li>
</ul>
<h2 id="source-Map-–-开发阶段检错"><a href="#source-Map-–-开发阶段检错" class="headerlink" title="source Map – 开发阶段检错"></a>source Map – 开发阶段检错</h2><p>告诉你文件的报错位置，用于调试bug<br>开发阶段 npm run dev 检错的<br><strong>在发布项目的时候，处于安全性考虑，建议关闭SourceMap</strong>。防止一些人通过报错位置来拿到我们的源代码(通过修改页面代码来主动让页面某功能报错来拿到该功能位置的源码这样吗？)<br>新版本开发环境建议使用cheap-module-source-map？</p>
<ol>
<li>什么是 source Map<br> <strong>Source Map就是一个信息文件，里面储存着位置信息</strong>。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的<strong>转换前的位置</strong>。<br> 有了它，出错的时候，<strong>除错工具将直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</li>
</ol>
<p>即是：页面报错，控制台会显示错误以及错误文件及其报错位置，如果没有配置这个，它显示的就是打包压缩后的代码的位置</p>
<ol start="2">
<li><p>webpack <strong>开发环境下的</strong> Source Map<br> <strong>在开发环境下</strong>，webpack<strong>默认启用了</strong>Source Map功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。<br> 但是，开发环境下默认生成的Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</p>
</li>
<li><p>解决默认的Source Map的问题<br> 开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="comment">// eval-source-map 仅限在&quot;开发模式&quot;下使用，不建议在&quot;生产模式&quot;下使用。</span></span><br><span class="line">    <span class="comment">//此选项生成的 Source Map 能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span></span><br><span class="line">    <span class="comment">// 在开发调试阶段，建议大家都把devtool的值设置为eval-source-map</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">//省略其它配置项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack <strong>生产环境下的</strong> Source Map<br>在生产环境下，如果省略了devtool选项，则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人</p>
</li>
<li><p><strong>只定位行数不暴露源码</strong> – 对调试和安全都比较友好<br>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以<strong>将devtool的值设置为nosources-source-map</strong>。<br>知道了行号，我们就可以定位到源码的行位置来解决bug</p>
</li>
<li><p>定位行数且暴露源码<br>在生产环境下，如果<strong>想在定位报错行数的同时，展示具体报错的源码</strong>。此时可以将devtool的值设置为source-map。<br>坚决不推荐。(但是这不是和eval-source-map一样吗？？)<br>这种方式会生成一个SourceMap(但是nosources-source-map也有，eval-soure-map应该也有吧)<br>可以看到在dist的js目录下，除了有bundle.js还有个bundle.js.map，这就是我们的SourceMap</p>
</li>
</ol>
<h3 id="Source-Map的最佳实践"><a href="#Source-Map的最佳实践" class="headerlink" title="Source Map的最佳实践"></a>Source Map的最佳实践</h3><ol>
<li>开发环境下:<ul>
<li>建议把devtool的值设置为<strong>eval-source-map</strong></li>
<li>好处: 可以精准定位到具体的错误行</li>
</ul>
</li>
<li>生产环境下:<ul>
<li>建议<strong>关闭Source Map</strong> 或 将devtool的值设置为<strong>nosources-source-map</strong></li>
<li>好处: 防止源码泄露，提高网站的安全性</li>
</ul>
</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul>
<li>两次 ctrl + c 可以直接结束 webpack serve？<br>原本需要一次ctrl + c 然后按Y + enter结束</li>
</ul>
<h3 id="webpack中-的原理和好处"><a href="#webpack中-的原理和好处" class="headerlink" title="webpack中 @ 的原理和好处"></a>webpack中 @ 的原理和好处</h3><p>这样一个场景：<br>src目录下 有一个info文件 js&#x2F;text&#x2F;info<br>而这个info文件要导入src目录下的msg.js文件<br>就需要这样导入: import msg from ‘..&#x2F;..&#x2F;msg’<br>如果info的文件层级再深一点，这个..&#x2F;会让人不知道翻了几层<br>所以<br><strong>建议大家都使用 @ 符号表示src源代码目录，从外往里查找，不要使用..&#x2F;从里往外查找</strong><br>import msg from ‘@&#x2F;msg.js’</p>
<p>在webpack里面，@不能直接用，需要先配置一下<br>在webpack.config.js中，module.exports中增加一个resolve属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 告诉webpack，程序员写的代码中，@符号表示src这一层目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在浏览器安装vue-devtools调试工具"><a href="#在浏览器安装vue-devtools调试工具" class="headerlink" title="在浏览器安装vue-devtools调试工具"></a>在浏览器安装vue-devtools调试工具</h3><p>edge扩展中直接搜，有一个vue.js-devtools<br><strong>在详情设置中，有个允许访问文件URL(文件网址)的设置，默认是关闭的状态，需要我们手动打开</strong></p>
<h2 id="实际开发中不需要自己配置webpack"><a href="#实际开发中不需要自己配置webpack" class="headerlink" title="实际开发中不需要自己配置webpack"></a><strong>实际开发中不需要自己配置webpack</strong></h2><ul>
<li>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</li>
<li>开箱即用，所有webpack配置项都是现成的!</li>
<li>我们只需要知道webpack 中的基本概念即可!</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tsukimiyanano.github.io/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/tsukimiya.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Ayu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ayu's Study Blog">
      <meta itemprop="description" content="你们怎么能这么卷！！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ayu's Study Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Node.js简单实现后端服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-15 20:23:00" itemprop="dateCreated datePublished" datetime="2024-04-15T20:23:00+08:00">2024-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-29 17:32:20" itemprop="dateModified" datetime="2024-04-29T17:32:20+08:00">2024-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/tsukimiya.github.io/categories/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/tsukimiya.github.io/2024/04/15/Node/Node.js%E5%81%9A%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E8%A7%A3/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>该示例没有用到数据库，是通过创建POST表单路由进行处理数据，将数据保存到文件中，以及数据校验<br>用到的npm包&#x2F;第三方模块：<br>Express：<code>npm i express@4.17.1</code> – Web 开发框架，快速创建 Web 服务器<br>Joi：<code>npm install joi --save</code> – hapijs 自带的数据校验模块<br>@escook&#x2F;express-joi中间件: <code>npm i @escook/express-joi</code> – 实现自动对表单数据进行验证的功能<br>cors： <code>npm i cors</code> – 配置cors跨域<br>dayjs： <code>npm install dayjs --save</code> – 格式化时间</p>
</blockquote>
<blockquote>
<p>全局安装了nodemon工具，可以监听文件的更改，自动重新执行</p>
</blockquote>
<blockquote>
<p>这个是航空文化馆项目的后端，还没写完<br>没有用到mysql模块：<code>npm i mysql</code><br>也没有用到express-session中间件：<code>npm i express-session</code>（这个干吗用的？）</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol start="0">
<li>如果是拿被别人写好的项目，第一步是导入这个项目所用的包，<code>npm i</code>命令</li>
<li>创建后端项目文件夹如serve</li>
<li>初始化文件夹<code>npm init -y</code><br> 在空项目的根目录中初始化一个package.json的包管理配置文件</li>
<li>安装必要的包&#x2F;依赖<br> 安装Express —— <code>npm i express@4.17.1</code></li>
<li>创建服务器文件，命名如app.js</li>
</ol>
<h2 id="创建简单的web服务器-及其-模块化"><a href="#创建简单的web服务器-及其-模块化" class="headerlink" title="创建简单的web服务器 及其 模块化"></a>创建简单的web服务器 及其 模块化</h2><ol>
<li><p>创建基本的express框架 – eser(vscode快捷生成代码&#x2F;&#x2F;自己配置 – 文件–首选项–配置用户代码片段)</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建express服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用app.listen方法，指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(port,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Express server running at http://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)      </span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由<br> 可以先在当前文件尝试是否成功，之后再分离到对应模块</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建express路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// 提交预约表单</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/form&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用postman测试请求是否成功<br> 向 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/form">http://127.0.0.1:8080/form</a> 发送post请求<br> 响应函数中打印出来的req.body结果是undefined，这是因为我们没有配置解析表单的中间件</p>
</li>
<li><p>配置解析表单的中间件<br> &#x2F;&#x2F; 配置解析表单数据的中间件,注意：这个中间件，只能解析applicaton&#x2F;x-www-form-urlencoded格式的表单数据<br> <code>app.use(express.urlencoded(&#123;extended:false&#125;))</code><br> 再次发送请求，我们就得到了表单提交的数据</p>
</li>
<li><p>分离到路由模块<br> 创建router文件夹，创建如user.js文件&#x2F;&#x2F;处理用户路由<br> 将路由部分写到这个地方，然后把router暴露出去<br> <code>module.exports = router</code><br> 然后在app.js中导入并使用路由模块</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入并使用用户路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>)</span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>
<p> 测试成功</p>
</li>
<li><p>分离处理函数到路由处理模块，同5操作<br> 创建router_handler文件夹，在该目录下创建对应的用户路由处理文件user.js<br> 把处理函数暴露出去</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">formSubmit</span> = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送表单数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在路由模块导入导入用户路由处理函数对应的模块<br> <code>const user_handler = require(&#39;../router_handler/user&#39;)</code><br> 路由的响应函数换成对应的user_handler.formSubmit</p>
</li>
</ol>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>这里使用joi模块来进行数据验证<br>Joi 是 hapijs 自带的数据校验模块，他已经高度封装常用的校验功能。</p>
<ol>
<li><p>安装joi包，为表单中携带的每个数据项，定义验证规则</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install joi --save</span><br><span class="line"><span class="comment">// ES6写法 import Joi from &#x27;joi&#x27;</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>安装 @escook&#x2F;express-joi 中间件，来实现自动对表单数据进行验证的功能：<br> <code>npm i @escook/express-joi</code></p>
</li>
<li><p>joi验证规则</p>
<ul>
<li>string() 值必须是字符串</li>
<li>number() 值必须是数字</li>
<li>alphanum() 值只能是包含 a-zA-Z0-9 的字符串</li>
<li>min(length) 最小长度</li>
<li>max(length) 最大长度</li>
<li>required() 值是必填项，不能为 undefined</li>
<li>pattern(正则表达式) 值必须符合正则表达式的规则</li>
<li>any() 任意</li>
<li>date() 日期</li>
<li>time() 时间</li>
<li>iso() 要求字符串值采用有效的 ISO 8601 日期格式。</li>
</ul>
</li>
<li><p>新建 &#x2F;schema&#x2F;user.js 用户信息验证规则模块，并初始化代码如下：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单校验规则</span></span><br><span class="line"><span class="keyword">const</span> unit = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> contact = joi.<span class="title function_">string</span>().required()</span><br><span class="line"><span class="keyword">const</span> phone = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[1][\d]&#123;10&#125;$/</span>).required()</span><br><span class="line"><span class="keyword">const</span> numVisitors = joi.<span class="title function_">number</span>().<span class="title function_">min</span>(<span class="number">16</span>).required()</span><br><span class="line"><span class="keyword">const</span> guide = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/yes|no|是|否/</span>).required()</span><br><span class="line"><span class="keyword">const</span> date = joi.<span class="title function_">date</span>().<span class="title function_">min</span>(<span class="string">&#x27;now&#x27;</span>).<span class="title function_">iso</span>().required()</span><br><span class="line"><span class="keyword">const</span> time = joi.<span class="title function_">string</span>().<span class="title function_">pattern</span>(<span class="regexp">/^[\d]&#123;2&#125;[\s]*:[\s]*[\d]&#123;2&#125;$/</span>).required()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单的验证规则对象</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">form_schema</span> =&#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        unit,</span><br><span class="line">        contact,</span><br><span class="line">        phone,</span><br><span class="line">        numVisitors,</span><br><span class="line">        guide,</span><br><span class="line">        date,</span><br><span class="line">        time,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由模块添加数据校验</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入需要验证的规则</span></span><br><span class="line"><span class="keyword">const</span> &#123;form_schema&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/user&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 在表单提交的路由中，声明局部中间件，对当前请求中携带的数据进行验证<br> 数据验证通过后，会把这次请求流转给后面的路由处理函数<br> 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理<br> <code>router.post(&#39;/form&#39;,expressJoi(form_schema), user_handler.formSubmit)</code></p>
</li>
<li><p>在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端<br> 在路由注册之后声明错误级别中间件，注意这里需要在app.js导入joi</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 错误中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err,req,res,next</span>)&#123;</span><br><span class="line">    <span class="comment">//数据验证失败</span></span><br><span class="line">    <span class="keyword">if</span>(err <span class="keyword">instanceof</span> joi.<span class="property">ValidationError</span>) <span class="keyword">return</span> res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 未知错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> postman测试成功</p>
</li>
</ol>
<h2 id="配置cors-跨域"><a href="#配置cors-跨域" class="headerlink" title="配置cors 跨域"></a>配置cors 跨域</h2><p>之前我们都是在postman发送请求测试，如果我们在自己写的页面发送请求会发现报错<br>这是因为我们的页面打开的是file协议，而服务器则是http协议，</p>
<p>使用<strong>cors中间件</strong>解决跨域问题<br>cors 是Express的一个第三方中间件。通过安装和配置cors 中间件，可以很方便地解决跨域问题。<br>使用步骤分为如下3步:<br>    1. 运行<code>npm install cors</code>安装中间件<br>    2. 使用<code>const cors = require(&#39;cors&#39;)</code>导入中间件<br>    3. 在路由之前调用<code>app.use(cors())</code>配置中间件</p>
<p>注意：<strong>一定要在路由之前配置cors中间件，从而解决接口跨域的问题</strong></p>
<ul>
<li>前端发送axios请求：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8080/form&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果要携带请求体：</span></span><br><span class="line">    <span class="comment">// 请求体参数，post请求体传参，可选</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        unit : <span class="string">&quot;00&quot;</span>,</span><br><span class="line">        contact : <span class="string">&quot;朱宇楼&quot;</span>,</span><br><span class="line">        <span class="attr">phone</span>: <span class="string">&#x27;15639038667&#x27;</span>,</span><br><span class="line">        <span class="attr">numVisitors</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">guide</span>: <span class="string">&#x27;yes&#x27;</span>,</span><br><span class="line">        <span class="attr">date</span>: <span class="string">&#x27;2025-05-15&#x27;</span>,</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;14:30&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .then 用来指定请求成功之后的回调函数</span></span><br><span class="line">    <span class="comment">// 形参中的 result 是请求成功之后的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
注意：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的，然而我们没有配置解析JSON表单数据的中间件，所以后端能够接收到请求，但是拿不到参数</li>
</ul>
<p>配置解析JSON格式表单数据的中间件：<code>app.use(express.json())</code><br>再次在页面发送axois请求，测试成功</p>
<h2 id="处理数据-–-date时间格式化"><a href="#处理数据-–-date时间格式化" class="headerlink" title="处理数据 – date时间格式化"></a>处理数据 – date时间格式化</h2><blockquote>
<p>在路由处理模块，我们通过<code>const userInfo = req.body</code>接收了获取的数据<br>    但是打印userInfo出来发现，<code>date: 2025-05-15T00:00:00.000Z,</code>，和我们传入的<code>2025-05-15</code>并不一致<br>    遍历对象打印date又变成了：<code>date: Thu May 15 2025 08:00:00 GMT+0800 (中国标准时间)</code><br>    这也许是因为数据校验调用了date()导致<code>const date = joi.date().min(&#39;now&#39;).iso().required()</code><br>    所以我们需要手动处理一下接收到的date的格式</p>
</blockquote>
<ol>
<li><p>下载dayjs组件库，并引入到路由处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载 dayjs 组件库</span></span><br><span class="line">npm install dayjs --save</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进行引用</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&#x27;dayjs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理data<br>我们可以通过forEach遍历，并打印出每一项的数据（需要把对象的键值对包装成数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entries()方法 把对象中的 每个键值对 包装成一对数组 最后返回一个数组</span></span><br><span class="line"><span class="comment">// 返回如[ [key1,value,],[key2,value2] ,.. ]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(userInfo).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] == <span class="string">&#x27;date&#x27;</span>)&#123;</span><br><span class="line">        item[<span class="number">1</span>] = <span class="title function_">dayjs</span>(item[<span class="number">1</span>]).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>date数据处理完毕</p>
</li>
</ol>
<h2 id="将数据保存到文件中"><a href="#将数据保存到文件中" class="headerlink" title="将数据保存到文件中"></a>将数据保存到文件中</h2><ol>
<li><p>导入fs文件处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>向form.txt文件中追加每一项数据,不需要我们手动去创建txt文件，如果没有会自动创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的路径，是以执行的文件为基准的,这里是暴露出去的函数，是在路由里面执行的</span></span><br><span class="line"><span class="comment">// 而路由是注册在app.js文件的，所以以app.js为基准</span></span><br><span class="line"><span class="comment">//这里是追加内容的函数，和写入函数writeFile使用一样，如果该文件不存在则会创建该文件</span></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./form.txt&#x27;</span>,data, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就成功向form.txt文件写入数据了，但是数据是没有换行的</p>
</li>
<li><p>写入数据换行 – 换行符常量 <code>os.EOL</code><br>先引入os模块：<code>const os = require(&#39;os&#39;)</code><br>然后修改追加的data数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里插入数据依旧插入的英文名称，没有进行更改对应中文处理</span></span><br><span class="line"><span class="keyword">let</span> data = item[<span class="number">0</span>] + <span class="string">&quot;: &quot;</span> + item[<span class="number">1</span>] + os.<span class="property">EOL</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;<span class="comment">// 每一次插入前，都多空上一行 和加上一行分隔符</span></span><br><span class="line">    data = os.<span class="property">EOL</span> + <span class="string">&quot;####预约申请表####&quot;</span> + os.<span class="property">EOL</span> + data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="增加msg路由模块"><a href="#增加msg路由模块" class="headerlink" title="增加msg路由模块"></a>增加msg路由模块</h2><blockquote>
<p>比form路由简单些，不需要进行太多数据验证，只需要保证数据不为空就行</p>
</blockquote>
<p>这里直接贴出代码</p>
<ul>
<li><p>路由模块 msg.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入express模块，并创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> msgRouter = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由处理模块</span></span><br><span class="line"><span class="keyword">const</span> msg_hander = <span class="built_in">require</span>(<span class="string">&#x27;../router_handler/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入验证表单数据的中间件</span></span><br><span class="line"><span class="keyword">const</span> expressJoi = <span class="built_in">require</span>(<span class="string">&#x27;@escook/express-joi&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入数据校验模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; msg_schema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../schema/msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msgRouter.<span class="title function_">post</span>(<span class="string">&#x27;/msg&#x27;</span>,<span class="title function_">expressJoi</span>(msg_schema),msg_hander.<span class="property">msgSubmit</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = msgRouter</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由处理模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msgSubmit</span> = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = req.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">&#x27;####留言####&#x27;</span> + os.<span class="property">EOL</span> + msg.<span class="property">msg</span> + os.<span class="property">EOL</span> + os.<span class="property">EOL</span>;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./msg.txt&#x27;</span>,data,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> err.<span class="property">message</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;发送留言数据成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据校验模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入joi模块</span></span><br><span class="line"><span class="keyword">const</span> joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>);</span><br><span class="line"><span class="comment">// 校验规则 msg不少于10个字符，且是必填项</span></span><br><span class="line"><span class="keyword">const</span> msg = joi.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">10</span>).required();</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">msg_schema</span> = &#123;</span><br><span class="line">    <span class="attr">body</span>:&#123;</span><br><span class="line">        msg,<span class="comment">//注意必须写在body属性中，因为数据在req.body中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：记得要在app.js主程序页面配置路由<code>app.use(msgRouter)</code></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ayu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">64k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">58 分钟</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/comments.js"></script><script src="/tsukimiya.github.io/js/utils.js"></script><script src="/tsukimiya.github.io/js/motion.js"></script><script src="/tsukimiya.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/tsukimiya.github.io/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":true,"locale":{"placeholder":"Leave Something, message or money"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/tieba"],"meta":["nick","mail","link"],"requiredMeta":["nick"],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/tsukimiya.github.io/default-index/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
